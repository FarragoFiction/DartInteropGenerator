{
  "fixes" : {
    "class Stage<T extends Function> extends List<StageObject> {" : "class Stage<T extends Function> {",
    "abstract class BaseError extends Error {" : "abstract class BaseError {",

    "external void setArray(WebGL.UniformLocation uniform, dynamic array);" : "external void setArray(WebGL.UniformLocation uniform, List<num> array);",
    "external void setArray2(WebGL.UniformLocation uniform, dynamic array);" : "external void setArray2(WebGL.UniformLocation uniform, List<num> array);",
    "external void setArray3(WebGL.UniformLocation uniform, dynamic array);" : "external void setArray3(WebGL.UniformLocation uniform, List<num> array);",
    "external void setArray4(WebGL.UniformLocation uniform, dynamic array);" : "external void setArray4(WebGL.UniformLocation uniform, List<num> array);",

    "/// Gets or sets a texture used to add random noise to particle positions\n\texternal ProceduralTexture get noiseTexture;\n\t\n\texternal set noiseTexture(ProceduralTexture value);" : "\t/// Gets or sets a texture used to add random noise to particle positions\n\texternal BaseTexture get noiseTexture;\n\t\n\texternal set noiseTexture(BaseTexture value);",
    "/// Adds action to chain of actions, may be a DoNothingAction\n\t/// @param action defines the next action to execute\n\t/// @returns The action passed in\n\t/// @see https://www.babylonjs-playground.com/#1T30HR#0\n\t@override\n\texternal Action then(Action action);" : "/// Adds action to chain of actions, may be a DoNothingAction\n\t/// @param action defines the next action to execute\n\t/// @returns The action passed in\n\t/// @see https://www.babylonjs-playground.com/#1T30HR#0\n\t@override\n\texternal Action then(IAction action);",
    "/// Define the input manager associated to the camera.\n\t@override\n\texternal FreeCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(FreeCameraInputsManager value);" : "/// Define the input manager associated to the camera.\n\t@override\n\texternal FreeCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(CameraInputsManager<Camera> value);",
    "abstract class VRDisplay extends HTML.EventTarget {" : "abstract class VRDisplay {// extends HTML.EventTarget {",
    "@override\n\texternal dynamic transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);" : "@override\n\texternal Light transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);",
    "/// Get if the submesh is ready to be used and all its information available.\n\t/// Child classes can use it to update shaders\n\t/// @param mesh defines the mesh to check\n\t/// @param subMesh defines which submesh to check\n\t/// @param useInstances specifies that instances should be used\n\t/// @returns a boolean indicating that the submesh is ready or not\n\t@override\n\texternal bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);" : "/// Get if the submesh is ready to be used and all its information available.\n\t/// Child classes can use it to update shaders\n\t/// @param mesh defines the mesh to check\n\t/// @param subMesh defines which submesh to check\n\t/// @param useInstances specifies that instances should be used\n\t/// @returns a boolean indicating that the submesh is ready or not\n\t@override\n\texternal bool isReadyForSubMesh(AbstractMesh mesh, BaseSubMesh subMesh, [bool useInstances]);",
    "/// Defines the camera the input is attached to.\n\t@override\n\texternal ArcRotateCamera get camera;\n\t@override\n\texternal set camera(ArcRotateCamera value);" : "/// Defines the camera the input is attached to.\n\t@override\n\texternal ArcRotateCamera get camera;\n\t@override\n\texternal set camera(Camera value);",
    "@override\n\texternal ArcRotateCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(ArcRotateCameraInputsManager value);" : "@override\n\texternal ArcRotateCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(CameraInputsManager<Camera> value);",
    "@override\n\texternal FlyCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(FlyCameraInputsManager value);" : "@override\n\texternal FlyCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(CameraInputsManager<Camera> value);",
    "@override\n\texternal FollowCamera get camera;\n\t@override\n\texternal set camera(FollowCamera value);" : "@override\n\texternal FollowCamera get camera;\n\t@override\n\texternal set camera(Camera value);",
    "@override\n\texternal FollowCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(FollowCameraInputsManager value);" : "@override\n\texternal FollowCameraInputsManager get inputs;\n\t@override\n\texternal set inputs(CameraInputsManager<Camera> value);",
    "external set checkInputs(void Function() value);\n\t\n\t/// Defines the camera the input is attached to.\n\texternal TCamera get camera;\n\texternal set camera(TCamera value);" : "external set checkInputs(void Function() value);\n\t\n\t/// Defines the camera the input is attached to.\n\texternal FreeCamera get camera;\n\texternal set camera(FreeCamera value);",
    "external WebGL.VertexArrayObject recordVertexArrayObject(dynamic /* object */ vertexBuffers, NativeDataBuffer indexBuffer, Effect effect);" : "external WebGL.VertexArrayObject recordVertexArrayObject(dynamic vertexBuffers, DataBuffer indexBuffer, Effect effect);",
    "external dynamic createRawShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, [WebGL.RenderingContext context, List<String> transformFeedbackVaryings]);" : "external WebGL.Program createRawShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, [WebGL.RenderingContext context, List<String> transformFeedbackVaryings]);",
    "external dynamic createShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, String defines, [WebGL.RenderingContext context, List<String> transformFeedbackVaryings]);" : "external WebGL.Program createShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, String defines, [WebGL.RenderingContext context, List<String> transformFeedbackVaryings]);",
    "external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);" : "external bool isReadyForSubMesh(AbstractMesh mesh, BaseSubMesh subMesh, [bool useInstances]);",
    "external TrailMesh clone([String name, TransformNode newGenerator, bool doNotCloneChildren, bool clonePhysicsImpostor]);" : "external TrailMesh clone([String name, Node newGenerator, bool doNotCloneChildren, bool clonePhysicsImpostor]);",
    "external set lockedTarget(AbstractMesh value);" : "external set lockedTarget(dynamic value);",
    "external SphereDirectedParticleEmitter createDirectedCylinderEmitter(num radius, num height, num radiusRange, Vector3 direction1, Vector3 direction2);" : "external CylinderDirectedParticleEmitter createDirectedCylinderEmitter(num radius, num height, num radiusRange, Vector3 direction1, Vector3 direction2);",
    "external TransformNode instantiateHierarchy([TransformNode newParent, MeshInstantiateHierarchyOptions options, void Function(TransformNode source, TransformNode clone) onNewNodeCreated]);" : "external TransformNode instantiateHierarchy([TransformNode newParent, TransformNodeInstantiateHierarchyOptions options, void Function(TransformNode source, TransformNode clone) onNewNodeCreated]);",
    "external void forceCompilation([void Function(IShadowGenerator generator) onCompiled, ShadowGeneratorForceCompilationOptions options]);" : "external void forceCompilation([void Function(IShadowGenerator generator) onCompiled, IShadowGeneratorForceCompilationOptions options]);",
    "external Promise<void> forceCompilationAsync([ShadowGeneratorForceCompilationAsyncOptions options]);" : "external Promise<void> forceCompilationAsync([IShadowGeneratorForceCompilationAsyncOptions options]);",
    "external set options(PointerDragBehaviorOptionsOptions value);" : "external set options(PointerDragBehaviorOptions value);",

    "external void updateDynamicIndexBuffer(DataBuffer indexBuffer, dynamic indices, [num offset]);" : "external void updateDynamicIndexBuffer(dynamic indexBuffer, dynamic indices, [num offset]);",
    "external void updateDynamicIndexBuffer(WebGL.Buffer indexBuffer, dynamic indices, [num offset]);" : "external void updateDynamicIndexBuffer(dynamic indexBuffer, dynamic indices, [num offset]);",
    "external void updateDynamicVertexBuffer(DataBuffer vertexBuffer, dynamic data, [num byteOffset, num byteLength]);" : "external void updateDynamicVertexBuffer(dynamic vertexBuffer, dynamic data, [num byteOffset, num byteLength]);",
    "external void updateDynamicVertexBuffer(WebGL.Buffer vertexBuffer, dynamic vertices, [num byteOffset, num byteLength]);" : "external void updateDynamicVertexBuffer(dynamic vertexBuffer, dynamic vertices, [num byteOffset, num byteLength]);",
    "external void updateDynamicTexture(InternalTexture texture, HTML.CanvasElement canvas, bool invertY, [bool premulAlpha, num format, bool forceBindTexture]);" : "external void updateDynamicTexture(InternalTexture texture, dynamic canvas, bool invertY, [bool premulAlpha, num format, bool forceBindTexture]);",
    
    "abstract class AbstractAssetTask {" : "abstract class AbstractAssetTask<T> {",
    "/// Callback called when the task is successful\n\texternal void Function(dynamic task) get onSuccess;\n\texternal set onSuccess(void Function(dynamic task) value);\n\t\n\t/// Callback called when the task is not successful\n\texternal void Function(dynamic task, [String message, dynamic exception]) get onError;\n\texternal set onError(void Function(dynamic task, [String message, dynamic exception]) value);" : "/// Callback called when the task is successful\n\texternal void Function(T task) get onSuccess;\n\texternal set onSuccess(void Function(T task) value);\n\t\n\t/// Callback called when the task is not successful\n\texternal void Function(T task, [String message, dynamic exception]) get onError;\n\texternal set onError(void Function(T task, [String message, dynamic exception]) value);",

    "class MeshAssetTask extends AbstractAssetTask" : "class MeshAssetTask extends AbstractAssetTask<MeshAssetTask>",
    "class TextFileAssetTask extends AbstractAssetTask" : "class TextFileAssetTask extends AbstractAssetTask<TextFileAssetTask>",
    "class BinaryFileAssetTask extends AbstractAssetTask" : "class BinaryFileAssetTask extends AbstractAssetTask<BinaryFileAssetTask>",
    "class ImageAssetTask extends AbstractAssetTask" : "class ImageAssetTask extends AbstractAssetTask<ImageAssetTask>",
    "class TextureAssetTask extends AbstractAssetTask" : "class TextureAssetTask extends AbstractAssetTask<TextureAssetTask>",
    "class CubeTextureAssetTask extends AbstractAssetTask" : "class CubeTextureAssetTask extends AbstractAssetTask<CubeTextureAssetTask>",
    "class HDRCubeTextureAssetTask extends AbstractAssetTask" : "class HDRCubeTextureAssetTask extends AbstractAssetTask<HDRCubeTextureAssetTask>",
    "class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask" : "class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask<EquiRectangularCubeTextureAssetTask>"
  },

  "classReplacements" : {
    "IMatrixLike" : "Matrix",
    "IColor3Like": "Color3",
    "IColor4Like": "Color4",
    "IVector2Like": "Vector2",
    "IVector3Like": "Vector3",
    "IVector4Like": "Vector4",
    "IViewportLike": "Viewport",
    "IPlaneLike": "Plane"
  },

  "extraImports" : [
    "babylon_extensions"
  ]
}