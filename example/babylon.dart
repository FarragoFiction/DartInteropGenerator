@JS("BABYLON")
library BABYLON;

import "dart:html" as HTML;
import "dart:js";
import "dart:math" as Math;
import "dart:typed_data";
import "dart:web_audio" as Audio;
import "dart:web_gl" as WebGL;

import "package:js/js.dart";

import "babylon_debug.dart";
import "babylon_extensions.dart";
import "interop_globals.dart";
import "promise.dart";

export "interop_globals.dart";
export "promise.dart";

/// @hidden
@JS()
@anonymous
class DeepImmutableArray<T> {
}

/// A class serves as a medium between the observable and its observers
@JS()
class EventState {
	
	/// Create a new EventState
	/// @param mask defines the mask associated with this state
	/// @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
	/// @param target defines the original target of the state
	/// @param currentTarget defines the current target of the state
	external factory EventState(num mask, [bool? skipNextObservers, dynamic? target, dynamic? currentTarget]);
	
	/// Initialize the current event state
	/// @param mask defines the mask associated with this state
	/// @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
	/// @param target defines the original target of the state
	/// @param currentTarget defines the current target of the state
	/// @returns the current event state
	external EventState initalize(num mask, [bool? skipNextObservers, dynamic? target, dynamic? currentTarget]);
	
	/// An Observer can set this property to true to prevent subsequent observers of being notified
	external bool get skipNextObservers;
	external set skipNextObservers(bool value);
	
	/// Get the mask value that were used to trigger the event corresponding to this EventState object
	external num get mask;
	external set mask(num value);
	
	/// The object that originally notified the event
	external dynamic get target;
	external set target(dynamic value);
	
	/// The current object in the bubbling phase
	external dynamic get currentTarget;
	external set currentTarget(dynamic value);
	
	/// This will be populated with the return value of the last function that was executed.
	/// If it is the first function in the callback chain it will be the event data.
	external dynamic get lastReturnValue;
	external set lastReturnValue(dynamic value);
	
	/// User defined information that will be sent to observers
	external dynamic get userInfo;
	external set userInfo(dynamic value);
}

/// Represent an Observer registered to a given Observable object.
@JS()
class Observer<T> {
	
	/// Creates a new observer
	/// @param callback defines the callback to call when the observer is notified
	/// @param mask defines the mask of the observer (used to filter notifications)
	/// @param scope defines the current scope used to restore the JS context
	external factory Observer(void Function(T eventData, EventState eventState) callback, num mask, [dynamic? scope]);
	
	/// Defines the callback to call when the observer is notified
	external void Function(T eventData, EventState eventState) get callback;
	external set callback(void Function(T eventData, EventState eventState) value);
	
	/// Defines the mask of the observer (used to filter notifications)
	external num get mask;
	external set mask(num value);
	
	/// Defines the current scope used to restore the JS context
	external dynamic get scope;
	external set scope(dynamic value);
	
	/// Gets or sets a property defining that the observer as to be unregistered after the next notification
	external bool get unregisterOnNextCall;
	external set unregisterOnNextCall(bool value);
}

/// Represent a list of observers registered to multiple Observables object.
@JS()
class MultiObserver<T> {
	external factory MultiObserver();
	
	/// Release associated resources
	external void dispose();
	
	/// Raise a callback when one of the observable will notify
	/// @param observables defines a list of observables to watch
	/// @param callback defines the callback to call on notification
	/// @param mask defines the mask used to filter notifications
	/// @param scope defines the current scope used to restore the JS context
	/// @returns the new MultiObserver
	external static MultiObserver<T> Watch<T>(List<Observable<T>> observables, void Function(T eventData, EventState eventState) callback, [num? mask, dynamic? scope]);
}

/// The Observable class is a simple implementation of the Observable pattern.
/// 
/// There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
/// This enable a more fine grained execution without having to rely on multiple different Observable objects.
/// For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
/// A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
@JS()
class Observable<T> {
	
	/// Creates a new observable
	/// @param onObserverAdded defines a callback to call when a new observer is added
	external factory Observable([void Function(Observer<T> observer)? onObserverAdded]);
	
	/// Gets the list of observers
	external List<Observer<T>> get observers;
	
	/// Create a new Observer with the specified callback
	/// @param callback the callback that will be executed for that Observer
	/// @param mask the mask used to filter observers
	/// @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
	/// @param scope optional scope for the callback to be called from
	/// @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
	/// @returns the new observer created for the callback
	external Observer<T>? add(void Function(T eventData, EventState eventState) callback, [num? mask, bool? insertFirst, dynamic? scope, bool? unregisterOnFirstCall]);
	
	/// Create a new Observer with the specified callback and unregisters after the next notification
	/// @param callback the callback that will be executed for that Observer
	/// @returns the new observer created for the callback
	external Observer<T>? addOnce(void Function(T eventData, EventState eventState) callback);
	
	/// Remove an Observer from the Observable object
	/// @param observer the instance of the Observer to remove
	/// @returns false if it doesn't belong to this Observable
	external bool remove(Observer<T>? observer);
	
	/// Remove a callback from the Observable object
	/// @param callback the callback to remove
	/// @param scope optional scope. If used only the callbacks with this scope will be removed
	/// @returns false if it doesn't belong to this Observable
	external bool removeCallback(void Function(T eventData, EventState eventState) callback, [dynamic? scope]);
	
	/// Moves the observable to the top of the observer list making it get called first when notified
	/// @param observer the observer to move
	external void makeObserverTopPriority(Observer<T> observer);
	
	/// Moves the observable to the bottom of the observer list making it get called last when notified
	/// @param observer the observer to move
	external void makeObserverBottomPriority(Observer<T> observer);
	
	/// Notify all Observers by calling their respective callback with the given data
	/// Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
	/// @param eventData defines the data to send to all observers
	/// @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
	/// @param target defines the original target of the state
	/// @param currentTarget defines the current target of the state
	/// @param userInfo defines any user info to send to observers
	/// @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
	external bool notifyObservers(T eventData, [num? mask, dynamic? target, dynamic? currentTarget, dynamic? userInfo]);
	
	/// Calling this will execute each callback, expecting it to be a promise or return a value.
	/// If at any point in the chain one function fails, the promise will fail and the execution will not continue.
	/// This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
	/// and it is crucial that all callbacks will be executed.
	/// The order of the callbacks is kept, callbacks are not executed parallel.
	/// 
	/// @param eventData The data to be sent to each callback
	/// @param mask is used to filter observers defaults to -1
	/// @param target defines the callback target (see EventState)
	/// @param currentTarget defines he current object in the bubbling phase
	/// @param userInfo defines any user info to send to observers
	/// @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
	external Promise<T> notifyObserversWithPromise(T eventData, [num? mask, dynamic? target, dynamic? currentTarget, dynamic? userInfo]);
	
	/// Notify a specific observer
	/// @param observer defines the observer to notify
	/// @param eventData defines the data to be sent to each callback
	/// @param mask is used to filter observers defaults to -1
	external void notifyObserver(Observer<T> observer, T eventData, [num? mask]);
	
	/// Gets a boolean indicating if the observable has at least one observer
	/// @returns true is the Observable has at least one Observer registered
	external bool hasObservers();
	
	/// Clear the list of observers
	external void clear();
	
	/// Clone the current observable
	/// @returns a new observable
	external Observable<T> clone();
	
	/// Does this observable handles observer registered with a given mask
	/// @param mask defines the mask to be tested
	/// @return whether or not one observer registered with the given mask is handeled
	/// 
	external bool hasSpecificMask([num? mask]);
}

/// Sets of helpers dealing with the DOM and some of the recurrent functions needed in
/// Babylon.js
@JS()
class DomManagement {
	external factory DomManagement();
	
	/// Checks if the window object exists
	/// @returns true if the window object exists
	external static bool IsWindowObjectExist();
	
	/// Checks if the navigator object exists
	/// @returns true if the navigator object exists
	external static bool IsNavigatorAvailable();
	
	/// Check if the document object exists
	/// @returns true if the document object exists
	external static bool IsDocumentAvailable();
	
	/// Extracts text content from a DOM element hierarchy
	/// @param element defines the root element
	/// @returns a string
	external static String GetDOMTextContent(HTML.Element element);
}

/// Logger used througouht the application to allow configuration of
/// the log level required for the messages.
@JS()
class Logger {
	external factory Logger();
	
	/// No log
	external static num get NoneLogLevel;
	
	/// Only message logs
	external static num get MessageLogLevel;
	
	/// Only warning logs
	external static num get WarningLogLevel;
	
	/// Only error logs
	external static num get ErrorLogLevel;
	
	/// All logs
	external static num get AllLogLevel;
	
	/// Gets a value indicating the number of loading errors
	/// @ignorenaming
	external static num get errorsCount;
	external static set errorsCount(num value);
	
	/// Callback called when a new log is added
	external static void Function(String entry) get OnNewCacheEntry;
	external static set OnNewCacheEntry(void Function(String entry) value);
	
	/// Log a message to the console
	external static void Function(String message) get Log;
	external static set Log(void Function(String message) value);
	
	/// Write a warning message to the console
	external static void Function(String message) get Warn;
	external static set Warn(void Function(String message) value);
	
	/// Write an error message to the console
	external static void Function(String message) get Error;
	external static set Error(void Function(String message) value);
	
	/// Gets current log cache (list of logs)
	external static String get LogCache;
	
	/// Clears the log cache
	external static void ClearLogCache();
	
	/// Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
	external static set LogLevels(num value);
}

/// Helper to manipulate strings
@JS()
class StringTools {
	external factory StringTools();
	
	/// Checks for a matching suffix at the end of a string (for ES5 and lower)
	/// @param str Source string
	/// @param suffix Suffix to search for in the source string
	/// @returns Boolean indicating whether the suffix was found (true) or not (false)
	external static bool EndsWith(String str, String suffix);
	
	/// Checks for a matching suffix at the beginning of a string (for ES5 and lower)
	/// @param str Source string
	/// @param suffix Suffix to search for in the source string
	/// @returns Boolean indicating whether the suffix was found (true) or not (false)
	external static bool StartsWith(String str, String suffix);
	
	/// Decodes a buffer into a string
	/// @param buffer The buffer to decode
	/// @returns The decoded string
	external static String Decode(dynamic buffer);
	
	/// Encode a buffer to a base64 string
	/// @param buffer defines the buffer to encode
	/// @returns the encoded string
	external static String EncodeArrayBufferToBase64(dynamic buffer);
	
	/// Converts a number to string and pads with preceeding zeroes until it is of specified length.
	/// @param num the number to convert and pad
	/// @param length the expected length of the string
	/// @returns the padded string
	external static String PadNumber(num num, num length);
}

/// Class containing a set of static utilities functions for deep copy.
@JS()
class DeepCopier {
	external factory DeepCopier();
	
	/// Tries to copy an object by duplicating every property
	/// @param source defines the source object
	/// @param destination defines the target object
	/// @param doNotCopyList defines a list of properties to avoid
	/// @param mustCopyList defines a list of properties to copy (even if they start with _)
	external static void DeepCopy(dynamic source, dynamic destination, [List<String>? doNotCopyList, List<String>? mustCopyList]);
}

/// Class containing a set of static utilities functions for precision date
@JS()
class PrecisionDate {
	external factory PrecisionDate();
	
	/// Gets either window.performance.now() if supported or Date.now() else
	external static num get Now;
}

/// Interface used to define the mechanism to get data from the network
@JS()
abstract class IWebRequest {
	
	/// Returns client's response url
	external String get responseURL;
	external set responseURL(String value);
	
	/// Returns client's status
	external num get status;
	external set status(num value);
	
	/// Returns client's status as a text
	external String get statusText;
	external set statusText(String value);
}

/// Extended version of XMLHttpRequest with support for customizations (headers, ...)
@JS()
class WebRequest implements IWebRequest {
	external factory WebRequest();
	
	/// Custom HTTP Request Headers to be sent with XMLHttpRequests
	/// i.e. when loading files, where the server/service expects an Authorization header
	external static dynamic /* object */ get CustomRequestHeaders;
	external static set CustomRequestHeaders(dynamic /* object */ value);
	
	/// Add callback functions in this array to update all the requests before they get sent to the network
	external static void Function(HTML.HttpRequest request, String url) get CustomRequestModifiers;
	external static set CustomRequestModifiers(void Function(HTML.HttpRequest request, String url) value);
	
	/// Gets or sets a function to be called when loading progress changes
	external dynamic Function(HTML.HttpRequest this_js, HTML.ProgressEvent ev)? get onprogress;
	
	external set onprogress(dynamic Function(HTML.HttpRequest this_js, HTML.ProgressEvent ev)? value);
	
	/// Returns client's state
	external num get readyState;
	
	/// Returns client's response
	external dynamic get response;
	
	/// Returns client's response as text
	external String get responseText;
	
	/// Gets or sets the expected response type
	external String get responseType;
	
	external set responseType(String value);
	
	/// @hidden
	external void addEventListener<K>(K type, dynamic Function(HTML.HttpRequest this_js, List<dynamic> ev) listener, [dynamic? options]);
	
	/// @hidden
	external void removeEventListener<K>(K type, dynamic Function(HTML.HttpRequest this_js, List<dynamic> ev) listener, [dynamic? options]);
	
	/// Cancels any network activity
	external void abort();
	
	/// Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD
	/// @param body defines an optional request body
	external void send([dynamic? body]);
	
	/// Sets the request method, request URL
	/// @param method defines the method to use (GET, POST, etc..)
	/// @param url defines the url to connect with
	external void open(String method, String url);
	
	/// Sets the value of a request header.
	/// @param name The name of the header whose value is to be set
	/// @param value The value to set as the body of the header
	external void setRequestHeader(String name, String value);
	
	/// Get the string containing the text of a particular header's value.
	/// @param name The name of the header
	/// @returns The string containing the text of the given header name
	external String? getResponseHeader(String name);
	
	/// Returns client's response url
	external String get responseURL;
	external set responseURL(String value);
	
	/// Returns client's status
	external num get status;
	external set status(num value);
	
	/// Returns client's status as a text
	external String get statusText;
	external set statusText(String value);
}

/// File request interface
@JS()
@anonymous
class IFileRequest {
	
	external factory IFileRequest({Observable<IFileRequest> onCompleteObservable, void Function() abort});
	
	/// Raised when the request is complete (success or error).
	external Observable<IFileRequest> get onCompleteObservable;
	external set onCompleteObservable( Observable<IFileRequest> value );
	
	/// Aborts the request for a file.
	external void Function() get abort;
	external set abort( void Function() value );
}

/// Define options used to create a render target texture
@JS()
class RenderTargetCreationOptions {
	external factory RenderTargetCreationOptions();
	
	/// Specifies is mipmaps must be generated
	external bool get generateMipMaps;
	external set generateMipMaps(bool value);
	
	/// Specifies whether or not a depth should be allocated in the texture (true by default)
	external bool get generateDepthBuffer;
	external set generateDepthBuffer(bool value);
	
	/// Specifies whether or not a stencil should be allocated in the texture (false by default)
	external bool get generateStencilBuffer;
	external set generateStencilBuffer(bool value);
	
	/// Defines texture type (int by default)
	external num get type;
	external set type(num value);
	
	/// Defines sampling mode (trilinear by default)
	external num get samplingMode;
	external set samplingMode(num value);
	
	/// Defines format (RGBA by default)
	external num get format;
	external set format(num value);
}

/// Defines the cross module used constants to avoid circular dependncies
@JS()
class Constants {
	external factory Constants();
	
	/// Defines that alpha blending is disabled
	external static num get ALPHA_DISABLE;
	
	/// Defines that alpha blending is SRC ALPHA * SRC + DEST
	external static num get ALPHA_ADD;
	
	/// Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST
	external static num get ALPHA_COMBINE;
	
	/// Defines that alpha blending is DEST - SRC * DEST
	external static num get ALPHA_SUBTRACT;
	
	/// Defines that alpha blending is SRC * DEST
	external static num get ALPHA_MULTIPLY;
	
	/// Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC) * DEST
	external static num get ALPHA_MAXIMIZED;
	
	/// Defines that alpha blending is SRC + DEST
	external static num get ALPHA_ONEONE;
	
	/// Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST
	external static num get ALPHA_PREMULTIPLIED;
	
	/// Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST
	/// Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
	external static num get ALPHA_PREMULTIPLIED_PORTERDUFF;
	
	/// Defines that alpha blending is CST * SRC + (1 - CST) * DEST
	external static num get ALPHA_INTERPOLATE;
	
	/// Defines that alpha blending is SRC + (1 - SRC) * DEST
	/// Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
	external static num get ALPHA_SCREENMODE;
	
	/// Defines that alpha blending is SRC + DST
	/// Alpha will be set to SRC ALPHA + DST ALPHA
	external static num get ALPHA_ONEONE_ONEONE;
	
	/// Defines that alpha blending is SRC * DST ALPHA + DST
	/// Alpha will be set to 0
	external static num get ALPHA_ALPHATOCOLOR;
	
	/// Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)
	external static num get ALPHA_REVERSEONEMINUS;
	
	/// Defines that alpha blending is SRC + DST * (1 - SRC ALPHA)
	/// Alpha will be set to SRC ALPHA + DST ALPHA * (1 - SRC ALPHA)
	external static num get ALPHA_SRC_DSTONEMINUSSRCALPHA;
	
	/// Defines that alpha blending is SRC + DST
	/// Alpha will be set to SRC ALPHA
	external static num get ALPHA_ONEONE_ONEZERO;
	
	/// Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)
	/// Alpha will be set to DST ALPHA
	external static num get ALPHA_EXCLUSION;
	
	/// Defines that alpha blending equation a SUM
	external static num get ALPHA_EQUATION_ADD;
	
	/// Defines that alpha blending equation a SUBSTRACTION
	external static num get ALPHA_EQUATION_SUBSTRACT;
	
	/// Defines that alpha blending equation a REVERSE SUBSTRACTION
	external static num get ALPHA_EQUATION_REVERSE_SUBTRACT;
	
	/// Defines that alpha blending equation a MAX operation
	external static num get ALPHA_EQUATION_MAX;
	
	/// Defines that alpha blending equation a MIN operation
	external static num get ALPHA_EQUATION_MIN;
	
	/// Defines that alpha blending equation a DARKEN operation:
	/// It takes the min of the src and sums the alpha channels.
	external static num get ALPHA_EQUATION_DARKEN;
	
	/// Defines that the ressource is not delayed
	external static num get DELAYLOADSTATE_NONE;
	
	/// Defines that the ressource was successfully delay loaded
	external static num get DELAYLOADSTATE_LOADED;
	
	/// Defines that the ressource is currently delay loading
	external static num get DELAYLOADSTATE_LOADING;
	
	/// Defines that the ressource is delayed and has not started loading
	external static num get DELAYLOADSTATE_NOTLOADED;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn
	external static num get NEVER;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn
	external static num get ALWAYS;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value
	external static num get LESS;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value
	external static num get EQUAL;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value
	external static num get LEQUAL;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value
	external static num get GREATER;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value
	external static num get GEQUAL;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value
	external static num get NOTEQUAL;
	
	/// Passed to stencilOperation to specify that stencil value must be kept
	external static num get KEEP;
	
	/// Passed to stencilOperation to specify that stencil value must be replaced
	external static num get REPLACE;
	
	/// Passed to stencilOperation to specify that stencil value must be incremented
	external static num get INCR;
	
	/// Passed to stencilOperation to specify that stencil value must be decremented
	external static num get DECR;
	
	/// Passed to stencilOperation to specify that stencil value must be inverted
	external static num get INVERT;
	
	/// Passed to stencilOperation to specify that stencil value must be incremented with wrapping
	external static num get INCR_WRAP;
	
	/// Passed to stencilOperation to specify that stencil value must be decremented with wrapping
	external static num get DECR_WRAP;
	
	/// Texture is not repeating outside of 0..1 UVs
	external static num get TEXTURE_CLAMP_ADDRESSMODE;
	
	/// Texture is repeating outside of 0..1 UVs
	external static num get TEXTURE_WRAP_ADDRESSMODE;
	
	/// Texture is repeating and mirrored
	external static num get TEXTURE_MIRROR_ADDRESSMODE;
	
	/// ALPHA
	external static num get TEXTUREFORMAT_ALPHA;
	
	/// LUMINANCE
	external static num get TEXTUREFORMAT_LUMINANCE;
	
	/// LUMINANCE_ALPHA
	external static num get TEXTUREFORMAT_LUMINANCE_ALPHA;
	
	/// RGB
	external static num get TEXTUREFORMAT_RGB;
	
	/// RGBA
	external static num get TEXTUREFORMAT_RGBA;
	
	/// RED
	external static num get TEXTUREFORMAT_RED;
	
	/// RED (2nd reference)
	external static num get TEXTUREFORMAT_R;
	
	/// RG
	external static num get TEXTUREFORMAT_RG;
	
	/// RED_INTEGER
	external static num get TEXTUREFORMAT_RED_INTEGER;
	
	/// RED_INTEGER (2nd reference)
	external static num get TEXTUREFORMAT_R_INTEGER;
	
	/// RG_INTEGER
	external static num get TEXTUREFORMAT_RG_INTEGER;
	
	/// RGB_INTEGER
	external static num get TEXTUREFORMAT_RGB_INTEGER;
	
	/// RGBA_INTEGER
	external static num get TEXTUREFORMAT_RGBA_INTEGER;
	
	/// UNSIGNED_BYTE
	external static num get TEXTURETYPE_UNSIGNED_BYTE;
	
	/// UNSIGNED_BYTE (2nd reference)
	external static num get TEXTURETYPE_UNSIGNED_INT;
	
	/// FLOAT
	external static num get TEXTURETYPE_FLOAT;
	
	/// HALF_FLOAT
	external static num get TEXTURETYPE_HALF_FLOAT;
	
	/// BYTE
	external static num get TEXTURETYPE_BYTE;
	
	/// SHORT
	external static num get TEXTURETYPE_SHORT;
	
	/// UNSIGNED_SHORT
	external static num get TEXTURETYPE_UNSIGNED_SHORT;
	
	/// INT
	external static num get TEXTURETYPE_INT;
	
	/// UNSIGNED_INT
	external static num get TEXTURETYPE_UNSIGNED_INTEGER;
	
	/// UNSIGNED_SHORT_4_4_4_4
	external static num get TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4;
	
	/// UNSIGNED_SHORT_5_5_5_1
	external static num get TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1;
	
	/// UNSIGNED_SHORT_5_6_5
	external static num get TEXTURETYPE_UNSIGNED_SHORT_5_6_5;
	
	/// UNSIGNED_INT_2_10_10_10_REV
	external static num get TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV;
	
	/// UNSIGNED_INT_24_8
	external static num get TEXTURETYPE_UNSIGNED_INT_24_8;
	
	/// UNSIGNED_INT_10F_11F_11F_REV
	external static num get TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;
	
	/// UNSIGNED_INT_5_9_9_9_REV
	external static num get TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV;
	
	/// FLOAT_32_UNSIGNED_INT_24_8_REV
	external static num get TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV;
	
	/// nearest is mag = nearest and min = nearest and no mip
	external static num get TEXTURE_NEAREST_SAMPLINGMODE;
	
	/// mag = nearest and min = nearest and mip = none
	external static num get TEXTURE_NEAREST_NEAREST;
	
	/// Bilinear is mag = linear and min = linear and no mip
	external static num get TEXTURE_BILINEAR_SAMPLINGMODE;
	
	/// mag = linear and min = linear and mip = none
	external static num get TEXTURE_LINEAR_LINEAR;
	
	/// Trilinear is mag = linear and min = linear and mip = linear
	external static num get TEXTURE_TRILINEAR_SAMPLINGMODE;
	
	/// Trilinear is mag = linear and min = linear and mip = linear
	external static num get TEXTURE_LINEAR_LINEAR_MIPLINEAR;
	
	/// mag = nearest and min = nearest and mip = nearest
	external static num get TEXTURE_NEAREST_NEAREST_MIPNEAREST;
	
	/// mag = nearest and min = linear and mip = nearest
	external static num get TEXTURE_NEAREST_LINEAR_MIPNEAREST;
	
	/// mag = nearest and min = linear and mip = linear
	external static num get TEXTURE_NEAREST_LINEAR_MIPLINEAR;
	
	/// mag = nearest and min = linear and mip = none
	external static num get TEXTURE_NEAREST_LINEAR;
	
	/// nearest is mag = nearest and min = nearest and mip = linear
	external static num get TEXTURE_NEAREST_NEAREST_MIPLINEAR;
	
	/// mag = linear and min = nearest and mip = nearest
	external static num get TEXTURE_LINEAR_NEAREST_MIPNEAREST;
	
	/// mag = linear and min = nearest and mip = linear
	external static num get TEXTURE_LINEAR_NEAREST_MIPLINEAR;
	
	/// Bilinear is mag = linear and min = linear and mip = nearest
	external static num get TEXTURE_LINEAR_LINEAR_MIPNEAREST;
	
	/// mag = linear and min = nearest and mip = none
	external static num get TEXTURE_LINEAR_NEAREST;
	
	/// Explicit coordinates mode
	external static num get TEXTURE_EXPLICIT_MODE;
	
	/// Spherical coordinates mode
	external static num get TEXTURE_SPHERICAL_MODE;
	
	/// Planar coordinates mode
	external static num get TEXTURE_PLANAR_MODE;
	
	/// Cubic coordinates mode
	external static num get TEXTURE_CUBIC_MODE;
	
	/// Projection coordinates mode
	external static num get TEXTURE_PROJECTION_MODE;
	
	/// Skybox coordinates mode
	external static num get TEXTURE_SKYBOX_MODE;
	
	/// Inverse Cubic coordinates mode
	external static num get TEXTURE_INVCUBIC_MODE;
	
	/// Equirectangular coordinates mode
	external static num get TEXTURE_EQUIRECTANGULAR_MODE;
	
	/// Equirectangular Fixed coordinates mode
	external static num get TEXTURE_FIXED_EQUIRECTANGULAR_MODE;
	
	/// Equirectangular Fixed Mirrored coordinates mode
	external static num get TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
	
	/// Offline (baking) quality for texture filtering
	external static num get TEXTURE_FILTERING_QUALITY_OFFLINE;
	
	/// High quality for texture filtering
	external static num get TEXTURE_FILTERING_QUALITY_HIGH;
	
	/// Medium quality for texture filtering
	external static num get TEXTURE_FILTERING_QUALITY_MEDIUM;
	
	/// Low quality for texture filtering
	external static num get TEXTURE_FILTERING_QUALITY_LOW;
	
	/// Defines that texture rescaling will use a floor to find the closer power of 2 size
	external static num get SCALEMODE_FLOOR;
	
	/// Defines that texture rescaling will look for the nearest power of 2 size
	external static num get SCALEMODE_NEAREST;
	
	/// Defines that texture rescaling will use a ceil to find the closer power of 2 size
	external static num get SCALEMODE_CEILING;
	
	/// The dirty texture flag value
	external static num get MATERIAL_TextureDirtyFlag;
	
	/// The dirty light flag value
	external static num get MATERIAL_LightDirtyFlag;
	
	/// The dirty fresnel flag value
	external static num get MATERIAL_FresnelDirtyFlag;
	
	/// The dirty attribute flag value
	external static num get MATERIAL_AttributesDirtyFlag;
	
	/// The dirty misc flag value
	external static num get MATERIAL_MiscDirtyFlag;
	
	/// The dirty prepass flag value
	external static num get MATERIAL_PrePassDirtyFlag;
	
	/// The all dirty flag value
	external static num get MATERIAL_AllDirtyFlag;
	
	/// Returns the triangle fill mode
	external static num get MATERIAL_TriangleFillMode;
	
	/// Returns the wireframe mode
	external static num get MATERIAL_WireFrameFillMode;
	
	/// Returns the point fill mode
	external static num get MATERIAL_PointFillMode;
	
	/// Returns the point list draw mode
	external static num get MATERIAL_PointListDrawMode;
	
	/// Returns the line list draw mode
	external static num get MATERIAL_LineListDrawMode;
	
	/// Returns the line loop draw mode
	external static num get MATERIAL_LineLoopDrawMode;
	
	/// Returns the line strip draw mode
	external static num get MATERIAL_LineStripDrawMode;
	
	/// Returns the triangle strip draw mode
	external static num get MATERIAL_TriangleStripDrawMode;
	
	/// Returns the triangle fan draw mode
	external static num get MATERIAL_TriangleFanDrawMode;
	
	/// Stores the clock-wise side orientation
	external static num get MATERIAL_ClockWiseSideOrientation;
	
	/// Stores the counter clock-wise side orientation
	external static num get MATERIAL_CounterClockWiseSideOrientation;
	
	/// Nothing
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_NothingTrigger;
	
	/// On pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnPickTrigger;
	
	/// On left pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnLeftPickTrigger;
	
	/// On right pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnRightPickTrigger;
	
	/// On center pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnCenterPickTrigger;
	
	/// On pick down
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnPickDownTrigger;
	
	/// On double pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnDoublePickTrigger;
	
	/// On pick up
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnPickUpTrigger;
	
	/// On pick out.
	/// This trigger will only be raised if you also declared a OnPickDown
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnPickOutTrigger;
	
	/// On long press
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnLongPressTrigger;
	
	/// On pointer over
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnPointerOverTrigger;
	
	/// On pointer out
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnPointerOutTrigger;
	
	/// On every frame
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnEveryFrameTrigger;
	
	/// On intersection enter
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnIntersectionEnterTrigger;
	
	/// On intersection exit
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnIntersectionExitTrigger;
	
	/// On key down
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnKeyDownTrigger;
	
	/// On key up
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get ACTION_OnKeyUpTrigger;
	
	/// Billboard mode will only apply to Y axis
	external static num get PARTICLES_BILLBOARDMODE_Y;
	
	/// Billboard mode will apply to all axes
	external static num get PARTICLES_BILLBOARDMODE_ALL;
	
	/// Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
	external static num get PARTICLES_BILLBOARDMODE_STRETCHED;
	
	/// Default culling strategy : this is an exclusion test and it's the more accurate.
	/// Test order :
	/// Is the bounding sphere outside the frustum ?
	/// If not, are the bounding box vertices outside the frustum ?
	/// It not, then the cullable object is in the frustum.
	external static num get MESHES_CULLINGSTRATEGY_STANDARD;
	
	/// Culling strategy : Bounding Sphere Only.
	/// This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.
	/// It's also less accurate than the standard because some not visible objects can still be selected.
	/// Test : is the bounding sphere outside the frustum ?
	/// If not, then the cullable object is in the frustum.
	external static num get MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
	
	/// Culling strategy : Optimistic Inclusion.
	/// This in an inclusion test first, then the standard exclusion test.
	/// This can be faster when a cullable object is expected to be almost always in the camera frustum.
	/// This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.
	/// Anyway, it's as accurate as the standard strategy.
	/// Test :
	/// Is the cullable object bounding sphere center in the frustum ?
	/// If not, apply the default culling strategy.
	external static num get MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION;
	
	/// Culling strategy : Optimistic Inclusion then Bounding Sphere Only.
	/// This in an inclusion test first, then the bounding sphere only exclusion test.
	/// This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.
	/// This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.
	/// It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.
	/// Test :
	/// Is the cullable object bounding sphere center in the frustum ?
	/// If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.
	external static num get MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;
	
	/// No logging while loading
	external static num get SCENELOADER_NO_LOGGING;
	
	/// Minimal logging while loading
	external static num get SCENELOADER_MINIMAL_LOGGING;
	
	/// Summary logging while loading
	external static num get SCENELOADER_SUMMARY_LOGGING;
	
	/// Detailled logging while loading
	external static num get SCENELOADER_DETAILED_LOGGING;
	
	/// Constant used to retrieve the irradiance texture index in the textures array in the prepass
	/// using getIndex(Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE)
	external static num get PREPASS_IRRADIANCE_TEXTURE_TYPE;
	
	/// Constant used to retrieve the position texture index in the textures array in the prepass
	/// using getIndex(Constants.PREPASS_POSITION_TEXTURE_INDEX)
	external static num get PREPASS_POSITION_TEXTURE_TYPE;
	
	/// Constant used to retrieve the velocity texture index in the textures array in the prepass
	/// using getIndex(Constants.PREPASS_VELOCITY_TEXTURE_INDEX)
	external static num get PREPASS_VELOCITY_TEXTURE_TYPE;
	
	/// Constant used to retrieve the reflectivity texture index in the textures array in the prepass
	/// using the getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE)
	external static num get PREPASS_REFLECTIVITY_TEXTURE_TYPE;
	
	/// Constant used to retrieve the lit color texture index in the textures array in the prepass
	/// using the getIndex(Constants.PREPASS_COLOR_TEXTURE_TYPE)
	external static num get PREPASS_COLOR_TEXTURE_TYPE;
	
	/// Constant used to retrieve depth + normal index in the textures array in the prepass
	/// using the getIndex(Constants.PREPASS_DEPTHNORMAL_TEXTURE_TYPE)
	external static num get PREPASS_DEPTHNORMAL_TEXTURE_TYPE;
	
	/// Constant used to retrieve albedo index in the textures array in the prepass
	/// using the getIndex(Constants.PREPASS_ALBEDO_TEXTURE_TYPE)
	external static num get PREPASS_ALBEDO_TEXTURE_TYPE;
}

/// This represents the required contract to create a new type of texture loader.
@JS()
abstract class IInternalTextureLoader {
	
	/// Defines wether the loader supports cascade loading the different faces.
	external bool get supportCascades;
	external set supportCascades(bool value);
	
	/// This returns if the loader support the current file information.
	/// @param extension defines the file extension of the file being loaded
	/// @param mimeType defines the optional mime type of the file being loaded
	/// @returns true if the loader can load the specified file
	external bool canLoad(String extension, [String? mimeType]);
	
	/// Uploads the cube texture data to the WebGL texture. It has already been bound.
	/// @param data contains the texture data
	/// @param texture defines the BabylonJS internal texture
	/// @param createPolynomials will be true if polynomials have been requested
	/// @param onLoad defines the callback to trigger once the texture is ready
	/// @param onError defines the callback to trigger in case of error
	/// @param options options to be passed to the loader
	external void loadCubeData(dynamic data, InternalTexture texture, bool createPolynomials, void Function([dynamic? data])? onLoad, void Function([String? message, dynamic? exception])? onError, [dynamic? options]);
	
	/// Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
	/// @param data contains the texture data
	/// @param texture defines the BabylonJS internal texture
	/// @param callback defines the method to call once ready to upload
	/// @param options options to be passed to the loader
	external void loadData(dynamic data, InternalTexture texture, void Function(num width, num height, bool loadMipmap, bool isCompressed, void Function() done, [bool? loadFailed]) callback, [dynamic? options]);
}

/// Class used to store and describe the pipeline context associated with an effect
@JS()
abstract class IPipelineContext {
	
	/// Gets a boolean indicating that this pipeline context is supporting asynchronous creating
	external bool get isAsync;
	external set isAsync(bool value);
	
	/// Gets a boolean indicating that the context is ready to be used (like shaders / pipelines are compiled and ready for instance)
	external bool get isReady;
	external set isReady(bool value);
}

/// Class used to store gfx data (like WebGLBuffer)
@JS()
class DataBuffer {
	external factory DataBuffer();
	
	/// Gets or sets the number of objects referencing this buffer
	external num get references;
	external set references(num value);
	
	/// Gets or sets the size of the underlying buffer
	external num get capacity;
	external set capacity(num value);
	
	/// Gets or sets a boolean indicating if the buffer contains 32bits indices
	external bool get is32Bits;
	external set is32Bits(bool value);
	
	/// Gets the underlying buffer
	external dynamic get underlyingResource;
}

/// @hidden
@JS()
abstract class IShaderProcessor {
	
	external String Function(String attribute) get attributeProcessor;
	external set attributeProcessor(String Function(String attribute) value);
	
	external String Function(String varying, bool isFragment) get varyingProcessor;
	external set varyingProcessor(String Function(String varying, bool isFragment) value);
	
	external String Function(String uniform, bool isFragment) get uniformProcessor;
	external set uniformProcessor(String Function(String uniform, bool isFragment) value);
	
	external String Function(String uniformBuffer, bool isFragment) get uniformBufferProcessor;
	external set uniformBufferProcessor(String Function(String uniformBuffer, bool isFragment) value);
	
	external String Function(String closingBracketLine, bool isFragment) get endOfUniformBufferProcessor;
	external set endOfUniformBufferProcessor(String Function(String closingBracketLine, bool isFragment) value);
	
	external String Function(String line, bool isFragment) get lineProcessor;
	external set lineProcessor(String Function(String line, bool isFragment) value);
	
	external String Function(String code, List<String> defines, bool isFragment) get preProcessor;
	external set preProcessor(String Function(String code, List<String> defines, bool isFragment) value);
	
	external String Function(String code, List<String> defines, bool isFragment, ThinEngine engine) get postProcessor;
	external set postProcessor(String Function(String code, List<String> defines, bool isFragment, ThinEngine engine) value);
}

/// @hidden
@JS()
@anonymous
class ProcessingOptions {
	
	external factory ProcessingOptions({List<String> defines, dynamic indexParameters, bool isFragment, bool shouldUseHighPrecisionShader, bool supportsUniformBuffers, String shadersRepository, dynamic /* object */ includesShadersStore, IShaderProcessor processor, String version, String platformName, bool lookForClosingBracketForUniformBuffer});
	
	external List<String> get defines;
	external set defines( List<String> value );
	
	external dynamic get indexParameters;
	external set indexParameters( dynamic value );
	
	external bool get isFragment;
	external set isFragment( bool value );
	
	external bool get shouldUseHighPrecisionShader;
	external set shouldUseHighPrecisionShader( bool value );
	
	external bool get supportsUniformBuffers;
	external set supportsUniformBuffers( bool value );
	
	external String get shadersRepository;
	external set shadersRepository( String value );
	
	external dynamic /* object */ get includesShadersStore;
	external set includesShadersStore( dynamic /* object */ value );
	
	external IShaderProcessor get processor;
	external set processor( IShaderProcessor value );
	
	external String get version;
	external set version( String value );
	
	external String get platformName;
	external set platformName( String value );
	
	external bool get lookForClosingBracketForUniformBuffer;
	external set lookForClosingBracketForUniformBuffer( bool value );
}

/// @hidden
@JS()
class ShaderCodeNode {
	external factory ShaderCodeNode();
	
	external String get line;
	external set line(String value);
	
	external List<ShaderCodeNode> get children;
	external set children(List<ShaderCodeNode> value);
	
	external String get additionalDefineKey;
	external set additionalDefineKey(String value);
	
	external String get additionalDefineValue;
	external set additionalDefineValue(String value);
	
	external bool isValid(dynamic /* object */ preprocessors);
	
	external String process(dynamic /* object */ preprocessors, ProcessingOptions options);
}

/// @hidden
@JS()
class ShaderCodeCursor {
	external factory ShaderCodeCursor();
	
	external num get lineIndex;
	external set lineIndex(num value);
	
	external String get currentLine;
	
	external bool get canRead;
	
	external set lines(List<String> value);
}

/// @hidden
@JS()
class ShaderCodeConditionNode extends ShaderCodeNode {
	external factory ShaderCodeConditionNode();
	
	@override
	external String process(dynamic /* object */ preprocessors, ProcessingOptions options);
}

/// @hidden
@JS()
class ShaderDefineExpression {
	external factory ShaderDefineExpression();
	
	external bool isTrue(dynamic /* object */ preprocessors);
	
	external static String postfixToInfix(List<String> postfix);
	
	external static List<String> infixToPostfix(String infix);
}

/// @hidden
@JS()
class ShaderCodeTestNode extends ShaderCodeNode {
	external factory ShaderCodeTestNode();
	
	external ShaderDefineExpression get testExpression;
	external set testExpression(ShaderDefineExpression value);
	
	@override
	external bool isValid(dynamic /* object */ preprocessors);
}

/// @hidden
@JS()
class ShaderDefineIsDefinedOperator extends ShaderDefineExpression {
	
	external factory ShaderDefineIsDefinedOperator(String define, [bool? not]);
	
	external String get define;
	external set define(String value);
	
	external bool get not;
	external set not(bool value);
	
	@override
	external bool isTrue(dynamic /* object */ preprocessors);
}

/// @hidden
@JS()
class ShaderDefineOrOperator extends ShaderDefineExpression {
	external factory ShaderDefineOrOperator();
	
	external ShaderDefineExpression get leftOperand;
	external set leftOperand(ShaderDefineExpression value);
	
	external ShaderDefineExpression get rightOperand;
	external set rightOperand(ShaderDefineExpression value);
	
	@override
	external bool isTrue(dynamic /* object */ preprocessors);
}

/// @hidden
@JS()
class ShaderDefineAndOperator extends ShaderDefineExpression {
	external factory ShaderDefineAndOperator();
	
	external ShaderDefineExpression get leftOperand;
	external set leftOperand(ShaderDefineExpression value);
	
	external ShaderDefineExpression get rightOperand;
	external set rightOperand(ShaderDefineExpression value);
	
	@override
	external bool isTrue(dynamic /* object */ preprocessors);
}

/// @hidden
@JS()
class ShaderDefineArithmeticOperator extends ShaderDefineExpression {
	
	external factory ShaderDefineArithmeticOperator(String define, String operand, String testValue);
	
	external String get define;
	external set define(String value);
	
	external String get operand;
	external set operand(String value);
	
	external String get testValue;
	external set testValue(String value);
	
	@override
	external bool isTrue(dynamic /* object */ preprocessors);
}

/// Class used to enable access to offline support
/// @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
@JS()
abstract class IOfflineProvider {
	
	/// Gets a boolean indicating if scene must be saved in the database
	external bool get enableSceneOffline;
	external set enableSceneOffline(bool value);
	
	/// Gets a boolean indicating if textures must be saved in the database
	external bool get enableTexturesOffline;
	external set enableTexturesOffline(bool value);
	
	/// Open the offline support and make it available
	/// @param successCallback defines the callback to call on success
	/// @param errorCallback defines the callback to call on error
	external void open(void Function() successCallback, void Function() errorCallback);
	
	/// Loads an image from the offline support
	/// @param url defines the url to load from
	/// @param image defines the target DOM image
	external void loadImage(String url, HTML.ImageElement image);
	
	/// Loads a file from offline support
	/// @param url defines the URL to load from
	/// @param sceneLoaded defines a callback to call on success
	/// @param progressCallBack defines a callback to call when progress changed
	/// @param errorCallback defines a callback to call on error
	/// @param useArrayBuffer defines a boolean to use array buffer instead of text string
	external void loadFile(String url, void Function(dynamic data) sceneLoaded, [void Function(dynamic data)? progressCallBack, void Function()? errorCallback, bool? useArrayBuffer]);
}

/// Class used to help managing file picking and drag'n'drop
/// File Storage
@JS()
class FilesInputStore {
	external factory FilesInputStore();
	
	/// List of files ready to be loaded
	external static dynamic /* object */ get FilesToLoad;
	external static set FilesToLoad(dynamic /* object */ value);
}

/// Class used to define a retry strategy when error happens while loading assets
@JS()
class RetryStrategy {
	external factory RetryStrategy();
	
	/// Function used to defines an exponential back off strategy
	/// @param maxRetries defines the maximum number of retries (3 by default)
	/// @param baseInterval defines the interval between retries
	/// @returns the strategy function to use
	external static num Function(String url, WebRequest request, num retryIndex) ExponentialBackoff([num? maxRetries, num? baseInterval]);
}

/// @ignore
/// Application error to support additional information when loading a file
@JS()
/* Manual Fix 1 */
abstract class BaseError {
	external factory BaseError();
}

/// @ignore
@JS()
class LoadFileError extends BaseError {
	
	/// Creates a new LoadFileError
	/// @param message defines the message of the error
	/// @param request defines the optional web request
	/// @param file defines the optional file
	external factory LoadFileError(String message, [dynamic? object]);
	
	external WebRequest get request;
	external set request(WebRequest value);
	
	external HTML.File get file;
	external set file(HTML.File value);
}

/// @ignore
@JS()
class RequestFileError extends BaseError {
	
	/// Creates a new LoadFileError
	/// @param message defines the message of the error
	/// @param request defines the optional web request
	external factory RequestFileError(String message, WebRequest request);
	
	external WebRequest get request;
	external set request(WebRequest value);
}

/// @ignore
@JS()
class ReadFileError extends BaseError {
	
	/// Creates a new ReadFileError
	/// @param message defines the message of the error
	/// @param file defines the optional file
	external factory ReadFileError(String message, HTML.File file);
	
	external HTML.File get file;
	external set file(HTML.File value);
}

/// @hidden
@JS()
class FileTools {
	external factory FileTools();
	
	/// Gets or sets the retry strategy to apply when an error happens while loading an asset
	external static num Function(String url, WebRequest request, num retryIndex) get DefaultRetryStrategy;
	external static set DefaultRetryStrategy(num Function(String url, WebRequest request, num retryIndex) value);
	
	/// Gets or sets the base URL to use to load assets
	external static String get BaseUrl;
	external static set BaseUrl(String value);
	
	/// Default behaviour for cors in the application.
	/// It can be a string if the expected behavior is identical in the entire app.
	/// Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
	external static dynamic get CorsBehavior;
	external static set CorsBehavior(dynamic value);
	
	/// Gets or sets a function used to pre-process url before using them to load assets
	external static String Function(String url) get PreprocessUrl;
	external static set PreprocessUrl(String Function(String url) value);
	
	/// Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
	/// @param url define the url we are trying
	/// @param element define the dom element where to configure the cors policy
	external static void SetCorsBehavior(dynamic url, FileToolsSetCorsBehaviorElement element);
	
	/// Loads an image as an HTMLImageElement.
	/// @param input url string, ArrayBuffer, or Blob to load
	/// @param onLoad callback called when the image successfully loads
	/// @param onError callback called when the image fails to load
	/// @param offlineProvider offline provider for caching
	/// @param mimeType optional mime type
	/// @returns the HTMLImageElement of the loaded image
	external static HTML.ImageElement? LoadImage(dynamic input, void Function(dynamic img) onLoad, void Function([String? message, dynamic? exception]) onError, IOfflineProvider? offlineProvider, [String? mimeType]);
	
	/// Reads a file from a File object
	/// @param file defines the file to load
	/// @param onSuccess defines the callback to call when data is loaded
	/// @param onProgress defines the callback to call during loading process
	/// @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
	/// @param onError defines the callback to call when an error occurs
	/// @returns a file request object
	external static IFileRequest ReadFile(HTML.File file, void Function(dynamic data) onSuccess, [dynamic Function(HTML.ProgressEvent ev)? onProgress, bool? useArrayBuffer, void Function(ReadFileError error)? onError]);
	
	/// Loads a file from a url
	/// @param url url to load
	/// @param onSuccess callback called when the file successfully loads
	/// @param onProgress callback called while file is loading (if the server supports this mode)
	/// @param offlineProvider defines the offline provider for caching
	/// @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
	/// @param onError callback called when the file fails to load
	/// @returns a file request object
	external static IFileRequest LoadFile(String url, void Function(dynamic data, [String? responseURL]) onSuccess, [void Function(HTML.ProgressEvent ev)? onProgress, IOfflineProvider? offlineProvider, bool? useArrayBuffer, void Function([WebRequest? request, LoadFileError? exception])? onError]);
	
	/// Loads a file
	/// @param url url to load
	/// @param onSuccess callback called when the file successfully loads
	/// @param onProgress callback called while file is loading (if the server supports this mode)
	/// @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
	/// @param onError callback called when the file fails to load
	/// @param onOpened callback called when the web request is opened
	/// @returns a file request object
	external static IFileRequest RequestFile(String url, void Function(dynamic data, [WebRequest? request]) onSuccess, [void Function(HTML.ProgressEvent event)? onProgress, IOfflineProvider? offlineProvider, bool? useArrayBuffer, void Function(RequestFileError error)? onError, void Function(WebRequest request)? onOpened]);
	
	/// Checks if the loaded document was accessed via `file:`-Protocol.
	/// @returns boolean
	external static bool IsFileURL();
}

/// @hidden
@JS()
class ShaderProcessor {
	external factory ShaderProcessor();
	
	external static void Process(String sourceCode, ProcessingOptions options, void Function(String migratedCode) callback, ThinEngine engine);
}

/// Interface used to define common properties for effect fallbacks
@JS()
abstract class IEffectFallbacks {
	
	/// Removes the defines that should be removed when falling back.
	/// @param currentDefines defines the current define statements for the shader.
	/// @param effect defines the current effect we try to compile
	/// @returns The resulting defines with defines of the current rank removed.
	external String reduce(String currentDefines, Effect effect);
	
	/// Removes the fallback from the bound mesh.
	external void unBindMesh();
	
	/// Checks to see if more fallbacks are still availible.
	external bool get hasMoreFallbacks;
	external set hasMoreFallbacks(bool value);
}

/// Interface for the size containing width and height
@JS()
abstract class ISize {
	
	/// Width
	external num get width;
	external set width(num value);
	
	/// Heighht
	external num get height;
	external set height(num value);
}

/// Size containing widht and height
@JS()
class Size implements ISize {
	
	/// Creates a Size object from the given width and height (floats).
	/// @param width width of the new size
	/// @param height height of the new size
	external factory Size(num width, num height);
	
	/// Width
	@override
	external num get width;
	@override
	external set width(num value);
	
	/// Height
	@override
	external num get height;
	@override
	external set height(num value);
	
	/// Returns a string with the Size width and height
	/// @returns a string with the Size width and height
	external String toString();
	
	/// "Size"
	/// @returns the string "Size"
	external String getClassName();
	
	/// Returns the Size hash code.
	/// @returns a hash code for a unique width and height
	external num getHashCode();
	
	/// Updates the current size from the given one.
	/// @param src the given size
	external void copyFrom(Size src);
	
	/// Updates in place the current Size from the given floats.
	/// @param width width of the new size
	/// @param height height of the new size
	/// @returns the updated Size.
	external Size copyFromFloats(num width, num height);
	
	/// Updates in place the current Size from the given floats.
	/// @param width width to set
	/// @param height height to set
	/// @returns the updated Size.
	external Size set(num width, num height);
	
	/// Multiplies the width and height by numbers
	/// @param w factor to multiple the width by
	/// @param h factor to multiple the height by
	/// @returns a new Size set with the multiplication result of the current Size and the given floats.
	external Size multiplyByFloats(num w, num h);
	
	/// Clones the size
	/// @returns a new Size copied from the given one.
	external Size clone();
	
	/// True if the current Size and the given one width and height are strictly equal.
	/// @param other the other size to compare against
	/// @returns True if the current Size and the given one width and height are strictly equal.
	external bool equals(Size other);
	
	/// The surface of the Size : width * height (float).
	external num get surface;
	
	/// Create a new size of zero
	/// @returns a new Size set to (0.0, 0.0)
	external static Size Zero();
	
	/// Sums the width and height of two sizes
	/// @param otherSize size to add to this size
	/// @returns a new Size set as the addition result of the current Size and the given one.
	external Size add(Size otherSize);
	
	/// Subtracts the width and height of two
	/// @param otherSize size to subtract to this size
	/// @returns a new Size set as the subtraction result of  the given one from the current Size.
	external Size subtract(Size otherSize);
	
	/// Creates a new Size set at the linear interpolation "amount" between "start" and "end"
	/// @param start starting size to lerp between
	/// @param end end size to lerp between
	/// @param amount amount to lerp between the start and end values
	/// @returns a new Size set at the linear interpolation "amount" between "start" and "end"
	external static Size Lerp(Size start, Size end, num amount);
}

/// Base class of all the textures in babylon.
/// It groups all the common properties required to work with Thin Engine.
@JS()
class ThinTexture {
	
	/// Instantiates a new ThinTexture.
	/// Base class of all the textures in babylon.
	/// This can be used as an internal texture wrapper in ThinEngine to benefit from the cache
	/// @param internalTexture Define the internalTexture to wrap
	external factory ThinTexture(InternalTexture? internalTexture);
	
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 0     | CLAMP_ADDRESSMODE  |             |
	/// | 1     | WRAP_ADDRESSMODE   |             |
	/// | 2     | MIRROR_ADDRESSMODE |             |
	external num get wrapU;
	
	external set wrapU(num value);
	
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 0     | CLAMP_ADDRESSMODE  |             |
	/// | 1     | WRAP_ADDRESSMODE   |             |
	/// | 2     | MIRROR_ADDRESSMODE |             |
	external num get wrapV;
	
	external set wrapV(num value);
	
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 0     | CLAMP_ADDRESSMODE  |             |
	/// | 1     | WRAP_ADDRESSMODE   |             |
	/// | 2     | MIRROR_ADDRESSMODE |             |
	external num get wrapR;
	external set wrapR(num value);
	
	/// With compliant hardware and browser (supporting anisotropic filtering)
	/// this defines the level of anisotropic filtering in the texture.
	/// The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.
	external num get anisotropicFilteringLevel;
	external set anisotropicFilteringLevel(num value);
	
	/// Define the current state of the loading sequence when in delayed load mode.
	external num get delayLoadState;
	external set delayLoadState(num value);
	
	/// How a texture is mapped.
	/// Unused in thin texture mode.
	external num get coordinatesMode;
	
	/// Define if the texture is a cube texture or if false a 2d texture.
	external bool get isCube;
	
	external set isCube(bool value);
	
	/// Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
	external bool get is3D;
	
	external set is3D(bool value);
	
	/// Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
	external bool get is2DArray;
	
	external set is2DArray(bool value);
	
	/// Get the class name of the texture.
	/// @returns "ThinTexture"
	external String getClassName();
	
	/// Get if the texture is ready to be used (downloaded, converted, mip mapped...).
	/// @returns true if fully ready
	external bool isReady();
	
	/// Triggers the load sequence in delayed load mode.
	external void delayLoad();
	
	/// Get the underlying lower level texture from Babylon.
	/// @returns the insternal texture
	external InternalTexture? getInternalTexture();
	
	/// Get the size of the texture.
	/// @returns the texture size.
	external ISize getSize();
	
	/// Get the base size of the texture.
	/// It can be different from the size if the texture has been resized for POT for instance
	/// @returns the base size
	external ISize getBaseSize();
	
	/// Update the sampling mode of the texture.
	/// Default is Trilinear mode.
	/// 
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |
	/// | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |
	/// | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |
	/// | 4     | NEAREST_NEAREST_MIPNEAREST |             |
	/// | 5    | NEAREST_LINEAR_MIPNEAREST |             |
	/// | 6    | NEAREST_LINEAR_MIPLINEAR |             |
	/// | 7    | NEAREST_LINEAR |             |
	/// | 8    | NEAREST_NEAREST |             |
	/// | 9   | LINEAR_NEAREST_MIPNEAREST |             |
	/// | 10   | LINEAR_NEAREST_MIPLINEAR |             |
	/// | 11   | LINEAR_LINEAR |             |
	/// | 12   | LINEAR_NEAREST |             |
	/// 
	/// > _mag_: magnification filter (close to the viewer)
	/// > _min_: minification filter (far from the viewer)
	/// > _mip_: filter used between mip map levels
	/// @param samplingMode Define the new sampling mode of the texture
	external void updateSamplingMode(num samplingMode);
	
	/// Release and destroy the underlying lower level texture aka internalTexture.
	external void releaseInternalTexture();
	
	/// Dispose the texture and release its associated resources.
	external void dispose();
}

/// Defines an array and its length.
/// It can be helpfull to group result from both Arrays and smart arrays in one structure.
@JS()
abstract class ISmartArrayLike<T> {
	
	/// The data of the array.
	external List<T> get data;
	external set data(List<T> value);
	
	/// The active length of the array.
	external num get length;
	external set length(num value);
}

/// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
@JS()
class SmartArray<T> implements ISmartArrayLike<T> {
	
	/// Instantiates a Smart Array.
	/// @param capacity defines the default capacity of the array.
	external factory SmartArray(num capacity);
	
	/// The full set of data from the array.
	@override
	external List<T> get data;
	@override
	external set data(List<T> value);
	
	/// The active length of the array.
	@override
	external num get length;
	@override
	external set length(num value);
	
	/// Pushes a value at the end of the active data.
	/// @param value defines the object to push in the array.
	external void push(T value);
	
	/// Iterates over the active data and apply the lambda to them.
	/// @param func defines the action to apply on each value.
	external void forEach(void Function(T content) func);
	
	/// Sorts the full sets of data.
	/// @param compareFn defines the comparison function to apply.
	external void sort(num Function(T a, T b) compareFn);
	
	/// Resets the active data to an empty array.
	external void reset();
	
	/// Releases all the data from the array as well as the array.
	external void dispose();
	
	/// Concats the active data with a given array.
	/// @param array defines the data to concatenate with.
	external void concat(dynamic array);
	
	/// Returns the position of a value in the active data.
	/// @param value defines the value to find the index for
	/// @returns the index if found in the active data otherwise -1
	external num indexOf(T value);
	
	/// Returns whether an element is part of the active data.
	/// @param value defines the value to look for
	/// @returns true if found in the active data otherwise false
	external bool contains(T value);
}

/// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
/// The data in this array can only be present once
@JS()
class SmartArrayNoDuplicate<T> extends SmartArray<T> {
	external factory SmartArrayNoDuplicate();
	
	/// Pushes a value at the end of the active data.
	/// THIS DOES NOT PREVENT DUPPLICATE DATA
	/// @param value defines the object to push in the array.
	@override
	external void push(T value);
	
	/// Pushes a value at the end of the active data.
	/// If the data is already present, it won t be added again
	/// @param value defines the object to push in the array.
	/// @returns true if added false if it was already present
	external bool pushNoDuplicate(T value);
	
	/// Resets the active data to an empty array.
	@override
	external void reset();
	
	/// Concats the active data with a given array.
	/// This ensures no dupplicate will be present in the result.
	/// @param array defines the data to concatenate with.
	external void concatWithNoDuplicate(dynamic array);
}

/// Class used to evalaute queries containing `and` and `or` operators
@JS()
class AndOrNotEvaluator {
	external factory AndOrNotEvaluator();
	
	/// Evaluate a query
	/// @param query defines the query to evaluate
	/// @param evaluateCallback defines the callback used to filter result
	/// @returns true if the query matches
	external static bool Eval(String query, bool Function(dynamic val) evaluateCallback);
}

/// Class used to store custom tags
@JS()
class Tags {
	external factory Tags();
	
	/// Adds support for tags on the given object
	/// @param obj defines the object to use
	external static void EnableFor(dynamic obj);
	
	/// Removes tags support
	/// @param obj defines the object to use
	external static void DisableFor(dynamic obj);
	
	/// Gets a boolean indicating if the given object has tags
	/// @param obj defines the object to use
	/// @returns a boolean
	external static bool HasTags(dynamic obj);
	
	/// Gets the tags available on a given object
	/// @param obj defines the object to use
	/// @param asString defines if the tags must be returned as a string instead of an array of strings
	/// @returns the tags
	external static dynamic GetTags(dynamic obj, [bool? asString]);
	
	/// Adds tags to an object
	/// @param obj defines the object to use
	/// @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.
	/// A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces
	external static void AddTagsTo(dynamic obj, String tagsString);
	
	/// Removes specific tags from a specific object
	/// @param obj defines the object to use
	/// @param tagsString defines the tags to remove
	external static void RemoveTagsFrom(dynamic obj, String tagsString);
	
	/// Defines if tags hosted on an object match a given query
	/// @param obj defines the object to use
	/// @param tagsQuery defines the tag query
	/// @returns a boolean
	external static bool MatchesQuery(dynamic obj, String tagsQuery);
}

/// Scalar computation library
@JS()
class Scalar {
	external factory Scalar();
	
	/// Two pi constants convenient for computation.
	external static num get TwoPi;
	external static set TwoPi(num value);
	
	/// Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
	/// @param a number
	/// @param b number
	/// @param epsilon (default = 1.401298E-45)
	/// @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
	external static bool WithinEpsilon(num a, num b, [num? epsilon]);
	
	/// Returns a string : the upper case translation of the number i to hexadecimal.
	/// @param i number
	/// @returns the upper case translation of the number i to hexadecimal.
	external static String ToHex(num i);
	
	/// Returns -1 if value is negative and +1 is value is positive.
	/// @param value the value
	/// @returns the value itself if it's equal to zero.
	external static num Sign(num value);
	
	/// Returns the value itself if it's between min and max.
	/// Returns min if the value is lower than min.
	/// Returns max if the value is greater than max.
	/// @param value the value to clmap
	/// @param min the min value to clamp to (default: 0)
	/// @param max the max value to clamp to (default: 1)
	/// @returns the clamped value
	external static num Clamp(num value, [num? min, num? max]);
	
	/// the log2 of value.
	/// @param value the value to compute log2 of
	/// @returns the log2 of value.
	external static num Log2(num value);
	
	/// Loops the value, so that it is never larger than length and never smaller than 0.
	/// 
	/// This is similar to the modulo operator but it works with floating point numbers.
	/// For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
	/// With t = 5 and length = 2.5, the result would be 0.0.
	/// Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator
	/// @param value the value
	/// @param length the length
	/// @returns the looped value
	external static num Repeat(num value, num length);
	
	/// Normalize the value between 0.0 and 1.0 using min and max values
	/// @param value value to normalize
	/// @param min max to normalize between
	/// @param max min to normalize between
	/// @returns the normalized value
	external static num Normalize(num value, num min, num max);
	
	/// Denormalize the value from 0.0 and 1.0 using min and max values
	/// @param normalized value to denormalize
	/// @param min max to denormalize between
	/// @param max min to denormalize between
	/// @returns the denormalized value
	external static num Denormalize(num normalized, num min, num max);
	
	/// Calculates the shortest difference between two given angles given in degrees.
	/// @param current current angle in degrees
	/// @param target target angle in degrees
	/// @returns the delta
	external static num DeltaAngle(num current, num target);
	
	/// PingPongs the value t, so that it is never larger than length and never smaller than 0.
	/// @param tx value
	/// @param length length
	/// @returns The returned value will move back and forth between 0 and length
	external static num PingPong(num tx, num length);
	
	/// Interpolates between min and max with smoothing at the limits.
	/// 
	/// This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
	/// from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.
	/// @param from from
	/// @param to to
	/// @param tx value
	/// @returns the smooth stepped value
	external static num SmoothStep(num from, num to, num tx);
	
	/// Moves a value current towards target.
	/// 
	/// This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
	/// Negative values of maxDelta pushes the value away from target.
	/// @param current current value
	/// @param target target value
	/// @param maxDelta max distance to move
	/// @returns resulting value
	external static num MoveTowards(num current, num target, num maxDelta);
	
	/// Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
	/// 
	/// Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
	/// are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.
	/// @param current current value
	/// @param target target value
	/// @param maxDelta max distance to move
	/// @returns resulting angle
	external static num MoveTowardsAngle(num current, num target, num maxDelta);
	
	/// Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.
	/// @param start start value
	/// @param end target value
	/// @param amount amount to lerp between
	/// @returns the lerped value
	external static num Lerp(num start, num end, num amount);
	
	/// Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
	/// The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.
	/// @param start start value
	/// @param end target value
	/// @param amount amount to lerp between
	/// @returns the lerped value
	external static num LerpAngle(num start, num end, num amount);
	
	/// Calculates the linear parameter t that produces the interpolant value within the range [a, b].
	/// @param a start value
	/// @param b target value
	/// @param value value between a and b
	/// @returns the inverseLerp value
	external static num InverseLerp(num a, num b, num value);
	
	/// Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".
	/// @see http://mathworld.wolfram.com/HermitePolynomial.html
	/// @param value1 spline value
	/// @param tangent1 spline value
	/// @param value2 spline value
	/// @param tangent2 spline value
	/// @param amount input value
	/// @returns hermite result
	external static num Hermite(num value1, num tangent1, num value2, num tangent2, num amount);
	
	/// Returns a random float number between and min and max values
	/// @param min min value of random
	/// @param max max value of random
	/// @returns random value
	external static num RandomRange(num min, num max);
	
	/// This function returns percentage of a number in a given range.
	/// 
	/// RangeToPercent(40,20,60) will return 0.5 (50%)
	/// RangeToPercent(34,0,100) will return 0.34 (34%)
	/// @param number to convert to percentage
	/// @param min min range
	/// @param max max range
	/// @returns the percentage
	external static num RangeToPercent(num number, num min, num max);
	
	/// This function returns number that corresponds to the percentage in a given range.
	/// 
	/// PercentToRange(0.34,0,100) will return 34.
	/// @param percent to convert to number
	/// @param min min range
	/// @param max max range
	/// @returns the number
	external static num PercentToRange(num percent, num min, num max);
	
	/// Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.
	/// @param angle The angle to normalize in radian.
	/// @return The converted angle.
	external static num NormalizeRadians(num angle);
}

/* var */
/// Constant used to convert a value to gamma space
/// @ignorenaming
@JS()
external dynamic get ToGammaSpace;

/* var */
/// Constant used to convert a value to linear space
/// @ignorenaming
@JS()
external dynamic get ToLinearSpace;

/* var */
/// Constant used to define the minimal number value in Babylon.js
/// @ignorenaming
@JS()
external dynamic get Epsilon;

/// Class used to represent a viewport on screen
@JS()
class Viewport {
	
	/// Creates a Viewport object located at (x, y) and sized (width, height)
	/// @param x defines viewport left coordinate
	/// @param y defines viewport top coordinate
	/// @param width defines the viewport width
	/// @param height defines the viewport height
	external factory Viewport(num x, num y, num width, num height);
	
	/// viewport left coordinate
	external num get x;
	external set x(num value);
	
	/// viewport top coordinate
	external num get y;
	external set y(num value);
	
	/// viewport width
	external num get width;
	external set width(num value);
	
	/// viewport height
	external num get height;
	external set height(num value);
	
	/// Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)
	/// @param renderWidth defines the rendering width
	/// @param renderHeight defines the rendering height
	/// @returns a new Viewport
	external Viewport toGlobal(num renderWidth, num renderHeight);
	
	/// Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)
	/// @param renderWidth defines the rendering width
	/// @param renderHeight defines the rendering height
	/// @param ref defines the target viewport
	/// @returns the current viewport
	external Viewport toGlobalToRef(num renderWidth, num renderHeight, Viewport ref);
	
	/// Returns a new Viewport copied from the current one
	/// @returns a new Viewport
	external Viewport clone();
}

/// Class containing a set of static utilities functions for arrays.
@JS()
class ArrayTools {
	external factory ArrayTools();
	
	/// Returns an array of the given size filled with element built from the given constructor and the paramters
	/// @param size the number of element to construct and put in the array
	/// @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.
	/// @returns a new array filled with new objects
	external static List<T> BuildArray<T>(num size, T Function() itemBuilder);
}

/// Represents a plane by the equation ax + by + cz + d = 0
@JS()
class Plane {
	
	/// Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0
	/// @param a a component of the plane
	/// @param b b component of the plane
	/// @param c c component of the plane
	/// @param d d component of the plane
	external factory Plane(num a, num b, num c, num d);
	
	/// Normal of the plane (a,b,c)
	external Vector3 get normal;
	external set normal(Vector3 value);
	
	/// d component of the plane
	external num get d;
	external set d(num value);
	
	/// @returns the plane coordinates as a new array of 4 elements [a, b, c, d].
	external List<num> asArray();
	
	/// @returns a new plane copied from the current Plane.
	external Plane clone();
	
	/// @returns the string "Plane".
	external String getClassName();
	
	/// @returns the Plane hash code.
	external num getHashCode();
	
	/// Normalize the current Plane in place.
	/// @returns the updated Plane.
	external Plane normalize();
	
	/// Applies a transformation the plane and returns the result
	/// @param transformation the transformation matrix to be applied to the plane
	/// @returns a new Plane as the result of the transformation of the current Plane by the given matrix.
	external Plane transform(Matrix transformation);
	
	/// Compute the dot product between the point and the plane normal
	/// @param point point to calculate the dot product with
	/// @returns the dot product (float) of the point coordinates and the plane normal.
	external num dotCoordinate(Vector3 point);
	
	/// Updates the current Plane from the plane defined by the three given points.
	/// @param point1 one of the points used to contruct the plane
	/// @param point2 one of the points used to contruct the plane
	/// @param point3 one of the points used to contruct the plane
	/// @returns the updated Plane.
	external Plane copyFromPoints(Vector3 point1, Vector3 point2, Vector3 point3);
	
	/// Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).
	/// Note that for this function to work as expected you should make sure that:
	/// - direction and the plane normal are normalized
	/// - epsilon is a number just bigger than -1, something like -0.99 for eg
	/// @param direction the direction to check if the plane is facing
	/// @param epsilon value the dot product is compared against (returns true if dot <= epsilon)
	/// @returns True if the plane is facing the given direction
	external bool isFrontFacingTo(Vector3 direction, num epsilon);
	
	/// Calculates the distance to a point
	/// @param point point to calculate distance to
	/// @returns the signed distance (float) from the given point to the Plane.
	external num signedDistanceTo(Vector3 point);
	
	/// Creates a plane from an  array
	/// @param array the array to create a plane from
	/// @returns a new Plane from the given array.
	external static Plane FromArray(List<num> array);
	
	/// Creates a plane from three points
	/// @param point1 point used to create the plane
	/// @param point2 point used to create the plane
	/// @param point3 point used to create the plane
	/// @returns a new Plane defined by the three given points.
	external static Plane FromPoints(Vector3 point1, Vector3 point2, Vector3 point3);
	
	/// Creates a plane from an origin point and a normal
	/// @param origin origin of the plane to be constructed
	/// @param normal normal of the plane to be constructed
	/// @returns a new Plane the normal vector to this plane at the given origin point.
	/// Note : the vector "normal" is updated because normalized.
	external static Plane FromPositionAndNormal(Vector3 origin, Vector3 normal);
	
	/// Calculates the distance from a plane and a point
	/// @param origin origin of the plane to be constructed
	/// @param normal normal of the plane to be constructed
	/// @param point point to calculate distance to
	/// @returns the signed distance between the plane defined by the normal vector at the "origin"" point and the given other point.
	external static num SignedDistanceToPlaneFromPositionAndNormal(Vector3 origin, Vector3 normal, Vector3 point);
}

/// @hidden
@JS()
class PerformanceConfigurator {
	external factory PerformanceConfigurator();
	
	/// @hidden
	external static bool get MatrixUse64Bits;
	external static set MatrixUse64Bits(bool value);
	
	/// @hidden
	external static bool get MatrixTrackPrecisionChange;
	external static set MatrixTrackPrecisionChange(bool value);
	
	/// @hidden
	external static dynamic get MatrixCurrentType;
	external static set MatrixCurrentType(dynamic value);
	
	/// @hidden
	external static List<dynamic>? get MatrixTrackedMatrices;
	external static set MatrixTrackedMatrices(List<dynamic>? value);
	
	/// @hidden
	external static void SetMatrixPrecision(bool use64bits);
}

/// Class representing a vector containing 2 coordinates
@JS()
class Vector2 {
	
	/// Creates a new Vector2 from the given x and y coordinates
	/// @param x defines the first coordinate
	/// @param y defines the second coordinate
	external factory Vector2([num? x, num? y]);
	
	/// defines the first coordinate
	external num get x;
	external set x(num value);
	
	/// defines the second coordinate
	external num get y;
	external set y(num value);
	
	/// Gets a string with the Vector2 coordinates
	/// @returns a string with the Vector2 coordinates
	external String toString();
	
	/// Gets class name
	/// @returns the string "Vector2"
	external String getClassName();
	
	/// Gets current vector hash code
	/// @returns the Vector2 hash code as a number
	external num getHashCode();
	
	/// Sets the Vector2 coordinates in the given array or Float32Array from the given index.
	/// @param array defines the source array
	/// @param index defines the offset in source array
	/// @returns the current Vector2
	external Vector2 toArray(dynamic array, [num? index]);
	
	/// Update the current vector from an array
	/// @param array defines the destination array
	/// @param index defines the offset in the destination array
	/// @returns the current Vector3
	external Vector2 fromArray(dynamic array, [num? index]);
	
	/// Copy the current vector to an array
	/// @returns a new array with 2 elements: the Vector2 coordinates.
	external List<num> asArray();
	
	/// Sets the Vector2 coordinates with the given Vector2 coordinates
	/// @param source defines the source Vector2
	/// @returns the current updated Vector2
	external Vector2 copyFrom(Vector2 source);
	
	/// Sets the Vector2 coordinates with the given floats
	/// @param x defines the first coordinate
	/// @param y defines the second coordinate
	/// @returns the current updated Vector2
	external Vector2 copyFromFloats(num x, num y);
	
	/// Sets the Vector2 coordinates with the given floats
	/// @param x defines the first coordinate
	/// @param y defines the second coordinate
	/// @returns the current updated Vector2
	external Vector2 set(num x, num y);
	
	/// Add another vector with the current one
	/// @param otherVector defines the other vector
	/// @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
	external Vector2 add(Vector2 otherVector);
	
	/// Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
	/// @param otherVector defines the other vector
	/// @param result defines the target vector
	/// @returns the unmodified current Vector2
	external Vector2 addToRef(Vector2 otherVector, Vector2 result);
	
	/// Set the Vector2 coordinates by adding the given Vector2 coordinates
	/// @param otherVector defines the other vector
	/// @returns the current updated Vector2
	external Vector2 addInPlace(Vector2 otherVector);
	
	/// Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates
	/// @param otherVector defines the other vector
	/// @returns a new Vector2
	external Vector2 addVector3(Vector3 otherVector);
	
	/// Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
	/// @param otherVector defines the other vector
	/// @returns a new Vector2
	external Vector2 subtract(Vector2 otherVector);
	
	/// Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
	/// @param otherVector defines the other vector
	/// @param result defines the target vector
	/// @returns the unmodified current Vector2
	external Vector2 subtractToRef(Vector2 otherVector, Vector2 result);
	
	/// Sets the current Vector2 coordinates by subtracting from it the given one coordinates
	/// @param otherVector defines the other vector
	/// @returns the current updated Vector2
	external Vector2 subtractInPlace(Vector2 otherVector);
	
	/// Multiplies in place the current Vector2 coordinates by the given ones
	/// @param otherVector defines the other vector
	/// @returns the current updated Vector2
	external Vector2 multiplyInPlace(Vector2 otherVector);
	
	/// Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
	/// @param otherVector defines the other vector
	/// @returns a new Vector2
	external Vector2 multiply(Vector2 otherVector);
	
	/// Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
	/// @param otherVector defines the other vector
	/// @param result defines the target vector
	/// @returns the unmodified current Vector2
	external Vector2 multiplyToRef(Vector2 otherVector, Vector2 result);
	
	/// Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
	/// @param x defines the first coordinate
	/// @param y defines the second coordinate
	/// @returns a new Vector2
	external Vector2 multiplyByFloats(num x, num y);
	
	/// Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
	/// @param otherVector defines the other vector
	/// @returns a new Vector2
	external Vector2 divide(Vector2 otherVector);
	
	/// Sets the "result" coordinates with the Vector2 divided by the given one coordinates
	/// @param otherVector defines the other vector
	/// @param result defines the target vector
	/// @returns the unmodified current Vector2
	external Vector2 divideToRef(Vector2 otherVector, Vector2 result);
	
	/// Divides the current Vector2 coordinates by the given ones
	/// @param otherVector defines the other vector
	/// @returns the current updated Vector2
	external Vector2 divideInPlace(Vector2 otherVector);
	
	/// Gets a new Vector2 with current Vector2 negated coordinates
	/// @returns a new Vector2
	external Vector2 negate();
	
	/// Negate this vector in place
	/// @returns this
	external Vector2 negateInPlace();
	
	/// Negate the current Vector2 and stores the result in the given vector "result" coordinates
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector2
	external Vector2 negateToRef(Vector2 result);
	
	/// Multiply the Vector2 coordinates by scale
	/// @param scale defines the scaling factor
	/// @returns the current updated Vector2
	external Vector2 scaleInPlace(num scale);
	
	/// Returns a new Vector2 scaled by "scale" from the current Vector2
	/// @param scale defines the scaling factor
	/// @returns a new Vector2
	external Vector2 scale(num scale);
	
	/// Scale the current Vector2 values by a factor to a given Vector2
	/// @param scale defines the scale factor
	/// @param result defines the Vector2 object where to store the result
	/// @returns the unmodified current Vector2
	external Vector2 scaleToRef(num scale, Vector2 result);
	
	/// Scale the current Vector2 values by a factor and add the result to a given Vector2
	/// @param scale defines the scale factor
	/// @param result defines the Vector2 object where to store the result
	/// @returns the unmodified current Vector2
	external Vector2 scaleAndAddToRef(num scale, Vector2 result);
	
	/// Gets a boolean if two vectors are equals
	/// @param otherVector defines the other vector
	/// @returns true if the given vector coordinates strictly equal the current Vector2 ones
	external bool equals(Vector2 otherVector);
	
	/// Gets a boolean if two vectors are equals (using an epsilon value)
	/// @param otherVector defines the other vector
	/// @param epsilon defines the minimal distance to consider equality
	/// @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.
	external bool equalsWithEpsilon(Vector2 otherVector, [num? epsilon]);
	
	/// Gets a new Vector2 from current Vector2 floored values
	/// @returns a new Vector2
	external Vector2 floor();
	
	/// Gets a new Vector2 from current Vector2 floored values
	/// @returns a new Vector2
	external Vector2 fract();
	
	/// Gets the length of the vector
	/// @returns the vector length (float)
	external num length();
	
	/// Gets the vector squared length
	/// @returns the vector squared length (float)
	external num lengthSquared();
	
	/// Normalize the vector
	/// @returns the current updated Vector2
	external Vector2 normalize();
	
	/// Gets a new Vector2 copied from the Vector2
	/// @returns a new Vector2
	external Vector2 clone();
	
	/// Gets a new Vector2(0, 0)
	/// @returns a new Vector2
	external static Vector2 Zero();
	
	/// Gets a new Vector2(1, 1)
	/// @returns a new Vector2
	external static Vector2 One();
	
	/// Gets a new Vector2 set from the given index element of the given array
	/// @param array defines the data source
	/// @param offset defines the offset in the data source
	/// @returns a new Vector2
	external static Vector2 FromArray(List<num> array, [num? offset]);
	
	/// Sets "result" from the given index element of the given array
	/// @param array defines the data source
	/// @param offset defines the offset in the data source
	/// @param result defines the target vector
	external static void FromArrayToRef(List<num> array, num offset, Vector2 result);
	
	/// Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
	/// @param value1 defines 1st point of control
	/// @param value2 defines 2nd point of control
	/// @param value3 defines 3rd point of control
	/// @param value4 defines 4th point of control
	/// @param amount defines the interpolation factor
	/// @returns a new Vector2
	external static Vector2 CatmullRom(Vector2 value1, Vector2 value2, Vector2 value3, Vector2 value4, num amount);
	
	/// Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
	/// If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
	/// If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
	/// @param value defines the value to clamp
	/// @param min defines the lower limit
	/// @param max defines the upper limit
	/// @returns a new Vector2
	external static Vector2 Clamp(Vector2 value, Vector2 min, Vector2 max);
	
	/// Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value3", "tangent1", "tangent2"
	/// @param value1 defines the 1st control point
	/// @param tangent1 defines the outgoing tangent
	/// @param value2 defines the 2nd control point
	/// @param tangent2 defines the incoming tangent
	/// @param amount defines the interpolation factor
	/// @returns a new Vector2
	external static Vector2 Hermite(Vector2 value1, Vector2 tangent1, Vector2 value2, Vector2 tangent2, num amount);
	
	/// Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
	/// @param start defines the start vector
	/// @param end defines the end vector
	/// @param amount defines the interpolation factor
	/// @returns a new Vector2
	external static Vector2 Lerp(Vector2 start, Vector2 end, num amount);
	
	/// Gets the dot product of the vector "left" and the vector "right"
	/// @param left defines first vector
	/// @param right defines second vector
	/// @returns the dot product (float)
	external static num Dot(Vector2 left, Vector2 right);
	
	/// Returns a new Vector2 equal to the normalized given vector
	/// @param vector defines the vector to normalize
	/// @returns a new Vector2
	external static Vector2 Normalize(Vector2 vector);
	
	/// Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
	/// @param left defines 1st vector
	/// @param right defines 2nd vector
	/// @returns a new Vector2
	external static Vector2 Minimize(Vector2 left, Vector2 right);
	
	/// Gets a new Vecto2 set with the maximal coordinate values from the "left" and "right" vectors
	/// @param left defines 1st vector
	/// @param right defines 2nd vector
	/// @returns a new Vector2
	external static Vector2 Maximize(Vector2 left, Vector2 right);
	
	/// Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix
	/// @param vector defines the vector to transform
	/// @param transformation defines the matrix to apply
	/// @returns a new Vector2
	external static Vector2 Transform(Vector2 vector, Matrix transformation);
	
	/// Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates
	/// @param vector defines the vector to transform
	/// @param transformation defines the matrix to apply
	/// @param result defines the target vector
	external static void TransformToRef(Vector2 vector, Matrix transformation, Vector2 result);
	
	/// Determines if a given vector is included in a triangle
	/// @param p defines the vector to test
	/// @param p0 defines 1st triangle point
	/// @param p1 defines 2nd triangle point
	/// @param p2 defines 3rd triangle point
	/// @returns true if the point "p" is in the triangle defined by the vertors "p0", "p1", "p2"
	external static bool PointInTriangle(Vector2 p, Vector2 p0, Vector2 p1, Vector2 p2);
	
	/// Gets the distance between the vectors "value1" and "value2"
	/// @param value1 defines first vector
	/// @param value2 defines second vector
	/// @returns the distance between vectors
	external static num Distance(Vector2 value1, Vector2 value2);
	
	/// Returns the squared distance between the vectors "value1" and "value2"
	/// @param value1 defines first vector
	/// @param value2 defines second vector
	/// @returns the squared distance between vectors
	external static num DistanceSquared(Vector2 value1, Vector2 value2);
	
	/// Gets a new Vector2 located at the center of the vectors "value1" and "value2"
	/// @param value1 defines first vector
	/// @param value2 defines second vector
	/// @returns a new Vector2
	external static Vector2 Center(Vector2 value1, Vector2 value2);
	
	/// Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
	/// @param p defines the middle point
	/// @param segA defines one point of the segment
	/// @param segB defines the other point of the segment
	/// @returns the shortest distance
	external static num DistanceOfPointFromSegment(Vector2 p, Vector2 segA, Vector2 segB);
}

/// Class used to store (x,y,z) vector representation
/// A Vector3 is the main object used in 3D geometry
/// It can represent etiher the coordinates of a point the space, either a direction
/// Reminder: js uses a left handed forward facing system
@JS()
class Vector3 {
	
	/// Creates a new Vector3 object from the given x, y, z (floats) coordinates.
	/// @param x defines the first coordinates (on X axis)
	/// @param y defines the second coordinates (on Y axis)
	/// @param z defines the third coordinates (on Z axis)
	external factory Vector3([num? x, num? y, num? z]);
	
	/// Gets or sets the x coordinate
	external num get x;
	
	external set x(num value);
	
	/// Gets or sets the y coordinate
	external num get y;
	
	external set y(num value);
	
	/// Gets or sets the z coordinate
	external num get z;
	
	external set z(num value);
	
	/// Creates a string representation of the Vector3
	/// @returns a string with the Vector3 coordinates.
	external String toString();
	
	/// Gets the class name
	/// @returns the string "Vector3"
	external String getClassName();
	
	/// Creates the Vector3 hash code
	/// @returns a number which tends to be unique between Vector3 instances
	external num getHashCode();
	
	/// Creates an array containing three elements : the coordinates of the Vector3
	/// @returns a new array of numbers
	external List<num> asArray();
	
	/// Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3
	/// @param array defines the destination array
	/// @param index defines the offset in the destination array
	/// @returns the current Vector3
	external Vector3 toArray(dynamic array, [num? index]);
	
	/// Update the current vector from an array
	/// @param array defines the destination array
	/// @param index defines the offset in the destination array
	/// @returns the current Vector3
	external Vector3 fromArray(dynamic array, [num? index]);
	
	/// Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
	/// @returns a new Quaternion object, computed from the Vector3 coordinates
	external Quaternion toQuaternion();
	
	/// Adds the given vector to the current Vector3
	/// @param otherVector defines the second operand
	/// @returns the current updated Vector3
	external Vector3 addInPlace(Vector3 otherVector);
	
	/// Adds the given coordinates to the current Vector3
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the current updated Vector3
	external Vector3 addInPlaceFromFloats(num x, num y, num z);
	
	/// Gets a new Vector3, result of the addition the current Vector3 and the given vector
	/// @param otherVector defines the second operand
	/// @returns the resulting Vector3
	external Vector3 add(Vector3 otherVector);
	
	/// Adds the current Vector3 to the given one and stores the result in the vector "result"
	/// @param otherVector defines the second operand
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 addToRef(Vector3 otherVector, Vector3 result);
	
	/// Subtract the given vector from the current Vector3
	/// @param otherVector defines the second operand
	/// @returns the current updated Vector3
	external Vector3 subtractInPlace(Vector3 otherVector);
	
	/// Returns a new Vector3, result of the subtraction of the given vector from the current Vector3
	/// @param otherVector defines the second operand
	/// @returns the resulting Vector3
	external Vector3 subtract(Vector3 otherVector);
	
	/// Subtracts the given vector from the current Vector3 and stores the result in the vector "result".
	/// @param otherVector defines the second operand
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 subtractToRef(Vector3 otherVector, Vector3 result);
	
	/// Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the resulting Vector3
	external Vector3 subtractFromFloats(num x, num y, num z);
	
	/// Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 subtractFromFloatsToRef(num x, num y, num z, Vector3 result);
	
	/// Gets a new Vector3 set with the current Vector3 negated coordinates
	/// @returns a new Vector3
	external Vector3 negate();
	
	/// Negate this vector in place
	/// @returns this
	external Vector3 negateInPlace();
	
	/// Negate the current Vector3 and stores the result in the given vector "result" coordinates
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 negateToRef(Vector3 result);
	
	/// Multiplies the Vector3 coordinates by the float "scale"
	/// @param scale defines the multiplier factor
	/// @returns the current updated Vector3
	external Vector3 scaleInPlace(num scale);
	
	/// Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
	/// @param scale defines the multiplier factor
	/// @returns a new Vector3
	external Vector3 scale(num scale);
	
	/// Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates
	/// @param scale defines the multiplier factor
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 scaleToRef(num scale, Vector3 result);
	
	/// Scale the current Vector3 values by a factor and add the result to a given Vector3
	/// @param scale defines the scale factor
	/// @param result defines the Vector3 object where to store the result
	/// @returns the unmodified current Vector3
	external Vector3 scaleAndAddToRef(num scale, Vector3 result);
	
	/// Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.
	/// @param origin defines the origin of the projection ray
	/// @param plane defines the plane to project to
	/// @returns the projected vector3
	external Vector3 projectOnPlane(Plane plane, Vector3 origin);
	
	/// Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.
	/// @param origin defines the origin of the projection ray
	/// @param plane defines the plane to project to
	/// @param result defines the Vector3 where to store the result
	external void projectOnPlaneToRef(Plane plane, Vector3 origin, Vector3 result);
	
	/// Returns true if the current Vector3 and the given vector coordinates are strictly equal
	/// @param otherVector defines the second operand
	/// @returns true if both vectors are equals
	external bool equals(Vector3 otherVector);
	
	/// Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon
	/// @param otherVector defines the second operand
	/// @param epsilon defines the minimal distance to define values as equals
	/// @returns true if both vectors are distant less than epsilon
	external bool equalsWithEpsilon(Vector3 otherVector, [num? epsilon]);
	
	/// Returns true if the current Vector3 coordinates equals the given floats
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns true if both vectors are equals
	external bool equalsToFloats(num x, num y, num z);
	
	/// Multiplies the current Vector3 coordinates by the given ones
	/// @param otherVector defines the second operand
	/// @returns the current updated Vector3
	external Vector3 multiplyInPlace(Vector3 otherVector);
	
	/// Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector
	/// @param otherVector defines the second operand
	/// @returns the new Vector3
	external Vector3 multiply(Vector3 otherVector);
	
	/// Multiplies the current Vector3 by the given one and stores the result in the given vector "result"
	/// @param otherVector defines the second operand
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 multiplyToRef(Vector3 otherVector, Vector3 result);
	
	/// Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the new Vector3
	external Vector3 multiplyByFloats(num x, num y, num z);
	
	/// Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones
	/// @param otherVector defines the second operand
	/// @returns the new Vector3
	external Vector3 divide(Vector3 otherVector);
	
	/// Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"
	/// @param otherVector defines the second operand
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector3
	external Vector3 divideToRef(Vector3 otherVector, Vector3 result);
	
	/// Divides the current Vector3 coordinates by the given ones.
	/// @param otherVector defines the second operand
	/// @returns the current updated Vector3
	external Vector3 divideInPlace(Vector3 otherVector);
	
	/// Updates the current Vector3 with the minimal coordinate values between its and the given vector ones
	/// @param other defines the second operand
	/// @returns the current updated Vector3
	external Vector3 minimizeInPlace(Vector3 other);
	
	/// Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.
	/// @param other defines the second operand
	/// @returns the current updated Vector3
	external Vector3 maximizeInPlace(Vector3 other);
	
	/// Updates the current Vector3 with the minimal coordinate values between its and the given coordinates
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the current updated Vector3
	external Vector3 minimizeInPlaceFromFloats(num x, num y, num z);
	
	/// Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the current updated Vector3
	external Vector3 maximizeInPlaceFromFloats(num x, num y, num z);
	
	/// Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction
	/// Check if is non uniform within a certain amount of decimal places to account for this
	/// @param epsilon the amount the values can differ
	/// @returns if the the vector is non uniform to a certain number of decimal places
	external bool isNonUniformWithinEpsilon(num epsilon);
	
	/// Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
	external bool get isNonUniform;
	
	/// Gets a new Vector3 from current Vector3 floored values
	/// @returns a new Vector3
	external Vector3 floor();
	
	/// Gets a new Vector3 from current Vector3 floored values
	/// @returns a new Vector3
	external Vector3 fract();
	
	/// Gets the length of the Vector3
	/// @returns the length of the Vector3
	external num length();
	
	/// Gets the squared length of the Vector3
	/// @returns squared length of the Vector3
	external num lengthSquared();
	
	/// Normalize the current Vector3.
	/// Please note that this is an in place operation.
	/// @returns the current updated Vector3
	external Vector3 normalize();
	
	/// Reorders the x y z properties of the vector in place
	/// @param order new ordering of the properties (eg. for vector 1,2,3 with "ZYX" will produce 3,2,1)
	/// @returns the current updated vector
	external dynamic reorderInPlace(String order);
	
	/// Rotates the vector around 0,0,0 by a quaternion
	/// @param quaternion the rotation quaternion
	/// @param result vector to store the result
	/// @returns the resulting vector
	external Vector3 rotateByQuaternionToRef(Quaternion quaternion, Vector3 result);
	
	/// Rotates a vector around a given point
	/// @param quaternion the rotation quaternion
	/// @param point the point to rotate around
	/// @param result vector to store the result
	/// @returns the resulting vector
	external Vector3 rotateByQuaternionAroundPointToRef(Quaternion quaternion, Vector3 point, Vector3 result);
	
	/// Returns a new Vector3 as the cross product of the current vector and the "other" one
	/// The cross product is then orthogonal to both current and "other"
	/// @param other defines the right operand
	/// @returns the cross product
	external Vector3 cross(Vector3 other);
	
	/// Normalize the current Vector3 with the given input length.
	/// Please note that this is an in place operation.
	/// @param len the length of the vector
	/// @returns the current updated Vector3
	external Vector3 normalizeFromLength(num len);
	
	/// Normalize the current Vector3 to a new vector
	/// @returns the new Vector3
	external Vector3 normalizeToNew();
	
	/// Normalize the current Vector3 to the reference
	/// @param reference define the Vector3 to update
	/// @returns the updated Vector3
	external Vector3 normalizeToRef(Vector3 reference);
	
	/// Creates a new Vector3 copied from the current Vector3
	/// @returns the new Vector3
	external Vector3 clone();
	
	/// Copies the given vector coordinates to the current Vector3 ones
	/// @param source defines the source Vector3
	/// @returns the current updated Vector3
	external Vector3 copyFrom(Vector3 source);
	
	/// Copies the given floats to the current Vector3 coordinates
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the current updated Vector3
	external Vector3 copyFromFloats(num x, num y, num z);
	
	/// Copies the given floats to the current Vector3 coordinates
	/// @param x defines the x coordinate of the operand
	/// @param y defines the y coordinate of the operand
	/// @param z defines the z coordinate of the operand
	/// @returns the current updated Vector3
	external Vector3 set(num x, num y, num z);
	
	/// Copies the given float to the current Vector3 coordinates
	/// @param v defines the x, y and z coordinates of the operand
	/// @returns the current updated Vector3
	external Vector3 setAll(num v);
	
	/// Get the clip factor between two vectors
	/// @param vector0 defines the first operand
	/// @param vector1 defines the second operand
	/// @param axis defines the axis to use
	/// @param size defines the size along the axis
	/// @returns the clip factor
	external static num GetClipFactor(Vector3 vector0, Vector3 vector1, Vector3 axis, num size);
	
	/// Get angle between two vectors
	/// @param vector0 angle between vector0 and vector1
	/// @param vector1 angle between vector0 and vector1
	/// @param normal direction of the normal
	/// @return the angle between vector0 and vector1
	external static num GetAngleBetweenVectors(Vector3 vector0, Vector3 vector1, Vector3 normal);
	
	/// Returns a new Vector3 set from the index "offset" of the given array
	/// @param array defines the source array
	/// @param offset defines the offset in the source array
	/// @returns the new Vector3
	external static Vector3 FromArray(List<num> array, [num? offset]);
	
	/// Returns a new Vector3 set from the index "offset" of the given Float32Array
	/// @param array defines the source array
	/// @param offset defines the offset in the source array
	/// @returns the new Vector3
	/// @deprecated Please use FromArray instead.
	external static Vector3 FromFloatArray(Float32List array, [num? offset]);
	
	/// Sets the given vector "result" with the element values from the index "offset" of the given array
	/// @param array defines the source array
	/// @param offset defines the offset in the source array
	/// @param result defines the Vector3 where to store the result
	external static void FromArrayToRef(List<num> array, num offset, Vector3 result);
	
	/// Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
	/// @param array defines the source array
	/// @param offset defines the offset in the source array
	/// @param result defines the Vector3 where to store the result
	/// @deprecated Please use FromArrayToRef instead.
	external static void FromFloatArrayToRef(Float32List array, num offset, Vector3 result);
	
	/// Sets the given vector "result" with the given floats.
	/// @param x defines the x coordinate of the source
	/// @param y defines the y coordinate of the source
	/// @param z defines the z coordinate of the source
	/// @param result defines the Vector3 where to store the result
	external static void FromFloatsToRef(num x, num y, num z, Vector3 result);
	
	/// Returns a new Vector3 set to (0.0, 0.0, 0.0)
	/// @returns a new empty Vector3
	external static Vector3 Zero();
	
	/// Returns a new Vector3 set to (1.0, 1.0, 1.0)
	/// @returns a new unit Vector3
	external static Vector3 One();
	
	/// Returns a new Vector3 set to (0.0, 1.0, 0.0)
	/// @returns a new up Vector3
	external static Vector3 Up();
	
	/// Gets a up Vector3 that must not be updated
	external static Vector3 get UpReadOnly;
	
	/// Gets a zero Vector3 that must not be updated
	external static Vector3 get ZeroReadOnly;
	
	/// Returns a new Vector3 set to (0.0, -1.0, 0.0)
	/// @returns a new down Vector3
	external static Vector3 Down();
	
	/// Returns a new Vector3 set to (0.0, 0.0, 1.0)
	/// @param rightHandedSystem is the scene right-handed (negative z)
	/// @returns a new forward Vector3
	external static Vector3 Forward([bool? rightHandedSystem]);
	
	/// Returns a new Vector3 set to (0.0, 0.0, -1.0)
	/// @param rightHandedSystem is the scene right-handed (negative-z)
	/// @returns a new forward Vector3
	external static Vector3 Backward([bool? rightHandedSystem]);
	
	/// Returns a new Vector3 set to (1.0, 0.0, 0.0)
	/// @returns a new right Vector3
	external static Vector3 Right();
	
	/// Returns a new Vector3 set to (-1.0, 0.0, 0.0)
	/// @returns a new left Vector3
	external static Vector3 Left();
	
	/// Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
	/// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
	/// @param vector defines the Vector3 to transform
	/// @param transformation defines the transformation matrix
	/// @returns the transformed Vector3
	external static Vector3 TransformCoordinates(Vector3 vector, Matrix transformation);
	
	/// Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
	/// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
	/// @param vector defines the Vector3 to transform
	/// @param transformation defines the transformation matrix
	/// @param result defines the Vector3 where to store the result
	external static void TransformCoordinatesToRef(Vector3 vector, Matrix transformation, Vector3 result);
	
	/// Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
	/// This method computes tranformed coordinates only, not transformed direction vectors
	/// @param x define the x coordinate of the source vector
	/// @param y define the y coordinate of the source vector
	/// @param z define the z coordinate of the source vector
	/// @param transformation defines the transformation matrix
	/// @param result defines the Vector3 where to store the result
	external static void TransformCoordinatesFromFloatsToRef(num x, num y, num z, Matrix transformation, Vector3 result);
	
	/// Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
	/// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
	/// @param vector defines the Vector3 to transform
	/// @param transformation defines the transformation matrix
	/// @returns the new Vector3
	external static Vector3 TransformNormal(Vector3 vector, Matrix transformation);
	
	/// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
	/// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
	/// @param vector defines the Vector3 to transform
	/// @param transformation defines the transformation matrix
	/// @param result defines the Vector3 where to store the result
	external static void TransformNormalToRef(Vector3 vector, Matrix transformation, Vector3 result);
	
	/// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
	/// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
	/// @param x define the x coordinate of the source vector
	/// @param y define the y coordinate of the source vector
	/// @param z define the z coordinate of the source vector
	/// @param transformation defines the transformation matrix
	/// @param result defines the Vector3 where to store the result
	external static void TransformNormalFromFloatsToRef(num x, num y, num z, Matrix transformation, Vector3 result);
	
	/// Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"
	/// @param value1 defines the first control point
	/// @param value2 defines the second control point
	/// @param value3 defines the third control point
	/// @param value4 defines the fourth control point
	/// @param amount defines the amount on the spline to use
	/// @returns the new Vector3
	external static Vector3 CatmullRom(Vector3 value1, Vector3 value2, Vector3 value3, Vector3 value4, num amount);
	
	/// Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
	/// If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
	/// If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
	/// @param value defines the current value
	/// @param min defines the lower range value
	/// @param max defines the upper range value
	/// @returns the new Vector3
	external static Vector3 Clamp(Vector3 value, Vector3 min, Vector3 max);
	
	/// Sets the given vector "result" with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
	/// If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
	/// If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
	/// @param value defines the current value
	/// @param min defines the lower range value
	/// @param max defines the upper range value
	/// @param result defines the Vector3 where to store the result
	external static void ClampToRef(Vector3 value, Vector3 min, Vector3 max, Vector3 result);
	
	/// Checks if a given vector is inside a specific range
	/// @param v defines the vector to test
	/// @param min defines the minimum range
	/// @param max defines the maximum range
	external static void CheckExtends(Vector3 v, Vector3 min, Vector3 max);
	
	/// Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
	/// @param value1 defines the first control point
	/// @param tangent1 defines the first tangent vector
	/// @param value2 defines the second control point
	/// @param tangent2 defines the second tangent vector
	/// @param amount defines the amount on the interpolation spline (between 0 and 1)
	/// @returns the new Vector3
	external static Vector3 Hermite(Vector3 value1, Vector3 tangent1, Vector3 value2, Vector3 tangent2, num amount);
	
	/// Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"
	/// @param start defines the start value
	/// @param end defines the end value
	/// @param amount max defines amount between both (between 0 and 1)
	/// @returns the new Vector3
	external static Vector3 Lerp(Vector3 start, Vector3 end, num amount);
	
	/// Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"
	/// @param start defines the start value
	/// @param end defines the end value
	/// @param amount max defines amount between both (between 0 and 1)
	/// @param result defines the Vector3 where to store the result
	external static void LerpToRef(Vector3 start, Vector3 end, num amount, Vector3 result);
	
	/// Returns the dot product (float) between the vectors "left" and "right"
	/// @param left defines the left operand
	/// @param right defines the right operand
	/// @returns the dot product
	external static num Dot(Vector3 left, Vector3 right);
	
	/// Returns a new Vector3 as the cross product of the vectors "left" and "right"
	/// The cross product is then orthogonal to both "left" and "right"
	/// @param left defines the left operand
	/// @param right defines the right operand
	/// @returns the cross product
	external static Vector3 Cross(Vector3 left, Vector3 right);
	
	/// Sets the given vector "result" with the cross product of "left" and "right"
	/// The cross product is then orthogonal to both "left" and "right"
	/// @param left defines the left operand
	/// @param right defines the right operand
	/// @param result defines the Vector3 where to store the result
	external static void CrossToRef(Vector3 left, Vector3 right, Vector3 result);
	
	/// Returns a new Vector3 as the normalization of the given vector
	/// @param vector defines the Vector3 to normalize
	/// @returns the new Vector3
	external static Vector3 Normalize(Vector3 vector);
	
	/// Sets the given vector "result" with the normalization of the given first vector
	/// @param vector defines the Vector3 to normalize
	/// @param result defines the Vector3 where to store the result
	external static void NormalizeToRef(Vector3 vector, Vector3 result);
	
	/// Project a Vector3 onto screen space
	/// @param vector defines the Vector3 to project
	/// @param world defines the world matrix to use
	/// @param transform defines the transform (view x projection) matrix to use
	/// @param viewport defines the screen viewport to use
	/// @returns the new Vector3
	external static Vector3 Project(Vector3 vector, Matrix world, Matrix transform, Viewport viewport);
	
	/// Project a Vector3 onto screen space to reference
	/// @param vector defines the Vector3 to project
	/// @param world defines the world matrix to use
	/// @param transform defines the transform (view x projection) matrix to use
	/// @param viewport defines the screen viewport to use
	/// @param result the vector in which the screen space will be stored
	/// @returns the new Vector3
	external static Vector3 ProjectToRef(Vector3 vector, Matrix world, Matrix transform, Viewport viewport, Vector3 result);
	
	/// Unproject from screen space to object space
	/// @param source defines the screen space Vector3 to use
	/// @param viewportWidth defines the current width of the viewport
	/// @param viewportHeight defines the current height of the viewport
	/// @param world defines the world matrix to use (can be set to Identity to go to world space)
	/// @param transform defines the transform (view x projection) matrix to use
	/// @returns the new Vector3
	external static Vector3 UnprojectFromTransform(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix transform);
	
	/// Unproject from screen space to object space
	/// @param source defines the screen space Vector3 to use
	/// @param viewportWidth defines the current width of the viewport
	/// @param viewportHeight defines the current height of the viewport
	/// @param world defines the world matrix to use (can be set to Identity to go to world space)
	/// @param view defines the view matrix to use
	/// @param projection defines the projection matrix to use
	/// @returns the new Vector3
	external static Vector3 Unproject(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);
	
	/// Unproject from screen space to object space
	/// @param source defines the screen space Vector3 to use
	/// @param viewportWidth defines the current width of the viewport
	/// @param viewportHeight defines the current height of the viewport
	/// @param world defines the world matrix to use (can be set to Identity to go to world space)
	/// @param view defines the view matrix to use
	/// @param projection defines the projection matrix to use
	/// @param result defines the Vector3 where to store the result
	external static void UnprojectToRef(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection, Vector3 result);
	
	/// Unproject from screen space to object space
	/// @param sourceX defines the screen space x coordinate to use
	/// @param sourceY defines the screen space y coordinate to use
	/// @param sourceZ defines the screen space z coordinate to use
	/// @param viewportWidth defines the current width of the viewport
	/// @param viewportHeight defines the current height of the viewport
	/// @param world defines the world matrix to use (can be set to Identity to go to world space)
	/// @param view defines the view matrix to use
	/// @param projection defines the projection matrix to use
	/// @param result defines the Vector3 where to store the result
	external static void UnprojectFloatsToRef(dynamic sourceX, dynamic sourceY, dynamic sourceZ, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection, Vector3 result);
	
	/// Gets the minimal coordinate values between two Vector3
	/// @param left defines the first operand
	/// @param right defines the second operand
	/// @returns the new Vector3
	external static Vector3 Minimize(Vector3 left, Vector3 right);
	
	/// Gets the maximal coordinate values between two Vector3
	/// @param left defines the first operand
	/// @param right defines the second operand
	/// @returns the new Vector3
	external static Vector3 Maximize(Vector3 left, Vector3 right);
	
	/// Returns the distance between the vectors "value1" and "value2"
	/// @param value1 defines the first operand
	/// @param value2 defines the second operand
	/// @returns the distance
	external static num Distance(Vector3 value1, Vector3 value2);
	
	/// Returns the squared distance between the vectors "value1" and "value2"
	/// @param value1 defines the first operand
	/// @param value2 defines the second operand
	/// @returns the squared distance
	external static num DistanceSquared(Vector3 value1, Vector3 value2);
	
	/// Returns a new Vector3 located at the center between "value1" and "value2"
	/// @param value1 defines the first operand
	/// @param value2 defines the second operand
	/// @returns the new Vector3
	external static Vector3 Center(Vector3 value1, Vector3 value2);
	
	/// Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
	/// RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
	/// to something in order to rotate it from its local system to the given target system
	/// Note: axis1, axis2 and axis3 are normalized during this operation
	/// @param axis1 defines the first axis
	/// @param axis2 defines the second axis
	/// @param axis3 defines the third axis
	/// @returns a new Vector3
	external static Vector3 RotationFromAxis(Vector3 axis1, Vector3 axis2, Vector3 axis3);
	
	/// The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3
	/// @param axis1 defines the first axis
	/// @param axis2 defines the second axis
	/// @param axis3 defines the third axis
	/// @param ref defines the Vector3 where to store the result
	external static void RotationFromAxisToRef(Vector3 axis1, Vector3 axis2, Vector3 axis3, Vector3 ref);
}

/// Vector4 class created for EulerAngle class conversion to Quaternion
@JS()
class Vector4 {
	
	/// Creates a Vector4 object from the given floats.
	/// @param x x value of the vector
	/// @param y y value of the vector
	/// @param z z value of the vector
	/// @param w w value of the vector
	external factory Vector4(num x, num y, num z, num w);
	
	/// x value of the vector
	external num get x;
	external set x(num value);
	
	/// y value of the vector
	external num get y;
	external set y(num value);
	
	/// z value of the vector
	external num get z;
	external set z(num value);
	
	/// w value of the vector
	external num get w;
	external set w(num value);
	
	/// Returns the string with the Vector4 coordinates.
	/// @returns a string containing all the vector values
	external String toString();
	
	/// Returns the string "Vector4".
	/// @returns "Vector4"
	external String getClassName();
	
	/// Returns the Vector4 hash code.
	/// @returns a unique hash code
	external num getHashCode();
	
	/// Returns a new array populated with 4 elements : the Vector4 coordinates.
	/// @returns the resulting array
	external List<num> asArray();
	
	/// Populates the given array from the given index with the Vector4 coordinates.
	/// @param array array to populate
	/// @param index index of the array to start at (default: 0)
	/// @returns the Vector4.
	external Vector4 toArray(dynamic array, [num? index]);
	
	/// Update the current vector from an array
	/// @param array defines the destination array
	/// @param index defines the offset in the destination array
	/// @returns the current Vector3
	external Vector4 fromArray(dynamic array, [num? index]);
	
	/// Adds the given vector to the current Vector4.
	/// @param otherVector the vector to add
	/// @returns the updated Vector4.
	external Vector4 addInPlace(Vector4 otherVector);
	
	/// Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.
	/// @param otherVector the vector to add
	/// @returns the resulting vector
	external Vector4 add(Vector4 otherVector);
	
	/// Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.
	/// @param otherVector the vector to add
	/// @param result the vector to store the result
	/// @returns the current Vector4.
	external Vector4 addToRef(Vector4 otherVector, Vector4 result);
	
	/// Subtract in place the given vector from the current Vector4.
	/// @param otherVector the vector to subtract
	/// @returns the updated Vector4.
	external Vector4 subtractInPlace(Vector4 otherVector);
	
	/// Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.
	/// @param otherVector the vector to add
	/// @returns the new vector with the result
	external Vector4 subtract(Vector4 otherVector);
	
	/// Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.
	/// @param otherVector the vector to subtract
	/// @param result the vector to store the result
	/// @returns the current Vector4.
	external Vector4 subtractToRef(Vector4 otherVector, Vector4 result);
	
	/// Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
	/// @param x value to subtract
	/// @param y value to subtract
	/// @param z value to subtract
	/// @param w value to subtract
	/// @returns new vector containing the result
	external Vector4 subtractFromFloats(num x, num y, num z, num w);
	
	/// Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.
	/// @param x value to subtract
	/// @param y value to subtract
	/// @param z value to subtract
	/// @param w value to subtract
	/// @param result the vector to store the result in
	/// @returns the current Vector4.
	external Vector4 subtractFromFloatsToRef(num x, num y, num z, num w, Vector4 result);
	
	/// Returns a new Vector4 set with the current Vector4 negated coordinates.
	/// @returns a new vector with the negated values
	external Vector4 negate();
	
	/// Negate this vector in place
	/// @returns this
	external Vector4 negateInPlace();
	
	/// Negate the current Vector4 and stores the result in the given vector "result" coordinates
	/// @param result defines the Vector3 object where to store the result
	/// @returns the current Vector4
	external Vector4 negateToRef(Vector4 result);
	
	/// Multiplies the current Vector4 coordinates by scale (float).
	/// @param scale the number to scale with
	/// @returns the updated Vector4.
	external Vector4 scaleInPlace(num scale);
	
	/// Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).
	/// @param scale the number to scale with
	/// @returns a new vector with the result
	external Vector4 scale(num scale);
	
	/// Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).
	/// @param scale the number to scale with
	/// @param result a vector to store the result in
	/// @returns the current Vector4.
	external Vector4 scaleToRef(num scale, Vector4 result);
	
	/// Scale the current Vector4 values by a factor and add the result to a given Vector4
	/// @param scale defines the scale factor
	/// @param result defines the Vector4 object where to store the result
	/// @returns the unmodified current Vector4
	external Vector4 scaleAndAddToRef(num scale, Vector4 result);
	
	/// Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.
	/// @param otherVector the vector to compare against
	/// @returns true if they are equal
	external bool equals(Vector4 otherVector);
	
	/// Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.
	/// @param otherVector vector to compare against
	/// @param epsilon (Default: very small number)
	/// @returns true if they are equal
	external bool equalsWithEpsilon(Vector4 otherVector, [num? epsilon]);
	
	/// Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.
	/// @param x x value to compare against
	/// @param y y value to compare against
	/// @param z z value to compare against
	/// @param w w value to compare against
	/// @returns true if equal
	external bool equalsToFloats(num x, num y, num z, num w);
	
	/// Multiplies in place the current Vector4 by the given one.
	/// @param otherVector vector to multiple with
	/// @returns the updated Vector4.
	external Vector4 multiplyInPlace(Vector4 otherVector);
	
	/// Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.
	/// @param otherVector vector to multiple with
	/// @returns resulting new vector
	external Vector4 multiply(Vector4 otherVector);
	
	/// Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.
	/// @param otherVector vector to multiple with
	/// @param result vector to store the result
	/// @returns the current Vector4.
	external Vector4 multiplyToRef(Vector4 otherVector, Vector4 result);
	
	/// Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.
	/// @param x x value multiply with
	/// @param y y value multiply with
	/// @param z z value multiply with
	/// @param w w value multiply with
	/// @returns resulting new vector
	external Vector4 multiplyByFloats(num x, num y, num z, num w);
	
	/// Returns a new Vector4 set with the division result of the current Vector4 by the given one.
	/// @param otherVector vector to devide with
	/// @returns resulting new vector
	external Vector4 divide(Vector4 otherVector);
	
	/// Updates the given vector "result" with the division result of the current Vector4 by the given one.
	/// @param otherVector vector to devide with
	/// @param result vector to store the result
	/// @returns the current Vector4.
	external Vector4 divideToRef(Vector4 otherVector, Vector4 result);
	
	/// Divides the current Vector3 coordinates by the given ones.
	/// @param otherVector vector to devide with
	/// @returns the updated Vector3.
	external Vector4 divideInPlace(Vector4 otherVector);
	
	/// Updates the Vector4 coordinates with the minimum values between its own and the given vector ones
	/// @param other defines the second operand
	/// @returns the current updated Vector4
	external Vector4 minimizeInPlace(Vector4 other);
	
	/// Updates the Vector4 coordinates with the maximum values between its own and the given vector ones
	/// @param other defines the second operand
	/// @returns the current updated Vector4
	external Vector4 maximizeInPlace(Vector4 other);
	
	/// Gets a new Vector4 from current Vector4 floored values
	/// @returns a new Vector4
	external Vector4 floor();
	
	/// Gets a new Vector4 from current Vector3 floored values
	/// @returns a new Vector4
	external Vector4 fract();
	
	/// Returns the Vector4 length (float).
	/// @returns the length
	external num length();
	
	/// Returns the Vector4 squared length (float).
	/// @returns the length squared
	external num lengthSquared();
	
	/// Normalizes in place the Vector4.
	/// @returns the updated Vector4.
	external Vector4 normalize();
	
	/// Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
	/// @returns this converted to a new vector3
	external Vector3 toVector3();
	
	/// Returns a new Vector4 copied from the current one.
	/// @returns the new cloned vector
	external Vector4 clone();
	
	/// Updates the current Vector4 with the given one coordinates.
	/// @param source the source vector to copy from
	/// @returns the updated Vector4.
	external Vector4 copyFrom(Vector4 source);
	
	/// Updates the current Vector4 coordinates with the given floats.
	/// @param x float to copy from
	/// @param y float to copy from
	/// @param z float to copy from
	/// @param w float to copy from
	/// @returns the updated Vector4.
	external Vector4 copyFromFloats(num x, num y, num z, num w);
	
	/// Updates the current Vector4 coordinates with the given floats.
	/// @param x float to set from
	/// @param y float to set from
	/// @param z float to set from
	/// @param w float to set from
	/// @returns the updated Vector4.
	external Vector4 set(num x, num y, num z, num w);
	
	/// Copies the given float to the current Vector3 coordinates
	/// @param v defines the x, y, z and w coordinates of the operand
	/// @returns the current updated Vector3
	external Vector4 setAll(num v);
	
	/// Returns a new Vector4 set from the starting index of the given array.
	/// @param array the array to pull values from
	/// @param offset the offset into the array to start at
	/// @returns the new vector
	external static Vector4 FromArray(List<num> array, [num? offset]);
	
	/// Updates the given vector "result" from the starting index of the given array.
	/// @param array the array to pull values from
	/// @param offset the offset into the array to start at
	/// @param result the vector to store the result in
	external static void FromArrayToRef(List<num> array, num offset, Vector4 result);
	
	/// Updates the given vector "result" from the starting index of the given Float32Array.
	/// @param array the array to pull values from
	/// @param offset the offset into the array to start at
	/// @param result the vector to store the result in
	external static void FromFloatArrayToRef(Float32List array, num offset, Vector4 result);
	
	/// Updates the given vector "result" coordinates from the given floats.
	/// @param x float to set from
	/// @param y float to set from
	/// @param z float to set from
	/// @param w float to set from
	/// @param result the vector to the floats in
	external static void FromFloatsToRef(num x, num y, num z, num w, Vector4 result);
	
	/// Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
	/// @returns the new vector
	external static Vector4 Zero();
	
	/// Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
	/// @returns the new vector
	external static Vector4 One();
	
	/// Returns a new normalized Vector4 from the given one.
	/// @param vector the vector to normalize
	/// @returns the vector
	external static Vector4 Normalize(Vector4 vector);
	
	/// Updates the given vector "result" from the normalization of the given one.
	/// @param vector the vector to normalize
	/// @param result the vector to store the result in
	external static void NormalizeToRef(Vector4 vector, Vector4 result);
	
	/// Returns a vector with the minimum values from the left and right vectors
	/// @param left left vector to minimize
	/// @param right right vector to minimize
	/// @returns a new vector with the minimum of the left and right vector values
	external static Vector4 Minimize(Vector4 left, Vector4 right);
	
	/// Returns a vector with the maximum values from the left and right vectors
	/// @param left left vector to maximize
	/// @param right right vector to maximize
	/// @returns a new vector with the maximum of the left and right vector values
	external static Vector4 Maximize(Vector4 left, Vector4 right);
	
	/// Returns the distance (float) between the vectors "value1" and "value2".
	/// @param value1 value to calulate the distance between
	/// @param value2 value to calulate the distance between
	/// @return the distance between the two vectors
	external static num Distance(Vector4 value1, Vector4 value2);
	
	/// Returns the squared distance (float) between the vectors "value1" and "value2".
	/// @param value1 value to calulate the distance between
	/// @param value2 value to calulate the distance between
	/// @return the distance between the two vectors squared
	external static num DistanceSquared(Vector4 value1, Vector4 value2);
	
	/// Returns a new Vector4 located at the center between the vectors "value1" and "value2".
	/// @param value1 value to calulate the center between
	/// @param value2 value to calulate the center between
	/// @return the center between the two vectors
	external static Vector4 Center(Vector4 value1, Vector4 value2);
	
	/// Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
	/// This methods computes transformed normalized direction vectors only.
	/// @param vector the vector to transform
	/// @param transformation the transformation matrix to apply
	/// @returns the new vector
	external static Vector4 TransformNormal(Vector4 vector, Matrix transformation);
	
	/// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
	/// This methods computes transformed normalized direction vectors only.
	/// @param vector the vector to transform
	/// @param transformation the transformation matrix to apply
	/// @param result the vector to store the result in
	external static void TransformNormalToRef(Vector4 vector, Matrix transformation, Vector4 result);
	
	/// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
	/// This methods computes transformed normalized direction vectors only.
	/// @param x value to transform
	/// @param y value to transform
	/// @param z value to transform
	/// @param w value to transform
	/// @param transformation the transformation matrix to apply
	/// @param result the vector to store the results in
	external static void TransformNormalFromFloatsToRef(num x, num y, num z, num w, Matrix transformation, Vector4 result);
	
	/// Creates a new Vector4 from a Vector3
	/// @param source defines the source data
	/// @param w defines the 4th component (default is 0)
	/// @returns a new Vector4
	external static Vector4 FromVector3(Vector3 source, [num? w]);
}

/// Class used to store quaternion data
/// @see https://en.wikipedia.org/wiki/Quaternion
/// @see https://doc.babylonjs.com/features/position,_rotation,_scaling
@JS()
class Quaternion {
	
	/// Creates a new Quaternion from the given floats
	/// @param x defines the first component (0 by default)
	/// @param y defines the second component (0 by default)
	/// @param z defines the third component (0 by default)
	/// @param w defines the fourth component (1.0 by default)
	external factory Quaternion([num? x, num? y, num? z, num? w]);
	
	/// Gets or sets the x coordinate
	external num get x;
	
	external set x(num value);
	
	/// Gets or sets the y coordinate
	external num get y;
	
	external set y(num value);
	
	/// Gets or sets the z coordinate
	external num get z;
	
	external set z(num value);
	
	/// Gets or sets the w coordinate
	external num get w;
	
	external set w(num value);
	
	/// Gets a string representation for the current quaternion
	/// @returns a string with the Quaternion coordinates
	external String toString();
	
	/// Gets the class name of the quaternion
	/// @returns the string "Quaternion"
	external String getClassName();
	
	/// Gets a hash code for this quaternion
	/// @returns the quaternion hash code
	external num getHashCode();
	
	/// Copy the quaternion to an array
	/// @returns a new array populated with 4 elements from the quaternion coordinates
	external List<num> asArray();
	
	/// Check if two quaternions are equals
	/// @param otherQuaternion defines the second operand
	/// @return true if the current quaternion and the given one coordinates are strictly equals
	external bool equals(Quaternion otherQuaternion);
	
	/// Gets a boolean if two quaternions are equals (using an epsilon value)
	/// @param otherQuaternion defines the other quaternion
	/// @param epsilon defines the minimal distance to consider equality
	/// @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.
	external bool equalsWithEpsilon(Quaternion otherQuaternion, [num? epsilon]);
	
	/// Clone the current quaternion
	/// @returns a new quaternion copied from the current one
	external Quaternion clone();
	
	/// Copy a quaternion to the current one
	/// @param other defines the other quaternion
	/// @returns the updated current quaternion
	external Quaternion copyFrom(Quaternion other);
	
	/// Updates the current quaternion with the given float coordinates
	/// @param x defines the x coordinate
	/// @param y defines the y coordinate
	/// @param z defines the z coordinate
	/// @param w defines the w coordinate
	/// @returns the updated current quaternion
	external Quaternion copyFromFloats(num x, num y, num z, num w);
	
	/// Updates the current quaternion from the given float coordinates
	/// @param x defines the x coordinate
	/// @param y defines the y coordinate
	/// @param z defines the z coordinate
	/// @param w defines the w coordinate
	/// @returns the updated current quaternion
	external Quaternion set(num x, num y, num z, num w);
	
	/// Adds two quaternions
	/// @param other defines the second operand
	/// @returns a new quaternion as the addition result of the given one and the current quaternion
	external Quaternion add(Quaternion other);
	
	/// Add a quaternion to the current one
	/// @param other defines the quaternion to add
	/// @returns the current quaternion
	external Quaternion addInPlace(Quaternion other);
	
	/// Subtract two quaternions
	/// @param other defines the second operand
	/// @returns a new quaternion as the subtraction result of the given one from the current one
	external Quaternion subtract(Quaternion other);
	
	/// Multiplies the current quaternion by a scale factor
	/// @param value defines the scale factor
	/// @returns a new quaternion set by multiplying the current quaternion coordinates by the float "scale"
	external Quaternion scale(num value);
	
	/// Scale the current quaternion values by a factor and stores the result to a given quaternion
	/// @param scale defines the scale factor
	/// @param result defines the Quaternion object where to store the result
	/// @returns the unmodified current quaternion
	external Quaternion scaleToRef(num scale, Quaternion result);
	
	/// Multiplies in place the current quaternion by a scale factor
	/// @param value defines the scale factor
	/// @returns the current modified quaternion
	external Quaternion scaleInPlace(num value);
	
	/// Scale the current quaternion values by a factor and add the result to a given quaternion
	/// @param scale defines the scale factor
	/// @param result defines the Quaternion object where to store the result
	/// @returns the unmodified current quaternion
	external Quaternion scaleAndAddToRef(num scale, Quaternion result);
	
	/// Multiplies two quaternions
	/// @param q1 defines the second operand
	/// @returns a new quaternion set as the multiplication result of the current one with the given one "q1"
	external Quaternion multiply(Quaternion q1);
	
	/// Sets the given "result" as the the multiplication result of the current one with the given one "q1"
	/// @param q1 defines the second operand
	/// @param result defines the target quaternion
	/// @returns the current quaternion
	external Quaternion multiplyToRef(Quaternion q1, Quaternion result);
	
	/// Updates the current quaternion with the multiplication of itself with the given one "q1"
	/// @param q1 defines the second operand
	/// @returns the currentupdated quaternion
	external Quaternion multiplyInPlace(Quaternion q1);
	
	/// Conjugates (1-q) the current quaternion and stores the result in the given quaternion
	/// @param ref defines the target quaternion
	/// @returns the current quaternion
	external Quaternion conjugateToRef(Quaternion ref);
	
	/// Conjugates in place (1-q) the current quaternion
	/// @returns the current updated quaternion
	external Quaternion conjugateInPlace();
	
	/// Conjugates in place (1-q) the current quaternion
	/// @returns a new quaternion
	external Quaternion conjugate();
	
	/// Gets length of current quaternion
	/// @returns the quaternion length (float)
	external num length();
	
	/// Normalize in place the current quaternion
	/// @returns the current updated quaternion
	external Quaternion normalize();
	
	/// Returns a new Vector3 set with the Euler angles translated from the current quaternion
	/// @param order is a reserved parameter and is ignored for now
	/// @returns a new Vector3 containing the Euler angles
	external Vector3 toEulerAngles([String? order]);
	
	/// Sets the given vector3 "result" with the Euler angles translated from the current quaternion
	/// @param result defines the vector which will be filled with the Euler angles
	/// @returns the current unchanged quaternion
	external Quaternion toEulerAnglesToRef(Vector3 result);
	
	/// Updates the given rotation matrix with the current quaternion values
	/// @param result defines the target matrix
	/// @returns the current unchanged quaternion
	external Quaternion toRotationMatrix(Matrix result);
	
	/// Updates the current quaternion from the given rotation matrix values
	/// @param matrix defines the source matrix
	/// @returns the current updated quaternion
	external Quaternion fromRotationMatrix(Matrix matrix);
	
	/// Creates a new quaternion from a rotation matrix
	/// @param matrix defines the source matrix
	/// @returns a new quaternion created from the given rotation matrix values
	external static Quaternion FromRotationMatrix(Matrix matrix);
	
	/// Updates the given quaternion with the given rotation matrix values
	/// @param matrix defines the source matrix
	/// @param result defines the target quaternion
	external static void FromRotationMatrixToRef(Matrix matrix, Quaternion result);
	
	/// Returns the dot product (float) between the quaternions "left" and "right"
	/// @param left defines the left operand
	/// @param right defines the right operand
	/// @returns the dot product
	external static num Dot(Quaternion left, Quaternion right);
	
	/// Checks if the two quaternions are close to each other
	/// @param quat0 defines the first quaternion to check
	/// @param quat1 defines the second quaternion to check
	/// @returns true if the two quaternions are close to each other
	external static bool AreClose(Quaternion quat0, Quaternion quat1);
	
	/// Creates an empty quaternion
	/// @returns a new quaternion set to (0.0, 0.0, 0.0)
	external static Quaternion Zero();
	
	/// Inverse a given quaternion
	/// @param q defines the source quaternion
	/// @returns a new quaternion as the inverted current quaternion
	external static Quaternion Inverse(Quaternion q);
	
	/// Inverse a given quaternion
	/// @param q defines the source quaternion
	/// @param result the quaternion the result will be stored in
	/// @returns the result quaternion
	external static Quaternion InverseToRef(Quaternion q, Quaternion result);
	
	/// Creates an identity quaternion
	/// @returns the identity quaternion
	external static Quaternion Identity();
	
	/// Gets a boolean indicating if the given quaternion is identity
	/// @param quaternion defines the quaternion to check
	/// @returns true if the quaternion is identity
	external static bool IsIdentity(Quaternion quaternion);
	
	/// Creates a quaternion from a rotation around an axis
	/// @param axis defines the axis to use
	/// @param angle defines the angle to use
	/// @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)
	external static Quaternion RotationAxis(Vector3 axis, num angle);
	
	/// Creates a rotation around an axis and stores it into the given quaternion
	/// @param axis defines the axis to use
	/// @param angle defines the angle to use
	/// @param result defines the target quaternion
	/// @returns the target quaternion
	external static Quaternion RotationAxisToRef(Vector3 axis, num angle, Quaternion result);
	
	/// Creates a new quaternion from data stored into an array
	/// @param array defines the data source
	/// @param offset defines the offset in the source array where the data starts
	/// @returns a new quaternion
	external static Quaternion FromArray(List<num> array, [num? offset]);
	
	/// Updates the given quaternion "result" from the starting index of the given array.
	/// @param array the array to pull values from
	/// @param offset the offset into the array to start at
	/// @param result the quaternion to store the result in
	external static void FromArrayToRef(List<num> array, num offset, Quaternion result);
	
	/// Create a quaternion from Euler rotation angles
	/// @param x Pitch
	/// @param y Yaw
	/// @param z Roll
	/// @returns the new Quaternion
	external static Quaternion FromEulerAngles(num x, num y, num z);
	
	/// Updates a quaternion from Euler rotation angles
	/// @param x Pitch
	/// @param y Yaw
	/// @param z Roll
	/// @param result the quaternion to store the result
	/// @returns the updated quaternion
	external static Quaternion FromEulerAnglesToRef(num x, num y, num z, Quaternion result);
	
	/// Create a quaternion from Euler rotation vector
	/// @param vec the Euler vector (x Pitch, y Yaw, z Roll)
	/// @returns the new Quaternion
	external static Quaternion FromEulerVector(Vector3 vec);
	
	/// Updates a quaternion from Euler rotation vector
	/// @param vec the Euler vector (x Pitch, y Yaw, z Roll)
	/// @param result the quaternion to store the result
	/// @returns the updated quaternion
	external static Quaternion FromEulerVectorToRef(Vector3 vec, Quaternion result);
	
	/// Creates a new quaternion from the given Euler float angles (y, x, z)
	/// @param yaw defines the rotation around Y axis
	/// @param pitch defines the rotation around X axis
	/// @param roll defines the rotation around Z axis
	/// @returns the new quaternion
	external static Quaternion RotationYawPitchRoll(num yaw, num pitch, num roll);
	
	/// Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion
	/// @param yaw defines the rotation around Y axis
	/// @param pitch defines the rotation around X axis
	/// @param roll defines the rotation around Z axis
	/// @param result defines the target quaternion
	external static void RotationYawPitchRollToRef(num yaw, num pitch, num roll, Quaternion result);
	
	/// Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation
	/// @param alpha defines the rotation around first axis
	/// @param beta defines the rotation around second axis
	/// @param gamma defines the rotation around third axis
	/// @returns the new quaternion
	external static Quaternion RotationAlphaBetaGamma(num alpha, num beta, num gamma);
	
	/// Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion
	/// @param alpha defines the rotation around first axis
	/// @param beta defines the rotation around second axis
	/// @param gamma defines the rotation around third axis
	/// @param result defines the target quaternion
	external static void RotationAlphaBetaGammaToRef(num alpha, num beta, num gamma, Quaternion result);
	
	/// Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)
	/// @param axis1 defines the first axis
	/// @param axis2 defines the second axis
	/// @param axis3 defines the third axis
	/// @returns the new quaternion
	external static Quaternion RotationQuaternionFromAxis(Vector3 axis1, Vector3 axis2, Vector3 axis3);
	
	/// Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion
	/// @param axis1 defines the first axis
	/// @param axis2 defines the second axis
	/// @param axis3 defines the third axis
	/// @param ref defines the target quaternion
	external static void RotationQuaternionFromAxisToRef(Vector3 axis1, Vector3 axis2, Vector3 axis3, Quaternion ref);
	
	/// Interpolates between two quaternions
	/// @param left defines first quaternion
	/// @param right defines second quaternion
	/// @param amount defines the gradient to use
	/// @returns the new interpolated quaternion
	external static Quaternion Slerp(Quaternion left, Quaternion right, num amount);
	
	/// Interpolates between two quaternions and stores it into a target quaternion
	/// @param left defines first quaternion
	/// @param right defines second quaternion
	/// @param amount defines the gradient to use
	/// @param result defines the target quaternion
	external static void SlerpToRef(Quaternion left, Quaternion right, num amount, Quaternion result);
	
	/// Interpolate between two quaternions using Hermite interpolation
	/// @param value1 defines first quaternion
	/// @param tangent1 defines the incoming tangent
	/// @param value2 defines second quaternion
	/// @param tangent2 defines the outgoing tangent
	/// @param amount defines the target quaternion
	/// @returns the new interpolated quaternion
	external static Quaternion Hermite(Quaternion value1, Quaternion tangent1, Quaternion value2, Quaternion tangent2, num amount);
}

/// Class used to store matrix data (4x4)
@JS()
class Matrix {
	
	/// Creates an empty matrix (filled with zeros)
	external factory Matrix();
	
	/// Gets the precision of matrix computations
	external static bool get Use64Bits;
	
	/// Gets the update flag of the matrix which is an unique number for the matrix.
	/// It will be incremented every time the matrix data change.
	/// You can use it to speed the comparison between two versions of the same matrix.
	external num get updateFlag;
	external set updateFlag(num value);
	
	/// Gets the internal data of the matrix
	external dynamic get m;
	
	/// Check if the current matrix is identity
	/// @returns true is the matrix is the identity matrix
	external bool isIdentity();
	
	/// Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)
	/// @returns true is the matrix is the identity matrix
	external bool isIdentityAs3x2();
	
	/// Gets the determinant of the matrix
	/// @returns the matrix determinant
	external num determinant();
	
	/// Returns the matrix as a Float32Array or Array<number>
	/// @returns the matrix underlying array
	external dynamic toArray();
	
	/// Returns the matrix as a Float32Array or Array<number>
	/// @returns the matrix underlying array.
	external dynamic asArray();
	
	/// Inverts the current matrix in place
	/// @returns the current inverted matrix
	external Matrix invert();
	
	/// Sets all the matrix elements to zero
	/// @returns the current matrix
	external Matrix reset();
	
	/// Adds the current matrix with a second one
	/// @param other defines the matrix to add
	/// @returns a new matrix as the addition of the current matrix and the given one
	external Matrix add(Matrix other);
	
	/// Sets the given matrix "result" to the addition of the current matrix and the given one
	/// @param other defines the matrix to add
	/// @param result defines the target matrix
	/// @returns the current matrix
	external Matrix addToRef(Matrix other, Matrix result);
	
	/// Adds in place the given matrix to the current matrix
	/// @param other defines the second operand
	/// @returns the current updated matrix
	external Matrix addToSelf(Matrix other);
	
	/// Sets the given matrix to the current inverted Matrix
	/// @param other defines the target matrix
	/// @returns the unmodified current matrix
	external Matrix invertToRef(Matrix other);
	
	/// add a value at the specified position in the current Matrix
	/// @param index the index of the value within the matrix. between 0 and 15.
	/// @param value the value to be added
	/// @returns the current updated matrix
	external Matrix addAtIndex(num index, num value);
	
	/// mutiply the specified position in the current Matrix by a value
	/// @param index the index of the value within the matrix. between 0 and 15.
	/// @param value the value to be added
	/// @returns the current updated matrix
	external Matrix multiplyAtIndex(num index, num value);
	
	/// Inserts the translation vector (using 3 floats) in the current matrix
	/// @param x defines the 1st component of the translation
	/// @param y defines the 2nd component of the translation
	/// @param z defines the 3rd component of the translation
	/// @returns the current updated matrix
	external Matrix setTranslationFromFloats(num x, num y, num z);
	
	/// Adds the translation vector (using 3 floats) in the current matrix
	/// @param x defines the 1st component of the translation
	/// @param y defines the 2nd component of the translation
	/// @param z defines the 3rd component of the translation
	/// @returns the current updated matrix
	external Matrix addTranslationFromFloats(num x, num y, num z);
	
	/// Inserts the translation vector in the current matrix
	/// @param vector3 defines the translation to insert
	/// @returns the current updated matrix
	external Matrix setTranslation(Vector3 vector3);
	
	/// Gets the translation value of the current matrix
	/// @returns a new Vector3 as the extracted translation from the matrix
	external Vector3 getTranslation();
	
	/// Fill a Vector3 with the extracted translation from the matrix
	/// @param result defines the Vector3 where to store the translation
	/// @returns the current matrix
	external Matrix getTranslationToRef(Vector3 result);
	
	/// Remove rotation and scaling part from the matrix
	/// @returns the updated matrix
	external Matrix removeRotationAndScaling();
	
	/// Multiply two matrices
	/// @param other defines the second operand
	/// @returns a new matrix set with the multiplication result of the current Matrix and the given one
	external Matrix multiply(Matrix other);
	
	/// Copy the current matrix from the given one
	/// @param other defines the source matrix
	/// @returns the current updated matrix
	external Matrix copyFrom(Matrix other);
	
	/// Populates the given array from the starting index with the current matrix values
	/// @param array defines the target array
	/// @param offset defines the offset in the target array where to start storing values
	/// @returns the current matrix
	external Matrix copyToArray(dynamic array, [num? offset]);
	
	/// Sets the given matrix "result" with the multiplication result of the current Matrix and the given one
	/// @param other defines the second operand
	/// @param result defines the matrix where to store the multiplication
	/// @returns the current matrix
	external Matrix multiplyToRef(Matrix other, Matrix result);
	
	/// Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one
	/// @param other defines the second operand
	/// @param result defines the array where to store the multiplication
	/// @param offset defines the offset in the target array where to start storing values
	/// @returns the current matrix
	external Matrix multiplyToArray(Matrix other, dynamic result, num offset);
	
	/// Check equality between this matrix and a second one
	/// @param value defines the second matrix to compare
	/// @returns true is the current matrix and the given one values are strictly equal
	external bool equals(Matrix value);
	
	/// Clone the current matrix
	/// @returns a new matrix from the current matrix
	external Matrix clone();
	
	/// Returns the name of the current matrix class
	/// @returns the string "Matrix"
	external String getClassName();
	
	/// Gets the hash code of the current matrix
	/// @returns the hash code
	external num getHashCode();
	
	/// Decomposes the current Matrix into a translation, rotation and scaling components
	/// @param scale defines the scale vector3 given as a reference to update
	/// @param rotation defines the rotation quaternion given as a reference to update
	/// @param translation defines the translation vector3 given as a reference to update
	/// @returns true if operation was successful
	external bool decompose([Vector3? scale, Quaternion? rotation, Vector3? translation]);
	
	/// Gets specific row of the matrix
	/// @param index defines the number of the row to get
	/// @returns the index-th row of the current matrix as a new Vector4
	external Vector4? getRow(num index);
	
	/// Sets the index-th row of the current matrix to the vector4 values
	/// @param index defines the number of the row to set
	/// @param row defines the target vector4
	/// @returns the updated current matrix
	external Matrix setRow(num index, Vector4 row);
	
	/// Compute the transpose of the matrix
	/// @returns the new transposed matrix
	external Matrix transpose();
	
	/// Compute the transpose of the matrix and store it in a given matrix
	/// @param result defines the target matrix
	/// @returns the current matrix
	external Matrix transposeToRef(Matrix result);
	
	/// Sets the index-th row of the current matrix with the given 4 x float values
	/// @param index defines the row index
	/// @param x defines the x component to set
	/// @param y defines the y component to set
	/// @param z defines the z component to set
	/// @param w defines the w component to set
	/// @returns the updated current matrix
	external Matrix setRowFromFloats(num index, num x, num y, num z, num w);
	
	/// Compute a new matrix set with the current matrix values multiplied by scale (float)
	/// @param scale defines the scale factor
	/// @returns a new matrix
	external Matrix scale(num scale);
	
	/// Scale the current matrix values by a factor to a given result matrix
	/// @param scale defines the scale factor
	/// @param result defines the matrix to store the result
	/// @returns the current matrix
	external Matrix scaleToRef(num scale, Matrix result);
	
	/// Scale the current matrix values by a factor and add the result to a given matrix
	/// @param scale defines the scale factor
	/// @param result defines the Matrix to store the result
	/// @returns the current matrix
	external Matrix scaleAndAddToRef(num scale, Matrix result);
	
	/// Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).
	/// @param ref matrix to store the result
	external void toNormalMatrix(Matrix ref);
	
	/// Gets only rotation part of the current matrix
	/// @returns a new matrix sets to the extracted rotation matrix from the current one
	external Matrix getRotationMatrix();
	
	/// Extracts the rotation matrix from the current one and sets it as the given "result"
	/// @param result defines the target matrix to store data to
	/// @returns the current matrix
	external Matrix getRotationMatrixToRef(Matrix result);
	
	/// Toggles model matrix from being right handed to left handed in place and vice versa
	external void toggleModelMatrixHandInPlace();
	
	/// Toggles projection matrix from being right handed to left handed in place and vice versa
	external void toggleProjectionMatrixHandInPlace();
	
	/// Creates a matrix from an array
	/// @param array defines the source array
	/// @param offset defines an offset in the source array
	/// @returns a new Matrix set from the starting index of the given array
	external static Matrix FromArray(List<num> array, [num? offset]);
	
	/// Copy the content of an array into a given matrix
	/// @param array defines the source array
	/// @param offset defines an offset in the source array
	/// @param result defines the target matrix
	external static void FromArrayToRef(List<num> array, num offset, Matrix result);
	
	/// Stores an array into a matrix after having multiplied each component by a given factor
	/// @param array defines the source array
	/// @param offset defines the offset in the source array
	/// @param scale defines the scaling factor
	/// @param result defines the target matrix
	external static void FromFloat32ArrayToRefScaled(dynamic array, num offset, num scale, Matrix result);
	
	/// Gets an identity matrix that must not be updated
	external static Matrix get IdentityReadOnly;
	
	/// Stores a list of values (16) inside a given matrix
	/// @param initialM11 defines 1st value of 1st row
	/// @param initialM12 defines 2nd value of 1st row
	/// @param initialM13 defines 3rd value of 1st row
	/// @param initialM14 defines 4th value of 1st row
	/// @param initialM21 defines 1st value of 2nd row
	/// @param initialM22 defines 2nd value of 2nd row
	/// @param initialM23 defines 3rd value of 2nd row
	/// @param initialM24 defines 4th value of 2nd row
	/// @param initialM31 defines 1st value of 3rd row
	/// @param initialM32 defines 2nd value of 3rd row
	/// @param initialM33 defines 3rd value of 3rd row
	/// @param initialM34 defines 4th value of 3rd row
	/// @param initialM41 defines 1st value of 4th row
	/// @param initialM42 defines 2nd value of 4th row
	/// @param initialM43 defines 3rd value of 4th row
	/// @param initialM44 defines 4th value of 4th row
	/// @param result defines the target matrix
	external static void FromValuesToRef(num initialM11, num initialM12, num initialM13, num initialM14, num initialM21, num initialM22, num initialM23, num initialM24, num initialM31, num initialM32, num initialM33, num initialM34, num initialM41, num initialM42, num initialM43, num initialM44, Matrix result);
	
	/// Creates new matrix from a list of values (16)
	/// @param initialM11 defines 1st value of 1st row
	/// @param initialM12 defines 2nd value of 1st row
	/// @param initialM13 defines 3rd value of 1st row
	/// @param initialM14 defines 4th value of 1st row
	/// @param initialM21 defines 1st value of 2nd row
	/// @param initialM22 defines 2nd value of 2nd row
	/// @param initialM23 defines 3rd value of 2nd row
	/// @param initialM24 defines 4th value of 2nd row
	/// @param initialM31 defines 1st value of 3rd row
	/// @param initialM32 defines 2nd value of 3rd row
	/// @param initialM33 defines 3rd value of 3rd row
	/// @param initialM34 defines 4th value of 3rd row
	/// @param initialM41 defines 1st value of 4th row
	/// @param initialM42 defines 2nd value of 4th row
	/// @param initialM43 defines 3rd value of 4th row
	/// @param initialM44 defines 4th value of 4th row
	/// @returns the new matrix
	external static Matrix FromValues(num initialM11, num initialM12, num initialM13, num initialM14, num initialM21, num initialM22, num initialM23, num initialM24, num initialM31, num initialM32, num initialM33, num initialM34, num initialM41, num initialM42, num initialM43, num initialM44);
	
	/// Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
	/// @param scale defines the scale vector3
	/// @param rotation defines the rotation quaternion
	/// @param translation defines the translation vector3
	/// @returns a new matrix
	external static Matrix Compose(Vector3 scale, Quaternion rotation, Vector3 translation);
	
	/// Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
	/// @param scale defines the scale vector3
	/// @param rotation defines the rotation quaternion
	/// @param translation defines the translation vector3
	/// @param result defines the target matrix
	external static void ComposeToRef(Vector3 scale, Quaternion rotation, Vector3 translation, Matrix result);
	
	/// Creates a new identity matrix
	/// @returns a new identity matrix
	external static Matrix Identity();
	
	/// Creates a new identity matrix and stores the result in a given matrix
	/// @param result defines the target matrix
	external static void IdentityToRef(Matrix result);
	
	/// Creates a new zero matrix
	/// @returns a new zero matrix
	external static Matrix Zero();
	
	/// Creates a new rotation matrix for "angle" radians around the X axis
	/// @param angle defines the angle (in radians) to use
	/// @return the new matrix
	external static Matrix RotationX(num angle);
	
	/// Creates a new matrix as the invert of a given matrix
	/// @param source defines the source matrix
	/// @returns the new matrix
	external static Matrix Invert(Matrix source);
	
	/// Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix
	/// @param angle defines the angle (in radians) to use
	/// @param result defines the target matrix
	external static void RotationXToRef(num angle, Matrix result);
	
	/// Creates a new rotation matrix for "angle" radians around the Y axis
	/// @param angle defines the angle (in radians) to use
	/// @return the new matrix
	external static Matrix RotationY(num angle);
	
	/// Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix
	/// @param angle defines the angle (in radians) to use
	/// @param result defines the target matrix
	external static void RotationYToRef(num angle, Matrix result);
	
	/// Creates a new rotation matrix for "angle" radians around the Z axis
	/// @param angle defines the angle (in radians) to use
	/// @return the new matrix
	external static Matrix RotationZ(num angle);
	
	/// Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix
	/// @param angle defines the angle (in radians) to use
	/// @param result defines the target matrix
	external static void RotationZToRef(num angle, Matrix result);
	
	/// Creates a new rotation matrix for "angle" radians around the given axis
	/// @param axis defines the axis to use
	/// @param angle defines the angle (in radians) to use
	/// @return the new matrix
	external static Matrix RotationAxis(Vector3 axis, num angle);
	
	/// Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix
	/// @param axis defines the axis to use
	/// @param angle defines the angle (in radians) to use
	/// @param result defines the target matrix
	external static void RotationAxisToRef(Vector3 axis, num angle, Matrix result);
	
	/// Takes normalised vectors and returns a rotation matrix to align "from" with "to".
	/// Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm
	/// @param from defines the vector to align
	/// @param to defines the vector to align to
	/// @param result defines the target matrix
	external static void RotationAlignToRef(Vector3 from, Vector3 to, Matrix result);
	
	/// Creates a rotation matrix
	/// @param yaw defines the yaw angle in radians (Y axis)
	/// @param pitch defines the pitch angle in radians (X axis)
	/// @param roll defines the roll angle in radians (Z axis)
	/// @returns the new rotation matrix
	external static Matrix RotationYawPitchRoll(num yaw, num pitch, num roll);
	
	/// Creates a rotation matrix and stores it in a given matrix
	/// @param yaw defines the yaw angle in radians (Y axis)
	/// @param pitch defines the pitch angle in radians (X axis)
	/// @param roll defines the roll angle in radians (Z axis)
	/// @param result defines the target matrix
	external static void RotationYawPitchRollToRef(num yaw, num pitch, num roll, Matrix result);
	
	/// Creates a scaling matrix
	/// @param x defines the scale factor on X axis
	/// @param y defines the scale factor on Y axis
	/// @param z defines the scale factor on Z axis
	/// @returns the new matrix
	external static Matrix Scaling(num x, num y, num z);
	
	/// Creates a scaling matrix and stores it in a given matrix
	/// @param x defines the scale factor on X axis
	/// @param y defines the scale factor on Y axis
	/// @param z defines the scale factor on Z axis
	/// @param result defines the target matrix
	external static void ScalingToRef(num x, num y, num z, Matrix result);
	
	/// Creates a translation matrix
	/// @param x defines the translation on X axis
	/// @param y defines the translation on Y axis
	/// @param z defines the translationon Z axis
	/// @returns the new matrix
	external static Matrix Translation(num x, num y, num z);
	
	/// Creates a translation matrix and stores it in a given matrix
	/// @param x defines the translation on X axis
	/// @param y defines the translation on Y axis
	/// @param z defines the translationon Z axis
	/// @param result defines the target matrix
	external static void TranslationToRef(num x, num y, num z, Matrix result);
	
	/// Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
	/// @param startValue defines the start value
	/// @param endValue defines the end value
	/// @param gradient defines the gradient factor
	/// @returns the new matrix
	external static Matrix Lerp(Matrix startValue, Matrix endValue, num gradient);
	
	/// Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
	/// @param startValue defines the start value
	/// @param endValue defines the end value
	/// @param gradient defines the gradient factor
	/// @param result defines the Matrix object where to store data
	external static void LerpToRef(Matrix startValue, Matrix endValue, num gradient, Matrix result);
	
	/// Builds a new matrix whose values are computed by:
	/// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
	/// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
	/// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
	/// @param startValue defines the first matrix
	/// @param endValue defines the second matrix
	/// @param gradient defines the gradient between the two matrices
	/// @returns the new matrix
	external static Matrix DecomposeLerp(Matrix startValue, Matrix endValue, num gradient);
	
	/// Update a matrix to values which are computed by:
	/// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
	/// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
	/// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
	/// @param startValue defines the first matrix
	/// @param endValue defines the second matrix
	/// @param gradient defines the gradient between the two matrices
	/// @param result defines the target matrix
	external static void DecomposeLerpToRef(Matrix startValue, Matrix endValue, num gradient, Matrix result);
	
	/// Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
	/// This function works in left handed mode
	/// @param eye defines the final position of the entity
	/// @param target defines where the entity should look at
	/// @param up defines the up vector for the entity
	/// @returns the new matrix
	external static Matrix LookAtLH(Vector3 eye, Vector3 target, Vector3 up);
	
	/// Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
	/// This function works in left handed mode
	/// @param eye defines the final position of the entity
	/// @param target defines where the entity should look at
	/// @param up defines the up vector for the entity
	/// @param result defines the target matrix
	external static void LookAtLHToRef(Vector3 eye, Vector3 target, Vector3 up, Matrix result);
	
	/// Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
	/// This function works in right handed mode
	/// @param eye defines the final position of the entity
	/// @param target defines where the entity should look at
	/// @param up defines the up vector for the entity
	/// @returns the new matrix
	external static Matrix LookAtRH(Vector3 eye, Vector3 target, Vector3 up);
	
	/// Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
	/// This function works in right handed mode
	/// @param eye defines the final position of the entity
	/// @param target defines where the entity should look at
	/// @param up defines the up vector for the entity
	/// @param result defines the target matrix
	external static void LookAtRHToRef(Vector3 eye, Vector3 target, Vector3 up, Matrix result);
	
	/// Create a left-handed orthographic projection matrix
	/// @param width defines the viewport width
	/// @param height defines the viewport height
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @returns a new matrix as a left-handed orthographic projection matrix
	external static Matrix OrthoLH(num width, num height, num znear, num zfar);
	
	/// Store a left-handed orthographic projection to a given matrix
	/// @param width defines the viewport width
	/// @param height defines the viewport height
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @param result defines the target matrix
	external static void OrthoLHToRef(num width, num height, num znear, num zfar, Matrix result);
	
	/// Create a left-handed orthographic projection matrix
	/// @param left defines the viewport left coordinate
	/// @param right defines the viewport right coordinate
	/// @param bottom defines the viewport bottom coordinate
	/// @param top defines the viewport top coordinate
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @returns a new matrix as a left-handed orthographic projection matrix
	external static Matrix OrthoOffCenterLH(num left, num right, num bottom, num top, num znear, num zfar);
	
	/// Stores a left-handed orthographic projection into a given matrix
	/// @param left defines the viewport left coordinate
	/// @param right defines the viewport right coordinate
	/// @param bottom defines the viewport bottom coordinate
	/// @param top defines the viewport top coordinate
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @param result defines the target matrix
	external static void OrthoOffCenterLHToRef(num left, num right, num bottom, num top, num znear, num zfar, Matrix result);
	
	/// Creates a right-handed orthographic projection matrix
	/// @param left defines the viewport left coordinate
	/// @param right defines the viewport right coordinate
	/// @param bottom defines the viewport bottom coordinate
	/// @param top defines the viewport top coordinate
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @returns a new matrix as a right-handed orthographic projection matrix
	external static Matrix OrthoOffCenterRH(num left, num right, num bottom, num top, num znear, num zfar);
	
	/// Stores a right-handed orthographic projection into a given matrix
	/// @param left defines the viewport left coordinate
	/// @param right defines the viewport right coordinate
	/// @param bottom defines the viewport bottom coordinate
	/// @param top defines the viewport top coordinate
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @param result defines the target matrix
	external static void OrthoOffCenterRHToRef(num left, num right, num bottom, num top, num znear, num zfar, Matrix result);
	
	/// Creates a left-handed perspective projection matrix
	/// @param width defines the viewport width
	/// @param height defines the viewport height
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @returns a new matrix as a left-handed perspective projection matrix
	external static Matrix PerspectiveLH(num width, num height, num znear, num zfar);
	
	/// Creates a left-handed perspective projection matrix
	/// @param fov defines the horizontal field of view
	/// @param aspect defines the aspect ratio
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @returns a new matrix as a left-handed perspective projection matrix
	external static Matrix PerspectiveFovLH(num fov, num aspect, num znear, num zfar);
	
	/// Stores a left-handed perspective projection into a given matrix
	/// @param fov defines the horizontal field of view
	/// @param aspect defines the aspect ratio
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @param result defines the target matrix
	/// @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
	external static void PerspectiveFovLHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool? isVerticalFovFixed]);
	
	/// Stores a left-handed perspective projection into a given matrix with depth reversed
	/// @param fov defines the horizontal field of view
	/// @param aspect defines the aspect ratio
	/// @param znear defines the near clip plane
	/// @param zfar not used as infinity is used as far clip
	/// @param result defines the target matrix
	/// @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
	external static void PerspectiveFovReverseLHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool? isVerticalFovFixed]);
	
	/// Creates a right-handed perspective projection matrix
	/// @param fov defines the horizontal field of view
	/// @param aspect defines the aspect ratio
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @returns a new matrix as a right-handed perspective projection matrix
	external static Matrix PerspectiveFovRH(num fov, num aspect, num znear, num zfar);
	
	/// Stores a right-handed perspective projection into a given matrix
	/// @param fov defines the horizontal field of view
	/// @param aspect defines the aspect ratio
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @param result defines the target matrix
	/// @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
	external static void PerspectiveFovRHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool? isVerticalFovFixed]);
	
	/// Stores a right-handed perspective projection into a given matrix
	/// @param fov defines the horizontal field of view
	/// @param aspect defines the aspect ratio
	/// @param znear defines the near clip plane
	/// @param zfar not used as infinity is used as far clip
	/// @param result defines the target matrix
	/// @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
	external static void PerspectiveFovReverseRHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool? isVerticalFovFixed]);
	
	/// Stores a perspective projection for WebVR info a given matrix
	/// @param fov defines the field of view
	/// @param znear defines the near clip plane
	/// @param zfar defines the far clip plane
	/// @param result defines the target matrix
	/// @param rightHanded defines if the matrix must be in right-handed mode (false by default)
	external static void PerspectiveFovWebVRToRef(MatrixPerspectiveFovWebVRToRefFov fov, num znear, num zfar, Matrix result, [bool? rightHanded]);
	
	/// Computes a complete transformation matrix
	/// @param viewport defines the viewport to use
	/// @param world defines the world matrix
	/// @param view defines the view matrix
	/// @param projection defines the projection matrix
	/// @param zmin defines the near clip plane
	/// @param zmax defines the far clip plane
	/// @returns the transformation matrix
	external static Matrix GetFinalMatrix(Viewport viewport, Matrix world, Matrix view, Matrix projection, num zmin, num zmax);
	
	/// Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array
	/// @param matrix defines the matrix to use
	/// @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix
	external static dynamic GetAsMatrix2x2(Matrix matrix);
	
	/// Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array
	/// @param matrix defines the matrix to use
	/// @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix
	external static dynamic GetAsMatrix3x3(Matrix matrix);
	
	/// Compute the transpose of a given matrix
	/// @param matrix defines the matrix to transpose
	/// @returns the new matrix
	external static Matrix Transpose(Matrix matrix);
	
	/// Compute the transpose of a matrix and store it in a target matrix
	/// @param matrix defines the matrix to transpose
	/// @param result defines the target matrix
	external static void TransposeToRef(Matrix matrix, Matrix result);
	
	/// Computes a reflection matrix from a plane
	/// @param plane defines the reflection plane
	/// @returns a new matrix
	external static Matrix Reflection(Plane plane);
	
	/// Computes a reflection matrix from a plane
	/// @param plane defines the reflection plane
	/// @param result defines the target matrix
	external static void ReflectionToRef(Plane plane, Matrix result);
	
	/// Sets the given matrix as a rotation matrix composed from the 3 left handed axes
	/// @param xaxis defines the value of the 1st axis
	/// @param yaxis defines the value of the 2nd axis
	/// @param zaxis defines the value of the 3rd axis
	/// @param result defines the target matrix
	external static void FromXYZAxesToRef(Vector3 xaxis, Vector3 yaxis, Vector3 zaxis, Matrix result);
	
	/// Creates a rotation matrix from a quaternion and stores it in a target matrix
	/// @param quat defines the quaternion to use
	/// @param result defines the target matrix
	external static void FromQuaternionToRef(Quaternion quat, Matrix result);
}

/// @hidden
@JS()
class TmpVectors {
	external factory TmpVectors();
	
	@JS("Vector2")
	external static List<Vector2> get Vector2_js;
	@JS("Vector2")
	external static set Vector2_js(List<Vector2> value);
	
	@JS("Vector3")
	external static List<Vector3> get Vector3_js;
	@JS("Vector3")
	external static set Vector3_js(List<Vector3> value);
	
	@JS("Vector4")
	external static List<Vector4> get Vector4_js;
	@JS("Vector4")
	external static set Vector4_js(List<Vector4> value);
	
	@JS("Quaternion")
	external static List<Quaternion> get Quaternion_js;
	@JS("Quaternion")
	external static set Quaternion_js(List<Quaternion> value);
	
	@JS("Matrix")
	external static List<Matrix> get Matrix_js;
	@JS("Matrix")
	external static set Matrix_js(List<Matrix> value);
}

/* enum */
abstract class Orientation {
	
	/// Clockwise
	static const int CW = 1;
	
	/// Counter clockwise
	static const int CCW = 2;
}

/// Class used to represent a Bezier curve
@JS()
class BezierCurve {
	external factory BezierCurve();
	
	/// Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats
	/// @param t defines the time
	/// @param x1 defines the left coordinate on X axis
	/// @param y1 defines the left coordinate on Y axis
	/// @param x2 defines the right coordinate on X axis
	/// @param y2 defines the right coordinate on Y axis
	/// @returns the interpolated value
	external static num Interpolate(num t, num x1, num y1, num x2, num y2);
}

/// Defines angle representation
@JS()
class Angle {
	
	/// Creates an Angle object of "radians" radians (float).
	/// @param radians the angle in radians
	external factory Angle(num radians);
	
	/// Get value in degrees
	/// @returns the Angle value in degrees (float)
	external num degrees();
	
	/// Get value in radians
	/// @returns the Angle value in radians (float)
	external num radians();
	
	/// Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points
	/// @param a defines first point as the origin
	/// @param b defines point
	/// @returns a new Angle
	external static Angle BetweenTwoPoints(Vector2 a, Vector2 b);
	
	/// Gets a new Angle object from the given float in radians
	/// @param radians defines the angle value in radians
	/// @returns a new Angle
	external static Angle FromRadians(num radians);
	
	/// Gets a new Angle object from the given float in degrees
	/// @param degrees defines the angle value in degrees
	/// @returns a new Angle
	external static Angle FromDegrees(num degrees);
}

/// This represents an arc in a 2d space.
@JS()
class Arc2 {
	
	/// Creates an Arc object from the three given points : start, middle and end.
	/// @param startPoint Defines the start point of the arc
	/// @param midPoint Defines the midlle point of the arc
	/// @param endPoint Defines the end point of the arc
	external factory Arc2(Vector2 startPoint, Vector2 midPoint, Vector2 endPoint);
	
	/// Defines the start point of the arc
	external Vector2 get startPoint;
	external set startPoint(Vector2 value);
	
	/// Defines the mid point of the arc
	external Vector2 get midPoint;
	external set midPoint(Vector2 value);
	
	/// Defines the end point of the arc
	external Vector2 get endPoint;
	external set endPoint(Vector2 value);
	
	/// Defines the center point of the arc.
	external Vector2 get centerPoint;
	external set centerPoint(Vector2 value);
	
	/// Defines the radius of the arc.
	external num get radius;
	external set radius(num value);
	
	/// Defines the angle of the arc (from mid point to end point).
	external Angle get angle;
	external set angle(Angle value);
	
	/// Defines the start angle of the arc (from start point to middle point).
	external Angle get startAngle;
	external set startAngle(Angle value);
	
	/// Defines the orientation of the arc (clock wise/counter clock wise).
	external int get orientation;
	external set orientation(int value);
}

/// Represents a 2D path made up of multiple 2D points
@JS()
class Path2 {
	
	/// Creates a Path2 object from the starting 2D coordinates x and y.
	/// @param x the starting points x value
	/// @param y the starting points y value
	external factory Path2(num x, num y);
	
	/// If the path start and end point are the same
	external bool get closed;
	external set closed(bool value);
	
	/// Adds a new segment until the given coordinates (x, y) to the current Path2.
	/// @param x the added points x value
	/// @param y the added points y value
	/// @returns the updated Path2.
	external Path2 addLineTo(num x, num y);
	
	/// Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.
	/// @param midX middle point x value
	/// @param midY middle point y value
	/// @param endX end point x value
	/// @param endY end point y value
	/// @param numberOfSegments (default: 36)
	/// @returns the updated Path2.
	external Path2 addArcTo(num midX, num midY, num endX, num endY, [num? numberOfSegments]);
	
	/// Closes the Path2.
	/// @returns the Path2.
	external Path2 close();
	
	/// Gets the sum of the distance between each sequential point in the path
	/// @returns the Path2 total length (float).
	external num length();
	
	/// Gets the points which construct the path
	/// @returns the Path2 internal array of points.
	external List<Vector2> getPoints();
	
	/// Retreives the point at the distance aways from the starting point
	/// @param normalizedLengthPosition the length along the path to retreive the point from
	/// @returns a new Vector2 located at a percentage of the Path2 total length on this path.
	external Vector2 getPointAtLengthPosition(num normalizedLengthPosition);
	
	/// Creates a new path starting from an x and y position
	/// @param x starting x value
	/// @param y starting y value
	/// @returns a new Path2 starting at the coordinates (x, y).
	external static Path2 StartingAt(num x, num y);
}

/// Represents a 3D path made up of multiple 3D points
@JS()
class Path3D {
	
	/// new Path3D(path, normal, raw)
	/// Creates a Path3D. A Path3D is a logical math object, so not a mesh.
	/// please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d
	/// @param path an array of Vector3, the curve axis of the Path3D
	/// @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.
	/// @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.
	/// @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.
	external factory Path3D(List<Vector3> path, [Vector3? firstNormal, bool? raw, bool? alignTangentsWithPath]);
	
	/// an array of Vector3, the curve axis of the Path3D
	external List<Vector3> get path;
	external set path(List<Vector3> value);
	
	/// Returns the Path3D array of successive Vector3 designing its curve.
	/// @returns the Path3D array of successive Vector3 designing its curve.
	external List<Vector3> getCurve();
	
	/// Returns the Path3D array of successive Vector3 designing its curve.
	/// @returns the Path3D array of successive Vector3 designing its curve.
	external List<Vector3> getPoints();
	
	/// @returns the computed length (float) of the path.
	external num length();
	
	/// Returns an array populated with tangent vectors on each Path3D curve point.
	/// @returns an array populated with tangent vectors on each Path3D curve point.
	external List<Vector3> getTangents();
	
	/// Returns an array populated with normal vectors on each Path3D curve point.
	/// @returns an array populated with normal vectors on each Path3D curve point.
	external List<Vector3> getNormals();
	
	/// Returns an array populated with binormal vectors on each Path3D curve point.
	/// @returns an array populated with binormal vectors on each Path3D curve point.
	external List<Vector3> getBinormals();
	
	/// Returns an array populated with distances (float) of the i-th point from the first curve point.
	/// @returns an array populated with distances (float) of the i-th point from the first curve point.
	external List<num> getDistances();
	
	/// Returns an interpolated point along this path
	/// @param position the position of the point along this path, from 0.0 to 1.0
	/// @returns a new Vector3 as the point
	external Vector3 getPointAt(num position);
	
	/// Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.
	/// @param position the position of the point along this path, from 0.0 to 1.0
	/// @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.
	/// @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.
	external Vector3 getTangentAt(num position, [bool? interpolated]);
	
	/// Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.
	/// @param position the position of the point along this path, from 0.0 to 1.0
	/// @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.
	/// @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.
	external Vector3 getNormalAt(num position, [bool? interpolated]);
	
	/// Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.
	/// @param position the position of the point along this path, from 0.0 to 1.0
	/// @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.
	/// @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.
	external Vector3 getBinormalAt(num position, [bool? interpolated]);
	
	/// Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.
	/// @param position the position of the point along this path, from 0.0 to 1.0
	/// @returns the distance of the interpolated Path3D curve point at the specified position along this path.
	external num getDistanceAt(num position);
	
	/// Returns the array index of the previous point of an interpolated point along this path
	/// @param position the position of the point to interpolate along this path, from 0.0 to 1.0
	/// @returns the array index
	external num getPreviousPointIndexAt(num position);
	
	/// Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)
	/// @param position the position of the point to interpolate along this path, from 0.0 to 1.0
	/// @returns the sub position
	external num getSubPositionAt(num position);
	
	/// Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0
	/// @param target the vector of which to get the closest position to
	/// @returns the position of the closest virtual point on this path to the target vector
	external num getClosestPositionTo(Vector3 target);
	
	/// Returns a sub path (slice) of this path
	/// @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values
	/// @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values
	/// @returns a sub path (slice) of this path
	external Path3D slice([num? start, num? end]);
	
	/// Forces the Path3D tangent, normal, binormal and distance recomputation.
	/// @param path path which all values are copied into the curves points
	/// @param firstNormal which should be projected onto the curve
	/// @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path
	/// @returns the same object updated.
	external Path3D update(List<Vector3> path, [Vector3? firstNormal, bool? alignTangentsWithPath]);
}

/// A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
/// A Curve3 is designed from a series of successive Vector3.
/// @see https://doc.babylonjs.com/how_to/how_to_use_curve3
@JS()
class Curve3 {
	
	/// A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
	/// A Curve3 is designed from a series of successive Vector3.
	/// Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object
	/// @param points points which make up the curve
	external factory Curve3(List<Vector3> points);
	
	/// Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve
	/// @param v0 (Vector3) the origin point of the Quadratic Bezier
	/// @param v1 (Vector3) the control point
	/// @param v2 (Vector3) the end point of the Quadratic Bezier
	/// @param nbPoints (integer) the wanted number of points in the curve
	/// @returns the created Curve3
	external static Curve3 CreateQuadraticBezier(Vector3 v0, Vector3 v1, Vector3 v2, num nbPoints);
	
	/// Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve
	/// @param v0 (Vector3) the origin point of the Cubic Bezier
	/// @param v1 (Vector3) the first control point
	/// @param v2 (Vector3) the second control point
	/// @param v3 (Vector3) the end point of the Cubic Bezier
	/// @param nbPoints (integer) the wanted number of points in the curve
	/// @returns the created Curve3
	external static Curve3 CreateCubicBezier(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, num nbPoints);
	
	/// Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline
	/// @param p1 (Vector3) the origin point of the Hermite Spline
	/// @param t1 (Vector3) the tangent vector at the origin point
	/// @param p2 (Vector3) the end point of the Hermite Spline
	/// @param t2 (Vector3) the tangent vector at the end point
	/// @param nbPoints (integer) the wanted number of points in the curve
	/// @returns the created Curve3
	external static Curve3 CreateHermiteSpline(Vector3 p1, Vector3 t1, Vector3 p2, Vector3 t2, num nbPoints);
	
	/// Returns a Curve3 object along a CatmullRom Spline curve :
	/// @param points (array of Vector3) the points the spline must pass through. At least, four points required
	/// @param nbPoints (integer) the wanted number of points between each curve control points
	/// @param closed (boolean) optional with default false, when true forms a closed loop from the points
	/// @returns the created Curve3
	external static Curve3 CreateCatmullRomSpline(List<Vector3> points, num nbPoints, [bool? closed]);
	
	/// @returns the Curve3 stored array of successive Vector3
	external List<Vector3> getPoints();
	
	/// @returns the computed length (float) of the curve.
	external num length();
	
	/// Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
	/// This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
	/// curveA and curveB keep unchanged.
	/// @param curve the curve to continue from this curve
	/// @returns the newly constructed curve
	@JS("continue")
	external Curve3 continue_js(Curve3 curve);
}

/// This represents the main contract an easing function should follow.
/// Easing functions are used throughout the animation system.
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
abstract class IEasingFunction {
	
	/// Given an input gradient between 0 and 1, this returns the corrseponding value
	/// of the easing function.
	/// The link below provides some of the most common examples of easing functions.
	/// @see https://easings.net/
	/// @param gradient Defines the value between 0 and 1 we want the easing value for
	/// @returns the corresponding value on the curve defined by the easing function
	external num ease(num gradient);
}

/// Base class used for every default easing function.
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class EasingFunction implements IEasingFunction {
	external factory EasingFunction();
	
	/// Interpolation follows the mathematical formula associated with the easing function.
	external static num get EASINGMODE_EASEIN;
	
	/// Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.
	external static num get EASINGMODE_EASEOUT;
	
	/// Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.
	external static num get EASINGMODE_EASEINOUT;
	
	/// Sets the easing mode of the current function.
	/// @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)
	external void setEasingMode(num easingMode);
	
	/// Gets the current easing mode.
	/// @returns the easing mode
	external num getEasingMode();
	
	/// @hidden
	external num easeInCore(num gradient);
	
	/// Given an input gradient between 0 and 1, this returns the corresponding value
	/// of the easing function.
	/// @param gradient Defines the value between 0 and 1 we want the easing value for
	/// @returns the corresponding value on the curve defined by the easing function
	@override
	external num ease(num gradient);
}

/// Easing function with a circle shape (see link below).
/// @see https://easings.net/#easeInCirc
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class CircleEase extends EasingFunction implements IEasingFunction {
	external factory CircleEase();
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a ease back shape (see link below).
/// @see https://easings.net/#easeInBack
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class BackEase extends EasingFunction implements IEasingFunction {
	
	/// Instantiates a back ease easing
	/// @see https://easings.net/#easeInBack
	/// @param amplitude Defines the amplitude of the function
	external factory BackEase([num? amplitude]);
	
	/// Defines the amplitude of the function
	external num get amplitude;
	external set amplitude(num value);
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a bouncing shape (see link below).
/// @see https://easings.net/#easeInBounce
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class BounceEase extends EasingFunction implements IEasingFunction {
	
	/// Instantiates a bounce easing
	/// @see https://easings.net/#easeInBounce
	/// @param bounces Defines the number of bounces
	/// @param bounciness Defines the amplitude of the bounce
	external factory BounceEase([num? bounces, num? bounciness]);
	
	/// Defines the number of bounces
	external num get bounces;
	external set bounces(num value);
	
	/// Defines the amplitude of the bounce
	external num get bounciness;
	external set bounciness(num value);
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a power of 3 shape (see link below).
/// @see https://easings.net/#easeInCubic
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class CubicEase extends EasingFunction implements IEasingFunction {
	external factory CubicEase();
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with an elastic shape (see link below).
/// @see https://easings.net/#easeInElastic
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class ElasticEase extends EasingFunction implements IEasingFunction {
	
	/// Instantiates an elastic easing function
	/// @see https://easings.net/#easeInElastic
	/// @param oscillations Defines the number of oscillations
	/// @param springiness Defines the amplitude of the oscillations
	external factory ElasticEase([num? oscillations, num? springiness]);
	
	/// Defines the number of oscillations
	external num get oscillations;
	external set oscillations(num value);
	
	/// Defines the amplitude of the oscillations
	external num get springiness;
	external set springiness(num value);
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with an exponential shape (see link below).
/// @see https://easings.net/#easeInExpo
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class ExponentialEase extends EasingFunction implements IEasingFunction {
	
	/// Instantiates an exponential easing function
	/// @see https://easings.net/#easeInExpo
	/// @param exponent Defines the exponent of the function
	external factory ExponentialEase([num? exponent]);
	
	/// Defines the exponent of the function
	external num get exponent;
	external set exponent(num value);
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a power shape (see link below).
/// @see https://easings.net/#easeInQuad
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class PowerEase extends EasingFunction implements IEasingFunction {
	
	/// Instantiates an power base easing function
	/// @see https://easings.net/#easeInQuad
	/// @param power Defines the power of the function
	external factory PowerEase([num? power]);
	
	/// Defines the power of the function
	external num get power;
	external set power(num value);
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a power of 2 shape (see link below).
/// @see https://easings.net/#easeInQuad
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class QuadraticEase extends EasingFunction implements IEasingFunction {
	external factory QuadraticEase();
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a power of 4 shape (see link below).
/// @see https://easings.net/#easeInQuart
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class QuarticEase extends EasingFunction implements IEasingFunction {
	external factory QuarticEase();
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a power of 5 shape (see link below).
/// @see https://easings.net/#easeInQuint
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class QuinticEase extends EasingFunction implements IEasingFunction {
	external factory QuinticEase();
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a sin shape (see link below).
/// @see https://easings.net/#easeInSine
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class SineEase extends EasingFunction implements IEasingFunction {
	external factory SineEase();
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Easing function with a bezier shape (see link below).
/// @see http://cubic-bezier.com/#.17,.67,.83,.67
/// @see https://doc.babylonjs.com/babylon101/animations#easing-functions
@JS()
class BezierCurveEase extends EasingFunction implements IEasingFunction {
	
	/// Instantiates a bezier function
	/// @see http://cubic-bezier.com/#.17,.67,.83,.67
	/// @param x1 Defines the x component of the start tangent in the bezier curve
	/// @param y1 Defines the y component of the start tangent in the bezier curve
	/// @param x2 Defines the x component of the end tangent in the bezier curve
	/// @param y2 Defines the y component of the end tangent in the bezier curve
	external factory BezierCurveEase([num? x1, num? y1, num? x2, num? y2]);
	
	/// Defines the x component of the start tangent in the bezier curve
	external num get x1;
	external set x1(num value);
	
	/// Defines the y component of the start tangent in the bezier curve
	external num get y1;
	external set y1(num value);
	
	/// Defines the x component of the end tangent in the bezier curve
	external num get x2;
	external set x2(num value);
	
	/// Defines the y component of the end tangent in the bezier curve
	external num get y2;
	external set y2(num value);
	
	/// @hidden
	@override
	external num easeInCore(num gradient);
}

/// Class used to hold a RBG color
@JS()
class Color3 {
	
	/// Creates a new Color3 object from red, green, blue values, all between 0 and 1
	/// @param r defines the red component (between 0 and 1, default is 0)
	/// @param g defines the green component (between 0 and 1, default is 0)
	/// @param b defines the blue component (between 0 and 1, default is 0)
	external factory Color3([num? r, num? g, num? b]);
	
	/// Defines the red component (between 0 and 1, default is 0)
	external num get r;
	external set r(num value);
	
	/// Defines the green component (between 0 and 1, default is 0)
	external num get g;
	external set g(num value);
	
	/// Defines the blue component (between 0 and 1, default is 0)
	external num get b;
	external set b(num value);
	
	/// Creates a string with the Color3 current values
	/// @returns the string representation of the Color3 object
	external String toString();
	
	/// Returns the string "Color3"
	/// @returns "Color3"
	external String getClassName();
	
	/// Compute the Color3 hash code
	/// @returns an unique number that can be used to hash Color3 objects
	external num getHashCode();
	
	/// Stores in the given array from the given starting index the red, green, blue values as successive elements
	/// @param array defines the array where to store the r,g,b components
	/// @param index defines an optional index in the target array to define where to start storing values
	/// @returns the current Color3 object
	external Color3 toArray(dynamic array, [num? index]);
	
	/// Update the current color with values stored in an array from the starting index of the given array
	/// @param array defines the source array
	/// @param offset defines an offset in the source array
	/// @returns the current Color3 object
	external Color3 fromArray(List<num> array, [num? offset]);
	
	/// Returns a new Color4 object from the current Color3 and the given alpha
	/// @param alpha defines the alpha component on the new Color4 object (default is 1)
	/// @returns a new Color4 object
	external Color4 toColor4([num? alpha]);
	
	/// Returns a new array populated with 3 numeric elements : red, green and blue values
	/// @returns the new array
	external List<num> asArray();
	
	/// Returns the luminance value
	/// @returns a float value
	external num toLuminance();
	
	/// Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object
	/// @param otherColor defines the second operand
	/// @returns the new Color3 object
	external Color3 multiply(Color3 otherColor);
	
	/// Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
	/// @param otherColor defines the second operand
	/// @param result defines the Color3 object where to store the result
	/// @returns the current Color3
	external Color3 multiplyToRef(Color3 otherColor, Color3 result);
	
	/// Determines equality between Color3 objects
	/// @param otherColor defines the second operand
	/// @returns true if the rgb values are equal to the given ones
	external bool equals(Color3 otherColor);
	
	/// Determines equality between the current Color3 object and a set of r,b,g values
	/// @param r defines the red component to check
	/// @param g defines the green component to check
	/// @param b defines the blue component to check
	/// @returns true if the rgb values are equal to the given ones
	external bool equalsFloats(num r, num g, num b);
	
	/// Multiplies in place each rgb value by scale
	/// @param scale defines the scaling factor
	/// @returns the updated Color3
	external Color3 scale(num scale);
	
	/// Multiplies the rgb values by scale and stores the result into "result"
	/// @param scale defines the scaling factor
	/// @param result defines the Color3 object where to store the result
	/// @returns the unmodified current Color3
	external Color3 scaleToRef(num scale, Color3 result);
	
	/// Scale the current Color3 values by a factor and add the result to a given Color3
	/// @param scale defines the scale factor
	/// @param result defines color to store the result into
	/// @returns the unmodified current Color3
	external Color3 scaleAndAddToRef(num scale, Color3 result);
	
	/// Clamps the rgb values by the min and max values and stores the result into "result"
	/// @param min defines minimum clamping value (default is 0)
	/// @param max defines maximum clamping value (default is 1)
	/// @param result defines color to store the result into
	/// @returns the original Color3
	external Color3 clampToRef(num? min, num? max, Color3 result);
	
	/// Creates a new Color3 set with the added values of the current Color3 and of the given one
	/// @param otherColor defines the second operand
	/// @returns the new Color3
	external Color3 add(Color3 otherColor);
	
	/// Stores the result of the addition of the current Color3 and given one rgb values into "result"
	/// @param otherColor defines the second operand
	/// @param result defines Color3 object to store the result into
	/// @returns the unmodified current Color3
	external Color3 addToRef(Color3 otherColor, Color3 result);
	
	/// Returns a new Color3 set with the subtracted values of the given one from the current Color3
	/// @param otherColor defines the second operand
	/// @returns the new Color3
	external Color3 subtract(Color3 otherColor);
	
	/// Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
	/// @param otherColor defines the second operand
	/// @param result defines Color3 object to store the result into
	/// @returns the unmodified current Color3
	external Color3 subtractToRef(Color3 otherColor, Color3 result);
	
	/// Copy the current object
	/// @returns a new Color3 copied the current one
	external Color3 clone();
	
	/// Copies the rgb values from the source in the current Color3
	/// @param source defines the source Color3 object
	/// @returns the updated Color3 object
	external Color3 copyFrom(Color3 source);
	
	/// Updates the Color3 rgb values from the given floats
	/// @param r defines the red component to read from
	/// @param g defines the green component to read from
	/// @param b defines the blue component to read from
	/// @returns the current Color3 object
	external Color3 copyFromFloats(num r, num g, num b);
	
	/// Updates the Color3 rgb values from the given floats
	/// @param r defines the red component to read from
	/// @param g defines the green component to read from
	/// @param b defines the blue component to read from
	/// @returns the current Color3 object
	external Color3 set(num r, num g, num b);
	
	/// Compute the Color3 hexadecimal code as a string
	/// @returns a string containing the hexadecimal representation of the Color3 object
	external String toHexString();
	
	/// Computes a new Color3 converted from the current one to linear space
	/// @returns a new Color3 object
	external Color3 toLinearSpace();
	
	/// Converts current color in rgb space to HSV values
	/// @returns a new color3 representing the HSV values
	external Color3 toHSV();
	
	/// Converts current color in rgb space to HSV values
	/// @param result defines the Color3 where to store the HSV values
	external void toHSVToRef(Color3 result);
	
	/// Converts the Color3 values to linear space and stores the result in "convertedColor"
	/// @param convertedColor defines the Color3 object where to store the linear space version
	/// @returns the unmodified Color3
	external Color3 toLinearSpaceToRef(Color3 convertedColor);
	
	/// Computes a new Color3 converted from the current one to gamma space
	/// @returns a new Color3 object
	external Color3 toGammaSpace();
	
	/// Converts the Color3 values to gamma space and stores the result in "convertedColor"
	/// @param convertedColor defines the Color3 object where to store the gamma space version
	/// @returns the unmodified Color3
	external Color3 toGammaSpaceToRef(Color3 convertedColor);
	
	/// Convert Hue, saturation and value to a Color3 (RGB)
	/// @param hue defines the hue
	/// @param saturation defines the saturation
	/// @param value defines the value
	/// @param result defines the Color3 where to store the RGB values
	external static void HSVtoRGBToRef(num hue, num saturation, num value, Color3 result);
	
	/// Creates a new Color3 from the string containing valid hexadecimal values
	/// @param hex defines a string containing valid hexadecimal values
	/// @returns a new Color3 object
	external static Color3 FromHexString(String hex);
	
	/// Creates a new Color3 from the starting index of the given array
	/// @param array defines the source array
	/// @param offset defines an offset in the source array
	/// @returns a new Color3 object
	external static Color3 FromArray(List<num> array, [num? offset]);
	
	/// Creates a new Color3 from the starting index element of the given array
	/// @param array defines the source array to read from
	/// @param offset defines the offset in the source array
	/// @param result defines the target Color3 object
	external static void FromArrayToRef(List<num> array, num? offset, Color3 result);
	
	/// Creates a new Color3 from integer values (< 256)
	/// @param r defines the red component to read from (value between 0 and 255)
	/// @param g defines the green component to read from (value between 0 and 255)
	/// @param b defines the blue component to read from (value between 0 and 255)
	/// @returns a new Color3 object
	external static Color3 FromInts(num r, num g, num b);
	
	/// Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
	/// @param start defines the start Color3 value
	/// @param end defines the end Color3 value
	/// @param amount defines the gradient value between start and end
	/// @returns a new Color3 object
	external static Color3 Lerp(Color3 start, Color3 end, num amount);
	
	/// Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
	/// @param left defines the start value
	/// @param right defines the end value
	/// @param amount defines the gradient factor
	/// @param result defines the Color3 object where to store the result
	external static void LerpToRef(Color3 left, Color3 right, num amount, Color3 result);
	
	/// Returns a Color3 value containing a red color
	/// @returns a new Color3 object
	external static Color3 Red();
	
	/// Returns a Color3 value containing a green color
	/// @returns a new Color3 object
	external static Color3 Green();
	
	/// Returns a Color3 value containing a blue color
	/// @returns a new Color3 object
	external static Color3 Blue();
	
	/// Returns a Color3 value containing a black color
	/// @returns a new Color3 object
	external static Color3 Black();
	
	/// Gets a Color3 value containing a black color that must not be updated
	external static Color3 get BlackReadOnly;
	
	/// Returns a Color3 value containing a white color
	/// @returns a new Color3 object
	external static Color3 White();
	
	/// Returns a Color3 value containing a purple color
	/// @returns a new Color3 object
	external static Color3 Purple();
	
	/// Returns a Color3 value containing a magenta color
	/// @returns a new Color3 object
	external static Color3 Magenta();
	
	/// Returns a Color3 value containing a yellow color
	/// @returns a new Color3 object
	external static Color3 Yellow();
	
	/// Returns a Color3 value containing a gray color
	/// @returns a new Color3 object
	external static Color3 Gray();
	
	/// Returns a Color3 value containing a teal color
	/// @returns a new Color3 object
	external static Color3 Teal();
	
	/// Returns a Color3 value containing a random color
	/// @returns a new Color3 object
	external static Color3 Random();
}

/// Class used to hold a RBGA color
@JS()
class Color4 {
	
	/// Creates a new Color4 object from red, green, blue values, all between 0 and 1
	/// @param r defines the red component (between 0 and 1, default is 0)
	/// @param g defines the green component (between 0 and 1, default is 0)
	/// @param b defines the blue component (between 0 and 1, default is 0)
	/// @param a defines the alpha component (between 0 and 1, default is 1)
	external factory Color4([num? r, num? g, num? b, num? a]);
	
	/// Defines the red component (between 0 and 1, default is 0)
	external num get r;
	external set r(num value);
	
	/// Defines the green component (between 0 and 1, default is 0)
	external num get g;
	external set g(num value);
	
	/// Defines the blue component (between 0 and 1, default is 0)
	external num get b;
	external set b(num value);
	
	/// Defines the alpha component (between 0 and 1, default is 1)
	external num get a;
	external set a(num value);
	
	/// Adds in place the given Color4 values to the current Color4 object
	/// @param right defines the second operand
	/// @returns the current updated Color4 object
	external Color4 addInPlace(Color4 right);
	
	/// Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
	/// @returns the new array
	external List<num> asArray();
	
	/// Stores from the starting index in the given array the Color4 successive values
	/// @param array defines the array where to store the r,g,b components
	/// @param index defines an optional index in the target array to define where to start storing values
	/// @returns the current Color4 object
	external Color4 toArray(List<num> array, [num? index]);
	
	/// Update the current color with values stored in an array from the starting index of the given array
	/// @param array defines the source array
	/// @param offset defines an offset in the source array
	/// @returns the current Color4 object
	external Color4 fromArray(List<num> array, [num? offset]);
	
	/// Determines equality between Color4 objects
	/// @param otherColor defines the second operand
	/// @returns true if the rgba values are equal to the given ones
	external bool equals(Color4 otherColor);
	
	/// Creates a new Color4 set with the added values of the current Color4 and of the given one
	/// @param right defines the second operand
	/// @returns a new Color4 object
	external Color4 add(Color4 right);
	
	/// Creates a new Color4 set with the subtracted values of the given one from the current Color4
	/// @param right defines the second operand
	/// @returns a new Color4 object
	external Color4 subtract(Color4 right);
	
	/// Subtracts the given ones from the current Color4 values and stores the results in "result"
	/// @param right defines the second operand
	/// @param result defines the Color4 object where to store the result
	/// @returns the current Color4 object
	external Color4 subtractToRef(Color4 right, Color4 result);
	
	/// Creates a new Color4 with the current Color4 values multiplied by scale
	/// @param scale defines the scaling factor to apply
	/// @returns a new Color4 object
	external Color4 scale(num scale);
	
	/// Multiplies the current Color4 values by scale and stores the result in "result"
	/// @param scale defines the scaling factor to apply
	/// @param result defines the Color4 object where to store the result
	/// @returns the current unmodified Color4
	external Color4 scaleToRef(num scale, Color4 result);
	
	/// Scale the current Color4 values by a factor and add the result to a given Color4
	/// @param scale defines the scale factor
	/// @param result defines the Color4 object where to store the result
	/// @returns the unmodified current Color4
	external Color4 scaleAndAddToRef(num scale, Color4 result);
	
	/// Clamps the rgb values by the min and max values and stores the result into "result"
	/// @param min defines minimum clamping value (default is 0)
	/// @param max defines maximum clamping value (default is 1)
	/// @param result defines color to store the result into.
	/// @returns the cuurent Color4
	external Color4 clampToRef(num? min, num? max, Color4 result);
	
	/// Multipy an Color4 value by another and return a new Color4 object
	/// @param color defines the Color4 value to multiply by
	/// @returns a new Color4 object
	external Color4 multiply(Color4 color);
	
	/// Multipy a Color4 value by another and push the result in a reference value
	/// @param color defines the Color4 value to multiply by
	/// @param result defines the Color4 to fill the result in
	/// @returns the result Color4
	external Color4 multiplyToRef(Color4 color, Color4 result);
	
	/// Creates a string with the Color4 current values
	/// @returns the string representation of the Color4 object
	external String toString();
	
	/// Returns the string "Color4"
	/// @returns "Color4"
	external String getClassName();
	
	/// Compute the Color4 hash code
	/// @returns an unique number that can be used to hash Color4 objects
	external num getHashCode();
	
	/// Creates a new Color4 copied from the current one
	/// @returns a new Color4 object
	external Color4 clone();
	
	/// Copies the given Color4 values into the current one
	/// @param source defines the source Color4 object
	/// @returns the current updated Color4 object
	external Color4 copyFrom(Color4 source);
	
	/// Copies the given float values into the current one
	/// @param r defines the red component to read from
	/// @param g defines the green component to read from
	/// @param b defines the blue component to read from
	/// @param a defines the alpha component to read from
	/// @returns the current updated Color4 object
	external Color4 copyFromFloats(num r, num g, num b, num a);
	
	/// Copies the given float values into the current one
	/// @param r defines the red component to read from
	/// @param g defines the green component to read from
	/// @param b defines the blue component to read from
	/// @param a defines the alpha component to read from
	/// @returns the current updated Color4 object
	external Color4 set(num r, num g, num b, num a);
	
	/// Compute the Color4 hexadecimal code as a string
	/// @param returnAsColor3 defines if the string should only contains RGB values (off by default)
	/// @returns a string containing the hexadecimal representation of the Color4 object
	external String toHexString([bool? returnAsColor3]);
	
	/// Computes a new Color4 converted from the current one to linear space
	/// @returns a new Color4 object
	external Color4 toLinearSpace();
	
	/// Converts the Color4 values to linear space and stores the result in "convertedColor"
	/// @param convertedColor defines the Color4 object where to store the linear space version
	/// @returns the unmodified Color4
	external Color4 toLinearSpaceToRef(Color4 convertedColor);
	
	/// Computes a new Color4 converted from the current one to gamma space
	/// @returns a new Color4 object
	external Color4 toGammaSpace();
	
	/// Converts the Color4 values to gamma space and stores the result in "convertedColor"
	/// @param convertedColor defines the Color4 object where to store the gamma space version
	/// @returns the unmodified Color4
	external Color4 toGammaSpaceToRef(Color4 convertedColor);
	
	/// Creates a new Color4 from the string containing valid hexadecimal values
	/// @param hex defines a string containing valid hexadecimal values
	/// @returns a new Color4 object
	external static Color4 FromHexString(String hex);
	
	/// Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
	/// @param left defines the start value
	/// @param right defines the end value
	/// @param amount defines the gradient factor
	/// @returns a new Color4 object
	external static Color4 Lerp(Color4 left, Color4 right, num amount);
	
	/// Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
	/// @param left defines the start value
	/// @param right defines the end value
	/// @param amount defines the gradient factor
	/// @param result defines the Color4 object where to store data
	external static void LerpToRef(Color4 left, Color4 right, num amount, Color4 result);
	
	/// Creates a new Color4 from a Color3 and an alpha value
	/// @param color3 defines the source Color3 to read from
	/// @param alpha defines the alpha component (1.0 by default)
	/// @returns a new Color4 object
	external static Color4 FromColor3(Color3 color3, [num? alpha]);
	
	/// Creates a new Color4 from the starting index element of the given array
	/// @param array defines the source array to read from
	/// @param offset defines the offset in the source array
	/// @returns a new Color4 object
	external static Color4 FromArray(List<num> array, [num? offset]);
	
	/// Creates a new Color4 from the starting index element of the given array
	/// @param array defines the source array to read from
	/// @param offset defines the offset in the source array
	/// @param result defines the target Color4 object
	external static void FromArrayToRef(List<num> array, num? offset, Color4 result);
	
	/// Creates a new Color3 from integer values (< 256)
	/// @param r defines the red component to read from (value between 0 and 255)
	/// @param g defines the green component to read from (value between 0 and 255)
	/// @param b defines the blue component to read from (value between 0 and 255)
	/// @param a defines the alpha component to read from (value between 0 and 255)
	/// @returns a new Color3 object
	external static Color4 FromInts(num r, num g, num b, num a);
	
	/// Check the content of a given array and convert it to an array containing RGBA data
	/// If the original array was already containing count * 4 values then it is returned directly
	/// @param colors defines the array to check
	/// @param count defines the number of RGBA data to expect
	/// @returns an array containing count * 4 values (RGBA)
	external static List<num> CheckColors4(List<num> colors, num count);
}

/// @hidden
@JS()
class TmpColors {
	external factory TmpColors();
	
	@JS("Color3")
	external static List<Color3> get Color3_js;
	@JS("Color3")
	external static set Color3_js(List<Color3> value);
	
	@JS("Color4")
	external static List<Color4> get Color4_js;
	@JS("Color4")
	external static set Color4_js(List<Color4> value);
}

/// Defines an interface which represents an animation key frame
@JS()
@anonymous
class IAnimationKey {
	
	external factory IAnimationKey({num frame, dynamic value, dynamic inTangent, dynamic outTangent, int interpolation});
	
	/// Frame of the key frame
	external num get frame;
	external set frame( num value );
	
	/// Value at the specifies key frame
	external dynamic get value;
	external set value( dynamic value );
	
	/// The input tangent for the cubic hermite spline
	external dynamic get inTangent;
	external set inTangent( dynamic value );
	
	/// The output tangent for the cubic hermite spline
	external dynamic get outTangent;
	external set outTangent( dynamic value );
	
	/// The animation interpolation type
	external int get interpolation;
	external set interpolation( int value );
}

/* enum */
abstract class AnimationKeyInterpolation {
	
	/// Do not interpolate between keys and use the start key value only. Tangents are ignored
	static const int STEP = 2;
}

/// Represents the range of an animation
@JS()
class AnimationRange {
	
	/// Initializes the range of an animation
	/// @param name The name of the animation range
	/// @param from The starting frame of the animation
	/// @param to The ending frame of the animation
	external factory AnimationRange(String name, num from, num to);
	
	/// The name of the animation range*
	external String get name;
	external set name(String value);
	
	/// The starting frame of the animation
	external num get from;
	external set from(num value);
	
	/// The ending frame of the animation
	external num get to;
	external set to(num value);
	
	/// Makes a copy of the animation range
	/// @returns A copy of the animation range
	external AnimationRange clone();
}

/// Composed of a frame, and an action function
@JS()
class AnimationEvent {
	
	/// Initializes the animation event
	/// @param frame The frame for which the event is triggered
	/// @param action The event to perform when triggered
	/// @param onlyOnce Specifies if the event should be triggered only once
	external factory AnimationEvent(num frame, void Function(num currentFrame) action, [bool? onlyOnce]);
	
	/// The frame for which the event is triggered *
	external num get frame;
	external set frame(num value);
	
	/// The event to perform when triggered *
	external void Function(num currentFrame) get action;
	external set action(void Function(num currentFrame) value);
	
	/// Specifies if the event should be triggered only once*
	external bool? get onlyOnce;
	external set onlyOnce(bool? value);
	
	/// Specifies if the animation event is done
	external bool get isDone;
	external set isDone(bool value);
}

/// Interface used to define a behavior
@JS()
abstract class Behavior<T> {
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
	
	/// Function called when the behavior needs to be initialized (after attaching it to a target)
	external void init();
	
	/// Called when the behavior is attached to a target
	/// @param target defines the target where the behavior is attached to
	external void attach(T target);
	
	/// Called when the behavior is detached from its target
	external void detach();
}

/// Interface implemented by classes supporting behaviors
@JS()
abstract class IBehaviorAware<T> {
	
	/// Attach a behavior
	/// @param behavior defines the behavior to attach
	/// @returns the current host
	external T addBehavior(Behavior<T> behavior);
	
	/// Remove a behavior from the current object
	/// @param behavior defines the behavior to detach
	/// @returns the current host
	external T removeBehavior(Behavior<T> behavior);
	
	/// Gets a behavior using its name to search
	/// @param name defines the name to search
	/// @returns the behavior or null if not found
	external Behavior<T>? getBehaviorByName(String name);
}

/// Class used to store data that will be store in GPU memory
@JS()
class Buffer {
	
	/// Constructor
	/// @param engine the engine
	/// @param data the data to use for this buffer
	/// @param updatable whether the data is updatable
	/// @param stride the stride (optional)
	/// @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
	/// @param instanced whether the buffer is instanced (optional)
	/// @param useBytes set to true if the stride in in bytes (optional)
	/// @param divisor sets an optional divisor for instances (1 by default)
	external factory Buffer(dynamic engine, dynamic data, bool updatable, [num? stride, bool? postponeInternalCreation, bool? instanced, bool? useBytes, num? divisor]);
	
	/// Gets the byte stride.
	external num get byteStride;
	
	/// Create a new VertexBuffer based on the current buffer
	/// @param kind defines the vertex buffer kind (position, normal, etc.)
	/// @param offset defines offset in the buffer (0 by default)
	/// @param size defines the size in floats of attributes (position is 3 for instance)
	/// @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)
	/// @param instanced defines if the vertex buffer contains indexed data
	/// @param useBytes defines if the offset and stride are in bytes     *
	/// @param divisor sets an optional divisor for instances (1 by default)
	/// @returns the new vertex buffer
	external VertexBuffer createVertexBuffer(String kind, num offset, num size, [num? stride, bool? instanced, bool? useBytes, num? divisor]);
	
	/// Gets a boolean indicating if the Buffer is updatable?
	/// @returns true if the buffer is updatable
	external bool isUpdatable();
	
	/// Gets current buffer's data
	/// @returns a DataArray or null
	external dynamic? getData();
	
	/// Gets underlying native buffer
	/// @returns underlying native buffer
	external DataBuffer? getBuffer();
	
	/// Gets the stride in float32 units (i.e. byte stride / 4).
	/// May not be an integer if the byte stride is not divisible by 4.
	/// @returns the stride in float32 units
	/// @deprecated Please use byteStride instead.
	external num getStrideSize();
	
	/// Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property
	/// @param data defines the data to store
	external void create([dynamic? data]);
	
	/// Update current buffer data
	/// @param data defines the data to store
	external void update(dynamic data);
	
	/// Updates the data directly.
	/// @param data the new data
	/// @param offset the new offset
	/// @param vertexCount the vertex count (optional)
	/// @param useBytes set to true if the offset is in bytes
	external void updateDirectly(dynamic data, num offset, [num? vertexCount, bool? useBytes]);
	
	/// Release all resources
	external void dispose();
}

/// Specialized buffer used to store vertex data
@JS()
class VertexBuffer {
	
	/// Constructor
	/// @param engine the engine
	/// @param data the data to use for this vertex buffer
	/// @param kind the vertex buffer kind
	/// @param updatable whether the data is updatable
	/// @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
	/// @param stride the stride (optional)
	/// @param instanced whether the buffer is instanced (optional)
	/// @param offset the offset of the data (optional)
	/// @param size the number of components (optional)
	/// @param type the type of the component (optional)
	/// @param normalized whether the data contains normalized data (optional)
	/// @param useBytes set to true if stride and offset are in bytes (optional)
	/// @param divisor defines the instance divisor to use (1 by default)
	/// @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed
	external factory VertexBuffer(dynamic engine, dynamic data, String kind, bool updatable, [bool? postponeInternalCreation, num? stride, bool? instanced, num? offset, num? size, num? type, bool? normalized, bool? useBytes, num? divisor, bool? takeBufferOwnership]);
	
	/// The byte type.
	external static num get BYTE;
	
	/// The unsigned byte type.
	external static num get UNSIGNED_BYTE;
	
	/// The short type.
	external static num get SHORT;
	
	/// The unsigned short type.
	external static num get UNSIGNED_SHORT;
	
	/// The integer type.
	external static num get INT;
	
	/// The unsigned integer type.
	external static num get UNSIGNED_INT;
	
	/// The float type.
	external static num get FLOAT;
	
	/// Gets or sets the instance divisor when in instanced mode
	external num get instanceDivisor;
	
	external set instanceDivisor(num value);
	
	/// Gets the byte stride.
	external num get byteStride;
	
	/// Gets the byte offset.
	external num get byteOffset;
	
	/// Gets whether integer data values should be normalized into a certain range when being casted to a float.
	external bool get normalized;
	
	/// Gets the data type of each component in the array.
	external num get type;
	
	/// Returns the kind of the VertexBuffer (string)
	/// @returns a string
	external String getKind();
	
	/// Gets a boolean indicating if the VertexBuffer is updatable?
	/// @returns true if the buffer is updatable
	external bool isUpdatable();
	
	/// Gets current buffer's data
	/// @returns a DataArray or null
	external dynamic? getData();
	
	/// Gets underlying native buffer
	/// @returns underlying native buffer
	external DataBuffer? getBuffer();
	
	/// Gets the stride in float32 units (i.e. byte stride / 4).
	/// May not be an integer if the byte stride is not divisible by 4.
	/// @returns the stride in float32 units
	/// @deprecated Please use byteStride instead.
	external num getStrideSize();
	
	/// Returns the offset as a multiple of the type byte length.
	/// @returns the offset in bytes
	/// @deprecated Please use byteOffset instead.
	external num getOffset();
	
	/// Returns the number of components per vertex attribute (integer)
	/// @returns the size in float
	external num getSize();
	
	/// Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced
	/// @returns true if this buffer is instanced
	external bool getIsInstanced();
	
	/// Returns the instancing divisor, zero for non-instanced (integer).
	/// @returns a number
	external num getInstanceDivisor();
	
	/// Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property
	/// @param data defines the data to store
	external void create([dynamic? data]);
	
	/// Updates the underlying buffer according to the passed numeric array or Float32Array.
	/// This function will create a new buffer if the current one is not updatable
	/// @param data defines the data to store
	external void update(dynamic data);
	
	/// Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
	/// Returns the directly updated WebGLBuffer.
	/// @param data the new data
	/// @param offset the new offset
	/// @param useBytes set to true if the offset is in bytes
	external void updateDirectly(dynamic data, num offset, [bool? useBytes]);
	
	/// Disposes the VertexBuffer and the underlying WebGLBuffer.
	external void dispose();
	
	/// Enumerates each value of this vertex buffer as numbers.
	/// @param count the number of values to enumerate
	/// @param callback the callback function called for each value
	external void forEach(num count, void Function(num value, num index) callback);
	
	/// Positions
	external static String get PositionKind;
	
	/// Normals
	external static String get NormalKind;
	
	/// Tangents
	external static String get TangentKind;
	
	/// Texture coordinates
	external static String get UVKind;
	
	/// Texture coordinates 2
	external static String get UV2Kind;
	
	/// Texture coordinates 3
	external static String get UV3Kind;
	
	/// Texture coordinates 4
	external static String get UV4Kind;
	
	/// Texture coordinates 5
	external static String get UV5Kind;
	
	/// Texture coordinates 6
	external static String get UV6Kind;
	
	/// Colors
	external static String get ColorKind;
	
	/// Matrix indices (for bones)
	external static String get MatricesIndicesKind;
	
	/// Matrix weights (for bones)
	external static String get MatricesWeightsKind;
	
	/// Additional matrix indices (for bones)
	external static String get MatricesIndicesExtraKind;
	
	/// Additional matrix weights (for bones)
	external static String get MatricesWeightsExtraKind;
	
	/// Deduces the stride given a kind.
	/// @param kind The kind string to deduce
	/// @returns The deduced stride
	external static num DeduceStride(String kind);
	
	/// Gets the byte length of the given type.
	/// @param type the type
	/// @returns the number of bytes
	external static num GetTypeByteLength(num type);
	
	/// Enumerates each value of the given parameters as numbers.
	/// @param data the data to enumerate
	/// @param byteOffset the byte offset of the data
	/// @param byteStride the byte stride of the data
	/// @param componentCount the number of components per element
	/// @param componentType the type of the component
	/// @param count the number of values to enumerate
	/// @param normalized whether the data is normalized
	/// @param callback the callback function called for each value
	external static void ForEach(dynamic data, num byteOffset, num byteStride, num componentCount, num componentType, num count, bool normalized, void Function(num value, num index) callback);
}

/// @hidden
@JS()
class IntersectionInfo {
	
	external factory IntersectionInfo(num? bu, num? bv, num distance);
	
	external num? get bu;
	external set bu(num? value);
	
	external num? get bv;
	external set bv(num? value);
	
	external num get distance;
	external set distance(num value);
	
	external num get faceId;
	external set faceId(num value);
	
	external num get subMeshId;
	external set subMeshId(num value);
}

/// Class used to store bounding sphere information
@JS()
class BoundingSphere {
	
	/// Creates a new bounding sphere
	/// @param min defines the minimum vector (in local space)
	/// @param max defines the maximum vector (in local space)
	/// @param worldMatrix defines the new world matrix
	external factory BoundingSphere(Vector3 min, Vector3 max, [Matrix? worldMatrix]);
	
	/// Gets the center of the bounding sphere in local space
	external Vector3 get center;
	
	/// Radius of the bounding sphere in local space
	external num get radius;
	external set radius(num value);
	
	/// Gets the center of the bounding sphere in world space
	external Vector3 get centerWorld;
	
	/// Radius of the bounding sphere in world space
	external num get radiusWorld;
	external set radiusWorld(num value);
	
	/// Gets the minimum vector in local space
	external Vector3 get minimum;
	
	/// Gets the maximum vector in local space
	external Vector3 get maximum;
	
	/// Recreates the entire bounding sphere from scratch as if we call the constructor in place
	/// @param min defines the new minimum vector (in local space)
	/// @param max defines the new maximum vector (in local space)
	/// @param worldMatrix defines the new world matrix
	external void reConstruct(Vector3 min, Vector3 max, [Matrix? worldMatrix]);
	
	/// Scale the current bounding sphere by applying a scale factor
	/// @param factor defines the scale factor to apply
	/// @returns the current bounding box
	external BoundingSphere scale(num factor);
	
	/// Gets the world matrix of the bounding box
	/// @returns a matrix
	external Matrix getWorldMatrix();
	
	/// Tests if the bounding sphere is intersecting the frustum planes
	/// @param frustumPlanes defines the frustum planes to test
	/// @returns true if there is an intersection
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// Tests if the bounding sphere center is in between the frustum planes.
	/// Used for optimistic fast inclusion.
	/// @param frustumPlanes defines the frustum planes to test
	/// @returns true if the sphere center is in between the frustum planes
	external bool isCenterInFrustum(List<Plane> frustumPlanes);
	
	/// Tests if a point is inside the bounding sphere
	/// @param point defines the point to test
	/// @returns true if the point is inside the bounding sphere
	external bool intersectsPoint(Vector3 point);
	
	/// Checks if two sphere intersct
	/// @param sphere0 sphere 0
	/// @param sphere1 sphere 1
	/// @returns true if the speres intersect
	external static bool Intersects(BoundingSphere sphere0, BoundingSphere sphere1);
}

/// Class used to store bounding box information
@JS()
class BoundingBox implements ICullable {
	
	/// Creates a new bounding box
	/// @param min defines the minimum vector (in local space)
	/// @param max defines the maximum vector (in local space)
	/// @param worldMatrix defines the new world matrix
	external factory BoundingBox(Vector3 min, Vector3 max, [Matrix? worldMatrix]);
	
	/// Gets the 8 vectors representing the bounding box in local space
	external List<Vector3> get vectors;
	
	/// Gets the center of the bounding box in local space
	external Vector3 get center;
	
	/// Gets the center of the bounding box in world space
	external Vector3 get centerWorld;
	
	/// Gets the extend size in local space
	external Vector3 get extendSize;
	
	/// Gets the extend size in world space
	external Vector3 get extendSizeWorld;
	
	/// Gets the OBB (object bounding box) directions
	external List<Vector3> get directions;
	
	/// Gets the 8 vectors representing the bounding box in world space
	external List<Vector3> get vectorsWorld;
	
	/// Gets the minimum vector in world space
	external Vector3 get minimumWorld;
	
	/// Gets the maximum vector in world space
	external Vector3 get maximumWorld;
	
	/// Gets the minimum vector in local space
	external Vector3 get minimum;
	
	/// Gets the maximum vector in local space
	external Vector3 get maximum;
	
	/// Recreates the entire bounding box from scratch as if we call the constructor in place
	/// @param min defines the new minimum vector (in local space)
	/// @param max defines the new maximum vector (in local space)
	/// @param worldMatrix defines the new world matrix
	external void reConstruct(Vector3 min, Vector3 max, [Matrix? worldMatrix]);
	
	/// Scale the current bounding box by applying a scale factor
	/// @param factor defines the scale factor to apply
	/// @returns the current bounding box
	external BoundingBox scale(num factor);
	
	/// Gets the world matrix of the bounding box
	/// @returns a matrix
	external Matrix getWorldMatrix();
	
	/// Tests if the bounding box is intersecting the frustum planes
	/// @param frustumPlanes defines the frustum planes to test
	/// @returns true if there is an intersection
	@override
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// Tests if the bounding box is entirely inside the frustum planes
	/// @param frustumPlanes defines the frustum planes to test
	/// @returns true if there is an inclusion
	@override
	external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
	
	/// Tests if a point is inside the bounding box
	/// @param point defines the point to test
	/// @returns true if the point is inside the bounding box
	external bool intersectsPoint(Vector3 point);
	
	/// Tests if the bounding box intersects with a bounding sphere
	/// @param sphere defines the sphere to test
	/// @returns true if there is an intersection
	external bool intersectsSphere(BoundingSphere sphere);
	
	/// Tests if the bounding box intersects with a box defined by a min and max vectors
	/// @param min defines the min vector to use
	/// @param max defines the max vector to use
	/// @returns true if there is an intersection
	external bool intersectsMinMax(Vector3 min, Vector3 max);
	
	/// Tests if two bounding boxes are intersections
	/// @param box0 defines the first box to test
	/// @param box1 defines the second box to test
	/// @returns true if there is an intersection
	external static bool Intersects(BoundingBox box0, BoundingBox box1);
	
	/// Tests if a bounding box defines by a min/max vectors intersects a sphere
	/// @param minPoint defines the minimum vector of the bounding box
	/// @param maxPoint defines the maximum vector of the bounding box
	/// @param sphereCenter defines the sphere center
	/// @param sphereRadius defines the sphere radius
	/// @returns true if there is an intersection
	external static bool IntersectsSphere(Vector3 minPoint, Vector3 maxPoint, Vector3 sphereCenter, num sphereRadius);
	
	/// Tests if a bounding box defined with 8 vectors is entirely inside frustum planes
	/// @param boundingVectors defines an array of 8 vectors representing a bounding box
	/// @param frustumPlanes defines the frustum planes to test
	/// @return true if there is an inclusion
	external static bool IsCompletelyInFrustum(List<Vector3> boundingVectors, List<Plane> frustumPlanes);
	
	/// Tests if a bounding box defined with 8 vectors intersects frustum planes
	/// @param boundingVectors defines an array of 8 vectors representing a bounding box
	/// @param frustumPlanes defines the frustum planes to test
	/// @return true if there is an intersection
	external static bool IsInFrustum(List<Vector3> boundingVectors, List<Plane> frustumPlanes);
}

/// @hidden
@JS()
class Collider {
	external factory Collider();
	
	/// Define if a collision was found
	external bool get collisionFound;
	external set collisionFound(bool value);
	
	/// Define last intersection point in local space
	external Vector3 get intersectionPoint;
	external set intersectionPoint(Vector3 value);
	
	/// Define last collided mesh
	external AbstractMesh? get collidedMesh;
	external set collidedMesh(AbstractMesh? value);
	
	external num get collisionMask;
	
	external set collisionMask(num value);
	
	/// Gets the plane normal used to compute the sliding response (in local space)
	external Vector3 get slidePlaneNormal;
}

/// Interface for cullable objects
/// @see https://doc.babylonjs.com/babylon101/materials#back-face-culling
@JS()
abstract class ICullable {
	
	/// Checks if the object or part of the object is in the frustum
	/// @param frustumPlanes Camera near/planes
	/// @returns true if the object is in frustum otherwise false
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// Checks if a cullable object (mesh...) is in the camera frustum
	/// Unlike isInFrustum this cheks the full bounding box
	/// @param frustumPlanes Camera near/planes
	/// @returns true if the object is in frustum otherwise false
	external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
}

/// Info for a bounding data of a mesh
@JS()
class BoundingInfo implements ICullable {
	
	/// Constructs bounding info
	/// @param minimum min vector of the bounding box/sphere
	/// @param maximum max vector of the bounding box/sphere
	/// @param worldMatrix defines the new world matrix
	external factory BoundingInfo(Vector3 minimum, Vector3 maximum, [Matrix? worldMatrix]);
	
	/// Bounding box for the mesh
	external BoundingBox get boundingBox;
	
	/// Bounding sphere for the mesh
	external BoundingSphere get boundingSphere;
	
	/// Recreates the entire bounding info from scratch as if we call the constructor in place
	/// @param min defines the new minimum vector (in local space)
	/// @param max defines the new maximum vector (in local space)
	/// @param worldMatrix defines the new world matrix
	external void reConstruct(Vector3 min, Vector3 max, [Matrix? worldMatrix]);
	
	/// min vector of the bounding box/sphere
	external Vector3 get minimum;
	
	/// max vector of the bounding box/sphere
	external Vector3 get maximum;
	
	/// If the info is locked and won't be updated to avoid perf overhead
	external bool get isLocked;
	
	external set isLocked(bool value);
	
	/// Updates the bounding sphere and box
	/// @param world world matrix to be used to update
	external void update(Matrix world);
	
	/// Recreate the bounding info to be centered around a specific point given a specific extend.
	/// @param center New center of the bounding info
	/// @param extend New extend of the bounding info
	/// @returns the current bounding info
	external BoundingInfo centerOn(Vector3 center, Vector3 extend);
	
	/// Scale the current bounding info by applying a scale factor
	/// @param factor defines the scale factor to apply
	/// @returns the current bounding info
	external BoundingInfo scale(num factor);
	
	/// Returns `true` if the bounding info is within the frustum defined by the passed array of planes.
	/// @param frustumPlanes defines the frustum to test
	/// @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)
	/// @returns true if the bounding info is in the frustum planes
	@override
	external bool isInFrustum(List<Plane> frustumPlanes, [num? strategy]);
	
	/// Gets the world distance between the min and max points of the bounding box
	external num get diagonalLength;
	
	/// Checks if a cullable object (mesh...) is in the camera frustum
	/// Unlike isInFrustum this cheks the full bounding box
	/// @param frustumPlanes Camera near/planes
	/// @returns true if the object is in frustum otherwise false
	@override
	external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
	
	/// Checks if a point is inside the bounding box and bounding sphere or the mesh
	/// @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
	/// @param point the point to check intersection with
	/// @returns if the point intersects
	external bool intersectsPoint(Vector3 point);
	
	/// Checks if another bounding info intersects the bounding box and bounding sphere or the mesh
	/// @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
	/// @param boundingInfo the bounding info to check intersection with
	/// @param precise if the intersection should be done using OBB
	/// @returns if the bounding info intersects
	external bool intersects(BoundingInfo boundingInfo, bool precise);
}

/* top level function */
/// Extracts minimum and maximum values from a list of indexed positions
/// @param positions defines the positions to use
/// @param indices defines the indices to the positions
/// @param indexStart defines the start index
/// @param indexCount defines the end index
/// @param bias defines bias value to add to the result
/// @return minimum and maximum values
@JS()
external ExtractMinAndMaxIndexed extractMinAndMaxIndexed(dynamic positions, dynamic indices, num indexStart, num indexCount, [Vector2? bias]);

/* top level function */
/// Extracts minimum and maximum values from a list of positions
/// @param positions defines the positions to use
/// @param start defines the start index in the positions array
/// @param count defines the number of positions to handle
/// @param bias defines bias value to add to the result
/// @param stride defines the stride size to use (distance between two positions in the positions array)
/// @return minimum and maximum values
@JS()
external ExtractMinAndMax extractMinAndMax(dynamic positions, num start, num count, [Vector2? bias, num? stride]);

/// Class used to manipulate GUIDs
@JS()
class GUID {
	external factory GUID();
	
	/// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
	/// Be aware Math.random() could cause collisions, but:
	/// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
	/// @returns a pseudo random id
	external static String RandomId();
}

/// Base class of all the textures in babylon.
/// It groups all the common properties the materials, post process, lights... might need
/// in order to make a correct use of the texture.
@JS()
class BaseTexture extends ThinTexture implements IAnimatable {
	
	/// Instantiates a new BaseTexture.
	/// Base class of all the textures in babylon.
	/// It groups all the common properties the materials, post process, lights... might need
	/// in order to make a correct use of the texture.
	/// @param sceneOrEngine Define the scene or engine the texture blongs to
	external factory BaseTexture(dynamic? sceneOrEngine);
	
	/// Default anisotropic filtering level for the application.
	/// It is set to 4 as a good tradeoff between perf and quality.
	external static num get DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
	external static set DEFAULT_ANISOTROPIC_FILTERING_LEVEL(num value);
	
	/// Gets or sets the unique id of the texture
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Define the name of the texture.
	external String get name;
	external set name(String value);
	
	/// Gets or sets an object used to store user defined information.
	external dynamic get metadata;
	external set metadata(dynamic value);
	
	/// For internal use only. Please do not use.
	external dynamic get reservedDataStore;
	external set reservedDataStore(dynamic value);
	
	/// Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).
	external set hasAlpha(bool value);
	
	external bool get hasAlpha;
	
	/// Defines if the alpha value should be determined via the rgb values.
	/// If true the luminance of the pixel might be used to find the corresponding alpha value.
	external bool get getAlphaFromRGB;
	external set getAlphaFromRGB(bool value);
	
	/// Intensity or strength of the texture.
	/// It is commonly used by materials to fine tune the intensity of the texture
	external num get level;
	external set level(num value);
	
	/// Define the UV chanel to use starting from 0 and defaulting to 0.
	/// This is part of the texture as textures usually maps to one uv set.
	external num get coordinatesIndex;
	external set coordinatesIndex(num value);
	
	/// How a texture is mapped.
	/// 
	/// | Value | Type                                | Description |
	/// | ----- | ----------------------------------- | ----------- |
	/// | 0     | EXPLICIT_MODE                       |             |
	/// | 1     | SPHERICAL_MODE                      |             |
	/// | 2     | PLANAR_MODE                         |             |
	/// | 3     | CUBIC_MODE                          |             |
	/// | 4     | PROJECTION_MODE                     |             |
	/// | 5     | SKYBOX_MODE                         |             |
	/// | 6     | INVCUBIC_MODE                       |             |
	/// | 7     | EQUIRECTANGULAR_MODE                |             |
	/// | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
	/// | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
	external set coordinatesMode(num value);
	
	@override
	external num get coordinatesMode;
	
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 0     | CLAMP_ADDRESSMODE  |             |
	/// | 1     | WRAP_ADDRESSMODE   |             |
	/// | 2     | MIRROR_ADDRESSMODE |             |
	@override
	external num get wrapU;
	
	@override
	external set wrapU(num value);
	
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 0     | CLAMP_ADDRESSMODE  |             |
	/// | 1     | WRAP_ADDRESSMODE   |             |
	/// | 2     | MIRROR_ADDRESSMODE |             |
	@override
	external num get wrapV;
	
	@override
	external set wrapV(num value);
	
	/// | Value | Type               | Description |
	/// | ----- | ------------------ | ----------- |
	/// | 0     | CLAMP_ADDRESSMODE  |             |
	/// | 1     | WRAP_ADDRESSMODE   |             |
	/// | 2     | MIRROR_ADDRESSMODE |             |
	@override
	external num get wrapR;
	@override
	external set wrapR(num value);
	
	/// With compliant hardware and browser (supporting anisotropic filtering)
	/// this defines the level of anisotropic filtering in the texture.
	/// The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.
	@override
	external num get anisotropicFilteringLevel;
	@override
	external set anisotropicFilteringLevel(num value);
	
	/// Define if the texture is a cube texture or if false a 2d texture.
	@override
	external bool get isCube;
	
	@override
	external set isCube(bool value);
	
	/// Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
	@override
	external bool get is3D;
	
	@override
	external set is3D(bool value);
	
	/// Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
	@override
	external bool get is2DArray;
	
	@override
	external set is2DArray(bool value);
	
	/// Define if the texture contains data in gamma space (most of the png/jpg aside bump).
	/// HDR texture are usually stored in linear space.
	/// This only impacts the PBR and Background materials
	external bool get gammaSpace;
	
	external set gammaSpace(bool value);
	
	/// Gets or sets whether or not the texture contains RGBD data.
	external bool get isRGBD;
	
	external set isRGBD(bool value);
	
	/// Is Z inverted in the texture (useful in a cube texture).
	external bool get invertZ;
	external set invertZ(bool value);
	
	/// Are mip maps generated for this texture or not.
	external bool get noMipmap;
	
	/// @hidden
	external bool get lodLevelInAlpha;
	external set lodLevelInAlpha(bool value);
	
	/// With prefiltered texture, defined the offset used during the prefiltering steps.
	external num get lodGenerationOffset;
	
	external set lodGenerationOffset(num value);
	
	/// With prefiltered texture, defined the scale used during the prefiltering steps.
	external num get lodGenerationScale;
	
	external set lodGenerationScale(num value);
	
	/// With prefiltered texture, defined if the specular generation is based on a linear ramp.
	/// By default we are using a log2 of the linear roughness helping to keep a better resolution for
	/// average roughness values.
	external bool get linearSpecularLOD;
	
	external set linearSpecularLOD(bool value);
	
	/// In case a better definition than spherical harmonics is required for the diffuse part of the environment.
	/// You can set the irradiance texture to rely on a texture instead of the spherical approach.
	/// This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).
	external BaseTexture? get irradianceTexture;
	
	external set irradianceTexture(BaseTexture? value);
	
	/// Define if the texture is a render target.
	external bool get isRenderTarget;
	external set isRenderTarget(bool value);
	
	/// Define the unique id of the texture in the scene.
	external String get uid;
	
	/// Return a string representation of the texture.
	/// @returns the texture as a string
	external String toString();
	
	/// Get the class name of the texture.
	/// @returns "BaseTexture"
	@override
	external String getClassName();
	
	/// Define the list of animation attached to the texture.
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// An event triggered when the texture is disposed.
	external Observable<BaseTexture> get onDisposeObservable;
	external set onDisposeObservable(Observable<BaseTexture> value);
	
	/// Callback triggered when the texture has been disposed.
	/// Kept for back compatibility, you can use the onDisposeObservable instead.
	external set onDispose(void Function() value);
	
	/// Define if the texture is preventinga material to render or not.
	/// If not and the texture is not ready, the engine will use a default black texture instead.
	external bool get isBlocking;
	
	/// Get the scene the texture belongs to.
	/// @returns the scene or null if undefined
	external Scene? getScene();
	
	/// Checks if the texture has the same transform matrix than another texture
	/// @param texture texture to check against
	/// @returns true if the transforms are the same, else false
	external bool checkTransformsAreIdentical(BaseTexture? texture);
	
	/// Get the texture transform matrix used to offset tile the texture for istance.
	/// @returns the transformation matrix
	external Matrix getTextureMatrix();
	
	/// Get the texture reflection matrix used to rotate/transform the reflection.
	/// @returns the reflection matrix
	external Matrix getReflectionTextureMatrix();
	
	/// Get if the texture is ready to be consumed (either it is ready or it is not blocking)
	/// @returns true if ready or not blocking
	external bool isReadyOrNotBlocking();
	
	/// Scales the texture if is `canRescale()`
	/// @param ratio the resize factor we want to use to rescale
	external void scale(num ratio);
	
	/// Get if the texture can rescale.
	external bool get canRescale;
	
	/// Clones the texture.
	/// @returns the cloned texture
	external BaseTexture? clone();
	
	/// Get the texture underlying type (INT, FLOAT...)
	external num get textureType;
	
	/// Get the texture underlying format (RGB, RGBA...)
	external num get textureFormat;
	
	/// Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.
	/// This will returns an RGBA array buffer containing either in values (0-255) or
	/// float values (0-1) depending of the underlying buffer type.
	/// @param faceIndex defines the face of the texture to read (in case of cube texture)
	/// @param level defines the LOD level of the texture to read (in case of Mip Maps)
	/// @param buffer defines a user defined buffer to fill with data (can be null)
	/// @returns The Array buffer containing the pixels data.
	external dynamic? readPixels([num? faceIndex, num? level, dynamic? buffer]);
	
	/// Dispose the texture and release its associated resources.
	@override
	external void dispose();
	
	/// Serialize the texture into a JSON representation that can be parsed later on.
	/// @returns the JSON representation of the texture
	external dynamic serialize();
	
	/// Helper function to be called back once a list of texture contains only ready textures.
	/// @param textures Define the list of textures to wait for
	/// @param callback Define the callback triggered once the entire list will be ready
	external static void WhenAllReady(List<BaseTexture> textures, void Function() callback);
	
	/// Get the polynomial representation of the texture data.
	/// This is mainly use as a fast way to recover IBL Diffuse irradiance data.
	/// @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance
	external SphericalPolynomial? get sphericalPolynomial;
	external set sphericalPolynomial(SphericalPolynomial? value);
}

/// @hidden
@JS()
class WebGLDataBuffer extends DataBuffer {
	
	external factory WebGLDataBuffer(WebGL.Buffer resource);
	
	@override
	external dynamic get underlyingResource;
}

/// @hidden
@JS()
class WebGLPipelineContext implements IPipelineContext {
	external factory WebGLPipelineContext();
	
	external ThinEngine get engine;
	external set engine(ThinEngine value);
	
	external WebGL.Program? get program;
	external set program(WebGL.Program? value);
	
	external WebGL.RenderingContext get context;
	external set context(WebGL.RenderingContext value);
	
	external WebGL.Shader get vertexShader;
	external set vertexShader(WebGL.Shader value);
	
	external WebGL.Shader get fragmentShader;
	external set fragmentShader(WebGL.Shader value);
	
	external bool get isParallelCompiled;
	external set isParallelCompiled(bool value);
	
	external void Function() get onCompiled;
	external set onCompiled(void Function() value);
	
	external WebGL.TransformFeedback? get transformFeedback;
	external set transformFeedback(WebGL.TransformFeedback? value);
	
	external String? get vertexCompilationError;
	external set vertexCompilationError(String? value);
	
	external String? get fragmentCompilationError;
	external set fragmentCompilationError(String? value);
	
	external String? get programLinkError;
	external set programLinkError(String? value);
	
	external String? get programValidationError;
	external set programValidationError(String? value);
	
	/// Gets a boolean indicating that this pipeline context is supporting asynchronous creating
	external bool get isAsync;
	external set isAsync(bool value);
	
	/// Gets a boolean indicating that the context is ready to be used (like shaders / pipelines are compiled and ready for instance)
	external bool get isReady;
	external set isReady(bool value);
}

/// The base engine class (root of all engines)
@JS()
class ThinEngine {
	
	/// Creates a new engine
	/// @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context
	/// @param antialias defines enable antialiasing (default: false)
	/// @param options defines further options to be sent to the getContext() function
	/// @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
	external factory ThinEngine(dynamic? canvasOrContext, [bool? antialias, EngineOptions? options, bool? adaptToDeviceRatio]);
	
	/// Use this array to turn off some WebGL2 features on known buggy browsers version
	external static ThinEngineExceptionList get ExceptionList;
	external static set ExceptionList(ThinEngineExceptionList value);
	
	/// Returns the current npm package of the sdk
	external static String get NpmPackage;
	
	/// Returns the current version of the framework
	external static String get Version;
	
	/// Returns a string describing the current engine
	external String get description;
	
	/// Gets or sets the epsilon value used by collision engine
	external static num get CollisionsEpsilon;
	external static set CollisionsEpsilon(num value);
	
	/// Gets or sets the relative url used to load shaders if using the engine in non-minified mode
	external static String get ShadersRepository;
	
	external static set ShadersRepository(String value);
	
	/// Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
	external bool get forcePOTTextures;
	external set forcePOTTextures(bool value);
	
	/// Gets a boolean indicating if the engine is currently rendering in fullscreen mode
	external bool get isFullscreen;
	external set isFullscreen(bool value);
	
	/// Gets or sets a boolean indicating if back faces must be culled (true by default)
	external bool get cullBackFaces;
	external set cullBackFaces(bool value);
	
	/// Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun
	external bool get renderEvenInBackground;
	external set renderEvenInBackground(bool value);
	
	/// Gets or sets a boolean indicating that cache can be kept between frames
	external bool get preventCacheWipeBetweenFrames;
	external set preventCacheWipeBetweenFrames(bool value);
	
	/// Gets or sets a boolean indicating if the engine should validate programs after compilation
	external bool get validateShaderPrograms;
	external set validateShaderPrograms(bool value);
	
	/// Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.
	/// This can provide greater z depth for distant objects.
	external bool get useReverseDepthBuffer;
	external set useReverseDepthBuffer(bool value);
	
	/// Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
	external bool get disableUniformBuffers;
	external set disableUniformBuffers(bool value);
	
	/// Gets a boolean indicating that the engine supports uniform buffers
	/// @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
	external bool get supportsUniformBuffers;
	
	/// Gets a boolean indicating that only power of 2 textures are supported
	/// Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
	external bool get needPOTTextures;
	
	/// Observable signaled when a context lost event is raised
	external Observable<ThinEngine> get onContextLostObservable;
	external set onContextLostObservable(Observable<ThinEngine> value);
	
	/// Observable signaled when a context restored event is raised
	external Observable<ThinEngine> get onContextRestoredObservable;
	external set onContextRestoredObservable(Observable<ThinEngine> value);
	
	/// Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#handling-webgl-context-lost
	external bool get doNotHandleContextLost;
	
	external set doNotHandleContextLost(bool value);
	
	/// Gets or sets a boolean indicating that vertex array object must be disabled even if they are supported
	external bool get disableVertexArrayObjects;
	external set disableVertexArrayObjects(bool value);
	
	/// Gets information about the current host
	external HostInformation get hostInformation;
	external set hostInformation(HostInformation value);
	
	/// sets the object from which width and height will be taken from when getting render width and height
	/// Will fallback to the gl object
	/// @param dimensions the framebuffer width and height that will be used.
	external set framebufferDimensionsObject(ThinEngineFramebufferDimensionsObjectDimensions? value);
	
	/// Gets the current viewport
	external Viewport? get currentViewport;
	
	/// Gets the default empty texture
	external InternalTexture get emptyTexture;
	
	/// Gets the default empty 3D texture
	external InternalTexture get emptyTexture3D;
	
	/// Gets the default empty 2D array texture
	external InternalTexture get emptyTexture2DArray;
	
	/// Gets the default empty cube texture
	external InternalTexture get emptyCubeTexture;
	
	/// Defines whether the engine has been created with the premultipliedAlpha option on or not.
	external bool get premultipliedAlpha;
	
	/// Observable event triggered before each texture is initialized
	external Observable<Texture> get onBeforeTextureInitObservable;
	external set onBeforeTextureInitObservable(Observable<Texture> value);
	
	/// Gets a boolean indicating if all created effects are ready
	/// @returns true if all effects are ready
	external bool areAllEffectsReady();
	
	/// Gets version of the current webGL context
	external num get webGLVersion;
	
	/// Gets a string identifying the name of the class
	/// @returns "Engine" string
	external String getClassName();
	
	/// Returns true if the stencil buffer has been enabled through the creation option of the context.
	external bool get isStencilEnable;
	
	/// Reset the texture cache to empty state
	external void resetTextureCache();
	
	/// Gets an object containing information about the current webGL context
	/// @returns an object containing the vender, the renderer and the version of the current webGL context
	external ThinEngineGetGlInfo getGlInfo();
	
	/// Defines the hardware scaling level.
	/// By default the hardware scaling level is computed from the window device ratio.
	/// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
	/// @param level defines the level to use
	external void setHardwareScalingLevel(num level);
	
	/// Gets the current hardware scaling level.
	/// By default the hardware scaling level is computed from the window device ratio.
	/// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
	/// @returns a number indicating the current hardware scaling level
	external num getHardwareScalingLevel();
	
	/// Gets the list of loaded textures
	/// @returns an array containing all loaded textures
	external List<InternalTexture> getLoadedTexturesCache();
	
	/// Gets the object containing all engine capabilities
	/// @returns the EngineCapabilities object
	external EngineCapabilities getCaps();
	
	/// stop executing a render loop function and remove it from the execution array
	/// @param renderFunction defines the function to be removed. If not provided all functions will be removed.
	external void stopRenderLoop([void Function()? renderFunction]);
	
	/// Gets the HTML canvas attached with the current webGL context
	/// @returns a HTML canvas
	external HTML.CanvasElement? getRenderingCanvas();
	
	/// Gets host window
	/// @returns the host window object
	external HTML.Window? getHostWindow();
	
	/// Gets the current render width
	/// @param useScreen defines if screen size must be used (or the current render target if any)
	/// @returns a number defining the current render width
	external num getRenderWidth([bool? useScreen]);
	
	/// Gets the current render height
	/// @param useScreen defines if screen size must be used (or the current render target if any)
	/// @returns a number defining the current render height
	external num getRenderHeight([bool? useScreen]);
	
	/// Register and execute a render loop. The engine can have more than one render function
	/// @param renderFunction defines the function to continuously execute
	external void runRenderLoop(void Function() renderFunction);
	
	/// Clear the current render buffer or the current render target (if any is set up)
	/// @param color defines the color to use
	/// @param backBuffer defines if the back buffer must be cleared
	/// @param depth defines if the depth buffer must be cleared
	/// @param stencil defines if the stencil buffer must be cleared
	external void clear(Color4? color, bool backBuffer, bool depth, [bool? stencil]);
	
	/// Set the WebGL's viewport
	/// @param viewport defines the viewport element to be used
	/// @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
	/// @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
	external void setViewport(Viewport viewport, [num? requiredWidth, num? requiredHeight]);
	
	/// Begin a new frame
	external void beginFrame();
	
	/// Enf the current frame
	external void endFrame();
	
	/// Resize the view according to the canvas' size
	external void resize();
	
	/// Force a specific size of the canvas
	/// @param width defines the new canvas' width
	/// @param height defines the new canvas' height
	/// @returns true if the size was changed
	external bool setSize(num width, num height);
	
	/// Binds the frame buffer to the specified texture.
	/// @param texture The texture to render to or null for the default canvas
	/// @param faceIndex The face of the texture to render to in case of cube texture
	/// @param requiredWidth The width of the target to render to
	/// @param requiredHeight The height of the target to render to
	/// @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
	/// @param lodLevel defines the lod level to bind to the frame buffer
	/// @param layer defines the 2d array index to bind to frame buffer to
	external void bindFramebuffer(InternalTexture texture, [num? faceIndex, num? requiredWidth, num? requiredHeight, bool? forceFullscreenViewport, num? lodLevel, num? layer]);
	
	/// Unbind the current render target texture from the webGL context
	/// @param texture defines the render target texture to unbind
	/// @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
	/// @param onBeforeUnbind defines a function which will be called before the effective unbind
	external void unBindFramebuffer(InternalTexture texture, [bool? disableGenerateMipMaps, void Function()? onBeforeUnbind]);
	
	/// Force a webGL flush (ie. a flush of all waiting webGL commands)
	external void flushFramebuffer();
	
	/// Unbind the current render target and bind the default framebuffer
	external void restoreDefaultFramebuffer();
	
	/// Creates a vertex buffer
	/// @param data the data for the vertex buffer
	/// @returns the new WebGL static buffer
	external DataBuffer createVertexBuffer(dynamic data);
	
	/// Creates a dynamic vertex buffer
	/// @param data the data for the dynamic vertex buffer
	/// @returns the new WebGL dynamic buffer
	external DataBuffer createDynamicVertexBuffer(dynamic data);
	
	/// Creates a new index buffer
	/// @param indices defines the content of the index buffer
	/// @param updatable defines if the index buffer must be updatable
	/// @returns a new webGL buffer
	external DataBuffer createIndexBuffer(dynamic indices, [bool? updatable]);
	
	/// Bind a webGL buffer to the webGL context
	/// @param buffer defines the buffer to bind
	external void bindArrayBuffer(DataBuffer? buffer);
	
	external void bindIndexBuffer(DataBuffer? buffer);
	
	/// update the bound buffer with the given data
	/// @param data defines the data to update
	external void updateArrayBuffer(Float32List data);
	
	/// Records a vertex array object
	/// @see https://doc.babylonjs.com/features/webgl2#vertex-array-objects
	/// @param vertexBuffers defines the list of vertex buffers to store
	/// @param indexBuffer defines the index buffer to store
	/// @param effect defines the effect to store
	/// @returns the new vertex array object
	external WebGL.VertexArrayObject recordVertexArrayObject(dynamic /* object */ vertexBuffers, DataBuffer? indexBuffer, Effect effect);
	
	/// Bind a specific vertex array object
	/// @see https://doc.babylonjs.com/features/webgl2#vertex-array-objects
	/// @param vertexArrayObject defines the vertex array object to bind
	/// @param indexBuffer defines the index buffer to bind
	external void bindVertexArrayObject(WebGL.VertexArrayObject vertexArrayObject, DataBuffer? indexBuffer);
	
	/// Bind webGl buffers directly to the webGL context
	/// @param vertexBuffer defines the vertex buffer to bind
	/// @param indexBuffer defines the index buffer to bind
	/// @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
	/// @param vertexStrideSize defines the vertex stride of the vertex buffer
	/// @param effect defines the effect associated with the vertex buffer
	external void bindBuffersDirectly(DataBuffer vertexBuffer, DataBuffer indexBuffer, List<num> vertexDeclaration, num vertexStrideSize, Effect effect);
	
	/// Bind a list of vertex buffers to the webGL context
	/// @param vertexBuffers defines the list of vertex buffers to bind
	/// @param indexBuffer defines the index buffer to bind
	/// @param effect defines the effect associated with the vertex buffers
	external void bindBuffers(dynamic /* object */ vertexBuffers, DataBuffer? indexBuffer, Effect effect);
	
	/// Unbind all instance attributes
	external void unbindInstanceAttributes();
	
	/// Release and free the memory of a vertex array object
	/// @param vao defines the vertex array object to delete
	external void releaseVertexArrayObject(WebGL.VertexArrayObject vao);
	
	/// Update the content of a webGL buffer used with instanciation and bind it to the webGL context
	/// @param instancesBuffer defines the webGL buffer to update and bind
	/// @param data defines the data to store in the buffer
	/// @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer
	external void updateAndBindInstancesBuffer(DataBuffer instancesBuffer, Float32List data, dynamic offsetLocations);
	
	/// Bind the content of a webGL buffer used with instantiation
	/// @param instancesBuffer defines the webGL buffer to bind
	/// @param attributesInfo defines the offsets or attributes information used to determine where data must be stored in the buffer
	/// @param computeStride defines Whether to compute the strides from the info or use the default 0
	external void bindInstancesBuffer(DataBuffer instancesBuffer, List<InstancingAttributeInfo> attributesInfo, [bool? computeStride]);
	
	/// Disable the instance attribute corresponding to the name in parameter
	/// @param name defines the name of the attribute to disable
	external void disableInstanceAttributeByName(String name);
	
	/// Disable the instance attribute corresponding to the location in parameter
	/// @param attributeLocation defines the attribute location of the attribute to disable
	external void disableInstanceAttribute(num attributeLocation);
	
	/// Disable the attribute corresponding to the location in parameter
	/// @param attributeLocation defines the attribute location of the attribute to disable
	external void disableAttributeByIndex(num attributeLocation);
	
	/// Send a draw order
	/// @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
	/// @param indexStart defines the starting index
	/// @param indexCount defines the number of index to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	external void draw(bool useTriangles, num indexStart, num indexCount, [num? instancesCount]);
	
	/// Draw a list of points
	/// @param verticesStart defines the index of first vertex to draw
	/// @param verticesCount defines the count of vertices to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	external void drawPointClouds(num verticesStart, num verticesCount, [num? instancesCount]);
	
	/// Draw a list of unindexed primitives
	/// @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
	/// @param verticesStart defines the index of first vertex to draw
	/// @param verticesCount defines the count of vertices to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	external void drawUnIndexed(bool useTriangles, num verticesStart, num verticesCount, [num? instancesCount]);
	
	/// Draw a list of indexed primitives
	/// @param fillMode defines the primitive to use
	/// @param indexStart defines the starting index
	/// @param indexCount defines the number of index to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	external void drawElementsType(num fillMode, num indexStart, num indexCount, [num? instancesCount]);
	
	/// Draw a list of unindexed primitives
	/// @param fillMode defines the primitive to use
	/// @param verticesStart defines the index of first vertex to draw
	/// @param verticesCount defines the count of vertices to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num? instancesCount]);
	
	/// Create a new effect (used to store vertex/fragment shaders)
	/// @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)
	/// @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object
	/// @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use
	/// @param samplers defines an array of string used to represent textures
	/// @param defines defines the string containing the defines to use to compile the shaders
	/// @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails
	/// @param onCompiled defines a function to call when the effect creation is successful
	/// @param onError defines a function to call when the effect creation has failed
	/// @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)
	/// @returns the new Effect
	external Effect createEffect(dynamic baseName, dynamic attributesNamesOrOptions, dynamic uniformsNamesOrEngine, [List<String>? samplers, String? defines, IEffectFallbacks? fallbacks, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, dynamic? indexParameters]);
	
	/// Directly creates a webGL program
	/// @param pipelineContext  defines the pipeline context to attach to
	/// @param vertexCode defines the vertex shader code to use
	/// @param fragmentCode defines the fragment shader code to use
	/// @param context defines the webGL context to use (if not set, the current one will be used)
	/// @param transformFeedbackVaryings defines the list of transform feedback varyings to use
	/// @returns the new webGL program
	external WebGL.Program createRawShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, [WebGL.RenderingContext? context, List<String>? transformFeedbackVaryings]);
	
	/// Creates a webGL program
	/// @param pipelineContext  defines the pipeline context to attach to
	/// @param vertexCode  defines the vertex shader code to use
	/// @param fragmentCode defines the fragment shader code to use
	/// @param defines defines the string containing the defines to use to compile the shaders
	/// @param context defines the webGL context to use (if not set, the current one will be used)
	/// @param transformFeedbackVaryings defines the list of transform feedback varyings to use
	/// @returns the new webGL program
	external WebGL.Program createShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, String? defines, [WebGL.RenderingContext? context, List<String>? transformFeedbackVaryings]);
	
	/// Creates a new pipeline context
	/// @returns the new pipeline
	external IPipelineContext createPipelineContext();
	
	/// Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
	/// @param pipelineContext defines the pipeline context to use
	/// @param uniformsNames defines the list of uniform names
	/// @returns an array of webGL uniform locations
	external List<WebGL.UniformLocation>? getUniforms(IPipelineContext pipelineContext, List<String> uniformsNames);
	
	/// Gets the lsit of active attributes for a given webGL program
	/// @param pipelineContext defines the pipeline context to use
	/// @param attributesNames defines the list of attribute names to get
	/// @returns an array of indices indicating the offset of each attribute
	external List<num> getAttributes(IPipelineContext pipelineContext, List<String> attributesNames);
	
	/// Activates an effect, mkaing it the current one (ie. the one used for rendering)
	/// @param effect defines the effect to activate
	external void enableEffect(Effect? effect);
	
	/// Set the value of an uniform to a number (int)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param value defines the int number to store
	/// @returns true if the value was set
	external bool setInt(WebGL.UniformLocation? uniform, num value);
	
	/// Set the value of an uniform to an array of int32
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if the value was set
	external bool setIntArray(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of int32 (stored as vec2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if the value was set
	external bool setIntArray2(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of int32 (stored as vec3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if the value was set
	external bool setIntArray3(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of int32 (stored as vec4)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if the value was set
	external bool setIntArray4(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of number
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if the value was set
	/* Manual Fix 2 */
	external bool setArray(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of number (stored as vec2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if the value was set
	/* Manual Fix 3 */
	external bool setArray2(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of number (stored as vec3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if the value was set
	/* Manual Fix 4 */
	external bool setArray3(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of number (stored as vec4)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if the value was set
	/* Manual Fix 5 */
	external bool setArray4(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of float32 (stored as matrices)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param matrices defines the array of float32 to store
	/// @returns true if the value was set
	external bool setMatrices(WebGL.UniformLocation? uniform, Float32List matrices);
	
	/// Set the value of an uniform to a matrix (3x3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param matrix defines the Float32Array representing the 3x3 matrix to store
	/// @returns true if the value was set
	external bool setMatrix3x3(WebGL.UniformLocation? uniform, Float32List matrix);
	
	/// Set the value of an uniform to a matrix (2x2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param matrix defines the Float32Array representing the 2x2 matrix to store
	/// @returns true if the value was set
	external bool setMatrix2x2(WebGL.UniformLocation? uniform, Float32List matrix);
	
	/// Set the value of an uniform to a number (float)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param value defines the float number to store
	/// @returns true if the value was transfered
	external bool setFloat(WebGL.UniformLocation? uniform, num value);
	
	/// Set the value of an uniform to a vec2
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param x defines the 1st component of the value
	/// @param y defines the 2nd component of the value
	/// @returns true if the value was set
	external bool setFloat2(WebGL.UniformLocation? uniform, num x, num y);
	
	/// Set the value of an uniform to a vec3
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param x defines the 1st component of the value
	/// @param y defines the 2nd component of the value
	/// @param z defines the 3rd component of the value
	/// @returns true if the value was set
	external bool setFloat3(WebGL.UniformLocation? uniform, num x, num y, num z);
	
	/// Set the value of an uniform to a vec4
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param x defines the 1st component of the value
	/// @param y defines the 2nd component of the value
	/// @param z defines the 3rd component of the value
	/// @param w defines the 4th component of the value
	/// @returns true if the value was set
	external bool setFloat4(WebGL.UniformLocation? uniform, num x, num y, num z, num w);
	
	/// Apply all cached states (depth, culling, stencil and alpha)
	external void applyStates();
	
	/// Enable or disable color writing
	/// @param enable defines the state to set
	external void setColorWrite(bool enable);
	
	/// Gets a boolean indicating if color writing is enabled
	/// @returns the current color writing state
	external bool getColorWrite();
	
	/// Gets the depth culling state manager
	external DepthCullingState get depthCullingState;
	
	/// Gets the alpha state manager
	external AlphaState get alphaState;
	
	/// Gets the stencil state manager
	external StencilState get stencilState;
	
	/// Clears the list of texture accessible through engine.
	/// This can help preventing texture load conflict due to name collision.
	external void clearInternalTexturesCache();
	
	/// Force the entire cache to be cleared
	/// You should not have to use this function unless your engine needs to share the webGL context with another engine
	/// @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
	external void wipeCaches([bool? bruteForce]);
	
	/// Usually called from Texture.ts.
	/// Passed information to create a WebGLTexture
	/// @param url defines a value which contains one of the following:
	/// * A conventional http URL, e.g. 'http://...' or 'file://...'
	/// * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
	/// * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
	/// @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
	/// @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
	/// @param scene needed for loading to the correct scene
	/// @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
	/// @param onLoad optional callback to be called upon successful completion
	/// @param onError optional callback to be called upon failure
	/// @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
	/// @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
	/// @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
	/// @param forcedExtension defines the extension to use to pick the right loader
	/// @param mimeType defines an optional mime type
	/// @param loaderOptions options to be passed to the loader
	/// @returns a InternalTexture for assignment back into BABYLON.Texture
	external InternalTexture createTexture(String? url, bool noMipmap, bool invertY, ISceneLike? scene, [num? samplingMode, void Function()? onLoad, void Function(String message, dynamic exception)? onError, dynamic? buffer, InternalTexture? fallback, num? format, String? forcedExtension, String? mimeType, dynamic? loaderOptions]);
	
	/// In case you are sharing the context with other applications, it might
	/// be interested to not cache the unpack flip y state to ensure a consistent
	/// value would be set.
	external bool get enableUnpackFlipYCached;
	external set enableUnpackFlipYCached(bool value);
	
	/// Update the sampling mode of a given texture
	/// @param samplingMode defines the required sampling mode
	/// @param texture defines the texture to update
	/// @param generateMipMaps defines whether to generate mipmaps for the texture
	external void updateTextureSamplingMode(num samplingMode, InternalTexture texture, [bool? generateMipMaps]);
	
	/// Update the sampling mode of a given texture
	/// @param texture defines the texture to update
	/// @param wrapU defines the texture wrap mode of the u coordinates
	/// @param wrapV defines the texture wrap mode of the v coordinates
	/// @param wrapR defines the texture wrap mode of the r coordinates
	external void updateTextureWrappingMode(InternalTexture texture, num? wrapU, [num? wrapV, num? wrapR]);
	
	/// Update a portion of an internal texture
	/// @param texture defines the texture to update
	/// @param imageData defines the data to store into the texture
	/// @param xOffset defines the x coordinates of the update rectangle
	/// @param yOffset defines the y coordinates of the update rectangle
	/// @param width defines the width of the update rectangle
	/// @param height defines the height of the update rectangle
	/// @param faceIndex defines the face index if texture is a cube (0 by default)
	/// @param lod defines the lod level to update (0 by default)
	external void updateTextureData(InternalTexture texture, dynamic imageData, num xOffset, num yOffset, num width, num height, [num? faceIndex, num? lod]);
	
	/// Binds an effect to the webGL context
	/// @param effect defines the effect to bind
	external void bindSamplers(Effect effect);
	
	/// Unbind all textures from the webGL context
	external void unbindAllTextures();
	
	/// Sets a texture to the according uniform.
	/// @param channel The texture channel
	/// @param uniform The uniform to set
	/// @param texture The texture to apply
	external void setTexture(num channel, WebGL.UniformLocation? uniform, ThinTexture? texture);
	
	/// Sets an array of texture to the webGL context
	/// @param channel defines the channel where the texture array must be set
	/// @param uniform defines the associated uniform location
	/// @param textures defines the array of textures to bind
	external void setTextureArray(num channel, WebGL.UniformLocation? uniform, List<ThinTexture> textures);
	
	/// Unbind all vertex attributes from the webGL context
	external void unbindAllAttributes();
	
	/// Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
	external void releaseEffects();
	
	/// Dispose and release all associated resources
	external void dispose();
	
	/// Attach a new callback raised when context lost event is fired
	/// @param callback defines the callback to call
	external void attachContextLostEvent(void Function(dynamic /* unresolved: WebGLContextEvent */ event) callback);
	
	/// Attach a new callback raised when context restored event is fired
	/// @param callback defines the callback to call
	external void attachContextRestoredEvent(void Function(dynamic /* unresolved: WebGLContextEvent */ event) callback);
	
	/// Get the current error code of the webGL context
	/// @returns the error code
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
	external num getError();
	
	/// Reads pixels from the current frame buffer. Please note that this function can be slow
	/// @param x defines the x coordinate of the rectangle where pixels must be read
	/// @param y defines the y coordinate of the rectangle where pixels must be read
	/// @param width defines the width of the rectangle where pixels must be read
	/// @param height defines the height of the rectangle where pixels must be read
	/// @param hasAlpha defines whether the output should have alpha or not (defaults to true)
	/// @returns a Uint8Array containing RGBA colors
	external Uint8List readPixels(num x, num y, num width, num height, [bool? hasAlpha]);
	
	/// Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
	external static bool get IsSupported;
	
	/// Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
	/// @returns true if the engine can be created
	/// @ignorenaming
	external static bool isSupported();
	
	/// Gets a boolean indicating if the engine can be instanciated on a performant device (ie. if a webGL context can be found and it does not use a slow implementation)
	external static bool get HasMajorPerformanceCaveat;
	
	/// Find the next highest power of two.
	/// @param x Number to start search from.
	/// @return Next highest power of two.
	external static num CeilingPOT(num x);
	
	/// Find the next lowest power of two.
	/// @param x Number to start search from.
	/// @return Next lowest power of two.
	external static num FloorPOT(num x);
	
	/// Find the nearest power of two.
	/// @param x Number to start search from.
	/// @return Next nearest power of two.
	external static num NearestPOT(num x);
	
	/// Get the closest exponent of two
	/// @param value defines the value to approximate
	/// @param max defines the maximum value to return
	/// @param mode defines how to define the closest value
	/// @returns closest exponent of two of the given value
	external static num GetExponentOfTwo(num value, num max, [num? mode]);
	
	/// Queue a new function into the requested animation frame pool (ie. this function will be executed byt the browser for the next frame)
	/// @param func - the function to be called
	/// @param requester - the object that will request the next frame. Falls back to window.
	/// @returns frame number
	external static num QueueNewFrame(void Function() func, [dynamic? requester]);
	
	/// Gets host document
	/// @returns the host document object
	external HTML.Document? getHostDocument();
	
	/// Create an uniform buffer
	/// @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
	/// @param elements defines the content of the uniform buffer
	/// @returns the webGL uniform buffer
	external DataBuffer createUniformBuffer(dynamic elements);
	
	/// Create a dynamic uniform buffer
	/// @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
	/// @param elements defines the content of the uniform buffer
	/// @returns the webGL uniform buffer
	external DataBuffer createDynamicUniformBuffer(dynamic elements);
	
	/// Update an existing uniform buffer
	/// @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
	/// @param uniformBuffer defines the target uniform buffer
	/// @param elements defines the content to update
	/// @param offset defines the offset in the uniform buffer where update should start
	/// @param count defines the size of the data to update
	external void updateUniformBuffer(DataBuffer uniformBuffer, dynamic elements, [num? offset, num? count]);
	
	/// Bind an uniform buffer to the current webGL context
	/// @param buffer defines the buffer to bind
	external void bindUniformBuffer(DataBuffer? buffer);
	
	/// Bind a buffer to the current webGL context at a given location
	/// @param buffer defines the buffer to bind
	/// @param location defines the index where to bind the buffer
	external void bindUniformBufferBase(DataBuffer buffer, num location);
	
	/// Bind a specific block at a given index in a specific shader program
	/// @param pipelineContext defines the pipeline context to use
	/// @param blockName defines the block name
	/// @param index defines the index where to bind the block
	external void bindUniformBlock(IPipelineContext pipelineContext, String blockName, num index);
	
	/// Creates a cube texture
	/// @param rootUrl defines the url where the files to load is located
	/// @param scene defines the current scene
	/// @param files defines the list of files to load (1 per face)
	/// @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
	/// @param onLoad defines an optional callback raised when the texture is loaded
	/// @param onError defines an optional callback raised if there is an issue to load the texture
	/// @param format defines the format of the data
	/// @param forcedExtension defines the extension to use to pick the right loader
	/// @param createPolynomials if a polynomial sphere should be created for the cube texture
	/// @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
	/// @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
	/// @param fallback defines texture to use while falling back when (compressed) texture file not found.
	/// @param loaderOptions options to be passed to the loader
	/// @returns the cube texture as an InternalTexture
	external InternalTexture createCubeTexture(String rootUrl, Scene? scene, List<String>? files, bool? noMipmap, void Function([dynamic? data])? onLoad, void Function([String? message, dynamic? exception])? onError, num? format, dynamic forcedExtension, bool createPolynomials, num lodScale, num lodOffset, InternalTexture? fallback, dynamic loaderOptions);
	
	/// Creates a new render target texture
	/// @param size defines the size of the texture
	/// @param options defines the options used to create the texture
	/// @returns a new render target texture stored in an InternalTexture
	external InternalTexture createRenderTargetTexture(dynamic size, dynamic options);
	
	/// Creates a depth stencil texture.
	/// This is only available in WebGL 2 or with the depth texture extension available.
	/// @param size The size of face edge in the texture.
	/// @param options The options defining the texture.
	/// @returns The texture
	external InternalTexture createDepthStencilTexture(dynamic size, DepthTextureCreationOptions options);
	
	/// Creates a raw texture
	/// @param data defines the data to store in the texture
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @param format defines the format of the data
	/// @param generateMipMaps defines if the engine should generate the mip levels
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)
	/// @param compression defines the compression used (null by default)
	/// @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
	/// @returns the raw texture inside an InternalTexture
	external InternalTexture createRawTexture(dynamic? data, num width, num height, num format, bool generateMipMaps, bool invertY, num samplingMode, String? compression, num type);
	
	/// Update a raw texture
	/// @param texture defines the texture to update
	/// @param data defines the data to store in the texture
	/// @param format defines the format of the data
	/// @param invertY defines if data must be stored with Y axis inverted
	external void updateRawTexture(InternalTexture? texture, dynamic? data, num format, bool invertY);
	
	/// Creates a new raw cube texture
	/// @param data defines the array of data to use to create each face
	/// @param size defines the size of the textures
	/// @param format defines the format of the data
	/// @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
	/// @param generateMipMaps  defines if the engine should generate the mip levels
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
	/// @param compression defines the compression used (null by default)
	/// @returns the cube texture as an InternalTexture
	external InternalTexture createRawCubeTexture(List<dynamic>? data, num size, num format, num type, bool generateMipMaps, bool invertY, num samplingMode, String? compression);
	
	/// Update a raw cube texture
	/// @param texture defines the texture to udpdate
	/// @param data defines the data to store
	/// @param format defines the data format
	/// @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
	/// @param invertY defines if data must be stored with Y axis inverted
	external void updateRawCubeTexture(InternalTexture texture, List<dynamic> data, num format, num type, bool invertY);
	
	/// Creates a new raw cube texture from a specified url
	/// @param url defines the url where the data is located
	/// @param scene defines the current scene
	/// @param size defines the size of the textures
	/// @param format defines the format of the data
	/// @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
	/// @param noMipmap defines if the engine should avoid generating the mip levels
	/// @param callback defines a callback used to extract texture data from loaded data
	/// @param mipmapGenerator defines to provide an optional tool to generate mip levels
	/// @param onLoad defines a callback called when texture is loaded
	/// @param onError defines a callback called if there is an error
	/// @returns the cube texture as an InternalTexture
	external InternalTexture createRawCubeTextureFromUrl(String url, Scene? scene, num size, num format, num type, bool noMipmap, List<dynamic>? Function(ByteBuffer ArrayBuffer) callback, List<List<dynamic>> Function(List<dynamic> faces)? mipmapGenerator, void Function()? onLoad, void Function([String? message, dynamic? exception])? onError);
	
	/// Creates a new raw 3D texture
	/// @param data defines the data used to create the texture
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @param depth defines the depth of the texture
	/// @param format defines the format of the texture
	/// @param generateMipMaps defines if the engine must generate mip levels
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
	/// @param compression defines the compressed used (can be null)
	/// @param textureType defines the compressed used (can be null)
	/// @returns a new raw 3D texture (stored in an InternalTexture)
	external InternalTexture createRawTexture3D(dynamic? data, num width, num height, num depth, num format, bool generateMipMaps, bool invertY, num samplingMode, String? compression, num textureType);
	
	/// Update a raw 3D texture
	/// @param texture defines the texture to update
	/// @param data defines the data to store
	/// @param format defines the data format
	/// @param invertY defines if data must be stored with Y axis inverted
	external void updateRawTexture3D(InternalTexture texture, dynamic? data, num format, bool invertY);
	
	/// Creates a new raw 2D array texture
	/// @param data defines the data used to create the texture
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @param depth defines the number of layers of the texture
	/// @param format defines the format of the texture
	/// @param generateMipMaps defines if the engine must generate mip levels
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
	/// @param compression defines the compressed used (can be null)
	/// @param textureType defines the compressed used (can be null)
	/// @returns a new raw 2D array texture (stored in an InternalTexture)
	external InternalTexture createRawTexture2DArray(dynamic? data, num width, num height, num depth, num format, bool generateMipMaps, bool invertY, num samplingMode, String? compression, num textureType);
	
	/// Update a raw 2D array texture
	/// @param texture defines the texture to update
	/// @param data defines the data to store
	/// @param format defines the data format
	/// @param invertY defines if data must be stored with Y axis inverted
	external void updateRawTexture2DArray(InternalTexture texture, dynamic? data, num format, bool invertY);
	
	/// Update a dynamic index buffer
	/// @param indexBuffer defines the target index buffer
	/// @param indices defines the data to update
	/// @param offset defines the offset in the target index buffer where update should start
	/* Manual Fix 31 */
	external void updateDynamicIndexBuffer(dynamic indexBuffer, dynamic indices, [num? offset]);
	
	/// Updates a dynamic vertex buffer.
	/// @param vertexBuffer the vertex buffer to update
	/// @param data the data used to update the vertex buffer
	/// @param byteOffset the byte offset of the data
	/// @param byteLength the byte length of the data
	/* Manual Fix 33 */
	external void updateDynamicVertexBuffer(dynamic vertexBuffer, dynamic data, [num? byteOffset, num? byteLength]);
	
	/// Creates a new render target cube texture
	/// @param size defines the size of the texture
	/// @param options defines the options used to create the texture
	/// @returns a new render target cube texture stored in an InternalTexture
	external InternalTexture createRenderTargetCubeTexture(num size, [RenderTargetCreationOptions? options]);
	
	/// Sets alpha constants used by some alpha blending modes
	/// @param r defines the red component
	/// @param g defines the green component
	/// @param b defines the blue component
	/// @param a defines the alpha component
	external void setAlphaConstants(num r, num g, num b, num a);
	
	/// Sets the current alpha mode
	/// @param mode defines the mode to use (one of the Engine.ALPHA_XXX)
	/// @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
	external void setAlphaMode(num mode, [bool? noDepthWriteChange]);
	
	/// Gets the current alpha mode
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
	/// @returns the current alpha mode
	external num getAlphaMode();
	
	/// Sets the current alpha equation
	/// @param equation defines the equation to use (one of the Engine.ALPHA_EQUATION_XXX)
	external void setAlphaEquation(num equation);
	
	/// Gets the current alpha equation.
	/// @returns the current alpha equation
	external num getAlphaEquation();
	
	/// Unbind a list of render target textures from the webGL context
	/// This is used only when drawBuffer extension or webGL2 are active
	/// @param textures defines the render target textures to unbind
	/// @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
	/// @param onBeforeUnbind defines a function which will be called before the effective unbind
	external void unBindMultiColorAttachmentFramebuffer(List<InternalTexture> textures, bool disableGenerateMipMaps, [void Function()? onBeforeUnbind]);
	
	/// Create a multi render target texture
	/// @see https://doc.babylonjs.com/features/webgl2#multiple-render-target
	/// @param size defines the size of the texture
	/// @param options defines the creation options
	/// @returns the cube texture as an InternalTexture
	external List<InternalTexture> createMultipleRenderTarget(dynamic size, IMultiRenderTargetOptions options);
	
	/// Update the sample count for a given multiple render target texture
	/// @see https://doc.babylonjs.com/features/webgl2#multisample-render-targets
	/// @param textures defines the textures to update
	/// @param samples defines the sample count to set
	/// @returns the effective sample count (could be 0 if multisample render targets are not supported)
	external num updateMultipleRenderTargetTextureSampleCount(List<InternalTexture>? textures, num samples);
	
	/// Select a subsets of attachments to draw to.
	/// @param attachments gl attachments
	external void bindAttachments(List<num> attachments);
	
	/// Creates a layout object to draw/clear on specific textures in a MRT
	/// @param textureStatus textureStatus[i] indicates if the i-th is active
	/// @returns A layout to be fed to the engine, calling `bindAttachments`.
	external List<num> buildTextureLayout(List<bool> textureStatus);
	
	/// Restores the webgl state to only draw on the main color attachment
	external void restoreSingleAttachment();
	
	/// Update a video texture
	/// @param texture defines the texture to update
	/// @param video defines the video element to use
	/// @param invertY defines if data must be stored with Y axis inverted
	external void updateVideoTexture(InternalTexture? texture, HTML.VideoElement video, bool invertY);
	
	/// Creates a dynamic texture
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @param generateMipMaps defines if the engine should generate the mip levels
	/// @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)
	/// @returns the dynamic texture inside an InternalTexture
	external InternalTexture createDynamicTexture(num width, num height, bool generateMipMaps, num samplingMode);
	
	/// Update the content of a dynamic texture
	/// @param texture defines the texture to update
	/// @param source defines the source containing the data
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param premulAlpha defines if alpha is stored as premultiplied
	/// @param format defines the format of the data
	/// @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)
	/* Manual Fix 35 */
	external void updateDynamicTexture(InternalTexture? texture, HTML.CanvasElement source, [bool? invertY, bool? premulAlpha, num? format, bool? forceBindTexture]);
	
	/// Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)
	/// @param rootUrl defines the url where the file to load is located
	/// @param scene defines the current scene
	/// @param lodScale defines scale to apply to the mip map selection
	/// @param lodOffset defines offset to apply to the mip map selection
	/// @param onLoad defines an optional callback raised when the texture is loaded
	/// @param onError defines an optional callback raised if there is an issue to load the texture
	/// @param format defines the format of the data
	/// @param forcedExtension defines the extension to use to pick the right loader
	/// @param createPolynomials defines wheter or not to create polynomails harmonics for the texture
	/// @returns the cube texture as an InternalTexture
	external InternalTexture createPrefilteredCubeTexture(String rootUrl, Scene? scene, num lodScale, num lodOffset, [void Function(InternalTexture? internalTexture)? onLoad, void Function([String? message, dynamic? exception])? onError, num? format, dynamic? forcedExtension, bool? createPolynomials]);
}

/// Uniform buffer objects.
/// 
/// Handles blocks of uniform on the GPU.
/// 
/// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
/// 
/// For more information, please refer to :
/// https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
@JS()
class UniformBuffer {
	
	/// Instantiates a new Uniform buffer objects.
	/// 
	/// Handles blocks of uniform on the GPU.
	/// 
	/// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
	/// 
	/// For more information, please refer to :
	/// @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
	/// @param engine Define the engine the buffer is associated with
	/// @param data Define the data contained in the buffer
	/// @param dynamic Define if the buffer is updatable
	external factory UniformBuffer(Engine engine, [List<num>? data, bool? dynamic]);
	
	/// Lambda to Update a 3x3 Matrix in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Float32List matrix) get updateMatrix3x3;
	external set updateMatrix3x3(void Function(String name, Float32List matrix) value);
	
	/// Lambda to Update a 2x2 Matrix in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Float32List matrix) get updateMatrix2x2;
	external set updateMatrix2x2(void Function(String name, Float32List matrix) value);
	
	/// Lambda to Update a single float in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, num x) get updateFloat;
	external set updateFloat(void Function(String name, num x) value);
	
	/// Lambda to Update a vec2 of float in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, num x, num y, [String? suffix]) get updateFloat2;
	external set updateFloat2(void Function(String name, num x, num y, [String? suffix]) value);
	
	/// Lambda to Update a vec3 of float in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, num x, num y, num z, [String? suffix]) get updateFloat3;
	external set updateFloat3(void Function(String name, num x, num y, num z, [String? suffix]) value);
	
	/// Lambda to Update a vec4 of float in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, num x, num y, num z, num w, [String? suffix]) get updateFloat4;
	external set updateFloat4(void Function(String name, num x, num y, num z, num w, [String? suffix]) value);
	
	/// Lambda to Update a 4x4 Matrix in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Matrix mat) get updateMatrix;
	external set updateMatrix(void Function(String name, Matrix mat) value);
	
	/// Lambda to Update vec3 of float from a Vector in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Vector3 vector) get updateVector3;
	external set updateVector3(void Function(String name, Vector3 vector) value);
	
	/// Lambda to Update vec4 of float from a Vector in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Vector4 vector) get updateVector4;
	external set updateVector4(void Function(String name, Vector4 vector) value);
	
	/// Lambda to Update vec3 of float from a Color in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Color3 color, [String? suffix]) get updateColor3;
	external set updateColor3(void Function(String name, Color3 color, [String? suffix]) value);
	
	/// Lambda to Update vec4 of float from a Color in a uniform buffer.
	/// This is dynamic to allow compat with webgl 1 and 2.
	/// You will need to pass the name of the uniform as well as the value.
	external void Function(String name, Color3 color, num alpha, [String? suffix]) get updateColor4;
	external set updateColor4(void Function(String name, Color3 color, num alpha, [String? suffix]) value);
	
	/// Indicates if the buffer is using the WebGL2 UBO implementation,
	/// or just falling back on setUniformXXX calls.
	external bool get useUbo;
	
	/// Indicates if the WebGL underlying uniform buffer is in sync
	/// with the javascript cache data.
	external bool get isSync;
	
	/// Indicates if the WebGL underlying uniform buffer is dynamic.
	/// Also, a dynamic UniformBuffer will disable cache verification and always
	/// update the underlying WebGL uniform buffer to the GPU.
	/// @returns if Dynamic, otherwise false
	external bool isDynamic();
	
	/// The data cache on JS side.
	/// @returns the underlying data as a float array
	external Float32List getData();
	
	/// The underlying WebGL Uniform buffer.
	/// @returns the webgl buffer
	external DataBuffer? getBuffer();
	
	/// Adds an uniform in the buffer.
	/// Warning : the subsequents calls of this function must be in the same order as declared in the shader
	/// for the layout to be correct !
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param size Data size, or data directly.
	external void addUniform(String name, dynamic size);
	
	/// Adds a Matrix 4x4 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param mat A 4x4 matrix.
	external void addMatrix(String name, Matrix mat);
	
	/// Adds a vec2 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param x Define the x component value of the vec2
	/// @param y Define the y component value of the vec2
	external void addFloat2(String name, num x, num y);
	
	/// Adds a vec3 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param x Define the x component value of the vec3
	/// @param y Define the y component value of the vec3
	/// @param z Define the z component value of the vec3
	external void addFloat3(String name, num x, num y, num z);
	
	/// Adds a vec3 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param color Define the vec3 from a Color
	external void addColor3(String name, Color3 color);
	
	/// Adds a vec4 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param color Define the rgb components from a Color
	/// @param alpha Define the a component of the vec4
	external void addColor4(String name, Color3 color, num alpha);
	
	/// Adds a vec3 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	/// @param vector Define the vec3 components from a Vector
	external void addVector3(String name, Vector3 vector);
	
	/// Adds a Matrix 3x3 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	external void addMatrix3x3(String name);
	
	/// Adds a Matrix 2x2 to the uniform buffer.
	/// @param name Name of the uniform, as used in the uniform block in the shader.
	external void addMatrix2x2(String name);
	
	/// Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
	external void create();
	
	/// Updates the WebGL Uniform Buffer on the GPU.
	/// If the `dynamic` flag is set to true, no cache comparison is done.
	/// Otherwise, the buffer will be updated only if the cache differs.
	external void update();
	
	/// Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
	/// @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
	/// @param data Define the flattened data
	/// @param size Define the size of the data.
	external void updateUniform(String uniformName, dynamic data, num size);
	
	/// Sets a sampler uniform on the effect.
	/// @param name Define the name of the sampler.
	/// @param texture Define the texture to set in the sampler
	external void setTexture(String name, BaseTexture? texture);
	
	/// Directly updates the value of the uniform in the cache AND on the GPU.
	/// @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
	/// @param data Define the flattened data
	external void updateUniformDirectly(String uniformName, dynamic data);
	
	/// Binds this uniform buffer to an effect.
	/// @param effect Define the effect to bind the buffer to
	/// @param name Name of the uniform block in the shader.
	external void bindToEffect(Effect effect, String name);
	
	/// Disposes the uniform buffer.
	external void dispose();
}

/// Manages the defines for the Material
@JS()
class MaterialDefines {
	external factory MaterialDefines();
	
	/* array access */
	
	/// Specifies if the material needs to be re-calculated
	external bool get isDirty;
	
	/// Marks the material to indicate that it has been re-calculated
	external void markAsProcessed();
	
	/// Marks the material to indicate that it needs to be re-calculated
	external void markAsUnprocessed();
	
	/// Marks the material to indicate all of its defines need to be re-calculated
	external void markAllAsDirty();
	
	/// Marks the material to indicate that image processing needs to be re-calculated
	external void markAsImageProcessingDirty();
	
	/// Marks the material to indicate the lights need to be re-calculated
	/// @param disposed Defines whether the light is dirty due to dispose or not
	external void markAsLightDirty([bool? disposed]);
	
	/// Marks the attribute state as changed
	external void markAsAttributesDirty();
	
	/// Marks the texture state as changed
	external void markAsTexturesDirty();
	
	/// Marks the fresnel state as changed
	external void markAsFresnelDirty();
	
	/// Marks the misc state as changed
	external void markAsMiscDirty();
	
	/// Marks the prepass state as changed
	external void markAsPrePassDirty();
	
	/// Rebuilds the material defines
	external void rebuild();
	
	/// Specifies if two material defines are equal
	/// @param other - A material define instance to compare to
	/// @returns - Boolean indicating if the material defines are equal (true) or not (false)
	external bool isEqual(MaterialDefines other);
	
	/// Clones this instance's defines to another instance
	/// @param other - material defines to clone values to
	external void cloneTo(MaterialDefines other);
	
	/// Resets the material define values
	external void reset();
	
	/// Converts the material define values to a string
	/// @returns - String of material define information
	external String toString();
}

/* enum */
abstract class InspectableType {
	
	/// Checkbox for booleans
	static const int Checkbox = 1;
	
	/// Sliders for numbers
	static const int Slider = 2;
	
	/// Vector3
	static const int Vector3 = 3;
	
	/// Quaternions
	static const int Quaternion = 4;
	
	/// Color3
	static const int Color3 = 5;
	
	/// String
	static const int String = 6;
}

/// Interface used to define custom inspectable properties.
/// This interface is used by the inspector to display custom property grids
/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
@JS()
@anonymous
class IInspectable {
	
	external factory IInspectable({String label, String propertyName, int type, num min, num max, num step});
	
	/// Gets the label to display
	external String get label;
	external set label( String value );
	
	/// Gets the name of the property to edit
	external String get propertyName;
	external set propertyName( String value );
	
	/// Gets the type of the editor to use
	external int get type;
	external set type( int value );
	
	/// Gets the minimum value of the property when using in "slider" mode
	external num get min;
	external set min( num value );
	
	/// Gets the maximum value of the property when using in "slider" mode
	external num get max;
	external set max( num value );
	
	/// Gets the setp to use when using in "slider" mode
	external num get step;
	external set step( num value );
}

/// Base class of all the lights in Babylon. It groups all the generic information about lights.
/// Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
/// All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
@JS()
abstract class Light extends Node {
	
	/// Creates a Light object in the scene.
	/// Documentation : https://doc.babylonjs.com/babylon101/lights
	/// @param name The firendly name of the light
	/// @param scene The scene the light belongs too
	external factory Light(String name, Scene scene);
	
	/// Falloff Default: light is falling off following the material specification:
	/// standard material is using standard falloff whereas pbr material can request special falloff per materials.
	external static num get FALLOFF_DEFAULT;
	
	/// Falloff Physical: light is falling off following the inverse squared distance law.
	external static num get FALLOFF_PHYSICAL;
	
	/// Falloff gltf: light is falling off as described in the gltf moving to PBR document
	/// to enhance interoperability with other engines.
	external static num get FALLOFF_GLTF;
	
	/// Falloff Standard: light is falling off like in the standard material
	/// to enhance interoperability with other materials.
	external static num get FALLOFF_STANDARD;
	
	/// If every light affecting the material is in this lightmapMode,
	/// material.lightmapTexture adds or multiplies
	/// (depends on material.useLightmapAsShadowmap)
	/// after every other light calculations.
	external static num get LIGHTMAP_DEFAULT;
	
	/// material.lightmapTexture as only diffuse lighting from this light
	/// adds only specular lighting from this light
	/// adds dynamic shadows
	external static num get LIGHTMAP_SPECULAR;
	
	/// material.lightmapTexture as only lighting
	/// no light calculation from this light
	/// only adds dynamic shadows from this light
	external static num get LIGHTMAP_SHADOWSONLY;
	
	/// Each light type uses the default quantity according to its type:
	/// point/spot lights use luminous intensity
	/// directional lights use illuminance
	external static num get INTENSITYMODE_AUTOMATIC;
	
	/// lumen (lm)
	external static num get INTENSITYMODE_LUMINOUSPOWER;
	
	/// candela (lm/sr)
	external static num get INTENSITYMODE_LUMINOUSINTENSITY;
	
	/// lux (lm/m^2)
	external static num get INTENSITYMODE_ILLUMINANCE;
	
	/// nit (cd/m^2)
	external static num get INTENSITYMODE_LUMINANCE;
	
	/// Light type const id of the point light.
	external static num get LIGHTTYPEID_POINTLIGHT;
	
	/// Light type const id of the directional light.
	external static num get LIGHTTYPEID_DIRECTIONALLIGHT;
	
	/// Light type const id of the spot light.
	external static num get LIGHTTYPEID_SPOTLIGHT;
	
	/// Light type const id of the hemispheric light.
	external static num get LIGHTTYPEID_HEMISPHERICLIGHT;
	
	/// Diffuse gives the basic color to an object.
	external Color3 get diffuse;
	external set diffuse(Color3 value);
	
	/// Specular produces a highlight color on an object.
	/// Note: This is note affecting PBR materials.
	external Color3 get specular;
	external set specular(Color3 value);
	
	/// Defines the falloff type for this light. This lets overrriding how punctual light are
	/// falling off base on range or angle.
	/// This can be set to any values in Light.FALLOFF_x.
	/// 
	/// Note: This is only useful for PBR Materials at the moment. This could be extended if required to
	/// other types of materials.
	external num get falloffType;
	external set falloffType(num value);
	
	/// Strength of the light.
	/// Note: By default it is define in the framework own unit.
	/// Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.
	external num get intensity;
	external set intensity(num value);
	
	/// Defines how far from the source the light is impacting in scene units.
	/// Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
	external num get range;
	
	/// Defines how far from the source the light is impacting in scene units.
	/// Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
	external set range(num value);
	
	/// Gets the photometric scale used to interpret the intensity.
	/// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
	external num get intensityMode;
	
	/// Sets the photometric scale used to interpret the intensity.
	/// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
	external set intensityMode(num value);
	
	/// Gets the light radius used by PBR Materials to simulate soft area lights.
	external num get radius;
	
	/// sets the light radius used by PBR Materials to simulate soft area lights.
	external set radius(num value);
	
	/// Defines the rendering priority of the lights. It can help in case of fallback or number of lights
	/// exceeding the number allowed of the materials.
	external num get renderPriority;
	external set renderPriority(num value);
	
	/// Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
	/// the current shadow generator.
	external bool get shadowEnabled;
	
	/// Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
	/// the current shadow generator.
	external set shadowEnabled(bool value);
	
	/// Gets the only meshes impacted by this light.
	external List<AbstractMesh> get includedOnlyMeshes;
	
	/// Sets the only meshes impacted by this light.
	external set includedOnlyMeshes(List<AbstractMesh> value);
	
	/// Gets the meshes not impacted by this light.
	external List<AbstractMesh> get excludedMeshes;
	
	/// Sets the meshes not impacted by this light.
	external set excludedMeshes(List<AbstractMesh> value);
	
	/// Gets the layer id use to find what meshes are not impacted by the light.
	/// Inactive if 0
	external num get excludeWithLayerMask;
	
	/// Sets the layer id use to find what meshes are not impacted by the light.
	/// Inactive if 0
	external set excludeWithLayerMask(num value);
	
	/// Gets the layer id use to find what meshes are impacted by the light.
	/// Inactive if 0
	external num get includeOnlyWithLayerMask;
	
	/// Sets the layer id use to find what meshes are impacted by the light.
	/// Inactive if 0
	external set includeOnlyWithLayerMask(num value);
	
	/// Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
	external num get lightmapMode;
	
	/// Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
	external set lightmapMode(num value);
	
	/// Sets the passed Effect "effect" with the Light information.
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The light
	external Light transferToEffect(Effect effect, String lightIndex);
	
	/// Sets the passed Effect "effect" with the Light textures.
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The light
	external Light transferTexturesToEffect(Effect effect, String lightIndex);
	
	/// Sets the passed Effect "effect" with the Light information.
	/// @param effect The effect to update
	/// @param lightDataUniformName The uniform used to store light data (position or direction)
	/// @returns The light
	external Light transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);
	
	/// Returns the string "Light".
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Converts the light information to a readable string for debug purpose.
	/// @param fullDetails Supports for multiple levels of logging within scene loading
	/// @returns the human readable light info
	external String toString([bool? fullDetails]);
	
	/// Set the enabled state of this node.
	/// @param value - the new enabled state
	@override
	external void setEnabled(bool value);
	
	/// Returns the Light associated shadow generator if any.
	/// @return the associated shadow generator.
	external IShadowGenerator? getShadowGenerator();
	
	/// Returns a Vector3, the absolute light position in the World.
	/// @returns the world space position of the light
	external Vector3 getAbsolutePosition();
	
	/// Specifies if the light will affect the passed mesh.
	/// @param mesh The mesh to test against the light
	/// @return true the mesh is affected otherwise, false.
	external bool canAffectMesh(AbstractMesh mesh);
	
	/// Sort function to order lights for rendering.
	/// @param a First Light object to compare to second.
	/// @param b Second Light object to compare first.
	/// @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.
	external static num CompareLightsPriority(Light a, Light b);
	
	/// Releases resources associated with this node.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Returns the light type ID (integer).
	/// @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
	external num getTypeID();
	
	/// Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
	/// @returns the scaled intensity in intensity mode unit
	external num getScaledIntensity();
	
	/// Returns a new Light object, named "name", from the current one.
	/// @param name The name of the cloned light
	/// @param newParent The parent of this light, if it has one
	/// @returns the new created light
	external Light? clone(String name, [Node? newParent]);
	
	/// Serializes the current light into a Serialization object.
	/// @returns the serialized object.
	external dynamic serialize();
	
	/// Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
	/// This new light is named "name" and added to the passed scene.
	/// @param type Type according to the types available in Light.LIGHTTYPEID_x
	/// @param name The friendly name of the light
	/// @param scene The scene the new light will belong to
	/// @returns the constructor function
	external static Light Function()? GetConstructorFromName(num type, String name, Scene scene);
	
	/// Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
	/// @param parsedLight The JSON representation of the light
	/// @param scene The scene to create the parsed light in
	/// @returns the created light after parsing
	external static Light? Parse(dynamic parsedLight, Scene scene);
	
	/// Prepares the list of defines specific to the light type.
	/// @param defines the list of defines
	/// @param lightIndex defines the index of the light for the effect
	external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

/* enum */
abstract class Space {
	
	/// Local (object) space
	static const int LOCAL = 1;
	
	/// World space
	static const int WORLD = 2;
	
	/// Bone space
	static const int BONE = 3;
}

/// Defines the 3 main axes
@JS()
class Axis {
	external factory Axis();
	
	/// X axis
	external static Vector3 get X;
	external static set X(Vector3 value);
	
	/// Y axis
	external static Vector3 get Y;
	external static set Y(Vector3 value);
	
	/// Z axis
	external static Vector3 get Z;
	external static set Z(Vector3 value);
}

/* enum */
abstract class Coordinate {
	
	/// X axis
	static const int X = 1;
	
	/// Y axis
	static const int Y = 2;
	
	/// Z axis
	static const int Z = 3;
}

/// Interface describing all the common properties and methods a shadow light needs to implement.
/// This helps both the shadow generator and materials to genrate the corresponding shadow maps
/// as well as binding the different shadow properties to the effects.
@JS()
abstract class IShadowLight extends Light {
	external factory IShadowLight();
	
	/// The light id in the scene (used in scene.findLighById for instance)
	@override
	external String get id;
	@override
	external set id(String value);
	
	/// The position the shdow will be casted from.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// In 2d mode (needCube being false), the direction used to cast the shadow.
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// The transformed position. Position of the light in world space taking parenting in account.
	external Vector3 get transformedPosition;
	external set transformedPosition(Vector3 value);
	
	/// The transformed direction. Direction of the light in world space taking parenting in account.
	external Vector3 get transformedDirection;
	external set transformedDirection(Vector3 value);
	
	/// The friendly name of the light in the scene.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the shadow projection clipping minimum z value.
	external num get shadowMinZ;
	external set shadowMinZ(num value);
	
	/// Defines the shadow projection clipping maximum z value.
	external num get shadowMaxZ;
	external set shadowMaxZ(num value);
	
	/// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
	/// @returns true if the information has been computed, false if it does not need to (no parenting)
	external bool computeTransformedInformation();
	
	/// Gets the scene the light belongs to.
	/// @returns The scene
	@override
	external Scene getScene();
	
	/// Callback defining a custom Projection Matrix Builder.
	/// This can be used to override the default projection matrix computation.
	external void Function(Matrix viewMatrix, List<AbstractMesh> renderList, Matrix result) get customProjectionMatrixBuilder;
	external set customProjectionMatrixBuilder(void Function(Matrix viewMatrix, List<AbstractMesh> renderList, Matrix result) value);
	
	/// Sets the shadow projection matrix in parameter to the generated projection matrix.
	/// @param matrix The materix to updated with the projection information
	/// @param viewMatrix The transform matrix of the light
	/// @param renderList The list of mesh to render in the map
	/// @returns The current light
	external IShadowLight setShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);
	
	/// Gets the current depth scale used in ESM.
	/// @returns The scale
	external num getDepthScale();
	
	/// Returns whether or not the shadow generation require a cube texture or a 2d texture.
	/// @returns true if a cube texture needs to be use
	external bool needCube();
	
	/// Detects if the projection matrix requires to be recomputed this frame.
	/// @returns true if it requires to be recomputed otherwise, false.
	external bool needProjectionMatrixCompute();
	
	/// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
	external void forceProjectionMatrixCompute();
	
	/// Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
	/// @param faceIndex The index of the face we are computed the direction to generate shadow
	/// @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
	external Vector3 getShadowDirection([num? faceIndex]);
	
	/// Gets the minZ used for shadow according to both the scene and the light.
	/// @param activeCamera The camera we are returning the min for
	/// @returns the depth min z
	external num getDepthMinZ(Camera activeCamera);
	
	/// Gets the maxZ used for shadow according to both the scene and the light.
	/// @param activeCamera The camera we are returning the max for
	/// @returns the depth max z
	external num getDepthMaxZ(Camera activeCamera);
}

/// Base implementation IShadowLight
/// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
@JS()
abstract class ShadowLight extends Light implements IShadowLight {
	external factory ShadowLight();
	
	/// Sets the position the shadow will be casted from. Also use as the light position for both
	/// point and spot lights.
	@override
	external Vector3 get position;
	
	/// Sets the position the shadow will be casted from. Also use as the light position for both
	/// point and spot lights.
	@override
	external set position(Vector3 value);
	
	/// In 2d mode (needCube being false), gets the direction used to cast the shadow.
	/// Also use as the light direction on spot and directional lights.
	@override
	external Vector3 get direction;
	
	/// In 2d mode (needCube being false), sets the direction used to cast the shadow.
	/// Also use as the light direction on spot and directional lights.
	@override
	external set direction(Vector3 value);
	
	/// Gets the shadow projection clipping minimum z value.
	@override
	external num get shadowMinZ;
	
	/// Sets the shadow projection clipping minimum z value.
	@override
	external set shadowMinZ(num value);
	
	/// Sets the shadow projection clipping maximum z value.
	@override
	external num get shadowMaxZ;
	
	/// Gets the shadow projection clipping maximum z value.
	@override
	external set shadowMaxZ(num value);
	
	/// Callback defining a custom Projection Matrix Builder.
	/// This can be used to override the default projection matrix computation.
	@override
	external void Function(Matrix viewMatrix, List<AbstractMesh> renderList, Matrix result) get customProjectionMatrixBuilder;
	@override
	external set customProjectionMatrixBuilder(void Function(Matrix viewMatrix, List<AbstractMesh> renderList, Matrix result) value);
	
	/// The transformed position. Position of the light in world space taking parenting in account.
	@override
	external Vector3 get transformedPosition;
	@override
	external set transformedPosition(Vector3 value);
	
	/// The transformed direction. Direction of the light in world space taking parenting in account.
	@override
	external Vector3 get transformedDirection;
	@override
	external set transformedDirection(Vector3 value);
	
	/// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
	/// @returns true if the information has been computed, false if it does not need to (no parenting)
	@override
	external bool computeTransformedInformation();
	
	/// Return the depth scale used for the shadow map.
	/// @returns the depth scale.
	@override
	external num getDepthScale();
	
	/// Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
	/// @param faceIndex The index of the face we are computed the direction to generate shadow
	/// @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
	@override
	external Vector3 getShadowDirection([num? faceIndex]);
	
	/// Returns the ShadowLight absolute position in the World.
	/// @returns the position vector in world space
	@override
	external Vector3 getAbsolutePosition();
	
	/// Sets the ShadowLight direction toward the passed target.
	/// @param target The point to target in local space
	/// @returns the updated ShadowLight direction
	external Vector3 setDirectionToTarget(Vector3 target);
	
	/// Returns the light rotation in euler definition.
	/// @returns the x y z rotation in local space.
	external Vector3 getRotation();
	
	/// Returns whether or not the shadow generation require a cube texture or a 2d texture.
	/// @returns true if a cube texture needs to be use
	@override
	external bool needCube();
	
	/// Detects if the projection matrix requires to be recomputed this frame.
	/// @returns true if it requires to be recomputed otherwise, false.
	@override
	external bool needProjectionMatrixCompute();
	
	/// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
	@override
	external void forceProjectionMatrixCompute();
	
	/// Computes the world matrix of the node
	/// @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
	/// @returns the world matrix
	@override
	external Matrix computeWorldMatrix([bool? force]);
	
	/// Gets the minZ used for shadow according to both the scene and the light.
	/// @param activeCamera The camera we are returning the min for
	/// @returns the depth min z
	@override
	external num getDepthMinZ(Camera activeCamera);
	
	/// Gets the maxZ used for shadow according to both the scene and the light.
	/// @param activeCamera The camera we are returning the max for
	/// @returns the depth max z
	@override
	external num getDepthMaxZ(Camera activeCamera);
	
	/// Sets the shadow projection matrix in parameter to the generated projection matrix.
	/// @param matrix The materix to updated with the projection information
	/// @param viewMatrix The transform matrix of the light
	/// @param renderList The list of mesh to render in the map
	/// @returns The current light
	@override
	external IShadowLight setShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);
}

/// Configuration needed for prepass-capable materials
@JS()
class PrePassConfiguration {
	external factory PrePassConfiguration();
	
	/// Previous world matrices of meshes carrying this material
	/// Used for computing velocity
	external dynamic /* object */ get previousWorldMatrices;
	external set previousWorldMatrices(dynamic /* object */ value);
	
	/// Previous view project matrix
	/// Used for computing velocity
	external Matrix get previousViewProjection;
	external set previousViewProjection(Matrix value);
	
	/// Previous bones of meshes carrying this material
	/// Used for computing velocity
	external dynamic /* object */ get previousBones;
	external set previousBones(dynamic /* object */ value);
	
	/// Add the required uniforms to the current list.
	/// @param uniforms defines the current uniform list.
	external static void AddUniforms(List<String> uniforms);
	
	/// Add the required samplers to the current list.
	/// @param samplers defines the current sampler list.
	external static void AddSamplers(List<String> samplers);
	
	/// Binds the material data.
	/// @param effect defines the effect to update
	/// @param scene defines the scene the material belongs to.
	/// @param mesh The mesh
	/// @param world World matrix of this mesh
	/// @param isFrozen Is the material frozen
	external void bindForSubMesh(Effect effect, Scene scene, Mesh mesh, Matrix world, bool isFrozen);
}

/// A target camera takes a mesh or position as a target and continues to look at it while it moves.
/// This is the base of the follow, arc rotate cameras and Free camera
/// @see https://doc.babylonjs.com/features/cameras
@JS()
class TargetCamera extends Camera {
	
	/// Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.
	/// This is the base of the follow, arc rotate cameras and Free camera
	/// @see https://doc.babylonjs.com/features/cameras
	/// @param name Defines the name of the camera in the scene
	/// @param position Defines the start position of the camera in the scene
	/// @param scene Defines the scene the camera belongs to
	/// @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
	external factory TargetCamera(String name, Vector3 position, Scene scene, [bool? setActiveOnSceneIfNoneActive]);
	
	/// Define the current direction the camera is moving to
	external Vector3 get cameraDirection;
	external set cameraDirection(Vector3 value);
	
	/// Define the current rotation the camera is rotating to
	external Vector2 get cameraRotation;
	external set cameraRotation(Vector2 value);
	
	/// Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera
	external bool get ignoreParentScaling;
	external set ignoreParentScaling(bool value);
	
	/// When set, the up vector of the camera will be updated by the rotation of the camera
	external bool get updateUpVectorFromRotation;
	external set updateUpVectorFromRotation(bool value);
	
	/// Define the current rotation of the camera
	external Vector3 get rotation;
	external set rotation(Vector3 value);
	
	/// Define the current rotation of the camera as a quaternion to prevent Gimbal lock
	external Quaternion get rotationQuaternion;
	external set rotationQuaternion(Quaternion value);
	
	/// Define the current speed of the camera
	external num get speed;
	external set speed(num value);
	
	/// Add constraint to the camera to prevent it to move freely in all directions and
	/// around all axis.
	external bool get noRotationConstraint;
	external set noRotationConstraint(bool value);
	
	/// Reverses mouselook direction to 'natural' panning as opposed to traditional direct
	/// panning
	external bool get invertRotation;
	external set invertRotation(bool value);
	
	/// Speed multiplier for inverse camera panning
	external num get inverseRotationSpeed;
	external set inverseRotationSpeed(num value);
	
	/// Define the current target of the camera as an object or a position.
	external dynamic? get lockedTarget;
	external set lockedTarget(dynamic? value);
	
	/// Gets the position in front of the camera at a given distance.
	/// @param distance The distance from the camera we want the position to be
	/// @returns the position
	external Vector3 getFrontPosition(num distance);
	
	/// Store current camera state of the camera (fov, position, rotation, etc..)
	/// @returns the camera
	@override
	external Camera storeState();
	
	/// Defines the target the camera should look at.
	/// @param target Defines the new target as a Vector or a mesh
	external void setTarget(Vector3 target);
	
	/// Defines the target point of the camera.
	/// The camera looks towards it form the radius distance.
	external Vector3 get target;
	
	external set target(Vector3 value);
	
	/// Return the current target position of the camera. This value is expressed in local space.
	/// @returns the target position
	external Vector3 getTarget();
	
	/// @hidden
	@override
	external Camera? createRigCamera(String name, num cameraIndex);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/* var */
/// @ignore
/// This is a list of all the different input types that are available in the application.
/// Fo instance: ArcRotateCameraGamepadInput...
@JS()
external dynamic get CameraInputTypes;

/// This is the contract to implement in order to create a new input class.
/// Inputs are dealing with listening to user actions and moving the camera accordingly.
@JS()
abstract class ICameraInput<TCamera extends Camera> {
	
	/// Defines the camera the input is attached to.
	external TCamera? get camera;
	external set camera(TCamera? value);
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	external String getSimpleName();
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	external void detachControl();
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Represents a map of input types to input instance or input index to input instance.
@JS()
@anonymous
class CameraInputsMap<TCamera extends Camera> {
}

/// This represents the input manager used within a camera.
/// It helps dealing with all the different kind of input attached to a camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class CameraInputsManager<TCamera extends Camera> {
	
	/// Instantiate a new Camera Input Manager.
	/// @param camera Defines the camera the input manager blongs to
	external factory CameraInputsManager(TCamera camera);
	
	/// Defines the list of inputs attahed to the camera.
	external CameraInputsMap<TCamera> get attached;
	external set attached(CameraInputsMap<TCamera> value);
	
	/// Defines the dom element the camera is collecting inputs from.
	/// This is null if the controls have not been attached.
	external bool get attachedToElement;
	external set attachedToElement(bool value);
	
	/// Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	external bool get noPreventDefault;
	external set noPreventDefault(bool value);
	
	/// Defined the camera the input manager belongs to.
	external TCamera get camera;
	external set camera(TCamera value);
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
	
	/// Add an input method to a camera
	/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
	/// @param input camera input method
	external void add(ICameraInput<TCamera> input);
	
	/// Remove a specific input method from a camera
	/// example: camera.inputs.remove(camera.inputs.attached.mouse);
	/// @param inputToRemove camera input method
	external void remove(ICameraInput<TCamera> inputToRemove);
	
	/// Remove a specific input type from a camera
	/// example: camera.inputs.remove("ArcRotateCameraGamepadInput");
	/// @param inputType the type of the input to remove
	external void removeByType(String inputType);
	
	/// Attach the input controls to the currently attached dom element to listen the events from.
	/// @param input Defines the input to attach
	external void attachInput(ICameraInput<TCamera> input);
	
	/// Attach the current manager inputs controls to a specific dom element to listen the events from.
	/// @param element Defines the dom element to collect the events from
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	external void attachElement([bool? noPreventDefault]);
	
	/// Detach the current manager inputs controls from a specific dom element.
	/// @param element Defines the dom element to collect the events from
	/// @param disconnect Defines whether the input should be removed from the current list of attached inputs
	external void detachElement([bool? disconnect]);
	
	/// Rebuild the dynamic inputCheck function from the current list of
	/// defined inputs in the manager.
	external void rebuildInputCheck();
	
	/// Remove all attached input methods from a camera
	external void clear();
	
	/// Serialize the current input manager attached to a camera.
	/// This ensures than once parsed,
	/// the input associated to the camera will be identical to the current ones
	/// @param serializedCamera Defines the camera serialization JSON the input serialization should write to
	external void serialize(dynamic serializedCamera);
	
	/// Parses an input manager serialized JSON to restore the previous list of inputs
	/// and states associated to a camera.
	/// @param parsedCamera Defines the JSON to parse
	external void parse(dynamic parsedCamera);
}

/// Gather the list of keyboard event types as constants.
@JS()
class KeyboardEventTypes {
	external factory KeyboardEventTypes();
	
	/// The keydown event is fired when a key becomes active (pressed).
	external static num get KEYDOWN;
	
	/// The keyup event is fired when a key has been released.
	external static num get KEYUP;
}

/// This class is used to store keyboard related info for the onKeyboardObservable event.
@JS()
class KeyboardInfo {
	
	/// Instantiates a new keyboard info.
	/// This class is used to store keyboard related info for the onKeyboardObservable event.
	/// @param type Defines the type of event (KeyboardEventTypes)
	/// @param event Defines the related dom event
	external factory KeyboardInfo(num type, HTML.KeyboardEvent event);
	
	/// Defines the type of event (KeyboardEventTypes)
	external num get type;
	external set type(num value);
	
	/// Defines the related dom event
	external HTML.KeyboardEvent get event;
	external set event(HTML.KeyboardEvent value);
}

/// This class is used to store keyboard related info for the onPreKeyboardObservable event.
/// Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
@JS()
class KeyboardInfoPre extends KeyboardInfo {
	
	/// Instantiates a new keyboard pre info.
	/// This class is used to store keyboard related info for the onPreKeyboardObservable event.
	/// @param type Defines the type of event (KeyboardEventTypes)
	/// @param event Defines the related dom event
	external factory KeyboardInfoPre(num type, HTML.KeyboardEvent event);
	
	/// Defines the type of event (KeyboardEventTypes)
	@override
	external num get type;
	@override
	external set type(num value);
	
	/// Defines the related dom event
	@override
	external HTML.KeyboardEvent get event;
	@override
	external set event(HTML.KeyboardEvent value);
	
	/// Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
	external bool get skipOnPointerObservable;
	external set skipOnPointerObservable(bool value);
}

/// Manage the keyboard inputs to control the movement of a free camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {
	external factory FreeCameraKeyboardMoveInput();
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 16 */
	@override
	external FreeCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Gets or Set the list of keyboard keys used to control the forward move of the camera.
	external List<num> get keysUp;
	external set keysUp(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the upward move of the camera.
	external List<num> get keysUpward;
	external set keysUpward(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the backward move of the camera.
	external List<num> get keysDown;
	external set keysDown(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the downward move of the camera.
	external List<num> get keysDownward;
	external set keysDownward(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
	external List<num> get keysLeft;
	external set keysLeft(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
	external List<num> get keysRight;
	external set keysRight(List<num> value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Interface used to define Action
@JS()
abstract class IAction {
	
	/// Trigger for the action
	external num get trigger;
	external set trigger(num value);
	
	/// Options of the trigger
	external dynamic get triggerOptions;
	external set triggerOptions(dynamic value);
	
	/// Gets the trigger parameters
	/// @returns the trigger parameters
	external dynamic getTriggerParameter();
	
	/// Serialize placeholder for child classes
	/// @param parent of child
	/// @returns the serialized object
	external dynamic serialize(dynamic parent);
	
	/// Adds action to chain of actions, may be a DoNothingAction
	/// @param action defines the next action to execute
	/// @returns The action passed in
	/// @see https://www.babylonjs-playground.com/#1T30HR#0
	external IAction then(IAction action);
}

/// The action to be carried out following a trigger
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#available-actions
@JS()
class Action implements IAction {
	
	/// Creates a new Action
	/// @param triggerOptions the trigger, with or without parameters, for the action
	/// @param condition an optional determinant of action
	external factory Action(dynamic triggerOptions, [Condition? condition]);
	
	/// the trigger, with or without parameters, for the action
	@override
	external dynamic get triggerOptions;
	@override
	external set triggerOptions(dynamic value);
	
	/// Trigger for the action
	@override
	external num get trigger;
	@override
	external set trigger(num value);
	
	/// An event triggered prior to action being executed.
	external Observable<Action> get onBeforeExecuteObservable;
	external set onBeforeExecuteObservable(Observable<Action> value);
	
	/// Gets the trigger parameters
	/// @returns the trigger parameters
	@override
	external dynamic getTriggerParameter();
	
	/// Execute placeholder for child classes
	/// @param evt optional action event
	external void execute([ActionEvent? evt]);
	
	/// Skips to next active action
	external void skipToNextActiveAction();
	
	/* Manual Fix 7 */
	
	/// Adds action to chain of actions, may be a DoNothingAction
	/// @param action defines the next action to execute
	/// @returns The action passed in
	/// @see https://www.babylonjs-playground.com/#1T30HR#0
	@override
	external Action then(IAction action);
	
	/// Serialize placeholder for child classes
	/// @param parent of child
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// A Condition applied to an Action
@JS()
class Condition {
	
	/// Creates a new Condition
	/// @param actionManager the manager of the action the condition is applied to
	external factory Condition(ActionManager actionManager);
	
	/// Check if the current condition is valid
	/// @returns a boolean
	external bool isValid();
	
	/// Serialize placeholder for child classes
	/// @returns the serialized object
	external dynamic serialize();
}

/// Defines specific conditional operators as extensions of Condition
@JS()
class ValueCondition extends Condition {
	
	/// Creates a new ValueCondition
	/// @param actionManager manager for the action the condition applies to
	/// @param target for the action
	/// @param propertyPath path to specify the property of the target the conditional operator uses
	/// @param value the value compared by the conditional operator against the current value of the property
	/// @param operator the conditional operator, default ValueCondition.IsEqual
	external factory ValueCondition(ActionManager actionManager, dynamic target, String propertyPath, dynamic value, [num? operator]);
	
	/// path to specify the property of the target the conditional operator uses
	external String get propertyPath;
	external set propertyPath(String value);
	
	/// the value compared by the conditional operator against the current value of the property
	external dynamic get value;
	external set value(dynamic value);
	
	/// the conditional operator, default ValueCondition.IsEqual
	external num get operator;
	external set operator(num value);
	
	/// returns the number for IsEqual
	external static num get IsEqual;
	
	/// Returns the number for IsDifferent
	external static num get IsDifferent;
	
	/// Returns the number for IsGreater
	external static num get IsGreater;
	
	/// Returns the number for IsLesser
	external static num get IsLesser;
	
	/// Compares the given value with the property value for the specified conditional operator
	/// @returns the result of the comparison
	@override
	external bool isValid();
	
	/// Serialize the ValueCondition into a JSON compatible object
	/// @returns serialization object
	@override
	external dynamic serialize();
	
	/// Gets the name of the conditional operator for the ValueCondition
	/// @param operator the conditional operator
	/// @returns the name
	external static String GetOperatorName(num operator);
}

/// Defines a predicate condition as an extension of Condition
@JS()
class PredicateCondition extends Condition {
	
	/// Creates a new PredicateCondition
	/// @param actionManager manager for the action the condition applies to
	/// @param predicate defines the predicate function used to validate the condition
	external factory PredicateCondition(ActionManager actionManager, bool Function() predicate);
	
	/// defines the predicate function used to validate the condition
	external bool Function() get predicate;
	external set predicate(bool Function() value);
	
	/// @returns the validity of the predicate condition
	@override
	external bool isValid();
}

/// Defines a state condition as an extension of Condition
@JS()
class StateCondition extends Condition {
	
	/// Creates a new StateCondition
	/// @param actionManager manager for the action the condition applies to
	/// @param target of the condition
	/// @param value to compare with target state
	external factory StateCondition(ActionManager actionManager, dynamic target, String value);
	
	/// Value to compare with target state
	external String get value;
	external set value(String value);
	
	/// Gets a boolean indicating if the current condition is met
	/// @returns the validity of the state
	@override
	external bool isValid();
	
	/// Serialize the StateCondition into a JSON compatible object
	/// @returns serialization object
	@override
	external dynamic serialize();
}

/// This defines an action responsible to toggle a boolean once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class SwitchBooleanAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the object containing the boolean
	/// @param propertyPath defines the path to the boolean property in the target object
	/// @param condition defines the trigger related conditions
	external factory SwitchBooleanAction(dynamic triggerOptions, dynamic target, String propertyPath, [Condition? condition]);
	
	/// The path to the boolean property in the target object
	external String get propertyPath;
	external set propertyPath(String value);
	
	/// Execute the action toggle the boolean value.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to set a the state field of the target
/// to a desired value once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class SetStateAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the object containing the state property
	/// @param value defines the value to store in the state field
	/// @param condition defines the trigger related conditions
	external factory SetStateAction(dynamic triggerOptions, dynamic target, String value, [Condition? condition]);
	
	/// The value to store in the state field.
	external String get value;
	external set value(String value);
	
	/// Execute the action and store the value on the target state property.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to set a property of the target
/// to a desired value once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class SetValueAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the object containing the property
	/// @param propertyPath defines the path of the property to set in the target
	/// @param value defines the value to set in the property
	/// @param condition defines the trigger related conditions
	external factory SetValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [Condition? condition]);
	
	/// The path of the property to set in the target.
	external String get propertyPath;
	external set propertyPath(String value);
	
	/// The value to set in the property
	external dynamic get value;
	external set value(dynamic value);
	
	/// Execute the action and set the targetted property to the desired value.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to increment the target value
/// to a desired value once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class IncrementValueAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the object containing the property
	/// @param propertyPath defines the path of the property to increment in the target
	/// @param value defines the value value we should increment the property by
	/// @param condition defines the trigger related conditions
	external factory IncrementValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [Condition? condition]);
	
	/// The path of the property to increment in the target.
	external String get propertyPath;
	external set propertyPath(String value);
	
	/// The value we should increment the property by.
	external dynamic get value;
	external set value(dynamic value);
	
	/// Execute the action and increment the target of the value amount.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to start an animation once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class PlayAnimationAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the target animation or animation name
	/// @param from defines from where the animation should start (animation frame)
	/// @param end defines where the animation should stop (animation frame)
	/// @param loop defines if the animation should loop or stop after the first play
	/// @param condition defines the trigger related conditions
	external factory PlayAnimationAction(dynamic triggerOptions, dynamic target, num from, num to, [bool? loop, Condition? condition]);
	
	/// Where the animation should start (animation frame)
	external num get from;
	external set from(num value);
	
	/// Where the animation should stop (animation frame)
	external num get to;
	external set to(num value);
	
	/// Define if the animation should loop or stop after the first play.
	external bool get loop;
	external set loop(bool value);
	
	/// Execute the action and play the animation.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to stop an animation once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class StopAnimationAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the target animation or animation name
	/// @param condition defines the trigger related conditions
	external factory StopAnimationAction(dynamic triggerOptions, dynamic target, [Condition? condition]);
	
	/// Execute the action and stop the animation.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible that does nothing once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class DoNothingAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param condition defines the trigger related conditions
	external factory DoNothingAction([dynamic? triggerOptions, Condition? condition]);
	
	/// Execute the action and do nothing.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to trigger several actions once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class CombineAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param children defines the list of aggregated animations to run
	/// @param condition defines the trigger related conditions
	external factory CombineAction(dynamic triggerOptions, List<Action> children, [Condition? condition]);
	
	/// The list of aggregated animations to run.
	external List<Action> get children;
	external set children(List<Action> value);
	
	/// Execute the action and executes all the aggregated actions.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to run code (external event) once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class ExecuteCodeAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param func defines the callback function to run
	/// @param condition defines the trigger related conditions
	external factory ExecuteCodeAction(dynamic triggerOptions, void Function(ActionEvent evt) func, [Condition? condition]);
	
	/// The callback function to run.
	external void Function(ActionEvent evt) get func;
	external set func(void Function(ActionEvent evt) value);
	
	/// Execute the action and run the attached code.
	@override
	external void execute([ActionEvent? evt]);
}

/// This defines an action responsible to set the parent property of the target once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class SetParentAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the target containing the parent property
	/// @param parent defines from where the animation should start (animation frame)
	/// @param condition defines the trigger related conditions
	external factory SetParentAction(dynamic triggerOptions, dynamic target, dynamic parent, [Condition? condition]);
	
	/// Execute the action and set the parent property.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// Action Manager manages all events to be triggered on a given mesh or the global scene.
/// A single scene can have many Action Managers to handle predefined actions on specific meshes.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class ActionManager extends AbstractActionManager {
	
	/// Creates a new action manager
	/// @param scene defines the hosting scene
	external factory ActionManager(Scene scene);
	
	/// Nothing
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get NothingTrigger;
	
	/// On pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnPickTrigger;
	
	/// On left pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnLeftPickTrigger;
	
	/// On right pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnRightPickTrigger;
	
	/// On center pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnCenterPickTrigger;
	
	/// On pick down
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnPickDownTrigger;
	
	/// On double pick
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnDoublePickTrigger;
	
	/// On pick up
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnPickUpTrigger;
	
	/// On pick out.
	/// This trigger will only be raised if you also declared a OnPickDown
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnPickOutTrigger;
	
	/// On long press
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnLongPressTrigger;
	
	/// On pointer over
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnPointerOverTrigger;
	
	/// On pointer out
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnPointerOutTrigger;
	
	/// On every frame
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnEveryFrameTrigger;
	
	/// On intersection enter
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnIntersectionEnterTrigger;
	
	/// On intersection exit
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnIntersectionExitTrigger;
	
	/// On key down
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnKeyDownTrigger;
	
	/// On key up
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
	external static num get OnKeyUpTrigger;
	
	/// Releases all associated resources
	@override
	external void dispose();
	
	/// Gets hosting scene
	/// @returns the hosting scene
	external Scene getScene();
	
	/// Does this action manager handles actions of any of the given triggers
	/// @param triggers defines the triggers to be tested
	/// @return a boolean indicating whether one (or more) of the triggers is handled
	@override
	external bool hasSpecificTriggers(List<num> triggers);
	
	/// Does this action manager handles actions of any of the given triggers. This function takes two arguments for
	/// speed.
	/// @param triggerA defines the trigger to be tested
	/// @param triggerB defines the trigger to be tested
	/// @return a boolean indicating whether one (or more) of the triggers is handled
	@override
	external bool hasSpecificTriggers2(num triggerA, num triggerB);
	
	/// Does this action manager handles actions of a given trigger
	/// @param trigger defines the trigger to be tested
	/// @param parameterPredicate defines an optional predicate to filter triggers by parameter
	/// @return whether the trigger is handled
	@override
	external bool hasSpecificTrigger(num trigger, [bool Function(dynamic parameter)? parameterPredicate]);
	
	/// Does this action manager has pointer triggers
	@override
	external bool get hasPointerTriggers;
	
	/// Does this action manager has pick triggers
	@override
	external bool get hasPickTriggers;
	
	/// Registers an action to this action manager
	/// @param action defines the action to be registered
	/// @return the action amended (prepared) after registration
	@override
	external IAction? registerAction(IAction action);
	
	/// Unregisters an action to this action manager
	/// @param action defines the action to be unregistered
	/// @return a boolean indicating whether the action has been unregistered
	@override
	external bool unregisterAction(IAction action);
	
	/// Process a specific trigger
	/// @param trigger defines the trigger to process
	/// @param evt defines the event details to be processed
	@override
	external void processTrigger(num trigger, [IActionEvent? evt]);
	
	/// Serialize this manager to a JSON object
	/// @param name defines the property name to store this manager
	/// @returns a JSON representation of this manager
	@override
	external dynamic serialize(String name);
	
	/// Creates a new ActionManager from a JSON data
	/// @param parsedActions defines the JSON data to read from
	/// @param object defines the hosting mesh
	/// @param scene defines the hosting scene
	external static void Parse(dynamic parsedActions, AbstractMesh? object, Scene scene);
	
	/// Get a trigger name by index
	/// @param trigger defines the trigger index
	/// @returns a trigger name
	external static String GetTriggerName(num trigger);
}

/// Class representing a ray with position and direction
@JS()
class Ray {
	
	/// Creates a new ray
	/// @param origin origin point
	/// @param direction direction
	/// @param length length of the ray
	external factory Ray(Vector3 origin, Vector3 direction, [num? length]);
	
	/// origin point
	external Vector3 get origin;
	external set origin(Vector3 value);
	
	/// direction
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// length of the ray
	external num get length;
	external set length(num value);
	
	/// Checks if the ray intersects a box
	/// This does not account for the ray lenght by design to improve perfs.
	/// @param minimum bound of the box
	/// @param maximum bound of the box
	/// @param intersectionTreshold extra extend to be added to the box in all direction
	/// @returns if the box was hit
	external bool intersectsBoxMinMax(Vector3 minimum, Vector3 maximum, [num? intersectionTreshold]);
	
	/// Checks if the ray intersects a box
	/// This does not account for the ray lenght by design to improve perfs.
	/// @param box the bounding box to check
	/// @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
	/// @returns if the box was hit
	external bool intersectsBox(BoundingBox box, [num? intersectionTreshold]);
	
	/// If the ray hits a sphere
	/// @param sphere the bounding sphere to check
	/// @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
	/// @returns true if it hits the sphere
	external bool intersectsSphere(BoundingSphere sphere, [num? intersectionTreshold]);
	
	/// If the ray hits a triange
	/// @param vertex0 triangle vertex
	/// @param vertex1 triangle vertex
	/// @param vertex2 triangle vertex
	/// @returns intersection information if hit
	external IntersectionInfo? intersectsTriangle(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2);
	
	/// Checks if ray intersects a plane
	/// @param plane the plane to check
	/// @returns the distance away it was hit
	external num? intersectsPlane(Plane plane);
	
	/// Calculate the intercept of a ray on a given axis
	/// @param axis to check 'x' | 'y' | 'z'
	/// @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
	/// @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
	external Vector3? intersectsAxis(String axis, [num? offset]);
	
	/// Checks if ray intersects a mesh
	/// @param mesh the mesh to check
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @returns picking info of the intersecton
	external PickingInfo intersectsMesh(AbstractMesh mesh, [bool? fastCheck]);
	
	/// Checks if ray intersects a mesh
	/// @param meshes the meshes to check
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param results array to store result in
	/// @returns Array of picking infos
	external List<PickingInfo> intersectsMeshes(List<AbstractMesh> meshes, [bool? fastCheck, List<PickingInfo>? results]);
	
	/// Intersection test between the ray and a given segment whithin a given tolerance (threshold)
	/// @param sega the first point of the segment to test the intersection against
	/// @param segb the second point of the segment to test the intersection against
	/// @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
	/// @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
	external num intersectionSegment(Vector3 sega, Vector3 segb, num threshold);
	
	/// Update the ray from viewport position
	/// @param x position
	/// @param y y position
	/// @param viewportWidth viewport width
	/// @param viewportHeight viewport height
	/// @param world world matrix
	/// @param view view matrix
	/// @param projection projection matrix
	/// @returns this ray updated
	external Ray update(num x, num y, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);
	
	/// Creates a ray with origin and direction of 0,0,0
	/// @returns the new ray
	external static Ray Zero();
	
	/// Creates a new ray from screen space and viewport
	/// @param x position
	/// @param y y position
	/// @param viewportWidth viewport width
	/// @param viewportHeight viewport height
	/// @param world world matrix
	/// @param view view matrix
	/// @param projection projection matrix
	/// @returns new ray
	external static Ray CreateNew(num x, num y, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);
	
	/// Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
	/// transformed to the given world matrix.
	/// @param origin The origin point
	/// @param end The end point
	/// @param world a matrix to transform the ray to. Default is the identity matrix.
	/// @returns the new ray
	external static Ray CreateNewFromTo(Vector3 origin, Vector3 end, [Matrix? world]);
	
	/// Transforms a ray by a matrix
	/// @param ray ray to transform
	/// @param matrix matrix to apply
	/// @returns the resulting new ray
	external static Ray Transform(Ray ray, Matrix matrix);
	
	/// Transforms a ray by a matrix
	/// @param ray ray to transform
	/// @param matrix matrix to apply
	/// @param result ray to store result in
	external static void TransformToRef(Ray ray, Matrix matrix, Ray result);
	
	/// Unproject a ray from screen space to object space
	/// @param sourceX defines the screen space x coordinate to use
	/// @param sourceY defines the screen space y coordinate to use
	/// @param viewportWidth defines the current width of the viewport
	/// @param viewportHeight defines the current height of the viewport
	/// @param world defines the world matrix to use (can be set to Identity to go to world space)
	/// @param view defines the view matrix to use
	/// @param projection defines the projection matrix to use
	external void unprojectRayToRef(dynamic sourceX, dynamic sourceY, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);
}

/// Represents a scene to be rendered by the engine.
/// @see https://doc.babylonjs.com/features/scene
@JS()
class Scene extends AbstractScene implements IAnimatable, IClipPlanesHolder {
	
	/// Creates a new Scene
	/// @param engine defines the engine to use to render this scene
	/// @param options defines the scene options
	external factory Scene(Engine engine, [SceneOptions? options]);
	
	/// The fog is deactivated
	external static num get FOGMODE_NONE;
	
	/// The fog density is following an exponential function
	external static num get FOGMODE_EXP;
	
	/// The fog density is following an exponential function faster than FOGMODE_EXP
	external static num get FOGMODE_EXP2;
	
	/// The fog density is following a linear function.
	external static num get FOGMODE_LINEAR;
	
	/// Gets or sets the minimum deltatime when deterministic lock step is enabled
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	external static num get MinDeltaTime;
	external static set MinDeltaTime(num value);
	
	/// Gets or sets the maximum deltatime when deterministic lock step is enabled
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	external static num get MaxDeltaTime;
	external static set MaxDeltaTime(num value);
	
	/// Factory used to create the default material.
	/// @param name The name of the material to create
	/// @param scene The scene to create the material for
	/// @returns The default material
	external static Material DefaultMaterialFactory(Scene scene);
	
	/// Factory used to create the a collision coordinator.
	/// @returns The collision coordinator
	external static ICollisionCoordinator CollisionCoordinatorFactory();
	
	/// Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position
	external Camera? get cameraToUseForPointers;
	external set cameraToUseForPointers(Camera? value);
	
	/// Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame
	external bool get autoClear;
	external set autoClear(bool value);
	
	/// Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame
	external bool get autoClearDepthAndStencil;
	external set autoClearDepthAndStencil(bool value);
	
	/// Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
	external Color4 get clearColor;
	external set clearColor(Color4 value);
	
	/// Defines the color used to simulate the ambient color (Default is (0, 0, 0))
	external Color3 get ambientColor;
	external set ambientColor(Color3 value);
	
	/// This is use to store the default BRDF lookup for PBR materials in your scene.
	/// It should only be one of the following (if not the default embedded one):
	/// * For uncorrelated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = false) : https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds
	/// * For correlated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedBRDF.dds
	/// * For correlated multi scattering BRDF (pbr.brdf.useEnergyConservation = true and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedMSBRDF.dds
	/// The material properties need to be setup according to the type of texture in use.
	external BaseTexture get environmentBRDFTexture;
	external set environmentBRDFTexture(BaseTexture value);
	
	/// Texture used in all pbr material as the reflection texture.
	/// As in the majority of the scene they are the same (exception for multi room and so on),
	/// this is easier to reference from here than from all the materials.
	@override
	external BaseTexture? get environmentTexture;
	
	/// Texture used in all pbr material as the reflection texture.
	/// As in the majority of the scene they are the same (exception for multi room and so on),
	/// this is easier to set here than in all the materials.
	@override
	external set environmentTexture(BaseTexture? value);
	
	/// Intensity of the environment in all pbr material.
	/// This dims or reinforces the IBL lighting overall (reflection and diffuse).
	/// As in the majority of the scene they are the same (exception for multi room and so on),
	/// this is easier to reference from here than from all the materials.
	external num get environmentIntensity;
	
	/// Intensity of the environment in all pbr material.
	/// This dims or reinforces the IBL lighting overall (reflection and diffuse).
	/// As in the majority of the scene they are the same (exception for multi room and so on),
	/// this is easier to set here than in all the materials.
	external set environmentIntensity(num value);
	
	/// Default image processing configuration used either in the rendering
	/// Forward main pass or through the imageProcessingPostProcess if present.
	/// As in the majority of the scene they are the same (exception for multi camera),
	/// this is easier to reference from here than from all the materials and post process.
	/// 
	/// No setter as we it is a shared configuration, you can set the values instead.
	external ImageProcessingConfiguration get imageProcessingConfiguration;
	
	/// Gets or sets a boolean indicating if all rendering must be done in wireframe
	external set forceWireframe(bool value);
	
	external bool get forceWireframe;
	
	/// Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection
	external set skipFrustumClipping(bool value);
	
	external bool get skipFrustumClipping;
	
	/// Gets or sets a boolean indicating if all rendering must be done in point cloud
	external set forcePointsCloud(bool value);
	
	external bool get forcePointsCloud;
	
	/// Gets or sets the active clipplane 1
	@override
	external Plane? get clipPlane;
	@override
	external set clipPlane(Plane? value);
	
	/// Gets or sets the active clipplane 2
	@override
	external Plane? get clipPlane2;
	@override
	external set clipPlane2(Plane? value);
	
	/// Gets or sets the active clipplane 3
	@override
	external Plane? get clipPlane3;
	@override
	external set clipPlane3(Plane? value);
	
	/// Gets or sets the active clipplane 4
	@override
	external Plane? get clipPlane4;
	@override
	external set clipPlane4(Plane? value);
	
	/// Gets or sets the active clipplane 5
	@override
	external Plane? get clipPlane5;
	@override
	external set clipPlane5(Plane? value);
	
	/// Gets or sets the active clipplane 6
	@override
	external Plane? get clipPlane6;
	@override
	external set clipPlane6(Plane? value);
	
	/// Gets or sets a boolean indicating if animations are enabled
	external bool get animationsEnabled;
	external set animationsEnabled(bool value);
	
	/// Gets or sets the animation properties override
	external AnimationPropertiesOverride? get animationPropertiesOverride;
	
	external set animationPropertiesOverride(AnimationPropertiesOverride? value);
	
	/// Gets or sets a boolean indicating if a constant deltatime has to be used
	/// This is mostly useful for testing purposes when you do not want the animations to scale with the framerate
	external bool get useConstantAnimationDeltaTime;
	external set useConstantAnimationDeltaTime(bool value);
	
	/// Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated
	/// Please note that it requires to run a ray cast through the scene on every frame
	external bool get constantlyUpdateMeshUnderPointer;
	external set constantlyUpdateMeshUnderPointer(bool value);
	
	/// Defines the HTML cursor to use when hovering over interactive elements
	external String get hoverCursor;
	external set hoverCursor(String value);
	
	/// Defines the HTML default cursor to use (empty by default)
	external String get defaultCursor;
	external set defaultCursor(String value);
	
	/// Defines whether cursors are handled by the scene.
	external bool get doNotHandleCursors;
	external set doNotHandleCursors(bool value);
	
	/// This is used to call preventDefault() on pointer down
	/// in order to block unwanted artifacts like system double clicks
	external bool get preventDefaultOnPointerDown;
	external set preventDefaultOnPointerDown(bool value);
	
	/// This is used to call preventDefault() on pointer up
	/// in order to block unwanted artifacts like system double clicks
	external bool get preventDefaultOnPointerUp;
	external set preventDefaultOnPointerUp(bool value);
	
	/// Gets or sets user defined metadata
	external dynamic get metadata;
	external set metadata(dynamic value);
	
	/// For internal use only. Please do not use.
	external dynamic get reservedDataStore;
	external set reservedDataStore(dynamic value);
	
	/// Gets the name of the plugin used to load this scene (null by default)
	external String get loadingPluginName;
	external set loadingPluginName(String value);
	
	/// Use this array to add regular expressions used to disable offline support for specific urls
	external List<RegExp> get disableOfflineSupportExceptionRules;
	external set disableOfflineSupportExceptionRules(List<RegExp> value);
	
	/// An event triggered when the scene is disposed.
	external Observable<Scene> get onDisposeObservable;
	external set onDisposeObservable(Observable<Scene> value);
	
	/// Sets a function to be executed when this scene is disposed.
	external set onDispose(void Function() value);
	
	/// An event triggered before rendering the scene (right after animations and physics)
	external Observable<Scene> get onBeforeRenderObservable;
	external set onBeforeRenderObservable(Observable<Scene> value);
	
	/// Sets a function to be executed before rendering this scene
	external set beforeRender(void Function()? value);
	
	/// An event triggered after rendering the scene
	external Observable<Scene> get onAfterRenderObservable;
	external set onAfterRenderObservable(Observable<Scene> value);
	
	/// An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)
	external Observable<Camera> get onAfterRenderCameraObservable;
	external set onAfterRenderCameraObservable(Observable<Camera> value);
	
	/// Sets a function to be executed after rendering this scene
	external set afterRender(void Function()? value);
	
	/// An event triggered before animating the scene
	external Observable<Scene> get onBeforeAnimationsObservable;
	external set onBeforeAnimationsObservable(Observable<Scene> value);
	
	/// An event triggered after animations processing
	external Observable<Scene> get onAfterAnimationsObservable;
	external set onAfterAnimationsObservable(Observable<Scene> value);
	
	/// An event triggered before draw calls are ready to be sent
	external Observable<Scene> get onBeforeDrawPhaseObservable;
	external set onBeforeDrawPhaseObservable(Observable<Scene> value);
	
	/// An event triggered after draw calls have been sent
	external Observable<Scene> get onAfterDrawPhaseObservable;
	external set onAfterDrawPhaseObservable(Observable<Scene> value);
	
	/// An event triggered when the scene is ready
	external Observable<Scene> get onReadyObservable;
	external set onReadyObservable(Observable<Scene> value);
	
	/// An event triggered before rendering a camera
	external Observable<Camera> get onBeforeCameraRenderObservable;
	external set onBeforeCameraRenderObservable(Observable<Camera> value);
	
	/// Sets a function to be executed before rendering a camera
	external set beforeCameraRender(void Function() value);
	
	/// An event triggered after rendering a camera
	external Observable<Camera> get onAfterCameraRenderObservable;
	external set onAfterCameraRenderObservable(Observable<Camera> value);
	
	/// Sets a function to be executed after rendering a camera
	external set afterCameraRender(void Function() value);
	
	/// An event triggered when active meshes evaluation is about to start
	external Observable<Scene> get onBeforeActiveMeshesEvaluationObservable;
	external set onBeforeActiveMeshesEvaluationObservable(Observable<Scene> value);
	
	/// An event triggered when active meshes evaluation is done
	external Observable<Scene> get onAfterActiveMeshesEvaluationObservable;
	external set onAfterActiveMeshesEvaluationObservable(Observable<Scene> value);
	
	/// An event triggered when particles rendering is about to start
	/// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
	external Observable<Scene> get onBeforeParticlesRenderingObservable;
	external set onBeforeParticlesRenderingObservable(Observable<Scene> value);
	
	/// An event triggered when particles rendering is done
	/// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
	external Observable<Scene> get onAfterParticlesRenderingObservable;
	external set onAfterParticlesRenderingObservable(Observable<Scene> value);
	
	/// An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed
	external Observable<Scene> get onDataLoadedObservable;
	external set onDataLoadedObservable(Observable<Scene> value);
	
	/// An event triggered when a camera is created
	external Observable<Camera> get onNewCameraAddedObservable;
	external set onNewCameraAddedObservable(Observable<Camera> value);
	
	/// An event triggered when a camera is removed
	external Observable<Camera> get onCameraRemovedObservable;
	external set onCameraRemovedObservable(Observable<Camera> value);
	
	/// An event triggered when a light is created
	external Observable<Light> get onNewLightAddedObservable;
	external set onNewLightAddedObservable(Observable<Light> value);
	
	/// An event triggered when a light is removed
	external Observable<Light> get onLightRemovedObservable;
	external set onLightRemovedObservable(Observable<Light> value);
	
	/// An event triggered when a geometry is created
	external Observable<Geometry> get onNewGeometryAddedObservable;
	external set onNewGeometryAddedObservable(Observable<Geometry> value);
	
	/// An event triggered when a geometry is removed
	external Observable<Geometry> get onGeometryRemovedObservable;
	external set onGeometryRemovedObservable(Observable<Geometry> value);
	
	/// An event triggered when a transform node is created
	external Observable<TransformNode> get onNewTransformNodeAddedObservable;
	external set onNewTransformNodeAddedObservable(Observable<TransformNode> value);
	
	/// An event triggered when a transform node is removed
	external Observable<TransformNode> get onTransformNodeRemovedObservable;
	external set onTransformNodeRemovedObservable(Observable<TransformNode> value);
	
	/// An event triggered when a mesh is created
	external Observable<AbstractMesh> get onNewMeshAddedObservable;
	external set onNewMeshAddedObservable(Observable<AbstractMesh> value);
	
	/// An event triggered when a mesh is removed
	external Observable<AbstractMesh> get onMeshRemovedObservable;
	external set onMeshRemovedObservable(Observable<AbstractMesh> value);
	
	/// An event triggered when a skeleton is created
	external Observable<Skeleton> get onNewSkeletonAddedObservable;
	external set onNewSkeletonAddedObservable(Observable<Skeleton> value);
	
	/// An event triggered when a skeleton is removed
	external Observable<Skeleton> get onSkeletonRemovedObservable;
	external set onSkeletonRemovedObservable(Observable<Skeleton> value);
	
	/// An event triggered when a material is created
	external Observable<Material> get onNewMaterialAddedObservable;
	external set onNewMaterialAddedObservable(Observable<Material> value);
	
	/// An event triggered when a multi material is created
	external Observable<MultiMaterial> get onNewMultiMaterialAddedObservable;
	external set onNewMultiMaterialAddedObservable(Observable<MultiMaterial> value);
	
	/// An event triggered when a material is removed
	external Observable<Material> get onMaterialRemovedObservable;
	external set onMaterialRemovedObservable(Observable<Material> value);
	
	/// An event triggered when a multi material is removed
	external Observable<MultiMaterial> get onMultiMaterialRemovedObservable;
	external set onMultiMaterialRemovedObservable(Observable<MultiMaterial> value);
	
	/// An event triggered when a texture is created
	external Observable<BaseTexture> get onNewTextureAddedObservable;
	external set onNewTextureAddedObservable(Observable<BaseTexture> value);
	
	/// An event triggered when a texture is removed
	external Observable<BaseTexture> get onTextureRemovedObservable;
	external set onTextureRemovedObservable(Observable<BaseTexture> value);
	
	/// An event triggered when render targets are about to be rendered
	/// Can happen multiple times per frame.
	external Observable<Scene> get onBeforeRenderTargetsRenderObservable;
	external set onBeforeRenderTargetsRenderObservable(Observable<Scene> value);
	
	/// An event triggered when render targets were rendered.
	/// Can happen multiple times per frame.
	external Observable<Scene> get onAfterRenderTargetsRenderObservable;
	external set onAfterRenderTargetsRenderObservable(Observable<Scene> value);
	
	/// An event triggered before calculating deterministic simulation step
	external Observable<Scene> get onBeforeStepObservable;
	external set onBeforeStepObservable(Observable<Scene> value);
	
	/// An event triggered after calculating deterministic simulation step
	external Observable<Scene> get onAfterStepObservable;
	external set onAfterStepObservable(Observable<Scene> value);
	
	/// An event triggered when the activeCamera property is updated
	external Observable<Scene> get onActiveCameraChanged;
	external set onActiveCameraChanged(Observable<Scene> value);
	
	/// This Observable will be triggered before rendering each renderingGroup of each rendered camera.
	/// The RenderinGroupInfo class contains all the information about the context in which the observable is called
	/// If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
	external Observable<RenderingGroupInfo> get onBeforeRenderingGroupObservable;
	external set onBeforeRenderingGroupObservable(Observable<RenderingGroupInfo> value);
	
	/// This Observable will be triggered after rendering each renderingGroup of each rendered camera.
	/// The RenderinGroupInfo class contains all the information about the context in which the observable is called
	/// If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
	external Observable<RenderingGroupInfo> get onAfterRenderingGroupObservable;
	external set onAfterRenderingGroupObservable(Observable<RenderingGroupInfo> value);
	
	/// This Observable will when a mesh has been imported into the scene.
	external Observable<AbstractMesh> get onMeshImportedObservable;
	external set onMeshImportedObservable(Observable<AbstractMesh> value);
	
	/// This Observable will when an animation file has been imported into the scene.
	external Observable<Scene> get onAnimationFileImportedObservable;
	external set onAnimationFileImportedObservable(Observable<Scene> value);
	
	/// Gets or sets a user defined funtion to select LOD from a mesh and a camera.
	/// By default this function is undefined and Babylon.js will select LOD based on distance to camera
	external AbstractMesh? Function(AbstractMesh mesh, Camera camera) get customLODSelector;
	external set customLODSelector(AbstractMesh? Function(AbstractMesh mesh, Camera camera) value);
	
	/// Gets or sets a predicate used to select candidate meshes for a pointer down event
	external bool Function(AbstractMesh Mesh) get pointerDownPredicate;
	external set pointerDownPredicate(bool Function(AbstractMesh Mesh) value);
	
	/// Gets or sets a predicate used to select candidate meshes for a pointer up event
	external bool Function(AbstractMesh Mesh) get pointerUpPredicate;
	external set pointerUpPredicate(bool Function(AbstractMesh Mesh) value);
	
	/// Gets or sets a predicate used to select candidate meshes for a pointer move event
	external bool Function(AbstractMesh Mesh) get pointerMovePredicate;
	external set pointerMovePredicate(bool Function(AbstractMesh Mesh) value);
	
	/// Callback called when a pointer move is detected
	external void Function(HTML.PointerEvent evt, PickingInfo pickInfo, PointerEventTypes type) get onPointerMove;
	external set onPointerMove(void Function(HTML.PointerEvent evt, PickingInfo pickInfo, PointerEventTypes type) value);
	
	/// Callback called when a pointer down is detected
	external void Function(HTML.PointerEvent evt, PickingInfo pickInfo, PointerEventTypes type) get onPointerDown;
	external set onPointerDown(void Function(HTML.PointerEvent evt, PickingInfo pickInfo, PointerEventTypes type) value);
	
	/// Callback called when a pointer up is detected
	external void Function(HTML.PointerEvent evt, PickingInfo? pickInfo, PointerEventTypes type) get onPointerUp;
	external set onPointerUp(void Function(HTML.PointerEvent evt, PickingInfo? pickInfo, PointerEventTypes type) value);
	
	/// Callback called when a pointer pick is detected
	external void Function(HTML.PointerEvent evt, PickingInfo pickInfo) get onPointerPick;
	external set onPointerPick(void Function(HTML.PointerEvent evt, PickingInfo pickInfo) value);
	
	/// This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).
	/// You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true
	external Observable<PointerInfoPre> get onPrePointerObservable;
	external set onPrePointerObservable(Observable<PointerInfoPre> value);
	
	/// Observable event triggered each time an input event is received from the rendering canvas
	external Observable<PointerInfo> get onPointerObservable;
	external set onPointerObservable(Observable<PointerInfo> value);
	
	/// Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
	external Vector2 get unTranslatedPointer;
	
	/// Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels
	external static num get DragMovementThreshold;
	
	external static set DragMovementThreshold(num value);
	
	/// Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms
	external static num get LongPressDelay;
	
	external static set LongPressDelay(num value);
	
	/// Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms
	external static num get DoubleClickDelay;
	
	external static set DoubleClickDelay(num value);
	
	/// If you need to check double click without raising a single click at first click, enable this flag
	external static bool get ExclusiveDoubleClickMode;
	
	external static set ExclusiveDoubleClickMode(bool value);
	
	/// This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()
	/// You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true
	external Observable<KeyboardInfoPre> get onPreKeyboardObservable;
	external set onPreKeyboardObservable(Observable<KeyboardInfoPre> value);
	
	/// Observable event triggered each time an keyboard event is received from the hosting window
	external Observable<KeyboardInfo> get onKeyboardObservable;
	external set onKeyboardObservable(Observable<KeyboardInfo> value);
	
	/// Gets or sets a boolean indicating if the scene must use right-handed coordinates system
	external set useRightHandedSystem(bool value);
	
	external bool get useRightHandedSystem;
	
	/// Sets the step Id used by deterministic lock step
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @param newStepId defines the step Id
	external void setStepId(num newStepId);
	
	/// Gets the step Id used by deterministic lock step
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @returns the step Id
	external num getStepId();
	
	/// Gets the internal step used by deterministic lock step
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @returns the internal step
	external num getInternalStep();
	
	/// Gets or sets a boolean indicating if fog is enabled on this scene
	/// @see https://doc.babylonjs.com/babylon101/environment#fog
	/// (Default is true)
	external set fogEnabled(bool value);
	
	external bool get fogEnabled;
	
	/// Gets or sets the fog mode to use
	/// @see https://doc.babylonjs.com/babylon101/environment#fog
	/// | mode | value |
	/// | --- | --- |
	/// | FOGMODE_NONE | 0 |
	/// | FOGMODE_EXP | 1 |
	/// | FOGMODE_EXP2 | 2 |
	/// | FOGMODE_LINEAR | 3 |
	external set fogMode(num value);
	
	external num get fogMode;
	
	/// Gets or sets the fog color to use
	/// @see https://doc.babylonjs.com/babylon101/environment#fog
	/// (Default is Color3(0.2, 0.2, 0.3))
	external Color3 get fogColor;
	external set fogColor(Color3 value);
	
	/// Gets or sets the fog density to use
	/// @see https://doc.babylonjs.com/babylon101/environment#fog
	/// (Default is 0.1)
	external num get fogDensity;
	external set fogDensity(num value);
	
	/// Gets or sets the fog start distance to use
	/// @see https://doc.babylonjs.com/babylon101/environment#fog
	/// (Default is 0)
	external num get fogStart;
	external set fogStart(num value);
	
	/// Gets or sets the fog end distance to use
	/// @see https://doc.babylonjs.com/babylon101/environment#fog
	/// (Default is 1000)
	external num get fogEnd;
	external set fogEnd(num value);
	
	/// Flag indicating that the frame buffer binding is handled by another component
	external bool get prePass;
	external set prePass(bool value);
	
	/// Gets or sets a boolean indicating if shadows are enabled on this scene
	external set shadowsEnabled(bool value);
	
	external bool get shadowsEnabled;
	
	/// Gets or sets a boolean indicating if lights are enabled on this scene
	external set lightsEnabled(bool value);
	
	external bool get lightsEnabled;
	
	/// All of the active cameras added to this scene.
	external List<Camera>? get activeCameras;
	external set activeCameras(List<Camera>? value);
	
	/// Gets or sets the current active camera
	external Camera? get activeCamera;
	
	external set activeCamera(Camera? value);
	
	/// The default material used on meshes when no material is affected
	external Material get defaultMaterial;
	
	/// The default material used on meshes when no material is affected
	external set defaultMaterial(Material value);
	
	/// Gets or sets a boolean indicating if textures are enabled on this scene
	external set texturesEnabled(bool value);
	
	external bool get texturesEnabled;
	
	/// Gets or sets a boolean indicating if physic engines are enabled on this scene
	external bool get physicsEnabled;
	external set physicsEnabled(bool value);
	
	/// Gets or sets a boolean indicating if particles are enabled on this scene
	external bool get particlesEnabled;
	external set particlesEnabled(bool value);
	
	/// Gets or sets a boolean indicating if sprites are enabled on this scene
	external bool get spritesEnabled;
	external set spritesEnabled(bool value);
	
	/// Gets or sets a boolean indicating if skeletons are enabled on this scene
	external set skeletonsEnabled(bool value);
	
	external bool get skeletonsEnabled;
	
	/// Gets or sets a boolean indicating if lens flares are enabled on this scene
	external bool get lensFlaresEnabled;
	external set lensFlaresEnabled(bool value);
	
	/// Gets or sets a boolean indicating if collisions are enabled on this scene
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	external bool get collisionsEnabled;
	external set collisionsEnabled(bool value);
	
	/// @hidden
	external ICollisionCoordinator get collisionCoordinator;
	
	/// Defines the gravity applied to this scene (used only for collisions)
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	external Vector3 get gravity;
	external set gravity(Vector3 value);
	
	/// Gets or sets a boolean indicating if postprocesses are enabled on this scene
	external bool get postProcessesEnabled;
	external set postProcessesEnabled(bool value);
	
	/// Gets the current postprocess manager
	external PostProcessManager get postProcessManager;
	external set postProcessManager(PostProcessManager value);
	
	/// Gets or sets a boolean indicating if render targets are enabled on this scene
	external bool get renderTargetsEnabled;
	external set renderTargetsEnabled(bool value);
	
	/// Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes
	/// We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com
	external bool get dumpNextRenderTargets;
	external set dumpNextRenderTargets(bool value);
	
	/// The list of user defined render targets added to the scene
	external List<RenderTargetTexture> get customRenderTargets;
	external set customRenderTargets(List<RenderTargetTexture> value);
	
	/// Defines if texture loading must be delayed
	/// If true, textures will only be loaded when they need to be rendered
	external bool get useDelayedTextureLoading;
	external set useDelayedTextureLoading(bool value);
	
	/// Gets the list of meshes imported to the scene through SceneLoader
	external List<String> get importedMeshesFiles;
	external set importedMeshesFiles(List<String> value);
	
	/// Gets or sets a boolean indicating if probes are enabled on this scene
	external bool get probesEnabled;
	external set probesEnabled(bool value);
	
	/// Gets or sets the current offline provider to use to store scene data
	/// @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
	external IOfflineProvider get offlineProvider;
	external set offlineProvider(IOfflineProvider value);
	
	/// Gets or sets the action manager associated with the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
	external AbstractActionManager get actionManager;
	external set actionManager(AbstractActionManager value);
	
	/// Gets or sets a boolean indicating if procedural textures are enabled on this scene
	external bool get proceduralTexturesEnabled;
	external set proceduralTexturesEnabled(bool value);
	
	/// Gets or sets a general scale for animation speed
	/// @see https://www.babylonjs-playground.com/#IBU2W7#3
	external num get animationTimeScale;
	external set animationTimeScale(num value);
	
	/// Gets or sets a boolean indicating that all submeshes of active meshes must be rendered
	/// Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)
	external bool get dispatchAllSubMeshesOfActiveMeshes;
	external set dispatchAllSubMeshesOfActiveMeshes(bool value);
	
	/// Gets the list of frustum planes (built from the active camera)
	external List<Plane> get frustumPlanes;
	
	/// Gets or sets a boolean indicating if lights must be sorted by priority (off by default)
	/// This is useful if there are more lights that the maximum simulteanous authorized
	external bool get requireLightSorting;
	external set requireLightSorting(bool value);
	
	/// @hidden
	external bool get useMaterialMeshMap;
	
	/// @hidden
	external bool get useClonedMeshMap;
	
	/// Gets a string identifying the name of the class
	/// @returns "Scene" string
	external String getClassName();
	
	/// Sets the default candidate providers for the scene.
	/// This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates
	/// and getCollidingSubMeshCandidates to their default function
	external void setDefaultCandidateProviders();
	
	/// Gets the mesh that is currently under the pointer
	external AbstractMesh? get meshUnderPointer;
	
	/// Gets or sets the current on-screen X position of the pointer
	external num get pointerX;
	
	external set pointerX(num value);
	
	/// Gets or sets the current on-screen Y position of the pointer
	external num get pointerY;
	
	external set pointerY(num value);
	
	/// Gets the cached material (ie. the latest rendered one)
	/// @returns the cached material
	external Material? getCachedMaterial();
	
	/// Gets the cached effect (ie. the latest rendered one)
	/// @returns the cached effect
	external Effect? getCachedEffect();
	
	/// Gets the cached visibility state (ie. the latest rendered one)
	/// @returns the cached visibility state
	external num? getCachedVisibility();
	
	/// Gets a boolean indicating if the current material / effect / visibility must be bind again
	/// @param material defines the current material
	/// @param effect defines the current effect
	/// @param visibility defines the current visibility state
	/// @returns true if one parameter is not cached
	external bool isCachedMaterialInvalid(Material material, Effect effect, [num? visibility]);
	
	/// Gets the engine associated with the scene
	/// @returns an Engine
	external Engine getEngine();
	
	/// Gets the total number of vertices rendered per frame
	/// @returns the total number of vertices rendered per frame
	external num getTotalVertices();
	
	/// Gets the performance counter for total vertices
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
	external PerfCounter get totalVerticesPerfCounter;
	
	/// Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
	/// @returns the total number of active indices rendered per frame
	external num getActiveIndices();
	
	/// Gets the performance counter for active indices
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
	external PerfCounter get totalActiveIndicesPerfCounter;
	
	/// Gets the total number of active particles rendered per frame
	/// @returns the total number of active particles rendered per frame
	external num getActiveParticles();
	
	/// Gets the performance counter for active particles
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
	external PerfCounter get activeParticlesPerfCounter;
	
	/// Gets the total number of active bones rendered per frame
	/// @returns the total number of active bones rendered per frame
	external num getActiveBones();
	
	/// Gets the performance counter for active bones
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
	external PerfCounter get activeBonesPerfCounter;
	
	/// Gets the array of active meshes
	/// @returns an array of AbstractMesh
	external SmartArray<AbstractMesh> getActiveMeshes();
	
	/// Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
	/// @returns a number
	external num getAnimationRatio();
	
	/// Gets an unique Id for the current render phase
	/// @returns a number
	external num getRenderId();
	
	/// Gets an unique Id for the current frame
	/// @returns a number
	external num getFrameId();
	
	/// Call this function if you want to manually increment the render Id
	external void incrementRenderId();
	
	/// Use this method to simulate a pointer move on a mesh
	/// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
	/// @param pickResult pickingInfo of the object wished to simulate pointer event on
	/// @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
	/// @returns the current scene
	external Scene simulatePointerMove(PickingInfo pickResult, [dynamic /* unresolved: PointerEventInit */? pointerEventInit]);
	
	/// Use this method to simulate a pointer down on a mesh
	/// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
	/// @param pickResult pickingInfo of the object wished to simulate pointer event on
	/// @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
	/// @returns the current scene
	external Scene simulatePointerDown(PickingInfo pickResult, [dynamic /* unresolved: PointerEventInit */? pointerEventInit]);
	
	/// Use this method to simulate a pointer up on a mesh
	/// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
	/// @param pickResult pickingInfo of the object wished to simulate pointer event on
	/// @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
	/// @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
	/// @returns the current scene
	external Scene simulatePointerUp(PickingInfo pickResult, [dynamic /* unresolved: PointerEventInit */? pointerEventInit, bool? doubleTap]);
	
	/// Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
	/// @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
	/// @returns true if the pointer was captured
	external bool isPointerCaptured([num? pointerId]);
	
	/// Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
	/// @param attachUp defines if you want to attach events to pointerup
	/// @param attachDown defines if you want to attach events to pointerdown
	/// @param attachMove defines if you want to attach events to pointermove
	external void attachControl([bool? attachUp, bool? attachDown, bool? attachMove]);
	
	/// Detaches all event handlers
	external void detachControl();
	
	/// This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
	/// Delay loaded resources are not taking in account
	/// @return true if all required resources are ready
	external bool isReady();
	
	/// Resets all cached information relative to material (including effect and visibility)
	external void resetCachedMaterial();
	
	/// Registers a function to be called before every frame render
	/// @param func defines the function to register
	external void registerBeforeRender(void Function() func);
	
	/// Unregisters a function called before every frame render
	/// @param func defines the function to unregister
	external void unregisterBeforeRender(void Function() func);
	
	/// Registers a function to be called after every frame render
	/// @param func defines the function to register
	external void registerAfterRender(void Function() func);
	
	/// Unregisters a function called after every frame render
	/// @param func defines the function to unregister
	external void unregisterAfterRender(void Function() func);
	
	/// The provided function will run before render once and will be disposed afterwards.
	/// A timeout delay can be provided so that the function will be executed in N ms.
	/// The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.
	/// @param func The function to be executed.
	/// @param timeout optional delay in ms
	external void executeOnceBeforeRender(void Function() func, [num? timeout]);
	
	/// Returns the number of items waiting to be loaded
	/// @returns the number of items waiting to be loaded
	external num getWaitingItemsCount();
	
	/// Returns a boolean indicating if the scene is still loading data
	external bool get isLoading;
	
	/// Registers a function to be executed when the scene is ready
	/// @param {Function} func - the function to be executed
	external void executeWhenReady(void Function() func);
	
	/// Returns a promise that resolves when the scene is ready
	/// @returns A promise that resolves when the scene is ready
	external Promise<void> whenReadyAsync();
	
	/// Gets all animatable attached to the scene
	external List<Animatable> get animatables;
	
	/// Resets the last animation time frame.
	/// Useful to override when animations start running when loading a scene for the first time.
	external void resetLastAnimationTimeFrame();
	
	/// Gets the current view matrix
	/// @returns a Matrix
	external Matrix getViewMatrix();
	
	/// Gets the current projection matrix
	/// @returns a Matrix
	external Matrix getProjectionMatrix();
	
	/// Gets the current transform matrix
	/// @returns a Matrix made of View * Projection
	external Matrix getTransformMatrix();
	
	/// Sets the current transform matrix
	/// @param viewL defines the View matrix to use
	/// @param projectionL defines the Projection matrix to use
	/// @param viewR defines the right View matrix to use (if provided)
	/// @param projectionR defines the right Projection matrix to use (if provided)
	external void setTransformMatrix(Matrix viewL, Matrix projectionL, [Matrix? viewR, Matrix? projectionR]);
	
	/// Gets the uniform buffer used to store scene data
	/// @returns a UniformBuffer
	external UniformBuffer getSceneUniformBuffer();
	
	/// Gets an unique (relatively to the current scene) Id
	/// @returns an unique number for the scene
	external num getUniqueId();
	
	/// Add a mesh to the list of scene's meshes
	/// @param newMesh defines the mesh to add
	/// @param recursive if all child meshes should also be added to the scene
	external void addMesh(AbstractMesh newMesh, [bool? recursive]);
	
	/// Remove a mesh for the list of scene's meshes
	/// @param toRemove defines the mesh to remove
	/// @param recursive if all child meshes should also be removed from the scene
	/// @returns the index where the mesh was in the mesh list
	external num removeMesh(AbstractMesh toRemove, [bool? recursive]);
	
	/// Add a transform node to the list of scene's transform nodes
	/// @param newTransformNode defines the transform node to add
	external void addTransformNode(TransformNode newTransformNode);
	
	/// Remove a transform node for the list of scene's transform nodes
	/// @param toRemove defines the transform node to remove
	/// @returns the index where the transform node was in the transform node list
	external num removeTransformNode(TransformNode toRemove);
	
	/// Remove a skeleton for the list of scene's skeletons
	/// @param toRemove defines the skeleton to remove
	/// @returns the index where the skeleton was in the skeleton list
	external num removeSkeleton(Skeleton toRemove);
	
	/// Remove a morph target for the list of scene's morph targets
	/// @param toRemove defines the morph target to remove
	/// @returns the index where the morph target was in the morph target list
	external num removeMorphTargetManager(MorphTargetManager toRemove);
	
	/// Remove a light for the list of scene's lights
	/// @param toRemove defines the light to remove
	/// @returns the index where the light was in the light list
	external num removeLight(Light toRemove);
	
	/// Remove a camera for the list of scene's cameras
	/// @param toRemove defines the camera to remove
	/// @returns the index where the camera was in the camera list
	external num removeCamera(Camera toRemove);
	
	/// Remove a particle system for the list of scene's particle systems
	/// @param toRemove defines the particle system to remove
	/// @returns the index where the particle system was in the particle system list
	external num removeParticleSystem(IParticleSystem toRemove);
	
	/// Remove a animation for the list of scene's animations
	/// @param toRemove defines the animation to remove
	/// @returns the index where the animation was in the animation list
	external num removeAnimation(Animation toRemove);
	
	/// Will stop the animation of the given target
	/// @param target - the target
	/// @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)
	/// @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)
	external void stopAnimation(dynamic target, [String? animationName, bool Function(dynamic target)? targetMask]);
	
	/// Removes the given animation group from this scene.
	/// @param toRemove The animation group to remove
	/// @returns The index of the removed animation group
	external num removeAnimationGroup(AnimationGroup toRemove);
	
	/// Removes the given multi-material from this scene.
	/// @param toRemove The multi-material to remove
	/// @returns The index of the removed multi-material
	external num removeMultiMaterial(MultiMaterial toRemove);
	
	/// Removes the given material from this scene.
	/// @param toRemove The material to remove
	/// @returns The index of the removed material
	external num removeMaterial(Material toRemove);
	
	/// Removes the given action manager from this scene.
	/// @param toRemove The action manager to remove
	/// @returns The index of the removed action manager
	external num removeActionManager(AbstractActionManager toRemove);
	
	/// Removes the given texture from this scene.
	/// @param toRemove The texture to remove
	/// @returns The index of the removed texture
	external num removeTexture(BaseTexture toRemove);
	
	/// Adds the given light to this scene
	/// @param newLight The light to add
	external void addLight(Light newLight);
	
	/// Sorts the list list based on light priorities
	external void sortLightsByPriority();
	
	/// Adds the given camera to this scene
	/// @param newCamera The camera to add
	external void addCamera(Camera newCamera);
	
	/// Adds the given skeleton to this scene
	/// @param newSkeleton The skeleton to add
	external void addSkeleton(Skeleton newSkeleton);
	
	/// Adds the given particle system to this scene
	/// @param newParticleSystem The particle system to add
	external void addParticleSystem(IParticleSystem newParticleSystem);
	
	/// Adds the given animation to this scene
	/// @param newAnimation The animation to add
	external void addAnimation(Animation newAnimation);
	
	/// Adds the given animation group to this scene.
	/// @param newAnimationGroup The animation group to add
	external void addAnimationGroup(AnimationGroup newAnimationGroup);
	
	/// Adds the given multi-material to this scene
	/// @param newMultiMaterial The multi-material to add
	external void addMultiMaterial(MultiMaterial newMultiMaterial);
	
	/// Adds the given material to this scene
	/// @param newMaterial The material to add
	external void addMaterial(Material newMaterial);
	
	/// Adds the given morph target to this scene
	/// @param newMorphTargetManager The morph target to add
	external void addMorphTargetManager(MorphTargetManager newMorphTargetManager);
	
	/// Adds the given geometry to this scene
	/// @param newGeometry The geometry to add
	external void addGeometry(Geometry newGeometry);
	
	/// Adds the given action manager to this scene
	/// @param newActionManager The action manager to add
	external void addActionManager(AbstractActionManager newActionManager);
	
	/// Adds the given texture to this scene.
	/// @param newTexture The texture to add
	external void addTexture(BaseTexture newTexture);
	
	/// Switch active camera
	/// @param newCamera defines the new active camera
	/// @param attachControl defines if attachControl must be called for the new active camera (default: true)
	external void switchActiveCamera(Camera newCamera, [bool? attachControl]);
	
	/// sets the active camera of the scene using its ID
	/// @param id defines the camera's ID
	/// @return the new active camera or null if none found.
	external Camera? setActiveCameraByID(String id);
	
	/// sets the active camera of the scene using its name
	/// @param name defines the camera's name
	/// @returns the new active camera or null if none found.
	external Camera? setActiveCameraByName(String name);
	
	/// get an animation group using its name
	/// @param name defines the material's name
	/// @return the animation group or null if none found.
	external AnimationGroup? getAnimationGroupByName(String name);
	
	/// Get a material using its unique id
	/// @param uniqueId defines the material's unique id
	/// @return the material or null if none found.
	external Material? getMaterialByUniqueID(num uniqueId);
	
	/// get a material using its id
	/// @param id defines the material's ID
	/// @return the material or null if none found.
	external Material? getMaterialByID(String id);
	
	/// Gets a the last added material using a given id
	/// @param id defines the material's ID
	/// @return the last material with the given id or null if none found.
	external Material? getLastMaterialByID(String id);
	
	/// Gets a material using its name
	/// @param name defines the material's name
	/// @return the material or null if none found.
	external Material? getMaterialByName(String name);
	
	/// Get a texture using its unique id
	/// @param uniqueId defines the texture's unique id
	/// @return the texture or null if none found.
	external BaseTexture? getTextureByUniqueID(num uniqueId);
	
	/// Gets a camera using its id
	/// @param id defines the id to look for
	/// @returns the camera or null if not found
	external Camera? getCameraByID(String id);
	
	/// Gets a camera using its unique id
	/// @param uniqueId defines the unique id to look for
	/// @returns the camera or null if not found
	external Camera? getCameraByUniqueID(num uniqueId);
	
	/// Gets a camera using its name
	/// @param name defines the camera's name
	/// @return the camera or null if none found.
	external Camera? getCameraByName(String name);
	
	/// Gets a bone using its id
	/// @param id defines the bone's id
	/// @return the bone or null if not found
	external Bone? getBoneByID(String id);
	
	/// Gets a bone using its id
	/// @param name defines the bone's name
	/// @return the bone or null if not found
	external Bone? getBoneByName(String name);
	
	/// Gets a light node using its name
	/// @param name defines the the light's name
	/// @return the light or null if none found.
	external Light? getLightByName(String name);
	
	/// Gets a light node using its id
	/// @param id defines the light's id
	/// @return the light or null if none found.
	external Light? getLightByID(String id);
	
	/// Gets a light node using its scene-generated unique ID
	/// @param uniqueId defines the light's unique id
	/// @return the light or null if none found.
	external Light? getLightByUniqueID(num uniqueId);
	
	/// Gets a particle system by id
	/// @param id defines the particle system id
	/// @return the corresponding system or null if none found
	external IParticleSystem? getParticleSystemByID(String id);
	
	/// Gets a geometry using its ID
	/// @param id defines the geometry's id
	/// @return the geometry or null if none found.
	external Geometry? getGeometryByID(String id);
	
	/// Add a new geometry to this scene
	/// @param geometry defines the geometry to be added to the scene.
	/// @param force defines if the geometry must be pushed even if a geometry with this id already exists
	/// @return a boolean defining if the geometry was added or not
	external bool pushGeometry(Geometry geometry, [bool? force]);
	
	/// Removes an existing geometry
	/// @param geometry defines the geometry to be removed from the scene
	/// @return a boolean defining if the geometry was removed or not
	external bool removeGeometry(Geometry geometry);
	
	/// Gets the list of geometries attached to the scene
	/// @returns an array of Geometry
	external List<Geometry> getGeometries();
	
	/// Gets the first added mesh found of a given ID
	/// @param id defines the id to search for
	/// @return the mesh found or null if not found at all
	external AbstractMesh? getMeshByID(String id);
	
	/// Gets a list of meshes using their id
	/// @param id defines the id to search for
	/// @returns a list of meshes
	external List<AbstractMesh> getMeshesByID(String id);
	
	/// Gets the first added transform node found of a given ID
	/// @param id defines the id to search for
	/// @return the found transform node or null if not found at all.
	external TransformNode? getTransformNodeByID(String id);
	
	/// Gets a transform node with its auto-generated unique id
	/// @param uniqueId efines the unique id to search for
	/// @return the found transform node or null if not found at all.
	external TransformNode? getTransformNodeByUniqueID(num uniqueId);
	
	/// Gets a list of transform nodes using their id
	/// @param id defines the id to search for
	/// @returns a list of transform nodes
	external List<TransformNode> getTransformNodesByID(String id);
	
	/// Gets a mesh with its auto-generated unique id
	/// @param uniqueId defines the unique id to search for
	/// @return the found mesh or null if not found at all.
	external AbstractMesh? getMeshByUniqueID(num uniqueId);
	
	/// Gets a the last added mesh using a given id
	/// @param id defines the id to search for
	/// @return the found mesh or null if not found at all.
	external AbstractMesh? getLastMeshByID(String id);
	
	/// Gets a the last added node (Mesh, Camera, Light) using a given id
	/// @param id defines the id to search for
	/// @return the found node or null if not found at all
	external Node? getLastEntryByID(String id);
	
	/// Gets a node (Mesh, Camera, Light) using a given id
	/// @param id defines the id to search for
	/// @return the found node or null if not found at all
	external Node? getNodeByID(String id);
	
	/// Gets a node (Mesh, Camera, Light) using a given name
	/// @param name defines the name to search for
	/// @return the found node or null if not found at all.
	external Node? getNodeByName(String name);
	
	/// Gets a mesh using a given name
	/// @param name defines the name to search for
	/// @return the found mesh or null if not found at all.
	external AbstractMesh? getMeshByName(String name);
	
	/// Gets a transform node using a given name
	/// @param name defines the name to search for
	/// @return the found transform node or null if not found at all.
	external TransformNode? getTransformNodeByName(String name);
	
	/// Gets a skeleton using a given id (if many are found, this function will pick the last one)
	/// @param id defines the id to search for
	/// @return the found skeleton or null if not found at all.
	external Skeleton? getLastSkeletonByID(String id);
	
	/// Gets a skeleton using a given auto generated unique id
	/// @param  uniqueId defines the unique id to search for
	/// @return the found skeleton or null if not found at all.
	external Skeleton? getSkeletonByUniqueId(num uniqueId);
	
	/// Gets a skeleton using a given id (if many are found, this function will pick the first one)
	/// @param id defines the id to search for
	/// @return the found skeleton or null if not found at all.
	external Skeleton? getSkeletonById(String id);
	
	/// Gets a skeleton using a given name
	/// @param name defines the name to search for
	/// @return the found skeleton or null if not found at all.
	external Skeleton? getSkeletonByName(String name);
	
	/// Gets a morph target manager  using a given id (if many are found, this function will pick the last one)
	/// @param id defines the id to search for
	/// @return the found morph target manager or null if not found at all.
	external MorphTargetManager? getMorphTargetManagerById(num id);
	
	/// Gets a morph target using a given id (if many are found, this function will pick the first one)
	/// @param id defines the id to search for
	/// @return the found morph target or null if not found at all.
	external MorphTarget? getMorphTargetById(String id);
	
	/// Gets a morph target using a given name (if many are found, this function will pick the first one)
	/// @param name defines the name to search for
	/// @return the found morph target or null if not found at all.
	external MorphTarget? getMorphTargetByName(String name);
	
	/// Gets a post process using a given name (if many are found, this function will pick the first one)
	/// @param name defines the name to search for
	/// @return the found post process or null if not found at all.
	external PostProcess? getPostProcessByName(String name);
	
	/// Gets a boolean indicating if the given mesh is active
	/// @param mesh defines the mesh to look for
	/// @returns true if the mesh is in the active list
	external bool isActiveMesh(AbstractMesh mesh);
	
	/// Return a unique id as a string which can serve as an identifier for the scene
	external String get uid;
	
	/// Add an externaly attached data from its key.
	/// This method call will fail and return false, if such key already exists.
	/// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
	/// @param key the unique key that identifies the data
	/// @param data the data object to associate to the key for this Engine instance
	/// @return true if no such key were already present and the data was added successfully, false otherwise
	external bool addExternalData<T>(String key, T data);
	
	/// Get an externaly attached data from its key
	/// @param key the unique key that identifies the data
	/// @return the associated data, if present (can be null), or undefined if not present
	external T? getExternalData<T>(String key);
	
	/// Get an externaly attached data from its key, create it using a factory if it's not already present
	/// @param key the unique key that identifies the data
	/// @param factory the factory that will be called to create the instance if and only if it doesn't exists
	/// @return the associated data, can be null if the factory returned null.
	external T getOrAddExternalDataWithFactory<T>(String key, T Function(String k) factory);
	
	/// Remove an externaly attached data from the Engine instance
	/// @param key the unique key that identifies the data
	/// @return true if the data was successfully removed, false if it doesn't exist
	external bool removeExternalData(String key);
	
	/// Clear the processed materials smart array preventing retention point in material dispose.
	external void freeProcessedMaterials();
	
	/// Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups
	/// It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance
	/// when disposing several meshes in a row or a hierarchy of meshes.
	/// When used, it is the responsability of the user to blockfreeActiveMeshesAndRenderingGroups back to false.
	external bool get blockfreeActiveMeshesAndRenderingGroups;
	
	external set blockfreeActiveMeshesAndRenderingGroups(bool value);
	
	/// Clear the active meshes smart array preventing retention point in mesh dispose.
	external void freeActiveMeshes();
	
	/// Clear the info related to rendering groups preventing retention points during dispose.
	external void freeRenderingGroups();
	
	/// Lambda returning the list of potentially active meshes.
	external ISmartArrayLike<AbstractMesh> Function() get getActiveMeshCandidates;
	external set getActiveMeshCandidates(ISmartArrayLike<AbstractMesh> Function() value);
	
	/// Lambda returning the list of potentially active sub meshes.
	external ISmartArrayLike<SubMesh> Function(AbstractMesh mesh) get getActiveSubMeshCandidates;
	external set getActiveSubMeshCandidates(ISmartArrayLike<SubMesh> Function(AbstractMesh mesh) value);
	
	/// Lambda returning the list of potentially intersecting sub meshes.
	external ISmartArrayLike<SubMesh> Function(AbstractMesh mesh, Ray localRay) get getIntersectingSubMeshCandidates;
	external set getIntersectingSubMeshCandidates(ISmartArrayLike<SubMesh> Function(AbstractMesh mesh, Ray localRay) value);
	
	/// Lambda returning the list of potentially colliding sub meshes.
	external ISmartArrayLike<SubMesh> Function(AbstractMesh mesh, Collider collider) get getCollidingSubMeshCandidates;
	external set getCollidingSubMeshCandidates(ISmartArrayLike<SubMesh> Function(AbstractMesh mesh, Collider collider) value);
	
	/// Use this function to stop evaluating active meshes. The current list will be keep alive between frames
	/// @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped
	/// @param onSuccess optional success callback
	/// @param onError optional error callback
	/// @returns the current scene
	external Scene freezeActiveMeshes([bool? skipEvaluateActiveMeshes, void Function()? onSuccess, void Function(String message)? onError]);
	
	/// Use this function to restart evaluating active meshes on every frame
	/// @returns the current scene
	external Scene unfreezeActiveMeshes();
	
	/// Update the transform matrix to update from the current active camera
	/// @param force defines a boolean used to force the update even if cache is up to date
	external void updateTransformMatrix([bool? force]);
	
	/// User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode
	external num Function() get getDeterministicFrameTime;
	external set getDeterministicFrameTime(num Function() value);
	
	/// Execute all animations (for a frame)
	external void animate();
	
	/// Render the scene
	/// @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)
	/// @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)
	external void render([bool? updateCameras, bool? ignoreAnimations]);
	
	/// Freeze all materials
	/// A frozen material will not be updatable but should be faster to render
	external void freezeMaterials();
	
	/// Unfreeze all materials
	/// A frozen material will not be updatable but should be faster to render
	external void unfreezeMaterials();
	
	/// Releases all held ressources
	external void dispose();
	
	/// Gets if the scene is already disposed
	external bool get isDisposed;
	
	/// Call this function to reduce memory footprint of the scene.
	/// Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
	external void clearCachedVertexData();
	
	/// This function will remove the local cached buffer data from texture.
	/// It will save memory but will prevent the texture from being rebuilt
	external void cleanCachedTextureBuffer();
	
	/// Get the world extend vectors with an optional filter
	/// 
	/// @param filterPredicate the predicate - which meshes should be included when calculating the world size
	/// @returns {{ min: Vector3; max: Vector3 }} min and max vectors
	external SceneGetWorldExtends getWorldExtends([bool Function(AbstractMesh mesh)? filterPredicate]);
	
	/// Creates a ray that can be used to pick in the scene
	/// @param x defines the x coordinate of the origin (on-screen)
	/// @param y defines the y coordinate of the origin (on-screen)
	/// @param world defines the world matrix to use if you want to pick in object space (instead of world space)
	/// @param camera defines the camera to use for the picking
	/// @param cameraViewSpace defines if picking will be done in view space (false by default)
	/// @returns a Ray
	external Ray createPickingRay(num x, num y, Matrix world, Camera? camera, [bool? cameraViewSpace]);
	
	/// Creates a ray that can be used to pick in the scene
	/// @param x defines the x coordinate of the origin (on-screen)
	/// @param y defines the y coordinate of the origin (on-screen)
	/// @param world defines the world matrix to use if you want to pick in object space (instead of world space)
	/// @param result defines the ray where to store the picking ray
	/// @param camera defines the camera to use for the picking
	/// @param cameraViewSpace defines if picking will be done in view space (false by default)
	/// @returns the current scene
	external Scene createPickingRayToRef(num x, num y, Matrix world, Ray result, Camera? camera, [bool? cameraViewSpace]);
	
	/// Creates a ray that can be used to pick in the scene
	/// @param x defines the x coordinate of the origin (on-screen)
	/// @param y defines the y coordinate of the origin (on-screen)
	/// @param camera defines the camera to use for the picking
	/// @returns a Ray
	external Ray createPickingRayInCameraSpace(num x, num y, [Camera? camera]);
	
	/// Creates a ray that can be used to pick in the scene
	/// @param x defines the x coordinate of the origin (on-screen)
	/// @param y defines the y coordinate of the origin (on-screen)
	/// @param result defines the ray where to store the picking ray
	/// @param camera defines the camera to use for the picking
	/// @returns the current scene
	external Scene createPickingRayInCameraSpaceToRef(num x, num y, Ray result, [Camera? camera]);
	
	/// Launch a ray to try to pick a mesh in the scene
	/// @param x position on screen
	/// @param y position on screen
	/// @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
	/// @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
	/// @returns a PickingInfo
	external PickingInfo? pick(num x, num y, [bool Function(AbstractMesh mesh)? predicate, bool? fastCheck, Camera? camera, dynamic? trianglePredicate]);
	
	/// Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)
	/// @param x position on screen
	/// @param y position on screen
	/// @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
	/// @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)
	external PickingInfo? pickWithBoundingInfo(num x, num y, [bool Function(AbstractMesh mesh)? predicate, bool? fastCheck, Camera? camera]);
	
	/// Use the given ray to pick a mesh in the scene
	/// @param ray The ray to use to pick meshes
	/// @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
	/// @returns a PickingInfo
	external PickingInfo? pickWithRay(Ray ray, [bool Function(AbstractMesh mesh)? predicate, bool? fastCheck, dynamic? trianglePredicate]);
	
	/// Launch a ray to try to pick a mesh in the scene
	/// @param x X position on screen
	/// @param y Y position on screen
	/// @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
	/// @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
	/// @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
	/// @returns an array of PickingInfo
	external List<PickingInfo>? multiPick(num x, num y, [bool Function(AbstractMesh mesh)? predicate, Camera? camera, dynamic? trianglePredicate]);
	
	/// Launch a ray to try to pick a mesh in the scene
	/// @param ray Ray to use
	/// @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
	/// @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
	/// @returns an array of PickingInfo
	external List<PickingInfo>? multiPickWithRay(Ray ray, bool Function(AbstractMesh mesh) predicate, [dynamic? trianglePredicate]);
	
	/// Force the value of meshUnderPointer
	/// @param mesh defines the mesh to use
	/// @param pointerId optional pointer id when using more than one pointer
	external void setPointerOverMesh(AbstractMesh? mesh, [num? pointerId]);
	
	/// Gets the mesh under the pointer
	/// @returns a Mesh or null if no mesh is under the pointer
	external AbstractMesh? getPointerOverMesh();
	
	/// Get a list of meshes by tags
	/// @param tagsQuery defines the tags query to use
	/// @param forEach defines a predicate used to filter results
	/// @returns an array of Mesh
	external List<Mesh> getMeshesByTags(String tagsQuery, [void Function(AbstractMesh mesh)? forEach]);
	
	/// Get a list of cameras by tags
	/// @param tagsQuery defines the tags query to use
	/// @param forEach defines a predicate used to filter results
	/// @returns an array of Camera
	external List<Camera> getCamerasByTags(String tagsQuery, [void Function(Camera camera)? forEach]);
	
	/// Get a list of lights by tags
	/// @param tagsQuery defines the tags query to use
	/// @param forEach defines a predicate used to filter results
	/// @returns an array of Light
	external List<Light> getLightsByTags(String tagsQuery, [void Function(Light light)? forEach]);
	
	/// Get a list of materials by tags
	/// @param tagsQuery defines the tags query to use
	/// @param forEach defines a predicate used to filter results
	/// @returns an array of Material
	external List<Material> getMaterialByTags(String tagsQuery, [void Function(Material material)? forEach]);
	
	/// Get a list of transform nodes by tags
	/// @param tagsQuery defines the tags query to use
	/// @param forEach defines a predicate used to filter results
	/// @returns an array of TransformNode
	external List<TransformNode> getTransformNodesByTags(String tagsQuery, [void Function(TransformNode transform)? forEach]);
	
	/// Overrides the default sort function applied in the renderging group to prepare the meshes.
	/// This allowed control for front to back rendering or reversly depending of the special needs.
	/// 
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param opaqueSortCompareFn The opaque queue comparison function use to sort.
	/// @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
	/// @param transparentSortCompareFn The transparent queue comparison function use to sort.
	external void setRenderingOrder(num renderingGroupId, [num Function(SubMesh a, SubMesh b)? opaqueSortCompareFn, num Function(SubMesh a, SubMesh b)? alphaTestSortCompareFn, num Function(SubMesh a, SubMesh b)? transparentSortCompareFn]);
	
	/// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
	/// 
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
	/// @param depth Automatically clears depth between groups if true and autoClear is true.
	/// @param stencil Automatically clears stencil between groups if true and autoClear is true.
	external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil, [bool? depth, bool? stencil]);
	
	/// Gets the current auto clear configuration for one rendering group of the rendering
	/// manager.
	/// @param index the rendering group index to get the information for
	/// @returns The auto clear setup for the requested rendering group
	external IRenderingManagerAutoClearSetup getAutoClearDepthStencilSetup(num index);
	
	/// Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync)
	external bool get blockMaterialDirtyMechanism;
	
	external set blockMaterialDirtyMechanism(bool value);
	
	/// Will flag all materials as dirty to trigger new shader compilation
	/// @param flag defines the flag used to specify which material part must be marked as dirty
	/// @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty
	external void markAllMaterialsAsDirty(num flag, [bool Function(Material mat)? predicate]);
	
	/// All of the sprite managers added to this scene
	/// @see https://doc.babylonjs.com/babylon101/sprites
	external List<ISpriteManager> get spriteManagers;
	external set spriteManagers(List<ISpriteManager> value);
	
	/// An event triggered when sprites rendering is about to start
	/// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
	external Observable<Scene> get onBeforeSpritesRenderingObservable;
	external set onBeforeSpritesRenderingObservable(Observable<Scene> value);
	
	/// An event triggered when sprites rendering is done
	/// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
	external Observable<Scene> get onAfterSpritesRenderingObservable;
	external set onAfterSpritesRenderingObservable(Observable<Scene> value);
	
	/// Launch a ray to try to pick a sprite in the scene
	/// @param x position on screen
	/// @param y position on screen
	/// @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
	/// @returns a PickingInfo
	external PickingInfo? pickSprite(num x, num y, [bool Function(Sprite sprite)? predicate, bool? fastCheck, Camera? camera]);
	
	/// Use the given ray to pick a sprite in the scene
	/// @param ray The ray (in world space) to use to pick meshes
	/// @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used
	/// @returns a PickingInfo
	external PickingInfo? pickSpriteWithRay(Ray ray, [bool Function(Sprite sprite)? predicate, bool? fastCheck, Camera? camera]);
	
	/// Launch a ray to try to pick sprites in the scene
	/// @param x position on screen
	/// @param y position on screen
	/// @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
	/// @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
	/// @returns a PickingInfo array
	external List<PickingInfo>? multiPickSprite(num x, num y, [bool Function(Sprite sprite)? predicate, Camera? camera]);
	
	/// Use the given ray to pick sprites in the scene
	/// @param ray The ray (in world space) to use to pick meshes
	/// @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
	/// @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used
	/// @returns a PickingInfo array
	external List<PickingInfo>? multiPickSpriteWithRay(Ray ray, [bool Function(Sprite sprite)? predicate, Camera? camera]);
	
	/// Force the sprite under the pointer
	/// @param sprite defines the sprite to use
	external void setPointerOverSprite(Sprite? sprite);
	
	/// Gets the sprite under the pointer
	/// @returns a Sprite or null if no sprite is under the pointer
	external Sprite? getPointerOverSprite();
	
	/// Will start the animation sequence of a given target
	/// @param target defines the target
	/// @param from defines from which frame should animation start
	/// @param to defines until which frame should animation run.
	/// @param weight defines the weight to apply to the animation (1.0 by default)
	/// @param loop defines if the animation loops
	/// @param speedRatio defines the speed in which to run the animation (1.0 by default)
	/// @param onAnimationEnd defines the function to be executed when the animation ends
	/// @param animatable defines an animatable object. If not provided a new one will be created from the given params
	/// @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)
	/// @param onAnimationLoop defines the callback to call when an animation loops
	/// @param isAdditive defines whether the animation should be evaluated additively (false by default)
	/// @returns the animatable object created for this animation
	external Animatable beginWeightedAnimation(dynamic target, num from, num to, num weight, [bool? loop, num? speedRatio, void Function()? onAnimationEnd, Animatable? animatable, bool Function(dynamic target)? targetMask, void Function()? onAnimationLoop, bool? isAdditive]);
	
	/// Will start the animation sequence of a given target
	/// @param target defines the target
	/// @param from defines from which frame should animation start
	/// @param to defines until which frame should animation run.
	/// @param loop defines if the animation loops
	/// @param speedRatio defines the speed in which to run the animation (1.0 by default)
	/// @param onAnimationEnd defines the function to be executed when the animation ends
	/// @param animatable defines an animatable object. If not provided a new one will be created from the given params
	/// @param stopCurrent defines if the current animations must be stopped first (true by default)
	/// @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)
	/// @param onAnimationLoop defines the callback to call when an animation loops
	/// @param isAdditive defines whether the animation should be evaluated additively (false by default)
	/// @returns the animatable object created for this animation
	external Animatable beginAnimation(dynamic target, num from, num to, [bool? loop, num? speedRatio, void Function()? onAnimationEnd, Animatable? animatable, bool? stopCurrent, bool Function(dynamic target)? targetMask, void Function()? onAnimationLoop, bool? isAdditive]);
	
	/// Will start the animation sequence of a given target and its hierarchy
	/// @param target defines the target
	/// @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.
	/// @param from defines from which frame should animation start
	/// @param to defines until which frame should animation run.
	/// @param loop defines if the animation loops
	/// @param speedRatio defines the speed in which to run the animation (1.0 by default)
	/// @param onAnimationEnd defines the function to be executed when the animation ends
	/// @param animatable defines an animatable object. If not provided a new one will be created from the given params
	/// @param stopCurrent defines if the current animations must be stopped first (true by default)
	/// @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)
	/// @param onAnimationLoop defines the callback to call when an animation loops
	/// @param isAdditive defines whether the animation should be evaluated additively (false by default)
	/// @returns the list of created animatables
	external List<Animatable> beginHierarchyAnimation(dynamic target, bool directDescendantsOnly, num from, num to, [bool? loop, num? speedRatio, void Function()? onAnimationEnd, Animatable? animatable, bool? stopCurrent, bool Function(dynamic target)? targetMask, void Function()? onAnimationLoop, bool? isAdditive]);
	
	/// Begin a new animation on a given node
	/// @param target defines the target where the animation will take place
	/// @param animations defines the list of animations to start
	/// @param from defines the initial value
	/// @param to defines the final value
	/// @param loop defines if you want animation to loop (off by default)
	/// @param speedRatio defines the speed ratio to apply to all animations
	/// @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
	/// @param onAnimationLoop defines the callback to call when an animation loops
	/// @param isAdditive defines whether the animation should be evaluated additively (false by default)
	/// @returns the list of created animatables
	external Animatable beginDirectAnimation(dynamic target, List<Animation> animations, num from, num to, [bool? loop, num? speedRatio, void Function()? onAnimationEnd, void Function()? onAnimationLoop, bool? isAdditive]);
	
	/// Begin a new animation on a given node and its hierarchy
	/// @param target defines the root node where the animation will take place
	/// @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.
	/// @param animations defines the list of animations to start
	/// @param from defines the initial value
	/// @param to defines the final value
	/// @param loop defines if you want animation to loop (off by default)
	/// @param speedRatio defines the speed ratio to apply to all animations
	/// @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
	/// @param onAnimationLoop defines the callback to call when an animation loops
	/// @param isAdditive defines whether the animation should be evaluated additively (false by default)
	/// @returns the list of animatables created for all nodes
	external List<Animatable> beginDirectHierarchyAnimation(Node target, bool directDescendantsOnly, List<Animation> animations, num from, num to, [bool? loop, num? speedRatio, void Function()? onAnimationEnd, void Function()? onAnimationLoop, bool? isAdditive]);
	
	/// Gets the animatable associated with a specific target
	/// @param target defines the target of the animatable
	/// @returns the required animatable if found
	external Animatable? getAnimatableByTarget(dynamic target);
	
	/// Gets all animatables associated with a given target
	/// @param target defines the target to look animatables for
	/// @returns an array of Animatables
	external List<Animatable> getAllAnimatablesByTarget(dynamic target);
	
	/// Stops and removes all animations that have been applied to the scene
	external void stopAllAnimations();
	
	/// Gets the current delta time used by animation engine
	external num get deltaTime;
	external set deltaTime(num value);
	
	/// The main sound track played by the scene.
	/// It cotains your primary collection of sounds.
	external SoundTrack get mainSoundTrack;
	external set mainSoundTrack(SoundTrack value);
	
	/// The list of sound tracks added to the scene
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
	external List<SoundTrack>? get soundTracks;
	external set soundTracks(List<SoundTrack>? value);
	
	/// Gets a sound using a given name
	/// @param name defines the name to search for
	/// @return the found sound or null if not found at all.
	external Sound? getSoundByName(String name);
	
	/// Gets or sets if audio support is enabled
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
	external bool get audioEnabled;
	external set audioEnabled(bool value);
	
	/// Gets or sets if audio will be output to headphones
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
	external bool get headphone;
	external set headphone(bool value);
	
	/// Gets or sets custom audio listener position provider
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
	external Vector3 Function()? get audioListenerPositionProvider;
	external set audioListenerPositionProvider(Vector3 Function()? value);
	
	/// Gets or sets a refresh rate when using 3D audio positioning
	external num get audioPositioningRefreshRate;
	external set audioPositioningRefreshRate(num value);
	
	/// Gets the gamepad manager associated with the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_use_gamepads
	external GamepadManager get gamepadManager;
	external set gamepadManager(GamepadManager value);
	
	/// Gets the octree used to boost mesh selection (picking)
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
	external Octree<AbstractMesh> get selectionOctree;
	external set selectionOctree(Octree<AbstractMesh> value);
	
	/// Creates or updates the octree used to boost selection (picking)
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
	/// @param maxCapacity defines the maximum capacity per leaf
	/// @param maxDepth defines the maximum depth of the octree
	/// @returns an octree of AbstractMesh
	external Octree<AbstractMesh> createOrUpdateSelectionOctree([num? maxCapacity, num? maxDepth]);
	
	/// Gets the debug layer (aka Inspector) associated with the scene
	/// @see https://doc.babylonjs.com/features/playground_debuglayer
	external DebugLayer get debugLayer;
	external set debugLayer(DebugLayer value);
	
	/// Creates a default light for the scene.
	/// @see https://doc.babylonjs.com/How_To/Fast_Build#create-default-light
	/// @param replace has the default false, when true replaces the existing lights in the scene with a hemispheric light
	external void createDefaultLight([bool? replace]);
	
	/// Creates a default camera for the scene.
	/// @see https://doc.babylonjs.com/How_To/Fast_Build#create-default-camera
	/// @param createArcRotateCamera has the default false which creates a free camera, when true creates an arc rotate camera
	/// @param replace has default false, when true replaces the active camera in the scene
	/// @param attachCameraControls has default false, when true attaches camera controls to the canvas.
	external void createDefaultCamera([bool? createArcRotateCamera, bool? replace, bool? attachCameraControls]);
	
	/// Creates a default camera and a default light.
	/// @see https://doc.babylonjs.com/how_to/Fast_Build#create-default-camera-or-light
	/// @param createArcRotateCamera has the default false which creates a free camera, when true creates an arc rotate camera
	/// @param replace has the default false, when true replaces the active camera/light in the scene
	/// @param attachCameraControls has the default false, when true attaches camera controls to the canvas.
	external void createDefaultCameraOrLight([bool? createArcRotateCamera, bool? replace, bool? attachCameraControls]);
	
	/// Creates a new sky box
	/// @see https://doc.babylonjs.com/how_to/Fast_Build#create-default-skybox
	/// @param environmentTexture defines the texture to use as environment texture
	/// @param pbr has default false which requires the StandardMaterial to be used, when true PBRMaterial must be used
	/// @param scale defines the overall scale of the skybox
	/// @param blur is only available when pbr is true, default is 0, no blur, maximum value is 1
	/// @param setGlobalEnvTexture has default true indicating that scene.environmentTexture must match the current skybox texture
	/// @returns a new mesh holding the sky box
	external Mesh? createDefaultSkybox([BaseTexture? environmentTexture, bool? pbr, num? scale, num? blur, bool? setGlobalEnvTexture]);
	
	/// Creates a new environment
	/// @see https://doc.babylonjs.com/How_To/Fast_Build#create-default-environment
	/// @param options defines the options you can use to configure the environment
	/// @returns the new EnvironmentHelper
	external EnvironmentHelper? createDefaultEnvironment([IEnvironmentHelperOptions? options]);
	
	/// Creates a new VREXperienceHelper
	/// @see https://doc.babylonjs.com/how_to/webvr_helper
	/// @param webVROptions defines the options used to create the new VREXperienceHelper
	/// @returns a new VREXperienceHelper
	external VRExperienceHelper createDefaultVRExperience([VRExperienceHelperOptions? webVROptions]);
	
	/// Creates a new WebXRDefaultExperience
	/// @see https://doc.babylonjs.com/how_to/introduction_to_webxr
	/// @param options experience options
	/// @returns a promise for a new WebXRDefaultExperience
	external Promise<WebXRDefaultExperience> createDefaultXRExperienceAsync(WebXRDefaultExperienceOptions options);
	
	/// Gets or sets the simplification queue attached to the scene
	/// @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
	external SimplificationQueue get simplificationQueue;
	external set simplificationQueue(SimplificationQueue value);
	
	/// Gets the current physics engine
	/// @returns a IPhysicsEngine or null if none attached
	external IPhysicsEngine? getPhysicsEngine();
	
	/// Enables physics to the current scene
	/// @param gravity defines the scene's gravity for the physics engine
	/// @param plugin defines the physics engine to be used. defaults to OimoJS.
	/// @return a boolean indicating if the physics engine was initialized
	external bool enablePhysics(Vector3? gravity, [IPhysicsEnginePlugin? plugin]);
	
	/// Disables and disposes the physics engine associated with the scene
	external void disablePhysicsEngine();
	
	/// Gets a boolean indicating if there is an active physics engine
	/// @returns a boolean indicating if there is an active physics engine
	external bool isPhysicsEnabled();
	
	/// Deletes a physics compound impostor
	/// @param compound defines the compound to delete
	external void deleteCompoundImpostor(dynamic compound);
	
	/// An event triggered when physic simulation is about to be run
	external Observable<Scene> get onBeforePhysicsObservable;
	external set onBeforePhysicsObservable(Observable<Scene> value);
	
	/// An event triggered when physic simulation has been done
	external Observable<Scene> get onAfterPhysicsObservable;
	external set onAfterPhysicsObservable(Observable<Scene> value);
	
	/// Gets or Sets the current geometry buffer associated to the scene.
	external GeometryBufferRenderer? get geometryBufferRenderer;
	external set geometryBufferRenderer(GeometryBufferRenderer? value);
	
	/// Enables a GeometryBufferRender and associates it with the scene
	/// @param ratio defines the scaling ratio to apply to the renderer (1 by default which means same resolution)
	/// @returns the GeometryBufferRenderer
	external GeometryBufferRenderer? enableGeometryBufferRenderer([num? ratio]);
	
	/// Disables the GeometryBufferRender associated with the scene
	external void disableGeometryBufferRenderer();
	
	/// Gets the postprocess render pipeline manager
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
	/// @see https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
	external PostProcessRenderPipelineManager get postProcessRenderPipelineManager;
	
	/// Gets or sets a boolean indicating if all bounding boxes must be rendered
	external bool get forceShowBoundingBoxes;
	external set forceShowBoundingBoxes(bool value);
	
	/// Gets the bounding box renderer associated with the scene
	/// @returns a BoundingBoxRenderer
	external BoundingBoxRenderer getBoundingBoxRenderer();
	
	/// Creates a depth renderer a given camera which contains a depth map which can be used for post processing.
	/// @param camera The camera to create the depth renderer on (default: scene's active camera)
	/// @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
	/// @param force32bitsFloat Forces 32 bits float when supported (else 16 bits float is prioritized over 32 bits float if supported)
	/// @returns the created depth renderer
	external DepthRenderer enableDepthRenderer([Camera? camera, bool? storeNonLinearDepth, bool? force32bitsFloat]);
	
	/// Disables a depth renderer for a given camera
	/// @param camera The camera to disable the depth renderer on (default: scene's active camera)
	external void disableDepthRenderer([Camera? camera]);
	
	/// Gets the outline renderer associated with the scene
	/// @returns a OutlineRenderer
	external OutlineRenderer getOutlineRenderer();
	
	/// Array of animations
	external List<Animation>? get animations;
	external set animations(List<Animation>? value);
}

/// Groups all the scene component constants in one place to ease maintenance.
/// @hidden
@JS()
class SceneComponentConstants {
	external factory SceneComponentConstants();
	
	external static String get NAME_EFFECTLAYER;
	
	external static String get NAME_LAYER;
	
	external static String get NAME_LENSFLARESYSTEM;
	
	external static String get NAME_BOUNDINGBOXRENDERER;
	
	external static String get NAME_PARTICLESYSTEM;
	
	external static String get NAME_GAMEPAD;
	
	external static String get NAME_SIMPLIFICATIONQUEUE;
	
	external static String get NAME_GEOMETRYBUFFERRENDERER;
	
	external static String get NAME_PREPASSRENDERER;
	
	external static String get NAME_DEPTHRENDERER;
	
	external static String get NAME_POSTPROCESSRENDERPIPELINEMANAGER;
	
	external static String get NAME_SPRITE;
	
	external static String get NAME_SUBSURFACE;
	
	external static String get NAME_OUTLINERENDERER;
	
	external static String get NAME_PROCEDURALTEXTURE;
	
	external static String get NAME_SHADOWGENERATOR;
	
	external static String get NAME_OCTREE;
	
	external static String get NAME_PHYSICSENGINE;
	
	external static String get NAME_AUDIO;
	
	external static num get STEP_ISREADYFORMESH_EFFECTLAYER;
	
	external static num get STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER;
	
	external static num get STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER;
	
	external static num get STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER;
	
	external static num get STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER;
	
	external static num get STEP_BEFORECAMERADRAW_EFFECTLAYER;
	
	external static num get STEP_BEFORECAMERADRAW_LAYER;
	
	external static num get STEP_BEFORECAMERADRAW_PREPASS;
	
	external static num get STEP_BEFORERENDERTARGETDRAW_LAYER;
	
	external static num get STEP_BEFORERENDERINGMESH_PREPASS;
	
	external static num get STEP_BEFORERENDERINGMESH_OUTLINE;
	
	external static num get STEP_AFTERRENDERINGMESH_PREPASS;
	
	external static num get STEP_AFTERRENDERINGMESH_OUTLINE;
	
	external static num get STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW;
	
	external static num get STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER;
	
	external static num get STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE;
	
	external static num get STEP_BEFORECAMERAUPDATE_GAMEPAD;
	
	external static num get STEP_BEFORECLEAR_PROCEDURALTEXTURE;
	
	external static num get STEP_AFTERRENDERTARGETDRAW_LAYER;
	
	external static num get STEP_AFTERCAMERADRAW_EFFECTLAYER;
	
	external static num get STEP_AFTERCAMERADRAW_LENSFLARESYSTEM;
	
	external static num get STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW;
	
	external static num get STEP_AFTERCAMERADRAW_LAYER;
	
	external static num get STEP_AFTERCAMERADRAW_PREPASS;
	
	external static num get STEP_AFTERRENDER_AUDIO;
	
	external static num get STEP_GATHERRENDERTARGETS_DEPTHRENDERER;
	
	external static num get STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER;
	
	external static num get STEP_GATHERRENDERTARGETS_SHADOWGENERATOR;
	
	external static num get STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER;
	
	external static num get STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER;
	
	external static num get STEP_BEFORECLEARSTAGE_PREPASS;
	
	external static num get STEP_POINTERMOVE_SPRITE;
	
	external static num get STEP_POINTERDOWN_SPRITE;
	
	external static num get STEP_POINTERUP_SPRITE;
}

/// This represents a scene component.
/// 
/// This is used to decouple the dependency the scene is having on the different workloads like
/// layers, post processes...
@JS()
abstract class ISceneComponent {
	
	/// The name of the component. Each component must have a unique name.
	external String get name;
	external set name(String value);
	
	/// The scene the component belongs to.
	external Scene get scene;
	external set scene(Scene value);
	
	/// Register the component to one instance of a scene.
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	external void rebuild();
	
	/// Disposes the component and the associated ressources.
	external void dispose();
}

/// This represents a SERIALIZABLE scene component.
/// 
/// This extends Scene Component to add Serialization methods on top.
@JS()
abstract class ISceneSerializableComponent implements ISceneComponent {
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
	
	/// Serializes the component data to the specified json object
	/// @param serializationObject The object to serialize to
	external void serialize(dynamic serializationObject);
}

/// Representation of a stage in the scene (Basically a list of ordered steps)
/// @hidden
@JS()
/* Manual Fix 0 */
class Stage<T extends Function> {
	
	/// Hide ctor from the rest of the world.
	/// @param items The items to add.
	external factory Stage();
	
	/// Creates a new Stage.
	/// @returns A new instance of a Stage
	external static Stage<T> Create<T extends Function>();
	
	/// Registers a step in an ordered way in the targeted stage.
	/// @param index Defines the position to register the step in
	/// @param component Defines the component attached to the step
	/// @param action Defines the action to launch during the step
	external void registerStep(num index, ISceneComponent component, T action);
	
	/// Clears all the steps from the stage.
	external void clear();
}

/// Defines the sprite scene component responsible to manage sprites
/// in a given scene.
@JS()
class SpriteSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory SpriteSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
}

/// Class used to provide helper for timing
@JS()
class TimingTools {
	external factory TimingTools();
	
	/// Polyfill for setImmediate
	/// @param action defines the action to execute after the current execution block
	external static void SetImmediate(void Function() action);
}

/// Class used to enable instatition of objects by class name
@JS()
class InstantiationTools {
	external factory InstantiationTools();
	
	/// Use this object to register external classes like custom textures or material
	/// to allow the laoders to instantiate them
	external static dynamic /* object */ get RegisteredExternalClasses;
	external static set RegisteredExternalClasses(dynamic /* object */ value);
	
	/// Tries to instantiate a new object from a given class name
	/// @param className defines the class name to instantiate
	/// @returns the new object or null if the system was not able to do the instantiation
	external static dynamic Instantiate(String className);
}

/// Class used to host copy specific utilities
@JS()
class CopyTools {
	external factory CopyTools();
	
	/// Reads the pixels stored in the webgl texture and returns them as a base64 string
	/// @param texture defines the texture to read pixels from
	/// @param faceIndex defines the face of the texture to read (in case of cube texture)
	/// @param level defines the LOD level of the texture to read (in case of Mip Maps)
	/// @returns The base64 encoded string or null
	external static String? GenerateBase64StringFromTexture(BaseTexture texture, [num? faceIndex, num? level]);
}

/// Define options used to create a depth texture
@JS()
class DepthTextureCreationOptions {
	external factory DepthTextureCreationOptions();
	
	/// Specifies whether or not a stencil should be allocated in the texture
	external bool get generateStencil;
	external set generateStencil(bool value);
	
	/// Specifies whether or not bilinear filtering is enable on the texture
	external bool get bilinearFiltering;
	external set bilinearFiltering(bool value);
	
	/// Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode
	external num get comparisonFunction;
	external set comparisonFunction(num value);
	
	/// Specifies if the created texture is a cube texture
	external bool get isCube;
	external set isCube(bool value);
}

/// Class for creating a cube texture
@JS()
class CubeTexture extends BaseTexture {
	
	/// Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
	/// as prefiltered data.
	/// @param rootUrl defines the url of the texture or the root name of the six images
	/// @param null defines the scene or engine the texture is attached to
	/// @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
	/// @param noMipmap defines if mipmaps should be created or not
	/// @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
	/// @param onLoad defines a callback triggered at the end of the file load if no errors occured
	/// @param onError defines a callback triggered in case of error during load
	/// @param format defines the internal format to use for the texture once loaded
	/// @param prefiltered defines whether or not the texture is created from prefiltered data
	/// @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name
	/// @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
	/// @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
	/// @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
	/// @param loaderOptions options to be passed to the loader
	/// @return the cube texture
	external factory CubeTexture(String rootUrl, dynamic sceneOrEngine, [List<String>? extensions, bool? noMipmap, List<String>? files, void Function()? onLoad, void Function([String? message, dynamic? exception])? onError, num? format, bool? prefiltered, dynamic? forcedExtension, bool? createPolynomials, num? lodScale, num? lodOffset, dynamic? loaderOptions]);
	
	/// Observable triggered once the texture has been loaded.
	external Observable<CubeTexture> get onLoadObservable;
	external set onLoadObservable(Observable<CubeTexture> value);
	
	/// The url of the texture
	external String get url;
	external set url(String value);
	
	/// Gets or sets the center of the bounding box associated with the cube texture.
	/// It must define where the camera used to render the texture was set
	/// @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode
	external Vector3 get boundingBoxPosition;
	external set boundingBoxPosition(Vector3 value);
	
	/// Gets or sets the size of the bounding box associated with the cube texture
	/// When defined, the cubemap will switch to local mode
	/// @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
	/// @example https://www.babylonjs-playground.com/#RNASML
	external set boundingBoxSize(Vector3 value);
	
	/// Returns the bounding box size
	/// @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode
	external Vector3 get boundingBoxSize;
	
	/// Sets texture matrix rotation angle around Y axis in radians.
	external set rotationY(num value);
	
	/// Gets texture matrix rotation angle around Y axis radians.
	external num get rotationY;
	
	/// Are mip maps generated for this texture or not.
	@override
	external bool get noMipmap;
	
	/// Creates a cube texture from an array of image urls
	/// @param files defines an array of image urls
	/// @param scene defines the hosting scene
	/// @param noMipmap specifies if mip maps are not used
	/// @returns a cube texture
	external static CubeTexture CreateFromImages(List<String> files, Scene scene, [bool? noMipmap]);
	
	/// Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.
	/// @param url defines the url of the prefiltered texture
	/// @param scene defines the scene the texture is attached to
	/// @param forcedExtension defines the extension of the file if different from the url
	/// @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
	/// @return the prefiltered texture
	external static CubeTexture CreateFromPrefilteredData(String url, Scene scene, [dynamic? forcedExtension, bool? createPolynomials]);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "CubeTexture"
	@override
	external String getClassName();
	
	/// Update the url (and optional buffer) of this texture if url was null during construction.
	/// @param url the url of the texture
	/// @param forcedExtension defines the extension to use
	/// @param onLoad callback called when the texture is loaded  (defaults to null)
	/// @param prefiltered Defines whether the updated texture is prefiltered or not
	external void updateURL(String url, [String? forcedExtension, void Function()? onLoad, bool? prefiltered]);
	
	/// Delays loading of the cube texture
	/// @param forcedExtension defines the extension to use
	@override
	external void delayLoad([String? forcedExtension]);
	
	/// Returns the reflection texture matrix
	/// @returns the reflection texture matrix
	@override
	external Matrix getReflectionTextureMatrix();
	
	/// Sets the reflection texture matrix
	/// @param value Reflection texture matrix
	external void setReflectionTextureMatrix(Matrix value);
	
	/// Parses text to create a cube texture
	/// @param parsedTexture define the serialized text to read from
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root url of the cube texture
	/// @returns a cube texture
	external static CubeTexture Parse(dynamic parsedTexture, Scene scene, String rootUrl);
	
	/// Makes a clone, or deep copy, of the cube texture
	/// @returns a new cube texture
	@override
	external CubeTexture? clone();
}

/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
@JS()
class ColorCurves {
	external factory ColorCurves();
	
	/// Gets the global Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external num get globalHue;
	
	/// Sets the global Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external set globalHue(num value);
	
	/// Gets the global Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external num get globalDensity;
	
	/// Sets the global Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external set globalDensity(num value);
	
	/// Gets the global Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external num get globalSaturation;
	
	/// Sets the global Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external set globalSaturation(num value);
	
	/// Gets the global Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external num get globalExposure;
	
	/// Sets the global Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external set globalExposure(num value);
	
	/// Gets the highlights Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external num get highlightsHue;
	
	/// Sets the highlights Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external set highlightsHue(num value);
	
	/// Gets the highlights Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external num get highlightsDensity;
	
	/// Sets the highlights Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external set highlightsDensity(num value);
	
	/// Gets the highlights Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external num get highlightsSaturation;
	
	/// Sets the highlights Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external set highlightsSaturation(num value);
	
	/// Gets the highlights Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external num get highlightsExposure;
	
	/// Sets the highlights Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external set highlightsExposure(num value);
	
	/// Gets the midtones Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external num get midtonesHue;
	
	/// Sets the midtones Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external set midtonesHue(num value);
	
	/// Gets the midtones Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external num get midtonesDensity;
	
	/// Sets the midtones Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external set midtonesDensity(num value);
	
	/// Gets the midtones Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external num get midtonesSaturation;
	
	/// Sets the midtones Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external set midtonesSaturation(num value);
	
	/// Gets the midtones Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external num get midtonesExposure;
	
	/// Sets the midtones Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external set midtonesExposure(num value);
	
	/// Gets the shadows Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external num get shadowsHue;
	
	/// Sets the shadows Hue value.
	/// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
	external set shadowsHue(num value);
	
	/// Gets the shadows Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external num get shadowsDensity;
	
	/// Sets the shadows Density value.
	/// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
	/// Values less than zero provide a filter of opposite hue.
	external set shadowsDensity(num value);
	
	/// Gets the shadows Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external num get shadowsSaturation;
	
	/// Sets the shadows Saturation value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
	external set shadowsSaturation(num value);
	
	/// Gets the shadows Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external num get shadowsExposure;
	
	/// Sets the shadows Exposure value.
	/// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
	external set shadowsExposure(num value);
	
	/// Returns the class name
	/// @returns The class name
	external String getClassName();
	
	/// Binds the color curves to the shader.
	/// @param colorCurves The color curve to bind
	/// @param effect The effect to bind to
	/// @param positiveUniform The positive uniform shader parameter
	/// @param neutralUniform The neutral uniform shader parameter
	/// @param negativeUniform The negative uniform shader parameter
	external static void Bind(ColorCurves colorCurves, Effect effect, [String? positiveUniform, String? neutralUniform, String? negativeUniform]);
	
	/// Prepare the list of uniforms associated with the ColorCurves effects.
	/// @param uniformsList The list of uniforms used in the effect
	external static void PrepareUniforms(List<String> uniformsList);
	
	/// Clones the current color curve instance.
	/// @return The cloned curves
	external ColorCurves clone();
	
	/// Serializes the current color curve instance to a json representation.
	/// @return a JSON representation
	external dynamic serialize();
	
	/// Parses the color curve from a json representation.
	/// @param source the JSON source to parse
	/// @return The parsed curves
	external static ColorCurves Parse(dynamic source);
}

/// Interface to follow in your material defines to integrate easily the
/// Image proccessing functions.
/// @hidden
@JS()
abstract class IImageProcessingConfigurationDefines {
	
	external bool get IMAGEPROCESSING;
	external set IMAGEPROCESSING(bool value);
	
	external bool get VIGNETTE;
	external set VIGNETTE(bool value);
	
	external bool get VIGNETTEBLENDMODEMULTIPLY;
	external set VIGNETTEBLENDMODEMULTIPLY(bool value);
	
	external bool get VIGNETTEBLENDMODEOPAQUE;
	external set VIGNETTEBLENDMODEOPAQUE(bool value);
	
	external bool get TONEMAPPING;
	external set TONEMAPPING(bool value);
	
	external bool get TONEMAPPING_ACES;
	external set TONEMAPPING_ACES(bool value);
	
	external bool get CONTRAST;
	external set CONTRAST(bool value);
	
	external bool get EXPOSURE;
	external set EXPOSURE(bool value);
	
	external bool get COLORCURVES;
	external set COLORCURVES(bool value);
	
	external bool get COLORGRADING;
	external set COLORGRADING(bool value);
	
	external bool get COLORGRADING3D;
	external set COLORGRADING3D(bool value);
	
	external bool get SAMPLER3DGREENDEPTH;
	external set SAMPLER3DGREENDEPTH(bool value);
	
	external bool get SAMPLER3DBGRMAP;
	external set SAMPLER3DBGRMAP(bool value);
	
	external bool get IMAGEPROCESSINGPOSTPROCESS;
	external set IMAGEPROCESSINGPOSTPROCESS(bool value);
}

/// @hidden
@JS()
class ImageProcessingConfigurationDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
	
	external factory ImageProcessingConfigurationDefines();
	
	@override
	external bool get IMAGEPROCESSING;
	@override
	external set IMAGEPROCESSING(bool value);
	
	@override
	external bool get VIGNETTE;
	@override
	external set VIGNETTE(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEMULTIPLY;
	@override
	external set VIGNETTEBLENDMODEMULTIPLY(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEOPAQUE;
	@override
	external set VIGNETTEBLENDMODEOPAQUE(bool value);
	
	@override
	external bool get TONEMAPPING;
	@override
	external set TONEMAPPING(bool value);
	
	@override
	external bool get TONEMAPPING_ACES;
	@override
	external set TONEMAPPING_ACES(bool value);
	
	@override
	external bool get CONTRAST;
	@override
	external set CONTRAST(bool value);
	
	@override
	external bool get COLORCURVES;
	@override
	external set COLORCURVES(bool value);
	
	@override
	external bool get COLORGRADING;
	@override
	external set COLORGRADING(bool value);
	
	@override
	external bool get COLORGRADING3D;
	@override
	external set COLORGRADING3D(bool value);
	
	@override
	external bool get SAMPLER3DGREENDEPTH;
	@override
	external set SAMPLER3DGREENDEPTH(bool value);
	
	@override
	external bool get SAMPLER3DBGRMAP;
	@override
	external set SAMPLER3DBGRMAP(bool value);
	
	@override
	external bool get IMAGEPROCESSINGPOSTPROCESS;
	@override
	external set IMAGEPROCESSINGPOSTPROCESS(bool value);
	
	@override
	external bool get EXPOSURE;
	@override
	external set EXPOSURE(bool value);
}

/// This groups together the common properties used for image processing either in direct forward pass
/// or through post processing effect depending on the use of the image processing pipeline in your scene
/// or not.
@JS()
class ImageProcessingConfiguration {
	external factory ImageProcessingConfiguration();
	
	/// Default tone mapping applied in BabylonJS.
	external static num get TONEMAPPING_STANDARD;
	
	/// ACES Tone mapping (used by default in unreal and unity). This can help getting closer
	/// to other engines rendering to increase portability.
	external static num get TONEMAPPING_ACES;
	
	/// Color curves setup used in the effect if colorCurvesEnabled is set to true
	external ColorCurves? get colorCurves;
	external set colorCurves(ColorCurves? value);
	
	/// Gets wether the color curves effect is enabled.
	external bool get colorCurvesEnabled;
	
	/// Sets wether the color curves effect is enabled.
	external set colorCurvesEnabled(bool value);
	
	/// Color grading LUT texture used in the effect if colorGradingEnabled is set to true
	external BaseTexture? get colorGradingTexture;
	
	/// Color grading LUT texture used in the effect if colorGradingEnabled is set to true
	external set colorGradingTexture(BaseTexture? value);
	
	/// Gets wether the color grading effect is enabled.
	external bool get colorGradingEnabled;
	
	/// Sets wether the color grading effect is enabled.
	external set colorGradingEnabled(bool value);
	
	/// Gets wether the color grading effect is using a green depth for the 3d Texture.
	external bool get colorGradingWithGreenDepth;
	
	/// Sets wether the color grading effect is using a green depth for the 3d Texture.
	external set colorGradingWithGreenDepth(bool value);
	
	/// Gets wether the color grading texture contains BGR values.
	external bool get colorGradingBGR;
	
	/// Sets wether the color grading texture contains BGR values.
	external set colorGradingBGR(bool value);
	
	/// Gets the Exposure used in the effect.
	external num get exposure;
	
	/// Sets the Exposure used in the effect.
	external set exposure(num value);
	
	/// Gets wether the tone mapping effect is enabled.
	external bool get toneMappingEnabled;
	
	/// Sets wether the tone mapping effect is enabled.
	external set toneMappingEnabled(bool value);
	
	/// Gets the type of tone mapping effect.
	external num get toneMappingType;
	
	/// Sets the type of tone mapping effect used in BabylonJS.
	external set toneMappingType(num value);
	
	/// Gets the contrast used in the effect.
	external num get contrast;
	
	/// Sets the contrast used in the effect.
	external set contrast(num value);
	
	/// Vignette stretch size.
	external num get vignetteStretch;
	external set vignetteStretch(num value);
	
	/// Vignette centre X Offset.
	external num get vignetteCentreX;
	external set vignetteCentreX(num value);
	
	/// Vignette centre Y Offset.
	external num get vignetteCentreY;
	external set vignetteCentreY(num value);
	
	/// Vignette weight or intensity of the vignette effect.
	external num get vignetteWeight;
	external set vignetteWeight(num value);
	
	/// Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
	/// if vignetteEnabled is set to true.
	external Color4 get vignetteColor;
	external set vignetteColor(Color4 value);
	
	/// Camera field of view used by the Vignette effect.
	external num get vignetteCameraFov;
	external set vignetteCameraFov(num value);
	
	/// Gets the vignette blend mode allowing different kind of effect.
	external num get vignetteBlendMode;
	
	/// Sets the vignette blend mode allowing different kind of effect.
	external set vignetteBlendMode(num value);
	
	/// Gets wether the vignette effect is enabled.
	external bool get vignetteEnabled;
	
	/// Sets wether the vignette effect is enabled.
	external set vignetteEnabled(bool value);
	
	/// Gets wether the image processing is applied through a post process or not.
	external bool get applyByPostProcess;
	
	/// Sets wether the image processing is applied through a post process or not.
	external set applyByPostProcess(bool value);
	
	/// Gets wether the image processing is enabled or not.
	external bool get isEnabled;
	
	/// Sets wether the image processing is enabled or not.
	external set isEnabled(bool value);
	
	/// An event triggered when the configuration changes and requires Shader to Update some parameters.
	external Observable<ImageProcessingConfiguration> get onUpdateParameters;
	external set onUpdateParameters(Observable<ImageProcessingConfiguration> value);
	
	/// Gets the current class name.
	/// @return "ImageProcessingConfiguration"
	external String getClassName();
	
	/// Prepare the list of uniforms associated with the Image Processing effects.
	/// @param uniforms The list of uniforms used in the effect
	/// @param defines the list of defines currently in use
	external static void PrepareUniforms(List<String> uniforms, IImageProcessingConfigurationDefines defines);
	
	/// Prepare the list of samplers associated with the Image Processing effects.
	/// @param samplersList The list of uniforms used in the effect
	/// @param defines the list of defines currently in use
	external static void PrepareSamplers(List<String> samplersList, IImageProcessingConfigurationDefines defines);
	
	/// Prepare the list of defines associated to the shader.
	/// @param defines the list of defines to complete
	/// @param forPostProcess Define if we are currently in post process mode or not
	external void prepareDefines(IImageProcessingConfigurationDefines defines, [bool? forPostProcess]);
	
	/// Returns true if all the image processing information are ready.
	/// @returns True if ready, otherwise, false
	external bool isReady();
	
	/// Binds the image processing to the shader.
	/// @param effect The effect to bind to
	/// @param overrideAspectRatio Override the aspect ratio of the effect
	external void bind(Effect effect, [num? overrideAspectRatio]);
	
	/// Clones the current image processing instance.
	/// @return The cloned image processing
	external ImageProcessingConfiguration clone();
	
	/// Serializes the current image processing instance to a json representation.
	/// @return a JSON representation
	external dynamic serialize();
	
	/// Parses the image processing from a json representation.
	/// @param source the JSON source to parse
	/// @return The parsed image processing
	external static ImageProcessingConfiguration Parse(dynamic source);
	
	/// Used to apply the vignette as a mix with the pixel color.
	external static num get VIGNETTEMODE_MULTIPLY;
	
	/// Used to apply the vignette as a replacement of the pixel color.
	external static num get VIGNETTEMODE_OPAQUE;
}

/* var */
/// @hidden
@JS()
external dynamic get postprocessVertexShader;

/* enum */
abstract class NodeMaterialBlockConnectionPointTypes {
	
	/// Float
	static const int Float = 2;
	
	/// Int
	static const int Int = 3;
	
	/// Vector2
	static const int Vector2 = 5;
	
	/// Vector3
	static const int Vector3 = 9;
	
	/// Vector4
	static const int Vector4 = 17;
	
	/// Color3
	static const int Color3 = 33;
	
	/// Color4
	static const int Color4 = 65;
	
	/// Matrix
	static const int Matrix = 129;
	
	/// Custom object
	static const int Object = 257;
	
	/// Detect type based on connection
	static const int AutoDetect = 1025;
	
	/// Output type that will be defined by input type
	static const int BasedOnInput = 2049;
}

/* enum */
abstract class NodeMaterialBlockTargets {
	
	/// Vertex shader
	static const int Vertex = 2;
	
	/// Fragment shader
	static const int Fragment = 3;
	
	/// Neutral
	static const int Neutral = 5;
	
	/// Vertex and Fragment
	static const int VertexAndFragment = 4;
}

/* enum */
abstract class NodeMaterialBlockConnectionPointMode {
	
	/// Value is an uniform
	static const int Uniform = 1;
	
	/// Value is a mesh attribute
	static const int Attribute = 2;
	
	/// Value is a varying between vertex and fragment shaders
	static const int Varying = 3;
	
	/// Mode is undefined
	static const int Undefined = 4;
}

/* enum */
abstract class NodeMaterialSystemValues {
	
	/// World
	static const int World = 2;
	
	/// View
	static const int View = 3;
	
	/// Projection
	static const int Projection = 4;
	
	/// ViewProjection
	static const int ViewProjection = 5;
	
	/// WorldView
	static const int WorldView = 6;
	
	/// WorldViewProjection
	static const int WorldViewProjection = 7;
	
	/// CameraPosition
	static const int CameraPosition = 8;
	
	/// Fog Color
	static const int FogColor = 9;
	
	/// Delta time
	static const int DeltaTime = 10;
}

/// Represents a camera frustum
@JS()
class Frustum {
	external factory Frustum();
	
	/// Gets the planes representing the frustum
	/// @param transform matrix to be applied to the returned planes
	/// @returns a new array of 6 Frustum planes computed by the given transformation matrix.
	external static List<Plane> GetPlanes(Matrix transform);
	
	/// Gets the near frustum plane transformed by the transform matrix
	/// @param transform transformation matrix to be applied to the resulting frustum plane
	/// @param frustumPlane the resuling frustum plane
	external static void GetNearPlaneToRef(Matrix transform, Plane frustumPlane);
	
	/// Gets the far frustum plane transformed by the transform matrix
	/// @param transform transformation matrix to be applied to the resulting frustum plane
	/// @param frustumPlane the resuling frustum plane
	external static void GetFarPlaneToRef(Matrix transform, Plane frustumPlane);
	
	/// Gets the left frustum plane transformed by the transform matrix
	/// @param transform transformation matrix to be applied to the resulting frustum plane
	/// @param frustumPlane the resuling frustum plane
	external static void GetLeftPlaneToRef(Matrix transform, Plane frustumPlane);
	
	/// Gets the right frustum plane transformed by the transform matrix
	/// @param transform transformation matrix to be applied to the resulting frustum plane
	/// @param frustumPlane the resuling frustum plane
	external static void GetRightPlaneToRef(Matrix transform, Plane frustumPlane);
	
	/// Gets the top frustum plane transformed by the transform matrix
	/// @param transform transformation matrix to be applied to the resulting frustum plane
	/// @param frustumPlane the resuling frustum plane
	external static void GetTopPlaneToRef(Matrix transform, Plane frustumPlane);
	
	/// Gets the bottom frustum plane transformed by the transform matrix
	/// @param transform transformation matrix to be applied to the resulting frustum plane
	/// @param frustumPlane the resuling frustum plane
	external static void GetBottomPlaneToRef(Matrix transform, Plane frustumPlane);
	
	/// Sets the given array "frustumPlanes" with the 6 Frustum planes computed by the given transformation matrix.
	/// @param transform transformation matrix to be applied to the resulting frustum planes
	/// @param frustumPlanes the resuling frustum planes
	external static void GetPlanesToRef(Matrix transform, List<Plane> frustumPlanes);
}

/// Contains position and normal vectors for a vertex
@JS()
class PositionNormalVertex {
	
	/// Creates a PositionNormalVertex
	/// @param position the position of the vertex (defaut: 0,0,0)
	/// @param normal the normal of the vertex (defaut: 0,1,0)
	external factory PositionNormalVertex([Vector3? position, Vector3? normal]);
	
	/// the position of the vertex (defaut: 0,0,0)
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// the normal of the vertex (defaut: 0,1,0)
	external Vector3 get normal;
	external set normal(Vector3 value);
	
	/// Clones the PositionNormalVertex
	/// @returns the cloned PositionNormalVertex
	external PositionNormalVertex clone();
}

/// Contains position, normal and uv vectors for a vertex
@JS()
class PositionNormalTextureVertex {
	
	/// Creates a PositionNormalTextureVertex
	/// @param position the position of the vertex (defaut: 0,0,0)
	/// @param normal the normal of the vertex (defaut: 0,1,0)
	/// @param uv the uv of the vertex (default: 0,0)
	external factory PositionNormalTextureVertex([Vector3? position, Vector3? normal, Vector2? uv]);
	
	/// the position of the vertex (defaut: 0,0,0)
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// the normal of the vertex (defaut: 0,1,0)
	external Vector3 get normal;
	external set normal(Vector3 value);
	
	/// the uv of the vertex (default: 0,0)
	external Vector2 get uv;
	external set uv(Vector2 value);
	
	/// Clones the PositionNormalTextureVertex
	/// @returns the cloned PositionNormalTextureVertex
	external PositionNormalTextureVertex clone();
}

/* enum */
abstract class AnimatedInputBlockTypes {
	
	/// No animation
	static const int None = 1;
	
	/// Time based animation. Will only work for floats
	static const int Time = 2;
}

/// Block used to expose an input value
@JS()
class InputBlock extends NodeMaterialBlock {
	
	/// Creates a new InputBlock
	/// @param name defines the block name
	/// @param target defines the target of that block (Vertex by default)
	/// @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
	external factory InputBlock(String name, [int? target, int? type]);
	
	/// Gets or set a value used to limit the range of float values
	external num get min;
	external set min(num value);
	
	/// Gets or set a value used to limit the range of float values
	external num get max;
	external set max(num value);
	
	/// Gets or set a value indicating that this input can only get 0 and 1 values
	external bool get isBoolean;
	external set isBoolean(bool value);
	
	/// Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix
	external num get matrixMode;
	external set matrixMode(num value);
	
	/// Gets or sets a boolean indicating that the value of this input will not change after a build
	external bool get isConstant;
	external set isConstant(bool value);
	
	/// Gets or sets the group to use to display this block in the Inspector
	external String get groupInInspector;
	external set groupInInspector(String value);
	
	/// Gets an observable raised when the value is changed
	external Observable<InputBlock> get onValueChangedObservable;
	external set onValueChangedObservable(Observable<InputBlock> value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only)
	external bool get convertToGammaSpace;
	external set convertToGammaSpace(bool value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only)
	external bool get convertToLinearSpace;
	external set convertToLinearSpace(bool value);
	
	/// Gets or sets the connection point type (default is float)
	external int get type;
	
	/// Validates if a name is a reserve word.
	/// @param newName the new name to be given to the node.
	/// @returns false if the name is a reserve word, else true.
	@override
	external bool validateBlockName(String newName);
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	/// Set the source of this connection point to a vertex attribute
	/// @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
	/// @returns the current connection point
	external InputBlock setAsAttribute([String? attributeName]);
	
	/// Set the source of this connection point to a system value
	/// @param value define the system value to use (world, view, etc...) or null to switch to manual value
	/// @returns the current connection point
	external InputBlock setAsSystemValue(int? value);
	
	/// Gets or sets the value of that point.
	/// Please note that this value will be ignored if valueCallback is defined
	external dynamic get value;
	
	external set value(dynamic value);
	
	/// Gets or sets a callback used to get the value of that point.
	/// Please note that setting this value will force the connection point to ignore the value property
	external dynamic Function() get valueCallback;
	
	external set valueCallback(dynamic Function() value);
	
	/// Gets or sets the associated variable name in the shader
	external String get associatedVariableName;
	
	external set associatedVariableName(String value);
	
	/// Gets or sets the type of animation applied to the input
	external int get animationType;
	
	external set animationType(int value);
	
	/// Gets a boolean indicating that this connection point not defined yet
	external bool get isUndefined;
	
	/// Gets or sets a boolean indicating that this connection point is coming from an uniform.
	/// In this case the connection point name must be the name of the uniform to use.
	/// Can only be set on inputs
	external bool get isUniform;
	
	external set isUniform(bool value);
	
	/// Gets or sets a boolean indicating that this connection point is coming from an attribute.
	/// In this case the connection point name must be the name of the attribute to use
	/// Can only be set on inputs
	external bool get isAttribute;
	
	external set isAttribute(bool value);
	
	/// Gets or sets a boolean indicating that this connection point is generating a varying variable.
	/// Can only be set on exit points
	external bool get isVarying;
	
	external set isVarying(bool value);
	
	/// Gets a boolean indicating that the current connection point is a system value
	external bool get isSystemValue;
	
	/// Gets or sets the current well known value or null if not defined as a system value
	external int? get systemValue;
	
	external set systemValue(int? value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Animate the input if animationType !== None
	/// @param scene defines the rendering scene
	external void animate(Scene scene);
	
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Set the input block to its default value (based on its type)
	external void setDefaultValue();
	
	@override
	external void dispose();
	
	@override
	external dynamic serialize();
}

/* enum */
abstract class NodeMaterialConnectionPointCompatibilityStates {
	
	/// Points are compatibles
	static const int Compatible = 1;
	
	/// Points are incompatible because of their types
	static const int TypeIncompatible = 2;
	
	/// Points are incompatible because of their targets (vertex vs fragment)
	static const int TargetIncompatible = 3;
}

/* enum */
abstract class NodeMaterialConnectionPointDirection {
	
	/// Input
	static const int Input = 1;
	
	/// Output
	static const int Output = 2;
}

/// Defines a connection point for a block
@JS()
class NodeMaterialConnectionPoint {
	
	/// Creates a new connection point
	/// @param name defines the connection point name
	/// @param ownerBlock defines the block hosting this connection point
	/// @param direction defines the direction of the connection point
	external factory NodeMaterialConnectionPoint(String name, NodeMaterialBlock ownerBlock, int direction);
	
	/// Checks if two types are equivalent
	/// @param type1 type 1 to check
	/// @param type2 type 2 to check
	/// @returns true if both types are equivalent, else false
	external static bool AreEquivalentTypes(num type1, num type2);
	
	/// Gets the direction of the point
	external int get direction;
	
	/// Indicates that this connection point needs dual validation before being connected to another point
	external bool get needDualDirectionValidation;
	external set needDualDirectionValidation(bool value);
	
	/// Gets or sets the additional types supported by this connection point
	external List<int> get acceptedConnectionPointTypes;
	external set acceptedConnectionPointTypes(List<int> value);
	
	/// Gets or sets the additional types excluded by this connection point
	external List<int> get excludedConnectionPointTypes;
	external set excludedConnectionPointTypes(List<int> value);
	
	/// Observable triggered when this point is connected
	external Observable<NodeMaterialConnectionPoint> get onConnectionObservable;
	external set onConnectionObservable(Observable<NodeMaterialConnectionPoint> value);
	
	/// Gets or sets the associated variable name in the shader
	external String get associatedVariableName;
	
	external set associatedVariableName(String value);
	
	/// Get the inner type (ie AutoDetect for instance instead of the inferred one)
	external int get innerType;
	
	/// Gets or sets the connection point type (default is float)
	external int get type;
	
	external set type(int value);
	
	/// Gets or sets the connection point name
	external String get name;
	external set name(String value);
	
	/// Gets or sets the connection point name
	external String get displayName;
	external set displayName(String value);
	
	/// Gets or sets a boolean indicating that this connection point can be omitted
	external bool get isOptional;
	external set isOptional(bool value);
	
	/// Gets or sets a boolean indicating that this connection point is exposed on a frame
	external bool get isExposedOnFrame;
	external set isExposedOnFrame(bool value);
	
	/// Gets or sets number indicating the position that the port is exposed to on a frame
	external num get exposedPortPosition;
	external set exposedPortPosition(num value);
	
	/// Gets or sets a string indicating that this uniform must be defined under a #ifdef
	external String get define;
	external set define(String value);
	
	/// Gets or sets the target of that connection point
	external int get target;
	
	external set target(int value);
	
	/// Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
	external bool get isConnected;
	
	/// Gets a boolean indicating that the current point is connected to an input block
	external bool get isConnectedToInputBlock;
	
	/// Gets a the connected input block (if any)
	external InputBlock? get connectInputBlock;
	
	/// Get the other side of the connection (if any)
	external NodeMaterialConnectionPoint? get connectedPoint;
	
	/// Get the block that owns this connection point
	external NodeMaterialBlock get ownerBlock;
	
	/// Get the block connected on the other side of this connection (if any)
	external NodeMaterialBlock? get sourceBlock;
	
	/// Get the block connected on the endpoints of this connection (if any)
	external List<NodeMaterialBlock> get connectedBlocks;
	
	/// Gets the list of connected endpoints
	external List<NodeMaterialConnectionPoint> get endpoints;
	
	/// Gets a boolean indicating if that output point is connected to at least one input
	external bool get hasEndpoints;
	
	/// Gets a boolean indicating that this connection will be used in the vertex shader
	external bool get isConnectedInVertexShader;
	
	/// Gets a boolean indicating that this connection will be used in the fragment shader
	external bool get isConnectedInFragmentShader;
	
	/// Creates a block suitable to be used as an input for this input point.
	/// If null is returned, a block based on the point type will be created.
	/// @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
	external List<dynamic /* Exact list: [NodeMaterialBlock, string] */>? createCustomInputBlock();
	
	/// Gets the current class name e.g. "NodeMaterialConnectionPoint"
	/// @returns the class name
	external String getClassName();
	
	/// Gets a boolean indicating if the current point can be connected to another point
	/// @param connectionPoint defines the other connection point
	/// @returns a boolean
	external bool canConnectTo(NodeMaterialConnectionPoint connectionPoint);
	
	/// Gets a number indicating if the current point can be connected to another point
	/// @param connectionPoint defines the other connection point
	/// @returns a number defining the compatibility state
	external int checkCompatibilityState(NodeMaterialConnectionPoint connectionPoint);
	
	/// Connect this point to another connection point
	/// @param connectionPoint defines the other connection point
	/// @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
	/// @returns the current connection point
	external NodeMaterialConnectionPoint connectTo(NodeMaterialConnectionPoint connectionPoint, [bool? ignoreConstraints]);
	
	/// Disconnect this point from one of his endpoint
	/// @param endpoint defines the other connection point
	/// @returns the current connection point
	external NodeMaterialConnectionPoint disconnectFrom(NodeMaterialConnectionPoint endpoint);
	
	/// Serializes this point in a JSON representation
	/// @param isInput defines if the connection point is an input (default is true)
	/// @returns the serialized point object
	external dynamic serialize([bool? isInput]);
	
	/// Release resources
	external void dispose();
}

/* enum */
abstract class NodeMaterialModes {
	
	/// Regular material
	static const int Material = 1;
	
	/// For post process
	static const int PostProcess = 2;
	
	/// For particle system
	static const int Particle = 3;
	
	/// For procedural texture
	static const int ProceduralTexture = 4;
}

/* var */
/// @hidden
@JS()
external dynamic get helperFunctions;

/// Block used to read a texture from a sampler
@JS()
class TextureBlock extends NodeMaterialBlock {
	
	/// Create a new TextureBlock
	/// @param name defines the block name
	external factory TextureBlock(String name, [bool? fragmentOnly]);
	
	/// Gets or sets the texture associated with the node
	external Texture? get texture;
	external set texture(Texture? value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to gamma space
	external bool get convertToGammaSpace;
	external set convertToGammaSpace(bool value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to linear space
	external bool get convertToLinearSpace;
	external set convertToLinearSpace(bool value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the uv input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the rgba output component
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the rgb output component
	external NodeMaterialConnectionPoint get rgb;
	
	/// Gets the r output component
	external NodeMaterialConnectionPoint get r;
	
	/// Gets the g output component
	external NodeMaterialConnectionPoint get g;
	
	/// Gets the b output component
	external NodeMaterialConnectionPoint get b;
	
	/// Gets the a output component
	external NodeMaterialConnectionPoint get a;
	
	@override
	external int get target;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void initializeDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances]);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external bool isReady([AbstractMesh? mesh, NodeMaterial? nodeMaterial, NodeMaterialDefines? defines, bool? useInstances]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external dynamic serialize();
}

/* var */
/// @hidden
@JS()
external dynamic get reflectionFunction;

/// Base block used to read a reflection texture from a sampler
@JS()
abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {
	
	/// Create a new ReflectionTextureBaseBlock
	/// @param name defines the block name
	external factory ReflectionTextureBaseBlock(String name);
	
	/// Gets or sets the texture associated with the node
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get position;
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the world normal input component
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the world input component
	external NodeMaterialConnectionPoint get world;
	
	/// Gets the camera (or eye) position component
	external NodeMaterialConnectionPoint get cameraPosition;
	
	/// Gets the view input component
	external NodeMaterialConnectionPoint get view;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external bool isReady([AbstractMesh? mesh, NodeMaterial? nodeMaterial, NodeMaterialDefines? defines, bool? useInstances]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	/// Gets the code to inject in the vertex shader
	/// @param state current state of the node material building
	/// @returns the shader code
	external String handleVertexSide(NodeMaterialBuildState state);
	
	/// Handles the inits for the fragment code path
	/// @param state node material build state
	external void handleFragmentSideInits(NodeMaterialBuildState state);
	
	/// Generates the reflection coords code for the fragment code path
	/// @param worldNormalVarName name of the world normal variable
	/// @param worldPos name of the world position variable. If not provided, will use the world position connected to this block
	/// @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates
	/// @returns the shader code
	external String handleFragmentSideCodeReflectionCoords(String worldNormalVarName, [String? worldPos, bool? onlyReflectionVector]);
	
	/// Generates the reflection color code for the fragment code path
	/// @param lodVarName name of the lod variable
	/// @param swizzleLookupTexture swizzle to use for the final color variable
	/// @returns the shader code
	external String handleFragmentSideCodeReflectionColor([String? lodVarName, String? swizzleLookupTexture]);
	
	/// Generates the code corresponding to the connected output points
	/// @param state node material build state
	/// @param varName name of the variable to output
	/// @returns the shader code
	external String writeOutputs(NodeMaterialBuildState state, String varName);
	
	@override
	external dynamic serialize();
}

/// Defines a connection point to be used for points with a custom object type
@JS()
class NodeMaterialConnectionPointCustomObject<T extends NodeMaterialBlock> extends NodeMaterialConnectionPoint {
	
	/// Creates a new connection point
	/// @param name defines the connection point name
	/// @param ownerBlock defines the block hosting this connection point
	/// @param direction defines the direction of the connection point
	external factory NodeMaterialConnectionPointCustomObject(String name, NodeMaterialBlock ownerBlock, int direction, T Function([List<dynamic>? args]) _blockType, String _blockName, [String? _nameForCheking]);
	
	/// Gets a number indicating if the current point can be connected to another point
	/// @param connectionPoint defines the other connection point
	/// @returns a number defining the compatibility state
	@override
	external int checkCompatibilityState(NodeMaterialConnectionPoint connectionPoint);
	
	/// Creates a block suitable to be used as an input for this input point.
	/// If null is returned, a block based on the point type will be created.
	/// @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
	@override
	external List<dynamic /* Exact list: [NodeMaterialBlock, string] */>? createCustomInputBlock();
}

/* enum */
abstract class PropertyTypeForEdition {
	
	/// property is a boolean
	static const int Boolean = 1;
	
	/// property is a float
	static const int Float = 2;
	
	/// property is a Vector2
	static const int Vector2 = 3;
	
	/// property is a list of values
	static const int List = 4;
}

/// Interface that defines an option in a variable of type list
@JS()
@anonymous
class IEditablePropertyListOption {
	
	external factory IEditablePropertyListOption({String label, num value});
	
	/// label of the option
	external String get label;
	external set label( String value );
	
	/// value of the option
	external num get value;
	external set value( num value );
}

/// Interface that defines the options available for an editable property
@JS()
@anonymous
class IEditablePropertyOption {
	
	external factory IEditablePropertyOption({num min, num max, IEditablePropertyOptionNotifiers notifiers, List<IEditablePropertyListOption> options});
	
	/// min value
	external num get min;
	external set min( num value );
	
	/// max value
	external num get max;
	external set max( num value );
	
	/// notifiers: indicates which actions to take when the property is changed
	external IEditablePropertyOptionNotifiers get notifiers;
	external set notifiers( IEditablePropertyOptionNotifiers value );
	
	/// list of the options for a variable of type list
	external List<IEditablePropertyListOption> get options;
	external set options( List<IEditablePropertyListOption> value );
}

/// Interface that describes an editable property
@JS()
@anonymous
class IPropertyDescriptionForEdition {
	
	external factory IPropertyDescriptionForEdition({String propertyName, String displayName, int type, String groupName, IEditablePropertyOption options});
	
	/// name of the property
	external String get propertyName;
	external set propertyName( String value );
	
	/// display name of the property
	external String get displayName;
	external set displayName( String value );
	
	/// type of the property
	external int get type;
	external set type( int value );
	
	/// group of the property - all properties with the same group value will be displayed in a specific section
	external String get groupName;
	external set groupName( String value );
	
	/// options for the property
	external IEditablePropertyOption get options;
	external set options( IEditablePropertyOption value );
}

/* top level function */
/// Decorator that flags a property in a node material block as being editable
@JS()
external void Function(dynamic target, String propertyKey) editableInPropertyPage(String displayName, [int? propertyType, String? groupName, IEditablePropertyOption? options]);

/// Block used to implement the refraction part of the sub surface module of the PBR material
@JS()
class RefractionBlock extends NodeMaterialBlock {
	
	/// Create a new RefractionBlock
	/// @param name defines the block name
	external factory RefractionBlock(String name);
	
	/// @hidden
	external NodeMaterialConnectionPoint get viewConnectionPoint;
	external set viewConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// @hidden
	external NodeMaterialConnectionPoint get indexOfRefractionConnectionPoint;
	external set indexOfRefractionConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// This parameters will make the material used its opacity to control how much it is refracting aginst not.
	/// Materials half opaque for instance using refraction could benefit from this control.
	external bool get linkRefractionWithTransparency;
	external set linkRefractionWithTransparency(bool value);
	
	/// Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
	external bool get invertRefractionY;
	external set invertRefractionY(bool value);
	
	/// Gets or sets the texture associated with the node
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the intensity input component
	external NodeMaterialConnectionPoint get intensity;
	
	/// Gets the tint at distance input component
	external NodeMaterialConnectionPoint get tintAtDistance;
	
	/// Gets the view input component
	external NodeMaterialConnectionPoint get view;
	
	/// Gets the refraction object output component
	external NodeMaterialConnectionPoint get refraction;
	
	/// Returns true if the block has a texture
	external bool get hasTexture;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external bool isReady([AbstractMesh? mesh, NodeMaterial? nodeMaterial, NodeMaterialDefines? defines, bool? useInstances]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	/// Gets the main code of the block (fragment side)
	/// @param state current state of the node material building
	/// @returns the shader code
	external String getCode(NodeMaterialBuildState state);
	
	@override
	external dynamic serialize();
}

/// Base block used as input for post process
@JS()
class CurrentScreenBlock extends NodeMaterialBlock {
	
	/// Create a new CurrentScreenBlock
	/// @param name defines the block name
	external factory CurrentScreenBlock(String name);
	
	/// Gets or sets the texture associated with the node
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to gamma space
	external bool get convertToGammaSpace;
	external set convertToGammaSpace(bool value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to linear space
	external bool get convertToLinearSpace;
	external set convertToLinearSpace(bool value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the uv input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the rgba output component
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the rgb output component
	external NodeMaterialConnectionPoint get rgb;
	
	/// Gets the r output component
	external NodeMaterialConnectionPoint get r;
	
	/// Gets the g output component
	external NodeMaterialConnectionPoint get g;
	
	/// Gets the b output component
	external NodeMaterialConnectionPoint get b;
	
	/// Gets the a output component
	external NodeMaterialConnectionPoint get a;
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	@override
	external int get target;
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external bool isReady([AbstractMesh? mesh, NodeMaterial? nodeMaterial, NodeMaterialDefines? defines, bool? useInstances]);
	
	@override
	external dynamic serialize();
}

/// Base block used for the particle texture
@JS()
class ParticleTextureBlock extends NodeMaterialBlock {
	
	/// Create a new ParticleTextureBlock
	/// @param name defines the block name
	external factory ParticleTextureBlock(String name);
	
	/// Gets or sets the texture associated with the node
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to gamma space
	external bool get convertToGammaSpace;
	external set convertToGammaSpace(bool value);
	
	/// Gets or sets a boolean indicating if content needs to be converted to linear space
	external bool get convertToLinearSpace;
	external set convertToLinearSpace(bool value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the uv input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the rgba output component
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the rgb output component
	external NodeMaterialConnectionPoint get rgb;
	
	/// Gets the r output component
	external NodeMaterialConnectionPoint get r;
	
	/// Gets the g output component
	external NodeMaterialConnectionPoint get g;
	
	/// Gets the b output component
	external NodeMaterialConnectionPoint get b;
	
	/// Gets the a output component
	external NodeMaterialConnectionPoint get a;
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external bool isReady([AbstractMesh? mesh, NodeMaterial? nodeMaterial, NodeMaterialDefines? defines, bool? useInstances]);
	
	@override
	external dynamic serialize();
}

/// Class used to store shared data between 2 NodeMaterialBuildState
@JS()
class NodeMaterialBuildStateSharedData {
	
	/// Creates a new shared data
	external factory NodeMaterialBuildStateSharedData();
	
	/// Gets the list of emitted varyings
	external List<String> get temps;
	external set temps(List<String> value);
	
	/// Gets the list of emitted varyings
	external List<String> get varyings;
	external set varyings(List<String> value);
	
	/// Gets the varying declaration string
	external String get varyingDeclaration;
	external set varyingDeclaration(String value);
	
	/// Input blocks
	external List<InputBlock> get inputBlocks;
	external set inputBlocks(List<InputBlock> value);
	
	/// Input blocks
	external dynamic get textureBlocks;
	external set textureBlocks(dynamic value);
	
	/// Bindable blocks (Blocks that need to set data to the effect)
	external List<NodeMaterialBlock> get bindableBlocks;
	external set bindableBlocks(List<NodeMaterialBlock> value);
	
	/// List of blocks that can provide a compilation fallback
	external List<NodeMaterialBlock> get blocksWithFallbacks;
	external set blocksWithFallbacks(List<NodeMaterialBlock> value);
	
	/// List of blocks that can provide a define update
	external List<NodeMaterialBlock> get blocksWithDefines;
	external set blocksWithDefines(List<NodeMaterialBlock> value);
	
	/// List of blocks that can provide a repeatable content
	external List<NodeMaterialBlock> get repeatableContentBlocks;
	external set repeatableContentBlocks(List<NodeMaterialBlock> value);
	
	/// List of blocks that can provide a dynamic list of uniforms
	external List<NodeMaterialBlock> get dynamicUniformBlocks;
	external set dynamicUniformBlocks(List<NodeMaterialBlock> value);
	
	/// List of blocks that can block the isReady function for the material
	external List<NodeMaterialBlock> get blockingBlocks;
	external set blockingBlocks(List<NodeMaterialBlock> value);
	
	/// Gets the list of animated inputs
	external List<InputBlock> get animatedInputs;
	external set animatedInputs(List<InputBlock> value);
	
	/// Build Id used to avoid multiple recompilations
	external num get buildId;
	external set buildId(num value);
	
	/// List of emitted variables
	external dynamic /* object */ get variableNames;
	external set variableNames(dynamic /* object */ value);
	
	/// List of emitted defines
	external dynamic /* object */ get defineNames;
	external set defineNames(dynamic /* object */ value);
	
	/// Should emit comments?
	external bool get emitComments;
	external set emitComments(bool value);
	
	/// Emit build activity
	external bool get verbose;
	external set verbose(bool value);
	
	/// Gets or sets the hosting scene
	external Scene get scene;
	external set scene(Scene value);
	
	/// Gets the compilation hints emitted at compilation time
	external NodeMaterialBuildStateSharedDataHints get hints;
	external set hints(NodeMaterialBuildStateSharedDataHints value);
	
	/// List of compilation checks
	external NodeMaterialBuildStateSharedDataChecks get checks;
	external set checks(NodeMaterialBuildStateSharedDataChecks value);
	
	/// Is vertex program allowed to be empty?
	external bool get allowEmptyVertexProgram;
	external set allowEmptyVertexProgram(bool value);
	
	/// Emits console errors and exceptions if there is a failing check
	external void emitErrors();
}

/// Class used to store node based material build state
@JS()
class NodeMaterialBuildState {
	external factory NodeMaterialBuildState();
	
	/// Gets or sets a boolean indicating if the current state can emit uniform buffers
	external bool get supportUniformBuffers;
	external set supportUniformBuffers(bool value);
	
	/// Gets the list of emitted attributes
	external List<String> get attributes;
	external set attributes(List<String> value);
	
	/// Gets the list of emitted uniforms
	external List<String> get uniforms;
	external set uniforms(List<String> value);
	
	/// Gets the list of emitted constants
	external List<String> get constants;
	external set constants(List<String> value);
	
	/// Gets the list of emitted samplers
	external List<String> get samplers;
	external set samplers(List<String> value);
	
	/// Gets the list of emitted functions
	external dynamic /* object */ get functions;
	external set functions(dynamic /* object */ value);
	
	/// Gets the list of emitted extensions
	external dynamic /* object */ get extensions;
	external set extensions(dynamic /* object */ value);
	
	/// Gets the target of the compilation state
	external int get target;
	external set target(int value);
	
	/// Gets the list of emitted counters
	external dynamic /* object */ get counters;
	external set counters(dynamic /* object */ value);
	
	/// Shared data between multiple NodeMaterialBuildState instances
	external NodeMaterialBuildStateSharedData get sharedData;
	external set sharedData(NodeMaterialBuildStateSharedData value);
	
	/// Gets the emitted compilation strings
	external String get compilationString;
	external set compilationString(String value);
	
	/// Finalize the compilation strings
	/// @param state defines the current compilation state
	external void finalize(NodeMaterialBuildState state);
}

/// Helper class used to generate session unique ID
@JS()
class UniqueIdGenerator {
	external factory UniqueIdGenerator();
	
	/// Gets an unique (relatively to the current scene) Id
	external static num get UniqueId;
}

/// EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
/// (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
@JS()
class EffectFallbacks implements IEffectFallbacks {
	external factory EffectFallbacks();
	
	/// Removes the fallback from the bound mesh.
	@override
	external void unBindMesh();
	
	/// Adds a fallback on the specified property.
	/// @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
	/// @param define The name of the define in the shader
	external void addFallback(num rank, String define);
	
	/// Sets the mesh to use CPU skinning when needing to fallback.
	/// @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
	/// @param mesh The mesh to use the fallbacks.
	external void addCPUSkinningFallback(num rank, AbstractMesh mesh);
	
	/// Removes the defines that should be removed when falling back.
	/// @param currentDefines defines the current define statements for the shader.
	/// @param effect defines the current effect we try to compile
	/// @returns The resulting defines with defines of the current rank removed.
	@override
	external String reduce(String currentDefines, Effect effect);
	
	/// Checks to see if more fallbacks are still availible.
	external bool get hasMoreFallbacks;
	external set hasMoreFallbacks(bool value);
}

/// Defines a block that can be used inside a node based material
@JS()
class NodeMaterialBlock {
	
	/// Creates a new NodeMaterialBlock
	/// @param name defines the block name
	/// @param target defines the target of that block (Vertex by default)
	/// @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false
	/// @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false
	external factory NodeMaterialBlock(String name, [int? target, bool? isFinalMerger, bool? isInput]);
	
	/// Gets or sets a boolean indicating that only one input can be connected at a time
	external bool get inputsAreExclusive;
	external set inputsAreExclusive(bool value);
	
	/// Gets the name of the block
	external String get name;
	
	/// Sets the name of the block. Will check if the name is valid.
	external set name(String value);
	
	/// Gets or sets the unique id of the node
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Gets or sets the comments associated with this block
	external String get comments;
	external set comments(String value);
	
	/// Gets a boolean indicating that this block can only be used once per NodeMaterial
	external bool get isUnique;
	
	/// Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)
	external bool get isFinalMerger;
	
	/// Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)
	external bool get isInput;
	
	/// Gets or sets the build Id
	external num get buildId;
	
	external set buildId(num value);
	
	/// Gets or sets the target of the block
	external int get target;
	
	external set target(int value);
	
	/// Gets the list of input points
	external List<NodeMaterialConnectionPoint> get inputs;
	
	/// Gets the list of output points
	external List<NodeMaterialConnectionPoint> get outputs;
	
	/// Find an input by its name
	/// @param name defines the name of the input to look for
	/// @returns the input or null if not found
	external NodeMaterialConnectionPoint? getInputByName(String name);
	
	/// Find an output by its name
	/// @param name defines the name of the outputto look for
	/// @returns the output or null if not found
	external NodeMaterialConnectionPoint? getOutputByName(String name);
	
	/// Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default)
	external bool get visibleInInspector;
	external set visibleInInspector(bool value);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	external void initialize(NodeMaterialBuildState state);
	
	/// Bind data to effect. Will only be called for blocks with isBindable === true
	/// @param effect defines the effect to bind data to
	/// @param nodeMaterial defines the hosting NodeMaterial
	/// @param mesh defines the mesh that will be rendered
	/// @param subMesh defines the submesh that will be rendered
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	/// Gets the current class name e.g. "NodeMaterialBlock"
	/// @returns the class name
	external String getClassName();
	
	/// Register a new input. Must be called inside a block constructor
	/// @param name defines the connection point name
	/// @param type defines the connection point type
	/// @param isOptional defines a boolean indicating that this input can be omitted
	/// @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
	/// @param point an already created connection point. If not provided, create a new one
	/// @returns the current block
	external dynamic registerInput(String name, int type, [bool? isOptional, int? target, NodeMaterialConnectionPoint? point]);
	
	/// Register a new output. Must be called inside a block constructor
	/// @param name defines the connection point name
	/// @param type defines the connection point type
	/// @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
	/// @param point an already created connection point. If not provided, create a new one
	/// @returns the current block
	external dynamic registerOutput(String name, int type, [int? target, NodeMaterialConnectionPoint? point]);
	
	/// Will return the first available input e.g. the first one which is not an uniform or an attribute
	/// @param forOutput defines an optional connection point to check compatibility with
	/// @returns the first available input or null
	external NodeMaterialConnectionPoint? getFirstAvailableInput([NodeMaterialConnectionPoint? forOutput]);
	
	/// Will return the first available output e.g. the first one which is not yet connected and not a varying
	/// @param forBlock defines an optional block to check compatibility with
	/// @returns the first available input or null
	external NodeMaterialConnectionPoint? getFirstAvailableOutput([NodeMaterialBlock? forBlock]);
	
	/// Gets the sibling of the given output
	/// @param current defines the current output
	/// @returns the next output in the list or null
	external NodeMaterialConnectionPoint? getSiblingOutput(NodeMaterialConnectionPoint current);
	
	/// Connect current block with another block
	/// @param other defines the block to connect with
	/// @param options define the various options to help pick the right connections
	/// @returns the current block
	external dynamic? connectTo(NodeMaterialBlock other, [NodeMaterialBlockConnectToOptions? options]);
	
	/// Add uniforms, samplers and uniform buffers at compilation time
	/// @param state defines the state to update
	/// @param nodeMaterial defines the node material requesting the update
	/// @param defines defines the material defines to update
	/// @param uniformBuffers defines the list of uniform buffer names
	external void updateUniformsAndSamples(NodeMaterialBuildState state, NodeMaterial nodeMaterial, NodeMaterialDefines defines, List<String> uniformBuffers);
	
	/// Add potential fallbacks if shader compilation fails
	/// @param mesh defines the mesh to be rendered
	/// @param fallbacks defines the current prioritized list of fallbacks
	external void provideFallbacks(AbstractMesh mesh, EffectFallbacks fallbacks);
	
	/// Initialize defines for shader compilation
	/// @param mesh defines the mesh to be rendered
	/// @param nodeMaterial defines the node material requesting the update
	/// @param defines defines the material defines to update
	/// @param useInstances specifies that instances should be used
	external void initializeDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances]);
	
	/// Update defines for shader compilation
	/// @param mesh defines the mesh to be rendered
	/// @param nodeMaterial defines the node material requesting the update
	/// @param defines defines the material defines to update
	/// @param useInstances specifies that instances should be used
	/// @param subMesh defines which submesh to render
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	/// Lets the block try to connect some inputs automatically
	/// @param material defines the hosting NodeMaterial
	external void autoConfigure(NodeMaterial material);
	
	/// Function called when a block is declared as repeatable content generator
	/// @param vertexShaderState defines the current compilation state for the vertex shader
	/// @param fragmentShaderState defines the current compilation state for the fragment shader
	/// @param mesh defines the mesh to be rendered
	/// @param defines defines the material defines to update
	external void replaceRepeatableContent(NodeMaterialBuildState vertexShaderState, NodeMaterialBuildState fragmentShaderState, AbstractMesh mesh, NodeMaterialDefines defines);
	
	/// Checks if the block is ready
	/// @param mesh defines the mesh to be rendered
	/// @param nodeMaterial defines the node material requesting the update
	/// @param defines defines the material defines to update
	/// @param useInstances specifies that instances should be used
	/// @returns true if the block is ready
	external bool isReady(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances]);
	
	/// Validates the new name for the block node.
	/// @param newName the new name to be given to the node.
	/// @returns false if the name is a reserve word, else true.
	external bool validateBlockName(String newName);
	
	/// Compile the current node and generate the shader code
	/// @param state defines the current compilation state (uniforms, samplers, current string)
	/// @param activeBlocks defines the list of active blocks (i.e. blocks to compile)
	/// @returns true if already built
	external bool build(NodeMaterialBuildState state, List<NodeMaterialBlock> activeBlocks);
	
	/// Clone the current block to a new identical block
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a copy of the current block
	external NodeMaterialBlock? clone(Scene scene, [String? rootUrl]);
	
	/// Serializes this block in a JSON representation
	/// @returns the serialized block object
	external dynamic serialize();
	
	/// Release resources
	external void dispose();
}

/// Base class of materials working in push mode in babylon JS
/// @hidden
@JS()
class PushMaterial extends Material {
	
	external factory PushMaterial(String name, Scene scene);
	
	@override
	external Effect? getEffect();
	
	@override
	external bool isReady([AbstractMesh? mesh, bool? useInstances]);
	
	/// Binds the given world matrix to the active effect
	/// 
	/// @param world the matrix to bind
	@override
	external void bindOnlyWorldMatrix(Matrix world);
	
	/// Binds the given normal matrix to the active effect
	/// 
	/// @param normalMatrix the matrix to bind
	external void bindOnlyNormalMatrix(Matrix normalMatrix);
	
	@override
	external void bind(Matrix world, [Mesh? mesh]);
}

/// Root class for all node material optimizers
@JS()
class NodeMaterialOptimizer {
	external factory NodeMaterialOptimizer();
	
	/// Function used to optimize a NodeMaterial graph
	/// @param vertexOutputNodes defines the list of output nodes for the vertex shader
	/// @param fragmentOutputNodes defines the list of output nodes for the fragment shader
	external void optimize(List<NodeMaterialBlock> vertexOutputNodes, List<NodeMaterialBlock> fragmentOutputNodes);
}

/// Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4
@JS()
class TransformBlock extends NodeMaterialBlock {
	
	/// Creates a new TransformBlock
	/// @param name defines the block name
	external factory TransformBlock(String name);
	
	/// Defines the value to use to complement W value to transform it to a Vector4
	external num get complementW;
	external set complementW(num value);
	
	/// Defines the value to use to complement z value to transform it to a Vector4
	external num get complementZ;
	external set complementZ(num value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the vector input
	external NodeMaterialConnectionPoint get vector;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	/// Gets the xyz output component
	external NodeMaterialConnectionPoint get xyz;
	
	/// Gets the matrix transform input
	external NodeMaterialConnectionPoint get transform;
	
	/// Update defines for shader compilation
	/// @param mesh defines the mesh to be rendered
	/// @param nodeMaterial defines the node material requesting the update
	/// @param defines defines the material defines to update
	/// @param useInstances specifies that instances should be used
	/// @param subMesh defines which submesh to render
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external dynamic serialize();
}

/// Block used to output the vertex position
@JS()
class VertexOutputBlock extends NodeMaterialBlock {
	
	/// Creates a new VertexOutputBlock
	/// @param name defines the block name
	external factory VertexOutputBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the vector input component
	external NodeMaterialConnectionPoint get vector;
}

/// Block used to output the final color
@JS()
class FragmentOutputBlock extends NodeMaterialBlock {
	
	/// Create a new FragmentOutputBlock
	/// @param name defines the block name
	external factory FragmentOutputBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the rgba input component
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the rgb input component
	external NodeMaterialConnectionPoint get rgb;
	
	/// Gets the a input component
	external NodeMaterialConnectionPoint get a;
}

/// Block used for the particle ramp gradient section
@JS()
class ParticleRampGradientBlock extends NodeMaterialBlock {
	
	/// Create a new ParticleRampGradientBlock
	/// @param name defines the block name
	external factory ParticleRampGradientBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the rampColor output component
	external NodeMaterialConnectionPoint get rampColor;
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
}

/// Block used for the particle blend multiply section
@JS()
class ParticleBlendMultiplyBlock extends NodeMaterialBlock {
	
	/// Create a new ParticleBlendMultiplyBlock
	/// @param name defines the block name
	external factory ParticleBlendMultiplyBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the alphaTexture input component
	external NodeMaterialConnectionPoint get alphaTexture;
	
	/// Gets the alphaColor input component
	external NodeMaterialConnectionPoint get alphaColor;
	
	/// Gets the blendColor output component
	external NodeMaterialConnectionPoint get blendColor;
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
}

/// Block used to create a Vector2/3/4 out of individual inputs (one for each component)
@JS()
class VectorMergerBlock extends NodeMaterialBlock {
	
	/// Create a new VectorMergerBlock
	/// @param name defines the block name
	external factory VectorMergerBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the xyz component (input)
	external NodeMaterialConnectionPoint get xyzIn;
	
	/// Gets the xy component (input)
	external NodeMaterialConnectionPoint get xyIn;
	
	/// Gets the x component (input)
	external NodeMaterialConnectionPoint get x;
	
	/// Gets the y component (input)
	external NodeMaterialConnectionPoint get y;
	
	/// Gets the z component (input)
	external NodeMaterialConnectionPoint get z;
	
	/// Gets the w component (input)
	external NodeMaterialConnectionPoint get w;
	
	/// Gets the xyzw component (output)
	external NodeMaterialConnectionPoint get xyzw;
	
	/// Gets the xyz component (output)
	external NodeMaterialConnectionPoint get xyzOut;
	
	/// Gets the xy component (output)
	external NodeMaterialConnectionPoint get xyOut;
	
	/// Gets the xy component (output)
	/// @deprecated Please use xyOut instead.
	external NodeMaterialConnectionPoint get xy;
	
	/// Gets the xyz component (output)
	/// @deprecated Please use xyzOut instead.
	external NodeMaterialConnectionPoint get xyz;
}

/// Block used to remap a float from a range to a new one
@JS()
class RemapBlock extends NodeMaterialBlock {
	
	/// Creates a new RemapBlock
	/// @param name defines the block name
	external factory RemapBlock(String name);
	
	/// Gets or sets the source range
	external Vector2 get sourceRange;
	external set sourceRange(Vector2 value);
	
	/// Gets or sets the target range
	external Vector2 get targetRange;
	external set targetRange(Vector2 value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the source min input component
	external NodeMaterialConnectionPoint get sourceMin;
	
	/// Gets the source max input component
	external NodeMaterialConnectionPoint get sourceMax;
	
	/// Gets the target min input component
	external NodeMaterialConnectionPoint get targetMin;
	
	/// Gets the target max input component
	external NodeMaterialConnectionPoint get targetMax;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external dynamic serialize();
}

/// Block used to multiply 2 values
@JS()
class MultiplyBlock extends NodeMaterialBlock {
	
	/// Creates a new MultiplyBlock
	/// @param name defines the block name
	external factory MultiplyBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Interface used by value gradients (color, factor, ...)
@JS()
abstract class IValueGradient {
	
	/// Gets or sets the gradient value (between 0 and 1)
	external num get gradient;
	external set gradient(num value);
}

/// Class used to store color4 gradient
@JS()
class ColorGradient implements IValueGradient {
	
	/// Creates a new color4 gradient
	/// @param gradient gets or sets the gradient value (between 0 and 1)
	/// @param color1 gets or sets first associated color
	/// @param color2 gets or sets first second color
	external factory ColorGradient(num gradient, Color4 color1, [Color4? color2]);
	
	/// Gets or sets the gradient value (between 0 and 1)
	@override
	external num get gradient;
	@override
	external set gradient(num value);
	
	/// Gets or sets first associated color
	external Color4 get color1;
	external set color1(Color4 value);
	
	/// Gets or sets second associated color
	external Color4? get color2;
	external set color2(Color4? value);
	
	/// Will get a color picked randomly between color1 and color2.
	/// If color2 is undefined then color1 will be used
	/// @param result defines the target Color4 to store the result in
	external void getColorToRef(Color4 result);
}

/// Class used to store color 3 gradient
@JS()
class Color3Gradient implements IValueGradient {
	
	/// Creates a new color3 gradient
	/// @param gradient gets or sets the gradient value (between 0 and 1)
	/// @param color gets or sets associated color
	external factory Color3Gradient(num gradient, Color3 color);
	
	/// Gets or sets the gradient value (between 0 and 1)
	@override
	external num get gradient;
	@override
	external set gradient(num value);
	
	/// Gets or sets the associated color
	external Color3 get color;
	external set color(Color3 value);
}

/// Class used to store factor gradient
@JS()
class FactorGradient implements IValueGradient {
	
	/// Creates a new factor gradient
	/// @param gradient gets or sets the gradient value (between 0 and 1)
	/// @param factor1 gets or sets first associated factor
	/// @param factor2 gets or sets second associated factor
	external factory FactorGradient(num gradient, num factor1, [num? factor2]);
	
	/// Gets or sets the gradient value (between 0 and 1)
	@override
	external num get gradient;
	@override
	external set gradient(num value);
	
	/// Gets or sets first associated factor
	external num get factor1;
	external set factor1(num value);
	
	/// Gets or sets second associated factor
	external num? get factor2;
	external set factor2(num? value);
	
	/// Will get a number picked randomly between factor1 and factor2.
	/// If factor2 is undefined then factor1 will be used
	/// @returns the picked number
	external num getFactor();
}

/// Helper used to simplify some generic gradient tasks
@JS()
class GradientHelper {
	external factory GradientHelper();
	
	/// Gets the current gradient from an array of IValueGradient
	/// @param ratio defines the current ratio to get
	/// @param gradients defines the array of IValueGradient
	/// @param updateFunc defines the callback function used to get the final value from the selected gradients
	external static void GetCurrentGradient(num ratio, List<IValueGradient> gradients, void Function(IValueGradient current, IValueGradient next, num scale) updateFunc);
}

/// Raw texture can help creating a texture directly from an array of data.
/// This can be super useful if you either get the data from an uncompressed source or
/// if you wish to create your texture pixel by pixel.
@JS()
class RawTexture extends Texture {
	
	/// Instantiates a new RawTexture.
	/// Raw texture can help creating a texture directly from an array of data.
	/// This can be super useful if you either get the data from an uncompressed source or
	/// if you wish to create your texture pixel by pixel.
	/// @param data define the array of data to use to create the texture
	/// @param width define the width of the texture
	/// @param height define the height of the texture
	/// @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps define whether mip maps should be generated or not
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
	external factory RawTexture(dynamic data, num width, num height, num format, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode, num? type]);
	
	/// Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
	external num get format;
	external set format(num value);
	
	/// Updates the texture underlying data.
	/// @param data Define the new data of the texture
	external void update(dynamic data);
	
	/// Creates a luminance texture from some data.
	/// @param data Define the texture data
	/// @param width Define the width of the texture
	/// @param height Define the height of the texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps Define whether or not to create mip maps for the texture
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @returns the luminance texture
	external static RawTexture CreateLuminanceTexture(dynamic data, num width, num height, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode]);
	
	/// Creates a luminance alpha texture from some data.
	/// @param data Define the texture data
	/// @param width Define the width of the texture
	/// @param height Define the height of the texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps Define whether or not to create mip maps for the texture
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @returns the luminance alpha texture
	external static RawTexture CreateLuminanceAlphaTexture(dynamic data, num width, num height, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode]);
	
	/// Creates an alpha texture from some data.
	/// @param data Define the texture data
	/// @param width Define the width of the texture
	/// @param height Define the height of the texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps Define whether or not to create mip maps for the texture
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @returns the alpha texture
	external static RawTexture CreateAlphaTexture(dynamic data, num width, num height, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode]);
	
	/// Creates a RGB texture from some data.
	/// @param data Define the texture data
	/// @param width Define the width of the texture
	/// @param height Define the height of the texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps Define whether or not to create mip maps for the texture
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
	/// @returns the RGB alpha texture
	external static RawTexture CreateRGBTexture(dynamic data, num width, num height, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode, num? type]);
	
	/// Creates a RGBA texture from some data.
	/// @param data Define the texture data
	/// @param width Define the width of the texture
	/// @param height Define the height of the texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps Define whether or not to create mip maps for the texture
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
	/// @returns the RGBA texture
	external static RawTexture CreateRGBATexture(dynamic data, num width, num height, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode, num? type]);
	
	/// Creates a R texture from some data.
	/// @param data Define the texture data
	/// @param width Define the width of the texture
	/// @param height Define the height of the texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param generateMipMaps Define whether or not to create mip maps for the texture
	/// @param invertY define if the data should be flipped on Y when uploaded to the GPU
	/// @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
	/// @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
	/// @returns the R texture
	external static RawTexture CreateRTexture(dynamic data, num width, num height, dynamic? sceneOrEngine, [bool? generateMipMaps, bool? invertY, num? samplingMode, num? type]);
}

/// Base class of the scene acting as a container for the different elements composing a scene.
/// This class is dynamically extended by the different components of the scene increasing
/// flexibility and reducing coupling
@JS()
abstract class AbstractScene {
	external factory AbstractScene();
	
	/// Adds a parser in the list of available ones
	/// @param name Defines the name of the parser
	/// @param parser Defines the parser to add
	external static void AddParser(String name, dynamic parser);
	
	/// Gets a general parser from the list of avaialble ones
	/// @param name Defines the name of the parser
	/// @returns the requested parser or null
	external static dynamic? GetParser(String name);
	
	/// Adds n individual parser in the list of available ones
	/// @param name Defines the name of the parser
	/// @param parser Defines the parser to add
	external static void AddIndividualParser(String name, dynamic parser);
	
	/// Gets an individual parser from the list of avaialble ones
	/// @param name Defines the name of the parser
	/// @returns the requested parser or null
	external static dynamic? GetIndividualParser(String name);
	
	/// Parser json data and populate both a scene and its associated container object
	/// @param jsonData Defines the data to parse
	/// @param scene Defines the scene to parse the data for
	/// @param container Defines the container attached to the parsing sequence
	/// @param rootUrl Defines the root url of the data
	external static void Parse(dynamic jsonData, Scene scene, AssetContainer container, String rootUrl);
	
	/// Gets the list of root nodes (ie. nodes with no parent)
	external List<Node> get rootNodes;
	external set rootNodes(List<Node> value);
	
	/// All of the cameras added to this scene
	/// @see https://doc.babylonjs.com/babylon101/cameras
	external List<Camera> get cameras;
	external set cameras(List<Camera> value);
	
	/// All of the lights added to this scene
	/// @see https://doc.babylonjs.com/babylon101/lights
	external List<Light> get lights;
	external set lights(List<Light> value);
	
	/// All of the (abstract) meshes added to this scene
	external List<AbstractMesh> get meshes;
	external set meshes(List<AbstractMesh> value);
	
	/// The list of skeletons added to the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
	external List<Skeleton> get skeletons;
	external set skeletons(List<Skeleton> value);
	
	/// All of the particle systems added to this scene
	/// @see https://doc.babylonjs.com/babylon101/particles
	external List<IParticleSystem> get particleSystems;
	external set particleSystems(List<IParticleSystem> value);
	
	/// Gets a list of Animations associated with the scene
	external List<Animation>? get animations;
	external set animations(List<Animation>? value);
	
	/// All of the animation groups added to this scene
	/// @see https://doc.babylonjs.com/how_to/group
	external List<AnimationGroup> get animationGroups;
	external set animationGroups(List<AnimationGroup> value);
	
	/// All of the multi-materials added to this scene
	/// @see https://doc.babylonjs.com/how_to/multi_materials
	external List<MultiMaterial> get multiMaterials;
	external set multiMaterials(List<MultiMaterial> value);
	
	/// All of the materials added to this scene
	/// In the context of a Scene, it is not supposed to be modified manually.
	/// Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.
	/// Note also that the order of the Material within the array is not significant and might change.
	/// @see https://doc.babylonjs.com/babylon101/materials
	external List<Material> get materials;
	external set materials(List<Material> value);
	
	/// The list of morph target managers added to the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh
	external List<MorphTargetManager> get morphTargetManagers;
	external set morphTargetManagers(List<MorphTargetManager> value);
	
	/// The list of geometries used in the scene.
	external List<Geometry> get geometries;
	external set geometries(List<Geometry> value);
	
	/// All of the tranform nodes added to this scene
	/// In the context of a Scene, it is not supposed to be modified manually.
	/// Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.
	/// Note also that the order of the TransformNode wihin the array is not significant and might change.
	/// @see https://doc.babylonjs.com/how_to/transformnode
	external List<TransformNode> get transformNodes;
	external set transformNodes(List<TransformNode> value);
	
	/// ActionManagers available on the scene.
	external List<AbstractActionManager> get actionManagers;
	external set actionManagers(List<AbstractActionManager> value);
	
	/// Textures to keep.
	external List<BaseTexture> get textures;
	external set textures(List<BaseTexture> value);
	
	/// Texture used in all pbr material as the reflection texture.
	/// As in the majority of the scene they are the same (exception for multi room and so on),
	/// this is easier to reference from here than from all the materials.
	external BaseTexture? get environmentTexture;
	
	external set environmentTexture(BaseTexture? value);
	
	/// The list of postprocesses added to the scene
	external List<PostProcess> get postProcesses;
	external set postProcesses(List<PostProcess> value);
	
	/// @returns all meshes, lights, cameras, transformNodes and bones
	external List<Node> getNodes();
	
	/// The list of procedural textures added to the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures
	external List<ProceduralTexture> get proceduralTextures;
	external set proceduralTextures(List<ProceduralTexture> value);
	
	/// The list of sounds used in the scene.
	external List<Sound>? get sounds;
	external set sounds(List<Sound>? value);
	
	/// The list of effect layers (highlights/glow) added to the scene
	/// @see https://doc.babylonjs.com/how_to/highlight_layer
	/// @see https://doc.babylonjs.com/how_to/glow_layer
	external List<EffectLayer> get effectLayers;
	external set effectLayers(List<EffectLayer> value);
	
	/// Removes the given effect layer from this scene.
	/// @param toRemove defines the effect layer to remove
	/// @returns the index of the removed effect layer
	external num removeEffectLayer(EffectLayer toRemove);
	
	/// Adds the given effect layer to this scene
	/// @param newEffectLayer defines the effect layer to add
	external void addEffectLayer(EffectLayer newEffectLayer);
	
	/// Return a the first highlight layer of the scene with a given name.
	/// @param name The name of the highlight layer to look for.
	/// @return The highlight layer if found otherwise null.
	external GlowLayer? getGlowLayerByName(String name);
	
	/// Return a the first highlight layer of the scene with a given name.
	/// @param name The name of the highlight layer to look for.
	/// @return The highlight layer if found otherwise null.
	external HighlightLayer? getHighlightLayerByName(String name);
	
	/// The list of layers (background and foreground) of the scene
	external List<Layer> get layers;
	external set layers(List<Layer> value);
	
	/// The list of lens flare system added to the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
	external List<LensFlareSystem> get lensFlareSystems;
	external set lensFlareSystems(List<LensFlareSystem> value);
	
	/// Removes the given lens flare system from this scene.
	/// @param toRemove The lens flare system to remove
	/// @returns The index of the removed lens flare system
	external num removeLensFlareSystem(LensFlareSystem toRemove);
	
	/// Adds the given lens flare system to this scene
	/// @param newLensFlareSystem The lens flare system to add
	external void addLensFlareSystem(LensFlareSystem newLensFlareSystem);
	
	/// Gets a lens flare system using its name
	/// @param name defines the name to look for
	/// @returns the lens flare system or null if not found
	external LensFlareSystem? getLensFlareSystemByName(String name);
	
	/// Gets a lens flare system using its id
	/// @param id defines the id to look for
	/// @returns the lens flare system or null if not found
	external LensFlareSystem? getLensFlareSystemByID(String id);
	
	/// The list of reflection probes added to the scene
	/// @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes
	external List<ReflectionProbe> get reflectionProbes;
	external set reflectionProbes(List<ReflectionProbe> value);
	
	/// Removes the given reflection probe from this scene.
	/// @param toRemove The reflection probe to remove
	/// @returns The index of the removed reflection probe
	external num removeReflectionProbe(ReflectionProbe toRemove);
	
	/// Adds the given reflection probe to this scene.
	/// @param newReflectionProbe The reflection probe to add
	external void addReflectionProbe(ReflectionProbe newReflectionProbe);
	
	/// Gets or Sets the current prepass renderer associated to the scene.
	external PrePassRenderer? get prePassRenderer;
	external set prePassRenderer(PrePassRenderer? value);
	
	/// Enables the prepass and associates it with the scene
	/// @returns the PrePassRenderer
	external PrePassRenderer? enablePrePassRenderer();
	
	/// Disables the prepass associated with the scene
	external void disablePrePassRenderer();
	
	/// Gets or Sets the current prepass renderer associated to the scene.
	external SubSurfaceConfiguration? get subSurfaceConfiguration;
	external set subSurfaceConfiguration(SubSurfaceConfiguration? value);
	
	/// Enables the subsurface effect for prepass
	/// @returns the SubSurfaceConfiguration
	external SubSurfaceConfiguration? enableSubSurfaceForPrePass();
	
	/// Disables the subsurface effect for prepass
	external void disableSubSurfaceForPrePass();
}

/// Defines the Procedural Texture scene component responsible to manage any Procedural Texture
/// in a given scene.
@JS()
class ProceduralTextureSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory ProceduralTextureSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get proceduralVertexShader;

/// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.
/// This is the base class of any Procedural texture and contains most of the shareable code.
/// @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures
@JS()
class ProceduralTexture extends Texture {
	
	/// Instantiates a new procedural texture.
	/// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
	/// This is the base class of any Procedural texture and contains most of the shareable code.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures
	/// @param name  Define the name of the texture
	/// @param size Define the size of the texture to create
	/// @param fragment Define the fragment shader to use to generate the texture or null if it is defined later
	/// @param scene Define the scene the texture belongs to
	/// @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
	/// @param generateMipMaps Define if the texture should creates mip maps or not
	/// @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
	/// @param textureType The FBO internal texture type
	external factory ProceduralTexture(String name, dynamic size, dynamic fragment, Scene? scene, [Texture? fallbackTexture, bool? generateMipMaps, bool? isCube, num? textureType]);
	
	/// Define if the texture is enabled or not (disabled texture will not render)
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Define if the texture must be cleared before rendering (default is true)
	external bool get autoClear;
	external set autoClear(bool value);
	
	/// Callback called when the texture is generated
	external void Function() get onGenerated;
	external set onGenerated(void Function() value);
	
	/// Event raised when the texture is generated
	external Observable<ProceduralTexture> get onGeneratedObservable;
	external set onGeneratedObservable(Observable<ProceduralTexture> value);
	
	/// Event raised before the texture is generated
	external Observable<ProceduralTexture> get onBeforeGenerationObservable;
	external set onBeforeGenerationObservable(Observable<ProceduralTexture> value);
	
	/// Gets or sets the node material used to create this texture (null if the texture was manually created)
	external NodeMaterial? get nodeMaterialSource;
	external set nodeMaterialSource(NodeMaterial? value);
	
	/// The effect that is created when initializing the post process.
	/// @returns The created effect corresponding the the postprocess.
	external Effect getEffect();
	
	/// Gets texture content (Use this function wisely as reading from a texture can be slow)
	/// @returns an ArrayBufferView (Uint8Array or Float32Array)
	external dynamic? getContent();
	
	/// Resets the texture in order to recreate its associated resources.
	/// This can be called in case of context loss
	external void reset();
	
	/// Is the texture ready to be used ? (rendered at least once)
	/// @returns true if ready, otherwise, false.
	@override
	external bool isReady();
	
	/// Resets the refresh counter of the texture and start bak from scratch.
	/// Could be useful to regenerate the texture if it is setup to render only once.
	external void resetRefreshCounter();
	
	/// Set the fragment shader to use in order to render the texture.
	/// @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
	external void setFragment(dynamic fragment);
	
	/// Define the refresh rate of the texture or the rendering frequency.
	/// Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
	external num get refreshRate;
	
	external set refreshRate(num value);
	
	/// Get the size the texture is rendering at.
	/// @returns the size (on cube texture it is always squared)
	external dynamic getRenderSize();
	
	/// Resize the texture to new value.
	/// @param size Define the new size the texture should have
	/// @param generateMipMaps Define whether the new texture should create mip maps
	external void resize(num size, bool generateMipMaps);
	
	/// Set a texture in the shader program used to render.
	/// @param name Define the name of the uniform samplers as defined in the shader
	/// @param texture Define the texture to bind to this sampler
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setTexture(String name, Texture texture);
	
	/// Set a float in the shader.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setFloat(String name, num value);
	
	/// Set a int in the shader.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setInt(String name, num value);
	
	/// Set an array of floats in the shader.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setFloats(String name, List<num> value);
	
	/// Set a vec3 in the shader from a Color3.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setColor3(String name, Color3 value);
	
	/// Set a vec4 in the shader from a Color4.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setColor4(String name, Color4 value);
	
	/// Set a vec2 in the shader from a Vector2.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setVector2(String name, Vector2 value);
	
	/// Set a vec3 in the shader from a Vector3.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setVector3(String name, Vector3 value);
	
	/// Set a mat4 in the shader from a MAtrix.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the texture itself allowing "fluent" like uniform updates
	external ProceduralTexture setMatrix(String name, Matrix value);
	
	/// Render the texture to its associated render target.
	/// @param useCameraPostProcess Define if camera post process should be applied to the texture
	external void render([bool? useCameraPostProcess]);
	
	/// Clone the texture.
	/// @returns the cloned texture
	@override
	external ProceduralTexture? clone();
	
	/// Dispose the texture and release its asoociated resources.
	@override
	external void dispose();
}

/// This represents the base class for particle system in Babylon.
/// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
/// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
/// @example https://doc.babylonjs.com/babylon101/particles
@JS()
class BaseParticleSystem {
	
	/// Instantiates a particle system.
	/// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
	/// @param name The name of the particle system
	external factory BaseParticleSystem(String name);
	
	/// Source color is added to the destination color without alpha affecting the result
	external static num get BLENDMODE_ONEONE;
	external static set BLENDMODE_ONEONE(num value);
	
	/// Blend current color and particle color using particle’s alpha
	external static num get BLENDMODE_STANDARD;
	external static set BLENDMODE_STANDARD(num value);
	
	/// Add current color and particle color multiplied by particle’s alpha
	external static num get BLENDMODE_ADD;
	external static set BLENDMODE_ADD(num value);
	
	/// Multiply current color with particle color
	external static num get BLENDMODE_MULTIPLY;
	external static set BLENDMODE_MULTIPLY(num value);
	
	/// Multiply current color with particle color then add current color and particle color multiplied by particle’s alpha
	external static num get BLENDMODE_MULTIPLYADD;
	external static set BLENDMODE_MULTIPLYADD(num value);
	
	/// List of animations used by the particle system.
	external List<Animation>? get animations;
	external set animations(List<Animation>? value);
	
	/// Gets or sets the unique id of the particle system
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// The id of the Particle system.
	external String get id;
	external set id(String value);
	
	/// The friendly name of the Particle system.
	external String get name;
	external set name(String value);
	
	/// Snippet ID if the particle system was created from the snippet server
	external String get snippetId;
	external set snippetId(String value);
	
	/// The rendering group used by the Particle system to chose when to render.
	external num get renderingGroupId;
	external set renderingGroupId(num value);
	
	/// The emitter represents the Mesh or position we are attaching the particle system to.
	external dynamic? get emitter;
	external set emitter(dynamic? value);
	
	/// The maximum number of particles to emit per frame
	external num get emitRate;
	external set emitRate(num value);
	
	/// If you want to launch only a few particles at once, that can be done, as well.
	external num get manualEmitCount;
	external set manualEmitCount(num value);
	
	/// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
	external num get updateSpeed;
	external set updateSpeed(num value);
	
	/// The amount of time the particle system is running (depends of the overall update speed).
	external num get targetStopDuration;
	external set targetStopDuration(num value);
	
	/// Specifies whether the particle system will be disposed once it reaches the end of the animation.
	external bool get disposeOnStop;
	external set disposeOnStop(bool value);
	
	/// Minimum power of emitting particles.
	external num get minEmitPower;
	external set minEmitPower(num value);
	
	/// Maximum power of emitting particles.
	external num get maxEmitPower;
	external set maxEmitPower(num value);
	
	/// Minimum life time of emitting particles.
	external num get minLifeTime;
	external set minLifeTime(num value);
	
	/// Maximum life time of emitting particles.
	external num get maxLifeTime;
	external set maxLifeTime(num value);
	
	/// Minimum Size of emitting particles.
	external num get minSize;
	external set minSize(num value);
	
	/// Maximum Size of emitting particles.
	external num get maxSize;
	external set maxSize(num value);
	
	/// Minimum scale of emitting particles on X axis.
	external num get minScaleX;
	external set minScaleX(num value);
	
	/// Maximum scale of emitting particles on X axis.
	external num get maxScaleX;
	external set maxScaleX(num value);
	
	/// Minimum scale of emitting particles on Y axis.
	external num get minScaleY;
	external set minScaleY(num value);
	
	/// Maximum scale of emitting particles on Y axis.
	external num get maxScaleY;
	external set maxScaleY(num value);
	
	/// Gets or sets the minimal initial rotation in radians.
	external num get minInitialRotation;
	external set minInitialRotation(num value);
	
	/// Gets or sets the maximal initial rotation in radians.
	external num get maxInitialRotation;
	external set maxInitialRotation(num value);
	
	/// Minimum angular speed of emitting particles (Z-axis rotation for each particle).
	external num get minAngularSpeed;
	external set minAngularSpeed(num value);
	
	/// Maximum angular speed of emitting particles (Z-axis rotation for each particle).
	external num get maxAngularSpeed;
	external set maxAngularSpeed(num value);
	
	/// The texture used to render each particle. (this can be a spritesheet)
	external BaseTexture? get particleTexture;
	external set particleTexture(BaseTexture? value);
	
	/// The layer mask we are rendering the particles through.
	external num get layerMask;
	external set layerMask(num value);
	
	/// This can help using your own shader to render the particle system.
	/// The according effect will be created
	external dynamic get customShader;
	external set customShader(dynamic value);
	
	/// By default particle system starts as soon as they are created. This prevents the
	/// automatic start to happen and let you decide when to start emitting particles.
	external bool get preventAutoStart;
	external set preventAutoStart(bool value);
	
	/* Manual Fix 6 */
	
		/// Gets or sets a texture used to add random noise to particle positions
	external BaseTexture? get noiseTexture;
	
	external set noiseTexture(BaseTexture? value);
	
	/// Gets or sets the strength to apply to the noise value (default is (10, 10, 10))
	external Vector3 get noiseStrength;
	external set noiseStrength(Vector3 value);
	
	/// Callback triggered when the particle animation is ending.
	external void Function()? get onAnimationEnd;
	external set onAnimationEnd(void Function()? value);
	
	/// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
	external num get blendMode;
	external set blendMode(num value);
	
	/// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
	/// to override the particles.
	external bool get forceDepthWrite;
	external set forceDepthWrite(bool value);
	
	/// Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0
	external num get preWarmCycles;
	external set preWarmCycles(num value);
	
	/// Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1)
	external num get preWarmStepOffset;
	external set preWarmStepOffset(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
	external num get spriteCellChangeSpeed;
	external set spriteCellChangeSpeed(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
	external num get startSpriteCellID;
	external set startSpriteCellID(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
	external num get endSpriteCellID;
	external set endSpriteCellID(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
	external num get spriteCellWidth;
	external set spriteCellWidth(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
	external num get spriteCellHeight;
	external set spriteCellHeight(num value);
	
	/// This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
	external bool get spriteRandomStartCell;
	external set spriteRandomStartCell(bool value);
	
	/// Gets or sets a Vector2 used to move the pivot (by default (0,0))
	external Vector2 get translationPivot;
	external set translationPivot(Vector2 value);
	
	/// Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
	external bool get beginAnimationOnStart;
	external set beginAnimationOnStart(bool value);
	
	/// Gets or sets the frame to start the animation from when beginAnimationOnStart is true
	external num get beginAnimationFrom;
	external set beginAnimationFrom(num value);
	
	/// Gets or sets the frame to end the animation on when beginAnimationOnStart is true
	external num get beginAnimationTo;
	external set beginAnimationTo(num value);
	
	/// Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
	external bool get beginAnimationLoop;
	external set beginAnimationLoop(bool value);
	
	/// Gets or sets a world offset applied to all particles
	external Vector3 get worldOffset;
	external set worldOffset(Vector3 value);
	
	/// Gets or sets whether an animation sprite sheet is enabled or not on the particle system
	external bool get isAnimationSheetEnabled;
	
	external set isAnimationSheetEnabled(bool value);
	
	/// Get hosting scene
	/// @returns the scene
	external Scene? getScene();
	
	/// You can use gravity if you want to give an orientation to your particles.
	external Vector3 get gravity;
	external set gravity(Vector3 value);
	
	/// Defines the delay in milliseconds before starting the system (0 by default)
	external num get startDelay;
	external set startDelay(num value);
	
	/// Gets the current list of drag gradients.
	/// You must use addDragGradient and removeDragGradient to udpate this list
	/// @returns the list of drag gradients
	external List<FactorGradient>? getDragGradients();
	
	/// Gets or sets a value indicating the damping to apply if the limit velocity factor is reached
	external num get limitVelocityDamping;
	external set limitVelocityDamping(num value);
	
	/// Gets the current list of limit velocity gradients.
	/// You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
	/// @returns the list of limit velocity gradients
	external List<FactorGradient>? getLimitVelocityGradients();
	
	/// Gets the current list of color gradients.
	/// You must use addColorGradient and removeColorGradient to udpate this list
	/// @returns the list of color gradients
	external List<ColorGradient>? getColorGradients();
	
	/// Gets the current list of size gradients.
	/// You must use addSizeGradient and removeSizeGradient to udpate this list
	/// @returns the list of size gradients
	external List<FactorGradient>? getSizeGradients();
	
	/// Gets the current list of color remap gradients.
	/// You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
	/// @returns the list of color remap gradients
	external List<FactorGradient>? getColorRemapGradients();
	
	/// Gets the current list of alpha remap gradients.
	/// You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
	/// @returns the list of alpha remap gradients
	external List<FactorGradient>? getAlphaRemapGradients();
	
	/// Gets the current list of life time gradients.
	/// You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
	/// @returns the list of life time gradients
	external List<FactorGradient>? getLifeTimeGradients();
	
	/// Gets the current list of angular speed gradients.
	/// You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
	/// @returns the list of angular speed gradients
	external List<FactorGradient>? getAngularSpeedGradients();
	
	/// Gets the current list of velocity gradients.
	/// You must use addVelocityGradient and removeVelocityGradient to udpate this list
	/// @returns the list of velocity gradients
	external List<FactorGradient>? getVelocityGradients();
	
	/// Gets the current list of start size gradients.
	/// You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
	/// @returns the list of start size gradients
	external List<FactorGradient>? getStartSizeGradients();
	
	/// Gets the current list of emit rate gradients.
	/// You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
	/// @returns the list of emit rate gradients
	external List<FactorGradient>? getEmitRateGradients();
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	/// This only works when particleEmitterTyps is a BoxParticleEmitter
	external Vector3 get direction1;
	
	external set direction1(Vector3 value);
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	/// This only works when particleEmitterTyps is a BoxParticleEmitter
	external Vector3 get direction2;
	
	external set direction2(Vector3 value);
	
	/// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
	/// This only works when particleEmitterTyps is a BoxParticleEmitter
	external Vector3 get minEmitBox;
	
	external set minEmitBox(Vector3 value);
	
	/// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
	/// This only works when particleEmitterTyps is a BoxParticleEmitter
	external Vector3 get maxEmitBox;
	
	external set maxEmitBox(Vector3 value);
	
	/// Random color of each particle after it has been emitted, between color1 and color2 vectors
	external Color4 get color1;
	external set color1(Color4 value);
	
	/// Random color of each particle after it has been emitted, between color1 and color2 vectors
	external Color4 get color2;
	external set color2(Color4 value);
	
	/// Color the particle will have at the end of its lifetime
	external Color4 get colorDead;
	external set colorDead(Color4 value);
	
	/// An optional mask to filter some colors out of the texture, or filter a part of the alpha channel
	external Color4 get textureMask;
	external set textureMask(Color4 value);
	
	/// The particle emitter type defines the emitter used by the particle system.
	/// It can be for example box, sphere, or cone...
	external IParticleEmitterType? get particleEmitterType;
	external set particleEmitterType(IParticleEmitterType? value);
	
	/// Gets or sets the billboard mode to use when isBillboardBased = true.
	/// Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
	external num get billboardMode;
	external set billboardMode(num value);
	
	/// Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
	external bool get isBillboardBased;
	
	external set isBillboardBased(bool value);
	
	/// Gets the image processing configuration used either in this material.
	external ImageProcessingConfiguration? get imageProcessingConfiguration;
	
	/// Sets the Default image processing configuration used either in the this material.
	/// 
	/// If sets to null, the scene one is in use.
	external set imageProcessingConfiguration(ImageProcessingConfiguration? value);
	
	/// Creates a Point Emitter for the particle system (emits directly from the emitter position)
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the box
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the box
	/// @returns the emitter
	external PointParticleEmitter createPointEmitter(Vector3 direction1, Vector3 direction2);
	
	/// Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
	/// @param radius The radius of the hemisphere to emit from
	/// @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
	/// @returns the emitter
	external HemisphericParticleEmitter createHemisphericEmitter([num? radius, num? radiusRange]);
	
	/// Creates a Sphere Emitter for the particle system (emits along the sphere radius)
	/// @param radius The radius of the sphere to emit from
	/// @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
	/// @returns the emitter
	external SphereParticleEmitter createSphereEmitter([num? radius, num? radiusRange]);
	
	/// Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
	/// @param radius The radius of the sphere to emit from
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
	/// @returns the emitter
	external SphereDirectedParticleEmitter createDirectedSphereEmitter([num? radius, Vector3? direction1, Vector3? direction2]);
	
	/// Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
	/// @param radius The radius of the emission cylinder
	/// @param height The height of the emission cylinder
	/// @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
	/// @param directionRandomizer How much to randomize the particle direction [0-1]
	/// @returns the emitter
	external CylinderParticleEmitter createCylinderEmitter([num? radius, num? height, num? radiusRange, num? directionRandomizer]);
	
	/// Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
	/// @param radius The radius of the cylinder to emit from
	/// @param height The height of the emission cylinder
	/// @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
	/// @returns the emitter
	external CylinderDirectedParticleEmitter createDirectedCylinderEmitter([num? radius, num? height, num? radiusRange, Vector3? direction1, Vector3? direction2]);
	
	/// Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
	/// @param radius The radius of the cone to emit from
	/// @param angle The base angle of the cone
	/// @returns the emitter
	external ConeParticleEmitter createConeEmitter([num? radius, num? angle]);
	
	/// Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the box
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the box
	/// @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
	/// @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
	/// @returns the emitter
	external BoxParticleEmitter createBoxEmitter(Vector3 direction1, Vector3 direction2, Vector3 minEmitBox, Vector3 maxEmitBox);
}

/* enum */
abstract class SubEmitterType {
	
	/// Attached to the particle over it's lifetime
	static const int ATTACHED = 1;
	
	/// Created when the particle dies
	static const int END = 2;
}

/// Sub emitter class used to emit particles from an existing particle
@JS()
class SubEmitter {
	
	/// Creates a sub emitter
	/// @param particleSystem the particle system to be used by the sub emitter
	external factory SubEmitter(ParticleSystem particleSystem);
	
	/// the particle system to be used by the sub emitter
	external ParticleSystem get particleSystem;
	external set particleSystem(ParticleSystem value);
	
	/// Type of the submitter (Default: END)
	external int get type;
	external set type(int value);
	
	/// If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)
	/// Note: This only is supported when using an emitter of type Mesh
	external bool get inheritDirection;
	external set inheritDirection(bool value);
	
	/// How much of the attached particles speed should be added to the sub emitted particle (default: 0)
	external num get inheritedVelocityAmount;
	external set inheritedVelocityAmount(num value);
	
	/// Clones the sub emitter
	/// @returns the cloned sub emitter
	external SubEmitter clone();
	
	/// Serialize current object to a JSON object
	/// @returns the serialized object
	external dynamic serialize();
	
	/// Creates a new SubEmitter from a serialized JSON version
	/// @param serializationObject defines the JSON object to read from
	/// @param sceneOrEngine defines the hosting scene or the hosting engine
	/// @param rootUrl defines the rootUrl for data loading
	/// @returns a new SubEmitter
	external static SubEmitter Parse(dynamic serializationObject, dynamic sceneOrEngine, String rootUrl);
	
	/// Release associated resources
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get clipPlaneFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get imageProcessingDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get imageProcessingFunctions;

/* var */
/// @hidden
@JS()
external dynamic get clipPlaneFragment;

/* var */
/// @hidden
@JS()
external dynamic get particlesPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get clipPlaneVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get clipPlaneVertex;

/* var */
/// @hidden
@JS()
external dynamic get particlesVertexShader;

/// Interface used to define entities containing multiple clip planes
@JS()
abstract class IClipPlanesHolder {
	
	/// Gets or sets the active clipplane 1
	external Plane? get clipPlane;
	external set clipPlane(Plane? value);
	
	/// Gets or sets the active clipplane 2
	external Plane? get clipPlane2;
	external set clipPlane2(Plane? value);
	
	/// Gets or sets the active clipplane 3
	external Plane? get clipPlane3;
	external set clipPlane3(Plane? value);
	
	/// Gets or sets the active clipplane 4
	external Plane? get clipPlane4;
	external set clipPlane4(Plane? value);
	
	/// Gets or sets the active clipplane 5
	external Plane? get clipPlane5;
	external set clipPlane5(Plane? value);
	
	/// Gets or sets the active clipplane 6
	external Plane? get clipPlane6;
	external set clipPlane6(Plane? value);
}

/// "Static Class" containing a few commonly used helper while dealing with material for rendering purpose.
/// 
/// It is complementary with MaterialHelper but provides completely independent functions (for tree shaking sake)
/// 
/// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
@JS()
class ThinMaterialHelper {
	external factory ThinMaterialHelper();
	
	/// Binds the clip plane information from the holder to the effect.
	/// @param effect The effect we are binding the data to
	/// @param holder The entity containing the clip plane information
	external static void BindClipPlane(Effect effect, IClipPlanesHolder holder);
}

/// This represents a particle system in Babylon.
/// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
/// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
/// @example https://doc.babylonjs.com/babylon101/particles
@JS()
class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {
	
	/// Instantiates a particle system.
	/// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
	/// @param name The name of the particle system
	/// @param capacity The max number of particles alive at the same time
	/// @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
	/// @param customEffect a custom effect used to change the way particles are rendered by default
	/// @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
	/// @param epsilon Offset used to render the particles
	external factory ParticleSystem(String name, num capacity, dynamic sceneOrEngine, [Effect? customEffect, bool? isAnimationSheetEnabled, num? epsilon]);
	
	/// Billboard mode will only apply to Y axis
	external static num get BILLBOARDMODE_Y;
	
	/// Billboard mode will apply to all axes
	external static num get BILLBOARDMODE_ALL;
	
	/// Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
	external static num get BILLBOARDMODE_STRETCHED;
	
	/// This function can be defined to provide custom update for active particles.
	/// This function will be called instead of regular update (age, position, color, etc.).
	/// Do not forget that this function will be called on every frame so try to keep it simple and fast :)
	external void Function(List<Particle> particles) get updateFunction;
	external set updateFunction(void Function(List<Particle> particles) value);
	
	/// This function can be defined to specify initial direction for every new particle.
	/// It by default use the emitterType defined function
	external void Function(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal) get startDirectionFunction;
	external set startDirectionFunction(void Function(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal) value);
	
	/// This function can be defined to specify initial position for every new particle.
	/// It by default use the emitterType defined function
	external void Function(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal) get startPositionFunction;
	external set startPositionFunction(void Function(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal) value);
	
	/// An event triggered when the system is disposed
	@override
	external Observable<IParticleSystem> get onDisposeObservable;
	@override
	external set onDisposeObservable(Observable<IParticleSystem> value);
	
	/// An event triggered when the system is stopped
	@override
	external Observable<IParticleSystem> get onStoppedObservable;
	@override
	external set onStoppedObservable(Observable<IParticleSystem> value);
	
	/// Sets a callback that will be triggered when the system is disposed
	external set onDispose(void Function() value);
	
	/// Gets or sets a matrix to use to compute projection
	@override
	external Matrix get defaultProjectionMatrix;
	@override
	external set defaultProjectionMatrix(Matrix value);
	
	/// Gets or sets a matrix to use to compute view
	external Matrix get defaultViewMatrix;
	external set defaultViewMatrix(Matrix value);
	
	/// The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.
	/// When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])
	external List<dynamic> get subEmitters;
	external set subEmitters(List<dynamic> value);
	
	/// The current active Sub-systems, this property is used by the root particle system only.
	external List<ParticleSystem> get activeSubSystems;
	external set activeSubSystems(List<ParticleSystem> value);
	
	/// Specifies if the particles are updated in emitter local space or world space
	@override
	external bool get isLocal;
	@override
	external set isLocal(bool value);
	
	/// Gets the current list of active particles
	external List<Particle> get particles;
	
	/// Gets the number of particles active at the same time.
	/// @returns The number of active particles.
	@override
	external num getActiveCount();
	
	/// Returns the string "ParticleSystem"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Gets a boolean indicating that the system is stopping
	/// @returns true if the system is currently stopping
	@override
	external bool isStopping();
	
	/// Gets the custom effect used to render the particles
	/// @param blendMode Blend mode for which the effect should be retrieved
	/// @returns The effect
	@override
	external Effect? getCustomEffect([num? blendMode]);
	
	/// Sets the custom effect used to render the particles
	/// @param effect The effect to set
	/// @param blendMode Blend mode for which the effect should be set
	@override
	external void setCustomEffect(Effect? effect, [num? blendMode]);
	
	/// Adds a new life time gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the life time factor to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addLifeTimeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific life time gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeLifeTimeGradient(num gradient);
	
	/// Adds a new size gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the size factor to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addSizeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific size gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeSizeGradient(num gradient);
	
	/// Adds a new color remap gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param min defines the color remap minimal range
	/// @param max defines the color remap maximal range
	/// @returns the current particle system
	@override
	external IParticleSystem addColorRemapGradient(num gradient, num min, num max);
	
	/// Remove a specific color remap gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeColorRemapGradient(num gradient);
	
	/// Adds a new alpha remap gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param min defines the alpha remap minimal range
	/// @param max defines the alpha remap maximal range
	/// @returns the current particle system
	@override
	external IParticleSystem addAlphaRemapGradient(num gradient, num min, num max);
	
	/// Remove a specific alpha remap gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeAlphaRemapGradient(num gradient);
	
	/// Adds a new angular speed gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the angular speed  to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addAngularSpeedGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific angular speed gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeAngularSpeedGradient(num gradient);
	
	/// Adds a new velocity gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the velocity to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addVelocityGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific velocity gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeVelocityGradient(num gradient);
	
	/// Adds a new limit velocity gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the limit velocity value to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addLimitVelocityGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific limit velocity gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeLimitVelocityGradient(num gradient);
	
	/// Adds a new drag gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the drag value to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addDragGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific drag gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeDragGradient(num gradient);
	
	/// Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the emit rate value to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addEmitRateGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific emit rate gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeEmitRateGradient(num gradient);
	
	/// Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the start size value to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addStartSizeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific start size gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeStartSizeGradient(num gradient);
	
	/// Gets the current list of ramp gradients.
	/// You must use addRampGradient and removeRampGradient to udpate this list
	/// @returns the list of ramp gradients
	@override
	external List<Color3Gradient>? getRampGradients();
	
	/// Force the system to rebuild all gradients that need to be resync
	@override
	external void forceRefreshGradients();
	
	/// Adds a new ramp gradient used to remap particle colors
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param color defines the color to affect to the specified gradient
	/// @returns the current particle system
	@override
	external ParticleSystem addRampGradient(num gradient, Color3 color);
	
	/// Remove a specific ramp gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external ParticleSystem removeRampGradient(num gradient);
	
	/// Adds a new color gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param color1 defines the color to affect to the specified gradient
	/// @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
	/// @returns this particle system
	@override
	external IParticleSystem addColorGradient(num gradient, Color4 color1, [Color4? color2]);
	
	/// Remove a specific color gradient
	/// @param gradient defines the gradient to remove
	/// @returns this particle system
	@override
	external IParticleSystem removeColorGradient(num gradient);
	
	/// Gets the maximum number of particles active at the same time.
	/// @returns The max number of active particles.
	@override
	external num getCapacity();
	
	/// Gets whether there are still active particles in the system.
	/// @returns True if it is alive, otherwise false.
	external bool isAlive();
	
	/// Gets if the system has been started. (Note: this will still be true after stop is called)
	/// @returns True if it has been started, otherwise false.
	@override
	external bool isStarted();
	
	/// Starts the particle system and begins to emit
	/// @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
	@override
	external void start([num? delay]);
	
	/// Stops the particle system.
	/// @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.
	@override
	external void stop([bool? stopSubEmitters]);
	
	/// Remove all active particles
	@override
	external void reset();
	
	/// "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
	/// Its lifetime will start back at 0.
	external void Function(Particle particle) get recycleParticle;
	external set recycleParticle(void Function(Particle particle) value);
	
	/// Fill the defines array according to the current settings of the particle system
	/// @param defines Array to be updated
	/// @param blendMode blend mode to take into account when updating the array
	@override
	external void fillDefines(List<String> defines, num blendMode);
	
	/// Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
	/// @param uniforms Uniforms array to fill
	/// @param attributes Attributes array to fill
	/// @param samplers Samplers array to fill
	@override
	external void fillUniformsAttributesAndSamplerNames(List<String> uniforms, List<String> attributes, List<String> samplers);
	
	/// Animates the particle system for the current frame by emitting new particles and or animating the living ones.
	/// @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)
	@override
	external void animate([bool? preWarmOnly]);
	
	/// Rebuilds the particle system.
	@override
	external void rebuild();
	
	/// Is this system ready to be used/rendered
	/// @return true if the system is ready
	@override
	external bool isReady();
	
	/// Renders the particle system in its current state.
	/// @returns the current number of particles
	@override
	external num render();
	
	/// Disposes the particle system and free the associated resources
	/// @param disposeTexture defines if the particule texture must be disposed as well (true by default)
	@override
	external void dispose([bool? disposeTexture]);
	
	/// Clones the particle system.
	/// @param name The name of the cloned object
	/// @param newEmitter The new emitter to use
	/// @returns the cloned particle system
	@override
	external ParticleSystem? clone(String name, dynamic newEmitter);
	
	/// Serializes the particle system to a JSON object
	/// @param serializeTexture defines if the texture must be serialized as well
	/// @returns the JSON object
	@override
	external dynamic serialize([bool? serializeTexture]);
	
	/// Parses a JSON object to create a particle system.
	/// @param parsedParticleSystem The JSON object to parse
	/// @param sceneOrEngine The scene or the engine to create the particle system in
	/// @param rootUrl The root url to use to load external dependencies like texture
	/// @param doNotStart Ignore the preventAutoStart attribute and does not start
	/// @returns the Parsed particle system
	external static ParticleSystem Parse(dynamic parsedParticleSystem, dynamic sceneOrEngine, String rootUrl, [bool? doNotStart]);
	
	/// Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
	external bool get isBillboardBased;
	external set isBillboardBased(bool value);
	
	/// Gets or sets a boolean indicating if a spritesheet is used to animate the particles texture
	external bool get isAnimationSheetEnabled;
	external set isAnimationSheetEnabled(bool value);
	
	/// Gets or sets a texture used to add random noise to particle positions
	external BaseTexture? get noiseTexture;
	external set noiseTexture(BaseTexture? value);
	
	/// Observable that will be called just before the particles are drawn
	external Observable<Effect?> get onBeforeDrawParticlesObservable;
	external set onBeforeDrawParticlesObservable(Observable<Effect?> value);
	
	/// Gets the name of the particle vertex shader
	external String get vertexShaderName;
	external set vertexShaderName(String value);
	
	/// Gets or sets a boolean indicating that ramp gradients must be used
	/// @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients
	external bool get useRampGradients;
	external set useRampGradients(bool value);
}

/// A particle represents one of the element emitted by a particle system.
/// This is mainly define by its coordinates, direction, velocity and age.
@JS()
class Particle {
	
	/// Creates a new instance Particle
	/// @param particleSystem the particle system the particle belongs to
	external factory Particle(ParticleSystem particleSystem);
	
	/// The particle system the particle belongs to.
	external ParticleSystem get particleSystem;
	external set particleSystem(ParticleSystem value);
	
	/// Unique ID of the particle
	external num get id;
	external set id(num value);
	
	/// The world position of the particle in the scene.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// The world direction of the particle in the scene.
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// The color of the particle.
	external Color4 get color;
	external set color(Color4 value);
	
	/// The color change of the particle per step.
	external Color4 get colorStep;
	external set colorStep(Color4 value);
	
	/// Defines how long will the life of the particle be.
	external num get lifeTime;
	external set lifeTime(num value);
	
	/// The current age of the particle.
	external num get age;
	external set age(num value);
	
	/// The current size of the particle.
	external num get size;
	external set size(num value);
	
	/// The current scale of the particle.
	external Vector2 get scale;
	external set scale(Vector2 value);
	
	/// The current angle of the particle.
	external num get angle;
	external set angle(num value);
	
	/// Defines how fast is the angle changing.
	external num get angularSpeed;
	external set angularSpeed(num value);
	
	/// Defines the cell index used by the particle to be rendered from a sprite.
	external num get cellIndex;
	external set cellIndex(num value);
	
	/// The information required to support color remapping
	external Vector4 get remapData;
	external set remapData(Vector4 value);
	
	/// Defines how the sprite cell index is updated for the particle
	external void updateCellIndex();
	
	/// Copy the properties of particle to another one.
	/// @param other the particle to copy the information to.
	external void copyTo(Particle other);
}

/// Particle emitter represents a volume emitting particles.
/// This is the responsibility of the implementation to define the volume shape like cone/sphere/box.
@JS()
abstract class IParticleEmitterType {
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	external IParticleEmitterType clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns the effect defines string
	external String getEffectDefines();
	
	/// Returns a string representing the class name
	/// @returns a string containing the class name
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	/// @param scene defines the hosting scene
	external void parse(dynamic serializationObject, Scene? scene);
}

/// Particle emitter emitting particles from the inside of a box.
/// It emits the particles randomly between 2 given directions.
@JS()
class BoxParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance BoxParticleEmitter
	external factory BoxParticleEmitter();
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	external Vector3 get direction1;
	external set direction1(Vector3 value);
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	external Vector3 get direction2;
	external set direction2(Vector3 value);
	
	/// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
	external Vector3 get minEmitBox;
	external set minEmitBox(Vector3 value);
	
	/// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
	external Vector3 get maxEmitBox;
	external set maxEmitBox(Vector3 value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external BoxParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "BoxParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a cone.
/// It emits the particles alongside the cone volume from the base to the particle.
/// The emission direction might be randomized.
@JS()
class ConeParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance ConeParticleEmitter
	/// @param radius the radius of the emission cone (1 by default)
	/// @param angle the cone base angle (PI by default)
	/// @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)
	external factory ConeParticleEmitter([num? radius, num? angle, num? directionRandomizer]);
	
	/// defines how much to randomize the particle direction [0-1] (default is 0)
	external num get directionRandomizer;
	external set directionRandomizer(num value);
	
	/// Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)
	external num get radiusRange;
	external set radiusRange(num value);
	
	/// Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)
	external num get heightRange;
	external set heightRange(num value);
	
	/// Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)
	external bool get emitFromSpawnPointOnly;
	external set emitFromSpawnPointOnly(bool value);
	
	/// Gets or sets the radius of the emission cone
	external num get radius;
	
	external set radius(num value);
	
	/// Gets or sets the angle of the emission cone
	external num get angle;
	
	external set angle(num value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external ConeParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "ConeParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a cylinder.
/// It emits the particles alongside the cylinder radius. The emission direction might be randomized.
@JS()
class CylinderParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance CylinderParticleEmitter
	/// @param radius the radius of the emission cylinder (1 by default)
	/// @param height the height of the emission cylinder (1 by default)
	/// @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
	/// @param directionRandomizer defines how much to randomize the particle direction [0-1]
	external factory CylinderParticleEmitter([num? radius, num? height, num? radiusRange, num? directionRandomizer]);
	
	/// The radius of the emission cylinder.
	external num get radius;
	external set radius(num value);
	
	/// The height of the emission cylinder.
	external num get height;
	external set height(num value);
	
	/// The range of emission [0-1] 0 Surface only, 1 Entire Radius.
	external num get radiusRange;
	external set radiusRange(num value);
	
	/// How much to randomize the particle direction [0-1].
	external num get directionRandomizer;
	external set directionRandomizer(num value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external CylinderParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "CylinderParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a cylinder.
/// It emits the particles randomly between two vectors.
@JS()
class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {
	
	/// Creates a new instance CylinderDirectedParticleEmitter
	/// @param radius the radius of the emission cylinder (1 by default)
	/// @param height the height of the emission cylinder (1 by default)
	/// @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
	/// @param direction1 the min limit of the emission direction (up vector by default)
	/// @param direction2 the max limit of the emission direction (up vector by default)
	external factory CylinderDirectedParticleEmitter([num? radius, num? height, num? radiusRange, Vector3? direction1, Vector3? direction2]);
	
	/// The min limit of the emission direction.
	external Vector3 get direction1;
	external set direction1(Vector3 value);
	
	/// The max limit of the emission direction.
	external Vector3 get direction2;
	external set direction2(Vector3 value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, [bool? isLocal]);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external CylinderDirectedParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "CylinderDirectedParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a hemisphere.
/// It emits the particles alongside the hemisphere radius. The emission direction might be randomized.
@JS()
class HemisphericParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance HemisphericParticleEmitter
	/// @param radius the radius of the emission hemisphere (1 by default)
	/// @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
	/// @param directionRandomizer defines how much to randomize the particle direction [0-1]
	external factory HemisphericParticleEmitter([num? radius, num? radiusRange, num? directionRandomizer]);
	
	/// The radius of the emission hemisphere.
	external num get radius;
	external set radius(num value);
	
	/// The range of emission [0-1] 0 Surface only, 1 Entire Radius.
	external num get radiusRange;
	external set radiusRange(num value);
	
	/// How much to randomize the particle direction [0-1].
	external num get directionRandomizer;
	external set directionRandomizer(num value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external HemisphericParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "HemisphericParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from a point.
/// It emits the particles randomly between 2 given directions.
@JS()
class PointParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance PointParticleEmitter
	external factory PointParticleEmitter();
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	external Vector3 get direction1;
	external set direction1(Vector3 value);
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	external Vector3 get direction2;
	external set direction2(Vector3 value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external PointParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "PointParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a sphere.
/// It emits the particles alongside the sphere radius. The emission direction might be randomized.
@JS()
class SphereParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance SphereParticleEmitter
	/// @param radius the radius of the emission sphere (1 by default)
	/// @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
	/// @param directionRandomizer defines how much to randomize the particle direction [0-1]
	external factory SphereParticleEmitter([num? radius, num? radiusRange, num? directionRandomizer]);
	
	/// The radius of the emission sphere.
	external num get radius;
	external set radius(num value);
	
	/// The range of emission [0-1] 0 Surface only, 1 Entire Radius.
	external num get radiusRange;
	external set radiusRange(num value);
	
	/// How much to randomize the particle direction [0-1].
	external num get directionRandomizer;
	external set directionRandomizer(num value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external SphereParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "SphereParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a sphere.
/// It emits the particles randomly between two vectors.
@JS()
class SphereDirectedParticleEmitter extends SphereParticleEmitter {
	
	/// Creates a new instance SphereDirectedParticleEmitter
	/// @param radius the radius of the emission sphere (1 by default)
	/// @param direction1 the min limit of the emission direction (up vector by default)
	/// @param direction2 the max limit of the emission direction (up vector by default)
	external factory SphereDirectedParticleEmitter([num? radius, Vector3? direction1, Vector3? direction2]);
	
	/// The min limit of the emission direction.
	external Vector3 get direction1;
	external set direction1(Vector3 value);
	
	/// The max limit of the emission direction.
	external Vector3 get direction2;
	external set direction2(Vector3 value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, [bool? isLocal]);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external SphereDirectedParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "SphereDirectedParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from a custom list of positions.
@JS()
class CustomParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance CustomParticleEmitter
	external factory CustomParticleEmitter();
	
	/// Gets or sets the position generator that will create the inital position of each particle.
	/// Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles
	external void Function(num index, Particle? particle, Vector3 outPosition) get particlePositionGenerator;
	external set particlePositionGenerator(void Function(num index, Particle? particle, Vector3 outPosition) value);
	
	/// Gets or sets the destination generator that will create the final destination of each particle.
	/// * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles
	external void Function(num index, Particle? particle, Vector3 outDestination) get particleDestinationGenerator;
	external set particleDestinationGenerator(void Function(num index, Particle? particle, Vector3 outDestination) value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external CustomParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "PointParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	@override
	external void parse(dynamic serializationObject, [Scene? scene]);
}

/// Particle emitter emitting particles from the inside of a box.
/// It emits the particles randomly between 2 given directions.
@JS()
class MeshParticleEmitter implements IParticleEmitterType {
	
	/// Creates a new instance MeshParticleEmitter
	/// @param mesh defines the mesh to use as source
	external factory MeshParticleEmitter([AbstractMesh? mesh]);
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	external Vector3 get direction1;
	external set direction1(Vector3 value);
	
	/// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
	external Vector3 get direction2;
	external set direction2(Vector3 value);
	
	/// Gets or sets a boolean indicating that particle directions must be built from mesh face normals
	external bool get useMeshNormalsForDirection;
	external set useMeshNormalsForDirection(bool value);
	
	/// Defines the mesh to use as source
	external AbstractMesh? get mesh;
	
	external set mesh(AbstractMesh? value);
	
	/// Called by the particle System when the direction is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param directionToUpdate is the direction vector to update with the result
	/// @param particle is the particle we are computed the direction for
	/// @param isLocal defines if the direction should be set in local space
	@override
	external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle, bool isLocal);
	
	/// Called by the particle System when the position is computed for the created particle.
	/// @param worldMatrix is the world matrix of the particle system
	/// @param positionToUpdate is the position vector to update with the result
	/// @param particle is the particle we are computed the position for
	/// @param isLocal defines if the position should be set in local space
	@override
	external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle, bool isLocal);
	
	/// Clones the current emitter and returns a copy of it
	/// @returns the new emitter
	@override
	external MeshParticleEmitter clone();
	
	/// Called by the GPUParticleSystem to setup the update shader
	/// @param effect defines the update shader
	@override
	external void applyToShader(Effect effect);
	
	/// Returns a string to use to update the GPU particles update shader
	/// @returns a string containng the defines string
	@override
	external String getEffectDefines();
	
	/// Returns the string "BoxParticleEmitter"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Serializes the particle system to a JSON object.
	/// @returns the JSON object
	@override
	external dynamic serialize();
	
	/// Parse properties from a JSON object
	/// @param serializationObject defines the JSON object
	/// @param scene defines the hosting scene
	@override
	external void parse(dynamic serializationObject, Scene? scene);
}

/// Interface representing a particle system in Babylon.js.
/// This groups the common functionalities that needs to be implemented in order to create a particle system.
/// A particle system represents a way to manage particles from their emission to their animation and rendering.
@JS()
abstract class IParticleSystem {
	
	/// List of animations used by the particle system.
	external List<Animation>? get animations;
	external set animations(List<Animation>? value);
	
	/// The id of the Particle system.
	external String get id;
	external set id(String value);
	
	/// The name of the Particle system.
	external String get name;
	external set name(String value);
	
	/// The emitter represents the Mesh or position we are attaching the particle system to.
	external dynamic? get emitter;
	external set emitter(dynamic? value);
	
	/// Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
	external bool get isBillboardBased;
	external set isBillboardBased(bool value);
	
	/// The rendering group used by the Particle system to chose when to render.
	external num get renderingGroupId;
	external set renderingGroupId(num value);
	
	/// The layer mask we are rendering the particles through.
	external num get layerMask;
	external set layerMask(num value);
	
	/// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
	external num get updateSpeed;
	external set updateSpeed(num value);
	
	/// The amount of time the particle system is running (depends of the overall update speed).
	external num get targetStopDuration;
	external set targetStopDuration(num value);
	
	/// The texture used to render each particle. (this can be a spritesheet)
	external BaseTexture? get particleTexture;
	external set particleTexture(BaseTexture? value);
	
	/// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE, ParticleSystem.BLENDMODE_STANDARD or ParticleSystem.BLENDMODE_ADD.
	external num get blendMode;
	external set blendMode(num value);
	
	/// Minimum life time of emitting particles.
	external num get minLifeTime;
	external set minLifeTime(num value);
	
	/// Maximum life time of emitting particles.
	external num get maxLifeTime;
	external set maxLifeTime(num value);
	
	/// Minimum Size of emitting particles.
	external num get minSize;
	external set minSize(num value);
	
	/// Maximum Size of emitting particles.
	external num get maxSize;
	external set maxSize(num value);
	
	/// Minimum scale of emitting particles on X axis.
	external num get minScaleX;
	external set minScaleX(num value);
	
	/// Maximum scale of emitting particles on X axis.
	external num get maxScaleX;
	external set maxScaleX(num value);
	
	/// Minimum scale of emitting particles on Y axis.
	external num get minScaleY;
	external set minScaleY(num value);
	
	/// Maximum scale of emitting particles on Y axis.
	external num get maxScaleY;
	external set maxScaleY(num value);
	
	/// Random color of each particle after it has been emitted, between color1 and color2 vectors.
	external Color4 get color1;
	external set color1(Color4 value);
	
	/// Random color of each particle after it has been emitted, between color1 and color2 vectors.
	external Color4 get color2;
	external set color2(Color4 value);
	
	/// Color the particle will have at the end of its lifetime.
	external Color4 get colorDead;
	external set colorDead(Color4 value);
	
	/// The maximum number of particles to emit per frame until we reach the activeParticleCount value
	external num get emitRate;
	external set emitRate(num value);
	
	/// You can use gravity if you want to give an orientation to your particles.
	external Vector3 get gravity;
	external set gravity(Vector3 value);
	
	/// Minimum power of emitting particles.
	external num get minEmitPower;
	external set minEmitPower(num value);
	
	/// Maximum power of emitting particles.
	external num get maxEmitPower;
	external set maxEmitPower(num value);
	
	/// Minimum angular speed of emitting particles (Z-axis rotation for each particle).
	external num get minAngularSpeed;
	external set minAngularSpeed(num value);
	
	/// Maximum angular speed of emitting particles (Z-axis rotation for each particle).
	external num get maxAngularSpeed;
	external set maxAngularSpeed(num value);
	
	/// Gets or sets the minimal initial rotation in radians.
	external num get minInitialRotation;
	external set minInitialRotation(num value);
	
	/// Gets or sets the maximal initial rotation in radians.
	external num get maxInitialRotation;
	external set maxInitialRotation(num value);
	
	/// The particle emitter type defines the emitter used by the particle system.
	/// It can be for example box, sphere, or cone...
	external IParticleEmitterType? get particleEmitterType;
	external set particleEmitterType(IParticleEmitterType? value);
	
	/// Defines the delay in milliseconds before starting the system (0 by default)
	external num get startDelay;
	external set startDelay(num value);
	
	/// Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0
	external num get preWarmCycles;
	external set preWarmCycles(num value);
	
	/// Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1)
	external num get preWarmStepOffset;
	external set preWarmStepOffset(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
	external num get spriteCellChangeSpeed;
	external set spriteCellChangeSpeed(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
	external num get startSpriteCellID;
	external set startSpriteCellID(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
	external num get endSpriteCellID;
	external set endSpriteCellID(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
	external num get spriteCellWidth;
	external set spriteCellWidth(num value);
	
	/// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
	external num get spriteCellHeight;
	external set spriteCellHeight(num value);
	
	/// This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
	external bool get spriteRandomStartCell;
	external set spriteRandomStartCell(bool value);
	
	/// Gets or sets a boolean indicating if a spritesheet is used to animate the particles texture
	external bool get isAnimationSheetEnabled;
	external set isAnimationSheetEnabled(bool value);
	
	/// Gets or sets a Vector2 used to move the pivot (by default (0,0))
	external Vector2 get translationPivot;
	external set translationPivot(Vector2 value);
	
	/// Gets or sets a texture used to add random noise to particle positions
	external BaseTexture? get noiseTexture;
	external set noiseTexture(BaseTexture? value);
	
	/// Gets or sets the strength to apply to the noise value (default is (10, 10, 10))
	external Vector3 get noiseStrength;
	external set noiseStrength(Vector3 value);
	
	/// Gets or sets the billboard mode to use when isBillboardBased = true.
	/// Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
	external num get billboardMode;
	external set billboardMode(num value);
	
	/// Gets or sets a value indicating the damping to apply if the limit velocity factor is reached
	external num get limitVelocityDamping;
	external set limitVelocityDamping(num value);
	
	/// Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
	external bool get beginAnimationOnStart;
	external set beginAnimationOnStart(bool value);
	
	/// Gets or sets the frame to start the animation from when beginAnimationOnStart is true
	external num get beginAnimationFrom;
	external set beginAnimationFrom(num value);
	
	/// Gets or sets the frame to end the animation on when beginAnimationOnStart is true
	external num get beginAnimationTo;
	external set beginAnimationTo(num value);
	
	/// Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
	external bool get beginAnimationLoop;
	external set beginAnimationLoop(bool value);
	
	/// Specifies whether the particle system will be disposed once it reaches the end of the animation.
	external bool get disposeOnStop;
	external set disposeOnStop(bool value);
	
	/// Specifies if the particles are updated in emitter local space or world space
	external bool get isLocal;
	external set isLocal(bool value);
	
	/// Snippet ID if the particle system was created from the snippet server
	external String get snippetId;
	external set snippetId(String value);
	
	/// Gets or sets a matrix to use to compute projection
	external Matrix get defaultProjectionMatrix;
	external set defaultProjectionMatrix(Matrix value);
	
	/// Gets the maximum number of particles active at the same time.
	/// @returns The max number of active particles.
	external num getCapacity();
	
	/// Gets the number of particles active at the same time.
	/// @returns The number of active particles.
	external num getActiveCount();
	
	/// Gets if the system has been started. (Note: this will still be true after stop is called)
	/// @returns True if it has been started, otherwise false.
	external bool isStarted();
	
	/// Animates the particle system for this frame.
	external void animate();
	
	/// Renders the particle system in its current state.
	/// @returns the current number of particles
	external num render();
	
	/// Dispose the particle system and frees its associated resources.
	/// @param disposeTexture defines if the particule texture must be disposed as well (true by default)
	external void dispose([bool? disposeTexture]);
	
	/// An event triggered when the system is disposed
	external Observable<IParticleSystem> get onDisposeObservable;
	external set onDisposeObservable(Observable<IParticleSystem> value);
	
	/// An event triggered when the system is stopped
	external Observable<IParticleSystem> get onStoppedObservable;
	external set onStoppedObservable(Observable<IParticleSystem> value);
	
	/// Clones the particle system.
	/// @param name The name of the cloned object
	/// @param newEmitter The new emitter to use
	/// @returns the cloned particle system
	external IParticleSystem? clone(String name, dynamic newEmitter);
	
	/// Serializes the particle system to a JSON object
	/// @param serializeTexture defines if the texture must be serialized as well
	/// @returns the JSON object
	external dynamic serialize(bool serializeTexture);
	
	/// Rebuild the particle system
	external void rebuild();
	
	/// Force the system to rebuild all gradients that need to be resync
	external void forceRefreshGradients();
	
	/// Starts the particle system and begins to emit
	/// @param delay defines the delay in milliseconds before starting the system (0 by default)
	external void start([num? delay]);
	
	/// Stops the particle system.
	external void stop();
	
	/// Remove all active particles
	external void reset();
	
	/// Gets a boolean indicating that the system is stopping
	/// @returns true if the system is currently stopping
	external bool isStopping();
	
	/// Is this system ready to be used/rendered
	/// @return true if the system is ready
	external bool isReady();
	
	/// Returns the string "ParticleSystem"
	/// @returns a string containing the class name
	external String getClassName();
	
	/// Gets the custom effect used to render the particles
	/// @param blendMode Blend mode for which the effect should be retrieved
	/// @returns The effect
	external Effect? getCustomEffect(num blendMode);
	
	/// Sets the custom effect used to render the particles
	/// @param effect The effect to set
	/// @param blendMode Blend mode for which the effect should be set
	external void setCustomEffect(Effect? effect, num blendMode);
	
	/// Fill the defines array according to the current settings of the particle system
	/// @param defines Array to be updated
	/// @param blendMode blend mode to take into account when updating the array
	external void fillDefines(List<String> defines, num blendMode);
	
	/// Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
	/// @param uniforms Uniforms array to fill
	/// @param attributes Attributes array to fill
	/// @param samplers Samplers array to fill
	external void fillUniformsAttributesAndSamplerNames(List<String> uniforms, List<String> attributes, List<String> samplers);
	
	/// Observable that will be called just before the particles are drawn
	external Observable<Effect?> get onBeforeDrawParticlesObservable;
	external set onBeforeDrawParticlesObservable(Observable<Effect?> value);
	
	/// Gets the name of the particle vertex shader
	external String get vertexShaderName;
	external set vertexShaderName(String value);
	
	/// Adds a new color gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param color1 defines the color to affect to the specified gradient
	/// @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
	/// @returns the current particle system
	external IParticleSystem addColorGradient(num gradient, Color4 color1, [Color4? color2]);
	
	/// Remove a specific color gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeColorGradient(num gradient);
	
	/// Adds a new size gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the size factor to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addSizeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific size gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeSizeGradient(num gradient);
	
	/// Gets the current list of color gradients.
	/// You must use addColorGradient and removeColorGradient to udpate this list
	/// @returns the list of color gradients
	external List<ColorGradient>? getColorGradients();
	
	/// Gets the current list of size gradients.
	/// You must use addSizeGradient and removeSizeGradient to udpate this list
	/// @returns the list of size gradients
	external List<FactorGradient>? getSizeGradients();
	
	/// Gets the current list of angular speed gradients.
	/// You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
	/// @returns the list of angular speed gradients
	external List<FactorGradient>? getAngularSpeedGradients();
	
	/// Adds a new angular speed gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the angular speed to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addAngularSpeedGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific angular speed gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeAngularSpeedGradient(num gradient);
	
	/// Gets the current list of velocity gradients.
	/// You must use addVelocityGradient and removeVelocityGradient to udpate this list
	/// @returns the list of velocity gradients
	external List<FactorGradient>? getVelocityGradients();
	
	/// Adds a new velocity gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the velocity to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addVelocityGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific velocity gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeVelocityGradient(num gradient);
	
	/// Gets the current list of limit velocity gradients.
	/// You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
	/// @returns the list of limit velocity gradients
	external List<FactorGradient>? getLimitVelocityGradients();
	
	/// Adds a new limit velocity gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the limit velocity to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addLimitVelocityGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific limit velocity gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeLimitVelocityGradient(num gradient);
	
	/// Adds a new drag gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the drag to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addDragGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific drag gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeDragGradient(num gradient);
	
	/// Gets the current list of drag gradients.
	/// You must use addDragGradient and removeDragGradient to udpate this list
	/// @returns the list of drag gradients
	external List<FactorGradient>? getDragGradients();
	
	/// Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the emit rate to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addEmitRateGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific emit rate gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeEmitRateGradient(num gradient);
	
	/// Gets the current list of emit rate gradients.
	/// You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
	/// @returns the list of emit rate gradients
	external List<FactorGradient>? getEmitRateGradients();
	
	/// Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the start size to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addStartSizeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific start size gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeStartSizeGradient(num gradient);
	
	/// Gets the current list of start size gradients.
	/// You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
	/// @returns the list of start size gradients
	external List<FactorGradient>? getStartSizeGradients();
	
	/// Adds a new life time gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the life time factor to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	external IParticleSystem addLifeTimeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific life time gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeLifeTimeGradient(num gradient);
	
	/// Gets the current list of life time gradients.
	/// You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
	/// @returns the list of life time gradients
	external List<FactorGradient>? getLifeTimeGradients();
	
	/// Adds a new ramp gradient used to remap particle colors
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param color defines the color to affect to the specified gradient
	/// @returns the current particle system
	external IParticleSystem addRampGradient(num gradient, Color3 color);
	
	/// Gets the current list of ramp gradients.
	/// You must use addRampGradient and removeRampGradient to udpate this list
	/// @returns the list of ramp gradients
	external List<Color3Gradient>? getRampGradients();
	
	/// Gets or sets a boolean indicating that ramp gradients must be used
	/// @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients
	external bool get useRampGradients;
	external set useRampGradients(bool value);
	
	/// Adds a new color remap gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param min defines the color remap minimal range
	/// @param max defines the color remap maximal range
	/// @returns the current particle system
	external IParticleSystem addColorRemapGradient(num gradient, num min, num max);
	
	/// Gets the current list of color remap gradients.
	/// You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
	/// @returns the list of color remap gradients
	external List<FactorGradient>? getColorRemapGradients();
	
	/// Adds a new alpha remap gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param min defines the alpha remap minimal range
	/// @param max defines the alpha remap maximal range
	/// @returns the current particle system
	external IParticleSystem addAlphaRemapGradient(num gradient, num min, num max);
	
	/// Gets the current list of alpha remap gradients.
	/// You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
	/// @returns the list of alpha remap gradients
	external List<FactorGradient>? getAlphaRemapGradients();
	
	/// Creates a Point Emitter for the particle system (emits directly from the emitter position)
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the box
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the box
	/// @returns the emitter
	external PointParticleEmitter createPointEmitter(Vector3 direction1, Vector3 direction2);
	
	/// Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
	/// @param radius The radius of the hemisphere to emit from
	/// @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
	/// @returns the emitter
	external HemisphericParticleEmitter createHemisphericEmitter(num radius, num radiusRange);
	
	/// Creates a Sphere Emitter for the particle system (emits along the sphere radius)
	/// @param radius The radius of the sphere to emit from
	/// @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
	/// @returns the emitter
	external SphereParticleEmitter createSphereEmitter(num radius, num radiusRange);
	
	/// Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
	/// @param radius The radius of the sphere to emit from
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
	/// @returns the emitter
	external SphereDirectedParticleEmitter createDirectedSphereEmitter(num radius, Vector3 direction1, Vector3 direction2);
	
	/// Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
	/// @param radius The radius of the emission cylinder
	/// @param height The height of the emission cylinder
	/// @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
	/// @param directionRandomizer How much to randomize the particle direction [0-1]
	/// @returns the emitter
	external CylinderParticleEmitter createCylinderEmitter(num radius, num height, num radiusRange, num directionRandomizer);
	
	/// Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
	/// @param radius The radius of the cylinder to emit from
	/// @param height The height of the emission cylinder
	/// @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
	/// @returns the emitter
	/* Manual Fix 24 */
	external CylinderDirectedParticleEmitter createDirectedCylinderEmitter(num radius, num height, num radiusRange, Vector3 direction1, Vector3 direction2);
	
	/// Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
	/// @param radius The radius of the cone to emit from
	/// @param angle The base angle of the cone
	/// @returns the emitter
	external ConeParticleEmitter createConeEmitter(num radius, num angle);
	
	/// Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
	/// @param direction1 Particles are emitted between the direction1 and direction2 from within the box
	/// @param direction2 Particles are emitted between the direction1 and direction2 from within the box
	/// @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
	/// @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
	/// @returns the emitter
	external BoxParticleEmitter createBoxEmitter(Vector3 direction1, Vector3 direction2, Vector3 minEmitBox, Vector3 maxEmitBox);
	
	/// Get hosting scene
	/// @returns the scene
	external Scene? getScene();
}

/// Block used to expand a Color3/4 into 4 outputs (one for each component)
@JS()
class ColorSplitterBlock extends NodeMaterialBlock {
	
	/// Create a new ColorSplitterBlock
	/// @param name defines the block name
	external factory ColorSplitterBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the rgba component (input)
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the rgb component (input)
	external NodeMaterialConnectionPoint get rgbIn;
	
	/// Gets the rgb component (output)
	external NodeMaterialConnectionPoint get rgbOut;
	
	/// Gets the r component (output)
	external NodeMaterialConnectionPoint get r;
	
	/// Gets the g component (output)
	external NodeMaterialConnectionPoint get g;
	
	/// Gets the b component (output)
	external NodeMaterialConnectionPoint get b;
	
	/// Gets the a component (output)
	external NodeMaterialConnectionPoint get a;
}

/* enum */
abstract class TrigonometryBlockOperations {
	
	/// Cos
	static const int Cos = 1;
	
	/// Sin
	static const int Sin = 2;
	
	/// Abs
	static const int Abs = 3;
	
	/// Exp
	static const int Exp = 4;
	
	/// Exp2
	static const int Exp2 = 5;
	
	/// Round
	static const int Round = 6;
	
	/// Floor
	static const int Floor = 7;
	
	/// Ceiling
	static const int Ceiling = 8;
	
	/// Square root
	static const int Sqrt = 9;
	
	/// Log
	static const int Log = 10;
	
	/// Tangent
	static const int Tan = 11;
	
	/// Arc tangent
	static const int ArcTan = 12;
	
	/// Arc cosinus
	static const int ArcCos = 13;
	
	/// Arc sinus
	static const int ArcSin = 14;
	
	/// Fraction
	static const int Fract = 15;
	
	/// Sign
	static const int Sign = 16;
	
	/// To radians (from degrees)
	static const int Radians = 17;
	
	/// To degrees (from radians)
	static const int Degrees = 18;
}

/// Block used to apply trigonometry operation to floats
@JS()
class TrigonometryBlock extends NodeMaterialBlock {
	
	/// Creates a new TrigonometryBlock
	/// @param name defines the block name
	external factory TrigonometryBlock(String name);
	
	/// Gets or sets the operation applied by the block
	external int get operation;
	external set operation(int value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external dynamic serialize();
}

/// Interface used to configure the node material editor
@JS()
@anonymous
class INodeMaterialEditorOptions {
	
	external factory INodeMaterialEditorOptions({String editorURL});
	
	/// Define the URl to load node editor script
	external String get editorURL;
	external set editorURL( String value );
}

/// @hidden
@JS()
class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
	
	external factory NodeMaterialDefines();
	
	external bool get NORMAL;
	external set NORMAL(bool value);
	
	external bool get TANGENT;
	external set TANGENT(bool value);
	
	external bool get UV1;
	external set UV1(bool value);
	
	/// BONES
	external num get NUM_BONE_INFLUENCERS;
	external set NUM_BONE_INFLUENCERS(num value);
	
	external num get BonesPerMesh;
	external set BonesPerMesh(num value);
	
	external bool get BONETEXTURE;
	external set BONETEXTURE(bool value);
	
	/// MORPH TARGETS
	external bool get MORPHTARGETS;
	external set MORPHTARGETS(bool value);
	
	external bool get MORPHTARGETS_NORMAL;
	external set MORPHTARGETS_NORMAL(bool value);
	
	external bool get MORPHTARGETS_TANGENT;
	external set MORPHTARGETS_TANGENT(bool value);
	
	external bool get MORPHTARGETS_UV;
	external set MORPHTARGETS_UV(bool value);
	
	external num get NUM_MORPH_INFLUENCERS;
	external set NUM_MORPH_INFLUENCERS(num value);
	
	/// IMAGE PROCESSING
	@override
	external bool get IMAGEPROCESSING;
	@override
	external set IMAGEPROCESSING(bool value);
	
	@override
	external bool get VIGNETTE;
	@override
	external set VIGNETTE(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEMULTIPLY;
	@override
	external set VIGNETTEBLENDMODEMULTIPLY(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEOPAQUE;
	@override
	external set VIGNETTEBLENDMODEOPAQUE(bool value);
	
	@override
	external bool get TONEMAPPING;
	@override
	external set TONEMAPPING(bool value);
	
	@override
	external bool get TONEMAPPING_ACES;
	@override
	external set TONEMAPPING_ACES(bool value);
	
	@override
	external bool get CONTRAST;
	@override
	external set CONTRAST(bool value);
	
	@override
	external bool get EXPOSURE;
	@override
	external set EXPOSURE(bool value);
	
	@override
	external bool get COLORCURVES;
	@override
	external set COLORCURVES(bool value);
	
	@override
	external bool get COLORGRADING;
	@override
	external set COLORGRADING(bool value);
	
	@override
	external bool get COLORGRADING3D;
	@override
	external set COLORGRADING3D(bool value);
	
	@override
	external bool get SAMPLER3DGREENDEPTH;
	@override
	external set SAMPLER3DGREENDEPTH(bool value);
	
	@override
	external bool get SAMPLER3DBGRMAP;
	@override
	external set SAMPLER3DBGRMAP(bool value);
	
	@override
	external bool get IMAGEPROCESSINGPOSTPROCESS;
	@override
	external set IMAGEPROCESSINGPOSTPROCESS(bool value);
	
	/// MISC.
	external num get BUMPDIRECTUV;
	external set BUMPDIRECTUV(num value);
	
	external void setValue(String name, dynamic value, [bool? markAsUnprocessedIfDirty]);
}

/// Class used to configure NodeMaterial
@JS()
@anonymous
class INodeMaterialOptions {
	
	external factory INodeMaterialOptions({bool emitComments});
	
	/// Defines if blocks should emit comments
	external bool get emitComments;
	external set emitComments( bool value );
}

/// Class used to create a node based material built by assembling shader blocks
@JS()
class NodeMaterial extends PushMaterial {
	
	/// Create a new node based material
	/// @param name defines the material name
	/// @param scene defines the hosting scene
	/// @param options defines creation option
	external factory NodeMaterial(String name, [Scene? scene, INodeMaterialOptions? options]);
	
	/// Define the Url to load node editor script
	external static String get EditorURL;
	external static set EditorURL(String value);
	
	/// Define the Url to load snippets
	external static String get SnippetUrl;
	external static set SnippetUrl(String value);
	
	/// Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content
	external static bool get IgnoreTexturesAtLoadTime;
	external static set IgnoreTexturesAtLoadTime(bool value);
	
	/// Snippet ID if the material was created from the snippet server
	external String get snippetId;
	external set snippetId(String value);
	
	/// Gets or sets data used by visual editor
	/// @see https://nme.babylonjs.com
	external dynamic get editorData;
	external set editorData(dynamic value);
	
	/// Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)
	external bool get ignoreAlpha;
	external set ignoreAlpha(bool value);
	
	/// Defines the maximum number of lights that can be used in the material
	external num get maxSimultaneousLights;
	external set maxSimultaneousLights(num value);
	
	/// Observable raised when the material is built
	external Observable<NodeMaterial> get onBuildObservable;
	external set onBuildObservable(Observable<NodeMaterial> value);
	
	/// Gets or sets options to control the node material overall behavior
	external INodeMaterialOptions get options;
	
	external set options(INodeMaterialOptions value);
	
	/// Gets the image processing configuration used either in this material.
	external ImageProcessingConfiguration get imageProcessingConfiguration;
	
	/// Sets the Default image processing configuration used either in the this material.
	/// 
	/// If sets to null, the scene one is in use.
	external set imageProcessingConfiguration(ImageProcessingConfiguration value);
	
	/// Gets an array of blocks that needs to be serialized even if they are not yet connected
	external List<NodeMaterialBlock> get attachedBlocks;
	external set attachedBlocks(List<NodeMaterialBlock> value);
	
	/// Gets the mode property
	external int get mode;
	
	/// A free comment about the material
	external String get comment;
	external set comment(String value);
	
	/// Gets the current class name of the material e.g. "NodeMaterial"
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get a block by its name
	/// @param name defines the name of the block to retrieve
	/// @returns the required block or null if not found
	external NodeMaterialBlock? getBlockByName(String name);
	
	/// Get a block by its name
	/// @param predicate defines the predicate used to find the good candidate
	/// @returns the required block or null if not found
	external NodeMaterialBlock? getBlockByPredicate(bool Function(NodeMaterialBlock block) predicate);
	
	/// Get an input block by its name
	/// @param predicate defines the predicate used to find the good candidate
	/// @returns the required input block or null if not found
	external InputBlock? getInputBlockByPredicate(bool Function(InputBlock block) predicate);
	
	/// Gets the list of input blocks attached to this material
	/// @returns an array of InputBlocks
	external List<InputBlock> getInputBlocks();
	
	/// Adds a new optimizer to the list of optimizers
	/// @param optimizer defines the optimizers to add
	/// @returns the current material
	external dynamic? registerOptimizer(NodeMaterialOptimizer optimizer);
	
	/// Remove an optimizer from the list of optimizers
	/// @param optimizer defines the optimizers to remove
	/// @returns the current material
	external dynamic? unregisterOptimizer(NodeMaterialOptimizer optimizer);
	
	/// Add a new block to the list of output nodes
	/// @param node defines the node to add
	/// @returns the current material
	external dynamic addOutputNode(NodeMaterialBlock node);
	
	/// Remove a block from the list of root nodes
	/// @param node defines the node to remove
	/// @returns the current material
	external dynamic removeOutputNode(NodeMaterialBlock node);
	
	/// Specifies if the material will require alpha blending
	/// @returns a boolean specifying if alpha blending is needed
	@override
	external bool needAlphaBlending();
	
	/// Specifies if this material should be rendered in alpha test mode
	/// @returns a boolean specifying if an alpha test is needed.
	@override
	external bool needAlphaTesting();
	
	/// Remove a block from the current node material
	/// @param block defines the block to remove
	external void removeBlock(NodeMaterialBlock block);
	
	/// Build the material and generates the inner effect
	/// @param verbose defines if the build should log activity
	external void build([bool? verbose]);
	
	/// Runs an otpimization phase to try to improve the shader code
	external void optimize();
	
	/// Create a post process from the material
	/// @param camera The camera to apply the render pass to.
	/// @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
	/// @returns the post process created
	external PostProcess? createPostProcess(Camera? camera, [dynamic? options, num? samplingMode, Engine? engine, bool? reusable, num? textureType, num? textureFormat]);
	
	/// Create the post process effect from the material
	/// @param postProcess The post process to create the effect for
	external void createEffectForPostProcess(PostProcess postProcess);
	
	/// Create a new procedural texture based on this node material
	/// @param size defines the size of the texture
	/// @param scene defines the hosting scene
	/// @returns the new procedural texture attached to this node material
	external ProceduralTexture? createProceduralTexture(dynamic size, Scene scene);
	
	/// Create the effect to be used as the custom effect for a particle system
	/// @param particleSystem Particle system to create the effect for
	/// @param onCompiled defines a function to call when the effect creation is successful
	/// @param onError defines a function to call when the effect creation has failed
	external void createEffectForParticles(IParticleSystem particleSystem, [void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError]);
	
	/// Get if the submesh is ready to be used and all its information available.
	/// Child classes can use it to update shaders
	/// @param mesh defines the mesh to check
	/// @param subMesh defines which submesh to check
	/// @param useInstances specifies that instances should be used
	/// @returns a boolean indicating that the submesh is ready or not
	@override
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Get a string representing the shaders built by the current node graph
	external String get compiledShaders;
	
	/// Binds the world matrix to the material
	/// @param world defines the world transformation matrix
	@override
	external void bindOnlyWorldMatrix(Matrix world);
	
	/// Binds the submesh to this material by preparing the effect and shader to draw
	/// @param world defines the world transformation matrix
	/// @param mesh defines the mesh containing the submesh
	/// @param subMesh defines the submesh to bind the material to
	@override
	external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
	
	/// Gets the active textures from the material
	/// @returns an array of textures
	@override
	external List<BaseTexture> getActiveTextures();
	
	/// Gets the list of texture blocks
	/// @returns an array of texture blocks
	external dynamic getTextureBlocks();
	
	/// Specifies if the material uses a texture
	/// @param texture defines the texture to check against the material
	/// @returns a boolean specifying if the material uses the texture
	@override
	external bool hasTexture(BaseTexture texture);
	
	/// Disposes the material
	/// @param forceDisposeEffect specifies if effects should be forcefully disposed
	/// @param forceDisposeTextures specifies if textures should be forcefully disposed
	/// @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
	@override
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? notBoundToMesh]);
	
	/// Launch the node material editor
	/// @param config Define the configuration of the editor
	/// @return a promise fulfilled when the node editor is visible
	external Promise<void> edit([INodeMaterialEditorOptions? config]);
	
	/// Clear the current material
	external void clear();
	
	/// Clear the current material and set it to a default state
	external void setToDefault();
	
	/// Clear the current material and set it to a default state for post process
	external void setToDefaultPostProcess();
	
	/// Clear the current material and set it to a default state for procedural texture
	external void setToDefaultProceduralTexture();
	
	/// Clear the current material and set it to a default state for particle
	external void setToDefaultParticle();
	
	/// Loads the current Node Material from a url pointing to a file save by the Node Material Editor
	/// @param url defines the url to load from
	/// @returns a promise that will fullfil when the material is fully loaded
	external Promise<void> loadAsync(String url);
	
	/// Generate a string containing the code declaration required to create an equivalent of this material
	/// @returns a string
	external String generateCode();
	
	/// Serializes this material in a JSON representation
	/// @returns the serialized material object
	@override
	external dynamic serialize([List<NodeMaterialBlock>? selectedBlocks]);
	
	/// Clear the current graph and load a new one from a serialization object
	/// @param source defines the JSON representation of the material
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @param merge defines whether or not the source must be merged or replace the current content
	external void loadFromSerialization(dynamic source, [String? rootUrl, bool? merge]);
	
	/// Makes a duplicate of the current material.
	/// @param name - name to use for the new material.
	@override
	external NodeMaterial? clone(String name);
	
	/// Creates a node material from parsed material data
	/// @param source defines the JSON representation of the material
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a new node material
	@override
	external static NodeMaterial? Parse(dynamic source, Scene scene, [String? rootUrl]);
	
	/// Creates a node material from a snippet saved in a remote file
	/// @param name defines the name of the material to create
	/// @param url defines the url to load from
	/// @param scene defines the hosting scene
	/// @returns a promise that will resolve to the new node material
	external static Promise<NodeMaterial> ParseFromFileAsync(String name, String url, Scene scene);
	
	/// Creates a node material from a snippet saved by the node material editor
	/// @param snippetId defines the snippet to load
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @param nodeMaterial defines a node material to update (instead of creating a new one)
	/// @returns a promise that will resolve to the new node material
	external static Promise<NodeMaterial> ParseFromSnippetAsync(String snippetId, Scene scene, [String? rootUrl, NodeMaterial? nodeMaterial]);
	
	/// Creates a new node material set to default basic configuration
	/// @param name defines the name of the material
	/// @param scene defines the hosting scene
	/// @returns a new NodeMaterial
	external static NodeMaterial CreateDefault(String name, [Scene? scene]);
}

/// Creation options of the multi render target texture.
@JS()
@anonymous
class IMultiRenderTargetOptions {
	
	external factory IMultiRenderTargetOptions({bool generateMipMaps, List<num> types, List<num> samplingModes, bool generateDepthBuffer, bool generateStencilBuffer, bool generateDepthTexture, num textureCount, bool doNotChangeAspectRatio, num defaultType});
	
	/// Define if the texture needs to create mip maps after render.
	external bool get generateMipMaps;
	external set generateMipMaps( bool value );
	
	/// Define the types of all the draw buffers we want to create
	external List<num> get types;
	external set types( List<num> value );
	
	/// Define the sampling modes of all the draw buffers we want to create
	external List<num> get samplingModes;
	external set samplingModes( List<num> value );
	
	/// Define if a depth buffer is required
	external bool get generateDepthBuffer;
	external set generateDepthBuffer( bool value );
	
	/// Define if a stencil buffer is required
	external bool get generateStencilBuffer;
	external set generateStencilBuffer( bool value );
	
	/// Define if a depth texture is required instead of a depth buffer
	external bool get generateDepthTexture;
	external set generateDepthTexture( bool value );
	
	/// Define the number of desired draw buffers
	external num get textureCount;
	external set textureCount( num value );
	
	/// Define if aspect ratio should be adapted to the texture or stay the scene one
	external bool get doNotChangeAspectRatio;
	external set doNotChangeAspectRatio( bool value );
	
	/// Define the default type of the buffers we are creating
	external num get defaultType;
	external set defaultType( num value );
}

/// A multi render target, like a render target provides the ability to render to a texture.
/// Unlike the render target, it can render to several draw buffers in one draw.
/// This is specially interesting in deferred rendering or for any effects requiring more than
/// just one color from a single pass.
@JS()
class MultiRenderTarget extends RenderTargetTexture {
	
	/// Instantiate a new multi render target texture.
	/// A multi render target, like a render target provides the ability to render to a texture.
	/// Unlike the render target, it can render to several draw buffers in one draw.
	/// This is specially interesting in deferred rendering or for any effects requiring more than
	/// just one color from a single pass.
	/// @param name Define the name of the texture
	/// @param size Define the size of the buffers to render to
	/// @param count Define the number of target we are rendering into
	/// @param scene Define the scene the texture belongs to
	/// @param options Define the options used to create the multi render target
	external factory MultiRenderTarget(String name, dynamic size, num count, Scene scene, [IMultiRenderTargetOptions? options]);
	
	/// Get if draw buffers are currently supported by the used hardware and browser.
	external bool get isSupported;
	
	/// Get the list of textures generated by the multi render target.
	external List<Texture> get textures;
	
	/// Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.
	external num get count;
	
	/// Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
	external Texture get depthTexture;
	
	/// Set the wrapping mode on U of all the textures we are rendering to.
	/// Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
	@override
	external set wrapU(num value);
	
	/// Set the wrapping mode on V of all the textures we are rendering to.
	/// Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
	@override
	external set wrapV(num value);
	
	/// Replaces a texture within the MRT.
	/// @param texture The new texture to insert in the MRT
	/// @param index The index of the texture to replace
	external void replaceTexture(Texture texture, num index);
	
	/// Define the number of samples used if MSAA is enabled.
	@override
	external num get samples;
	
	@override
	external set samples(num value);
	
	/// Resize all the textures in the multi render target.
	/// Be careful as it will recreate all the data in the new texture.
	/// @param size Define the new size
	@override
	external void resize(dynamic size);
	
	/// Changes the number of render targets in this MRT
	/// Be careful as it will recreate all the data in the new texture.
	/// @param count new texture count
	/// @param options Specifies texture types and sampling modes for new textures
	external void updateCount(num count, [IMultiRenderTargetOptions? options]);
	
	@override
	external void unbindFrameBuffer(Engine engine, num faceIndex);
	
	/// Dispose the render targets and their associated resources
	@override
	external void dispose();
	
	/// Release all the underlying texture used as draw buffers.
	external void releaseInternalTextures();
}

/* var */
/// @hidden
@JS()
external dynamic get imageProcessingPixelShader;

/// ImageProcessingPostProcess
/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#imageprocessing
@JS()
class ImageProcessingPostProcess extends PostProcess {
	
	external factory ImageProcessingPostProcess(String name, dynamic options, [Camera? camera, num? samplingMode, Engine? engine, bool? reusable, num? textureType, ImageProcessingConfiguration? imageProcessingConfiguration]);
	
	/// Gets the image processing configuration used either in this material.
	external ImageProcessingConfiguration get imageProcessingConfiguration;
	
	/// Sets the Default image processing configuration used either in the this material.
	/// 
	/// If sets to null, the scene one is in use.
	external set imageProcessingConfiguration(ImageProcessingConfiguration value);
	
	/// If the post process is supported.
	@override
	external bool get isSupported;
	
	/// Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
	external ColorCurves? get colorCurves;
	
	/// Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
	external set colorCurves(ColorCurves? value);
	
	/// Gets wether the color curves effect is enabled.
	external bool get colorCurvesEnabled;
	
	/// Sets wether the color curves effect is enabled.
	external set colorCurvesEnabled(bool value);
	
	/// Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
	external BaseTexture? get colorGradingTexture;
	
	/// Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
	external set colorGradingTexture(BaseTexture? value);
	
	/// Gets wether the color grading effect is enabled.
	external bool get colorGradingEnabled;
	
	/// Gets wether the color grading effect is enabled.
	external set colorGradingEnabled(bool value);
	
	/// Gets exposure used in the effect.
	external num get exposure;
	
	/// Sets exposure used in the effect.
	external set exposure(num value);
	
	/// Gets wether tonemapping is enabled or not.
	external bool get toneMappingEnabled;
	
	/// Sets wether tonemapping is enabled or not
	external set toneMappingEnabled(bool value);
	
	/// Gets the type of tone mapping effect.
	external num get toneMappingType;
	
	/// Sets the type of tone mapping effect.
	external set toneMappingType(num value);
	
	/// Gets contrast used in the effect.
	external num get contrast;
	
	/// Sets contrast used in the effect.
	external set contrast(num value);
	
	/// Gets Vignette stretch size.
	external num get vignetteStretch;
	
	/// Sets Vignette stretch size.
	external set vignetteStretch(num value);
	
	/// Gets Vignette centre X Offset.
	external num get vignetteCentreX;
	
	/// Sets Vignette centre X Offset.
	external set vignetteCentreX(num value);
	
	/// Gets Vignette centre Y Offset.
	external num get vignetteCentreY;
	
	/// Sets Vignette centre Y Offset.
	external set vignetteCentreY(num value);
	
	/// Gets Vignette weight or intensity of the vignette effect.
	external num get vignetteWeight;
	
	/// Sets Vignette weight or intensity of the vignette effect.
	external set vignetteWeight(num value);
	
	/// Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
	/// if vignetteEnabled is set to true.
	external Color4 get vignetteColor;
	
	/// Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
	/// if vignetteEnabled is set to true.
	external set vignetteColor(Color4 value);
	
	/// Gets Camera field of view used by the Vignette effect.
	external num get vignetteCameraFov;
	
	/// Sets Camera field of view used by the Vignette effect.
	external set vignetteCameraFov(num value);
	
	/// Gets the vignette blend mode allowing different kind of effect.
	external num get vignetteBlendMode;
	
	/// Sets the vignette blend mode allowing different kind of effect.
	external set vignetteBlendMode(num value);
	
	/// Gets wether the vignette effect is enabled.
	external bool get vignetteEnabled;
	
	/// Sets wether the vignette effect is enabled.
	external set vignetteEnabled(bool value);
	
	/// Gets wether the input of the processing is in Gamma or Linear Space.
	external bool get fromLinearSpace;
	
	/// Sets wether the input of the processing is in Gamma or Linear Space.
	external set fromLinearSpace(bool value);
	
	/// "ImageProcessingPostProcess"
	/// @returns "ImageProcessingPostProcess"
	@override
	external String getClassName();
	
	@override
	external void dispose([Camera? camera]);
}

/// Interface for defining prepass effects in the prepass post-process pipeline
@JS()
abstract class PrePassEffectConfiguration {
	
	/// Name of the effect
	external String get name;
	external set name(String value);
	
	/// Post process to attach for this effect
	external PostProcess get postProcess;
	external set postProcess(PostProcess value);
	
	/// Textures required in the MRT
	external List<num> get texturesRequired;
	external set texturesRequired(List<num> value);
	
	/// Is the effect enabled
	external bool get enabled;
	external set enabled(bool value);
	
	/// Disposes the effect configuration
	external void Function() get dispose;
	external set dispose(void Function() value);
	
	/// Creates the associated post process
	external PostProcess Function() get createPostProcess;
	external set createPostProcess(PostProcess Function() value);
}

/// This represents all the required information to add a fresnel effect on a material:
/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
@JS()
class FresnelParameters {
	
	/// Creates a new FresnelParameters object.
	/// 
	/// @param options provide your own settings to optionally to override defaults
	external factory FresnelParameters([dynamic? options]);
	
	/// Define if the fresnel effect is enable or not.
	external bool get isEnabled;
	
	external set isEnabled(bool value);
	
	/// Define the color used on edges (grazing angle)
	external Color3 get leftColor;
	external set leftColor(Color3 value);
	
	/// Define the color used on center
	external Color3 get rightColor;
	external set rightColor(Color3 value);
	
	/// Define bias applied to computed fresnel term
	external num get bias;
	external set bias(num value);
	
	/// Defined the power exponent applied to fresnel term
	external num get power;
	external set power(num value);
	
	/// Clones the current fresnel and its valuues
	/// @returns a clone fresnel configuration
	external FresnelParameters clone();
	
	/// Determines equality between FresnelParameters objects
	/// @param otherFresnelParameters defines the second operand
	/// @returns true if the power, bias, leftColor, rightColor and isEnabled values are equal to the given ones
	external bool equals(FresnelParameters otherFresnelParameters);
	
	/// Serializes the current fresnel parameters to a JSON representation.
	/// @return the JSON serialization
	external dynamic serialize();
	
	/// Parse a JSON object and deserialize it to a new Fresnel parameter object.
	/// @param parsedFresnelParameters Define the JSON representation
	/// @returns the parsed parameters
	external static FresnelParameters Parse(dynamic parsedFresnelParameters);
}

/// This groups all the flags used to control the materials channel.
@JS()
class MaterialFlags {
	external factory MaterialFlags();
	
	/// Are diffuse textures enabled in the application.
	external static bool get DiffuseTextureEnabled;
	
	external static set DiffuseTextureEnabled(bool value);
	
	/// Are detail textures enabled in the application.
	external static bool get DetailTextureEnabled;
	
	external static set DetailTextureEnabled(bool value);
	
	/// Are ambient textures enabled in the application.
	external static bool get AmbientTextureEnabled;
	
	external static set AmbientTextureEnabled(bool value);
	
	/// Are opacity textures enabled in the application.
	external static bool get OpacityTextureEnabled;
	
	external static set OpacityTextureEnabled(bool value);
	
	/// Are reflection textures enabled in the application.
	external static bool get ReflectionTextureEnabled;
	
	external static set ReflectionTextureEnabled(bool value);
	
	/// Are emissive textures enabled in the application.
	external static bool get EmissiveTextureEnabled;
	
	external static set EmissiveTextureEnabled(bool value);
	
	/// Are specular textures enabled in the application.
	external static bool get SpecularTextureEnabled;
	
	external static set SpecularTextureEnabled(bool value);
	
	/// Are bump textures enabled in the application.
	external static bool get BumpTextureEnabled;
	
	external static set BumpTextureEnabled(bool value);
	
	/// Are lightmap textures enabled in the application.
	external static bool get LightmapTextureEnabled;
	
	external static set LightmapTextureEnabled(bool value);
	
	/// Are refraction textures enabled in the application.
	external static bool get RefractionTextureEnabled;
	
	external static set RefractionTextureEnabled(bool value);
	
	/// Are color grading textures enabled in the application.
	external static bool get ColorGradingTextureEnabled;
	
	external static set ColorGradingTextureEnabled(bool value);
	
	/// Are fresnels enabled in the application.
	external static bool get FresnelEnabled;
	
	external static set FresnelEnabled(bool value);
	
	/// Are clear coat textures enabled in the application.
	external static bool get ClearCoatTextureEnabled;
	
	external static set ClearCoatTextureEnabled(bool value);
	
	/// Are clear coat bump textures enabled in the application.
	external static bool get ClearCoatBumpTextureEnabled;
	
	external static set ClearCoatBumpTextureEnabled(bool value);
	
	/// Are clear coat tint textures enabled in the application.
	external static bool get ClearCoatTintTextureEnabled;
	
	external static set ClearCoatTintTextureEnabled(bool value);
	
	/// Are sheen textures enabled in the application.
	external static bool get SheenTextureEnabled;
	
	external static set SheenTextureEnabled(bool value);
	
	/// Are anisotropic textures enabled in the application.
	external static bool get AnisotropicTextureEnabled;
	
	external static set AnisotropicTextureEnabled(bool value);
	
	/// Are thickness textures enabled in the application.
	external static bool get ThicknessTextureEnabled;
	
	external static set ThicknessTextureEnabled(bool value);
}

/* var */
/// @hidden
@JS()
external dynamic get defaultFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get defaultUboDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get prePassDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get lightFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get lightUboDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get lightsFragmentFunctions;

/* var */
/// @hidden
@JS()
external dynamic get shadowsFragmentFunctions;

/* var */
/// @hidden
@JS()
external dynamic get fresnelFunction;

/* var */
/// @hidden
@JS()
external dynamic get bumpFragmentMainFunctions;

/* var */
/// @hidden
@JS()
external dynamic get bumpFragmentFunctions;

/* var */
/// @hidden
@JS()
external dynamic get logDepthDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get fogFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get bumpFragment;

/* var */
/// @hidden
@JS()
external dynamic get depthPrePass;

/* var */
/// @hidden
@JS()
external dynamic get lightFragment;

/* var */
/// @hidden
@JS()
external dynamic get logDepthFragment;

/* var */
/// @hidden
@JS()
external dynamic get fogFragment;

/* var */
/// @hidden
@JS()
external dynamic get defaultPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get defaultVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get bonesDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get instancesDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get prePassVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get bumpVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get fogVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get morphTargetsVertexGlobalDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get morphTargetsVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get morphTargetsVertex;

/* var */
/// @hidden
@JS()
external dynamic get instancesVertex;

/* var */
/// @hidden
@JS()
external dynamic get bonesVertex;

/* var */
/// @hidden
@JS()
external dynamic get prePassVertex;

/* var */
/// @hidden
@JS()
external dynamic get bumpVertex;

/* var */
/// @hidden
@JS()
external dynamic get fogVertex;

/* var */
/// @hidden
@JS()
external dynamic get shadowsVertex;

/* var */
/// @hidden
@JS()
external dynamic get pointCloudVertex;

/* var */
/// @hidden
@JS()
external dynamic get logDepthVertex;

/* var */
/// @hidden
@JS()
external dynamic get defaultVertexShader;

/// @hidden
@JS()
abstract class IMaterialDetailMapDefines {
	
	external bool get DETAIL;
	external set DETAIL(bool value);
	
	external num get DETAILDIRECTUV;
	external set DETAILDIRECTUV(num value);
	
	external num get DETAIL_NORMALBLENDMETHOD;
	external set DETAIL_NORMALBLENDMETHOD(num value);
}

/// Define the code related to the detail map parameters of a material
/// 
/// Inspired from:
/// Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html
/// Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html
/// Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps
@JS()
class DetailMapConfiguration {
	
	/// Instantiate a new detail map
	/// @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
	external factory DetailMapConfiguration(void Function() markAllSubMeshesAsTexturesDirty);
	
	/// The detail texture of the material.
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture
	/// Bigger values mean stronger blending
	external num get diffuseBlendLevel;
	external set diffuseBlendLevel(num value);
	
	/// Defines how strongly the detail roughness channel is blended with the regular roughness value
	/// Bigger values mean stronger blending. Only used with PBR materials
	external num get roughnessBlendLevel;
	external set roughnessBlendLevel(num value);
	
	/// Defines how strong the bump effect from the detail map is
	/// Bigger values mean stronger effect
	external num get bumpLevel;
	external set bumpLevel(num value);
	
	/// The method used to blend the bump and detail normals together
	external num get normalBlendMethod;
	external set normalBlendMethod(num value);
	
	/// Enable or disable the detail map on this material
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Gets whether the submesh is ready to be used or not.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	/// @returns - boolean indicating that the submesh is ready or not.
	external bool isReadyForSubMesh(IMaterialDetailMapDefines defines, Scene scene);
	
	/// Update the defines for detail map usage
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	external void prepareDefines(IMaterialDetailMapDefines defines, Scene scene);
	
	/// Binds the material data.
	/// @param uniformBuffer defines the Uniform buffer to fill in.
	/// @param scene defines the scene the material belongs to.
	/// @param isFrozen defines whether the material is frozen or not.
	external void bindForSubMesh(UniformBuffer uniformBuffer, Scene scene, bool isFrozen);
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	external bool hasTexture(BaseTexture texture);
	
	/// Returns an array of the actively used textures.
	/// @param activeTextures Array of BaseTextures
	external void getActiveTextures(List<BaseTexture> activeTextures);
	
	/// Returns the animatable textures.
	/// @param animatables Array of animatable textures.
	external void getAnimatables(List<IAnimatable> animatables);
	
	/// Disposes the resources of the material.
	/// @param forceDisposeTextures - Forces the disposal of all textures.
	external void dispose([bool? forceDisposeTextures]);
	
	/// Get the current class name useful for serialization or dynamic coding.
	/// @returns "DetailMap"
	external String getClassName();
	
	/// Add the required uniforms to the current list.
	/// @param uniforms defines the current uniform list.
	external static void AddUniforms(List<String> uniforms);
	
	/// Add the required samplers to the current list.
	/// @param samplers defines the current sampler list.
	external static void AddSamplers(List<String> samplers);
	
	/// Add the required uniforms to the current buffer.
	/// @param uniformBuffer defines the current uniform buffer.
	external static void PrepareUniformBuffer(UniformBuffer uniformBuffer);
	
	/// Makes a duplicate of the current instance into another one.
	/// @param detailMap define the instance where to copy the info
	external void copyTo(DetailMapConfiguration detailMap);
	
	/// Serializes this detail map instance
	/// @returns - An object with the serialized instance.
	external dynamic serialize();
	
	/// Parses a detail map setting from a serialized object.
	/// @param source - Serialized object.
	/// @param scene Defines the scene we are parsing for
	/// @param rootUrl Defines the rootUrl to load from
	external void parse(dynamic source, Scene scene, String rootUrl);
}

/// @hidden
@JS()
class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines, IMaterialDetailMapDefines {
	
	external factory StandardMaterialDefines();
	
	external bool get MAINUV1;
	external set MAINUV1(bool value);
	
	external bool get MAINUV2;
	external set MAINUV2(bool value);
	
	external bool get DIFFUSE;
	external set DIFFUSE(bool value);
	
	external num get DIFFUSEDIRECTUV;
	external set DIFFUSEDIRECTUV(num value);
	
	@override
	external bool get DETAIL;
	@override
	external set DETAIL(bool value);
	
	@override
	external num get DETAILDIRECTUV;
	@override
	external set DETAILDIRECTUV(num value);
	
	@override
	external num get DETAIL_NORMALBLENDMETHOD;
	@override
	external set DETAIL_NORMALBLENDMETHOD(num value);
	
	external bool get AMBIENT;
	external set AMBIENT(bool value);
	
	external num get AMBIENTDIRECTUV;
	external set AMBIENTDIRECTUV(num value);
	
	external bool get OPACITY;
	external set OPACITY(bool value);
	
	external num get OPACITYDIRECTUV;
	external set OPACITYDIRECTUV(num value);
	
	external bool get OPACITYRGB;
	external set OPACITYRGB(bool value);
	
	external bool get REFLECTION;
	external set REFLECTION(bool value);
	
	external bool get EMISSIVE;
	external set EMISSIVE(bool value);
	
	external num get EMISSIVEDIRECTUV;
	external set EMISSIVEDIRECTUV(num value);
	
	external bool get SPECULAR;
	external set SPECULAR(bool value);
	
	external num get SPECULARDIRECTUV;
	external set SPECULARDIRECTUV(num value);
	
	external bool get BUMP;
	external set BUMP(bool value);
	
	external num get BUMPDIRECTUV;
	external set BUMPDIRECTUV(num value);
	
	external bool get PARALLAX;
	external set PARALLAX(bool value);
	
	external bool get PARALLAXOCCLUSION;
	external set PARALLAXOCCLUSION(bool value);
	
	external bool get SPECULAROVERALPHA;
	external set SPECULAROVERALPHA(bool value);
	
	external bool get CLIPPLANE;
	external set CLIPPLANE(bool value);
	
	external bool get CLIPPLANE2;
	external set CLIPPLANE2(bool value);
	
	external bool get CLIPPLANE3;
	external set CLIPPLANE3(bool value);
	
	external bool get CLIPPLANE4;
	external set CLIPPLANE4(bool value);
	
	external bool get CLIPPLANE5;
	external set CLIPPLANE5(bool value);
	
	external bool get CLIPPLANE6;
	external set CLIPPLANE6(bool value);
	
	external bool get ALPHATEST;
	external set ALPHATEST(bool value);
	
	external bool get DEPTHPREPASS;
	external set DEPTHPREPASS(bool value);
	
	external bool get ALPHAFROMDIFFUSE;
	external set ALPHAFROMDIFFUSE(bool value);
	
	external bool get POINTSIZE;
	external set POINTSIZE(bool value);
	
	external bool get FOG;
	external set FOG(bool value);
	
	external bool get SPECULARTERM;
	external set SPECULARTERM(bool value);
	
	external bool get DIFFUSEFRESNEL;
	external set DIFFUSEFRESNEL(bool value);
	
	external bool get OPACITYFRESNEL;
	external set OPACITYFRESNEL(bool value);
	
	external bool get REFLECTIONFRESNEL;
	external set REFLECTIONFRESNEL(bool value);
	
	external bool get REFRACTIONFRESNEL;
	external set REFRACTIONFRESNEL(bool value);
	
	external bool get EMISSIVEFRESNEL;
	external set EMISSIVEFRESNEL(bool value);
	
	external bool get FRESNEL;
	external set FRESNEL(bool value);
	
	external bool get NORMAL;
	external set NORMAL(bool value);
	
	external bool get UV1;
	external set UV1(bool value);
	
	external bool get UV2;
	external set UV2(bool value);
	
	external bool get VERTEXCOLOR;
	external set VERTEXCOLOR(bool value);
	
	external bool get VERTEXALPHA;
	external set VERTEXALPHA(bool value);
	
	external num get NUM_BONE_INFLUENCERS;
	external set NUM_BONE_INFLUENCERS(num value);
	
	external num get BonesPerMesh;
	external set BonesPerMesh(num value);
	
	external bool get BONETEXTURE;
	external set BONETEXTURE(bool value);
	
	external bool get BONES_VELOCITY_ENABLED;
	external set BONES_VELOCITY_ENABLED(bool value);
	
	external bool get INSTANCES;
	external set INSTANCES(bool value);
	
	external bool get THIN_INSTANCES;
	external set THIN_INSTANCES(bool value);
	
	external bool get GLOSSINESS;
	external set GLOSSINESS(bool value);
	
	external bool get ROUGHNESS;
	external set ROUGHNESS(bool value);
	
	external bool get EMISSIVEASILLUMINATION;
	external set EMISSIVEASILLUMINATION(bool value);
	
	external bool get LINKEMISSIVEWITHDIFFUSE;
	external set LINKEMISSIVEWITHDIFFUSE(bool value);
	
	external bool get REFLECTIONFRESNELFROMSPECULAR;
	external set REFLECTIONFRESNELFROMSPECULAR(bool value);
	
	external bool get LIGHTMAP;
	external set LIGHTMAP(bool value);
	
	external num get LIGHTMAPDIRECTUV;
	external set LIGHTMAPDIRECTUV(num value);
	
	external bool get OBJECTSPACE_NORMALMAP;
	external set OBJECTSPACE_NORMALMAP(bool value);
	
	external bool get USELIGHTMAPASSHADOWMAP;
	external set USELIGHTMAPASSHADOWMAP(bool value);
	
	external bool get REFLECTIONMAP_3D;
	external set REFLECTIONMAP_3D(bool value);
	
	external bool get REFLECTIONMAP_SPHERICAL;
	external set REFLECTIONMAP_SPHERICAL(bool value);
	
	external bool get REFLECTIONMAP_PLANAR;
	external set REFLECTIONMAP_PLANAR(bool value);
	
	external bool get REFLECTIONMAP_CUBIC;
	external set REFLECTIONMAP_CUBIC(bool value);
	
	external bool get USE_LOCAL_REFLECTIONMAP_CUBIC;
	external set USE_LOCAL_REFLECTIONMAP_CUBIC(bool value);
	
	external bool get REFLECTIONMAP_PROJECTION;
	external set REFLECTIONMAP_PROJECTION(bool value);
	
	external bool get REFLECTIONMAP_SKYBOX;
	external set REFLECTIONMAP_SKYBOX(bool value);
	
	external bool get REFLECTIONMAP_EXPLICIT;
	external set REFLECTIONMAP_EXPLICIT(bool value);
	
	external bool get REFLECTIONMAP_EQUIRECTANGULAR;
	external set REFLECTIONMAP_EQUIRECTANGULAR(bool value);
	
	external bool get REFLECTIONMAP_EQUIRECTANGULAR_FIXED;
	external set REFLECTIONMAP_EQUIRECTANGULAR_FIXED(bool value);
	
	external bool get REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED;
	external set REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED(bool value);
	
	external bool get INVERTCUBICMAP;
	external set INVERTCUBICMAP(bool value);
	
	external bool get LOGARITHMICDEPTH;
	external set LOGARITHMICDEPTH(bool value);
	
	external bool get REFRACTION;
	external set REFRACTION(bool value);
	
	external bool get REFRACTIONMAP_3D;
	external set REFRACTIONMAP_3D(bool value);
	
	external bool get REFLECTIONOVERALPHA;
	external set REFLECTIONOVERALPHA(bool value);
	
	external bool get TWOSIDEDLIGHTING;
	external set TWOSIDEDLIGHTING(bool value);
	
	external bool get SHADOWFLOAT;
	external set SHADOWFLOAT(bool value);
	
	external bool get MORPHTARGETS;
	external set MORPHTARGETS(bool value);
	
	external bool get MORPHTARGETS_NORMAL;
	external set MORPHTARGETS_NORMAL(bool value);
	
	external bool get MORPHTARGETS_TANGENT;
	external set MORPHTARGETS_TANGENT(bool value);
	
	external bool get MORPHTARGETS_UV;
	external set MORPHTARGETS_UV(bool value);
	
	external num get NUM_MORPH_INFLUENCERS;
	external set NUM_MORPH_INFLUENCERS(num value);
	
	external bool get NONUNIFORMSCALING;
	external set NONUNIFORMSCALING(bool value);
	
	external bool get PREMULTIPLYALPHA;
	external set PREMULTIPLYALPHA(bool value);
	
	external bool get ALPHATEST_AFTERALLALPHACOMPUTATIONS;
	external set ALPHATEST_AFTERALLALPHACOMPUTATIONS(bool value);
	
	external bool get ALPHABLEND;
	external set ALPHABLEND(bool value);
	
	external bool get PREPASS;
	external set PREPASS(bool value);
	
	external bool get PREPASS_IRRADIANCE;
	external set PREPASS_IRRADIANCE(bool value);
	
	external num get PREPASS_IRRADIANCE_INDEX;
	external set PREPASS_IRRADIANCE_INDEX(num value);
	
	external bool get PREPASS_ALBEDO;
	external set PREPASS_ALBEDO(bool value);
	
	external num get PREPASS_ALBEDO_INDEX;
	external set PREPASS_ALBEDO_INDEX(num value);
	
	external bool get PREPASS_DEPTHNORMAL;
	external set PREPASS_DEPTHNORMAL(bool value);
	
	external num get PREPASS_DEPTHNORMAL_INDEX;
	external set PREPASS_DEPTHNORMAL_INDEX(num value);
	
	external bool get PREPASS_POSITION;
	external set PREPASS_POSITION(bool value);
	
	external num get PREPASS_POSITION_INDEX;
	external set PREPASS_POSITION_INDEX(num value);
	
	external bool get PREPASS_VELOCITY;
	external set PREPASS_VELOCITY(bool value);
	
	external num get PREPASS_VELOCITY_INDEX;
	external set PREPASS_VELOCITY_INDEX(num value);
	
	external bool get PREPASS_REFLECTIVITY;
	external set PREPASS_REFLECTIVITY(bool value);
	
	external num get PREPASS_REFLECTIVITY_INDEX;
	external set PREPASS_REFLECTIVITY_INDEX(num value);
	
	external num get SCENE_MRT_COUNT;
	external set SCENE_MRT_COUNT(num value);
	
	external bool get RGBDLIGHTMAP;
	external set RGBDLIGHTMAP(bool value);
	
	external bool get RGBDREFLECTION;
	external set RGBDREFLECTION(bool value);
	
	external bool get RGBDREFRACTION;
	external set RGBDREFRACTION(bool value);
	
	@override
	external bool get IMAGEPROCESSING;
	@override
	external set IMAGEPROCESSING(bool value);
	
	@override
	external bool get VIGNETTE;
	@override
	external set VIGNETTE(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEMULTIPLY;
	@override
	external set VIGNETTEBLENDMODEMULTIPLY(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEOPAQUE;
	@override
	external set VIGNETTEBLENDMODEOPAQUE(bool value);
	
	@override
	external bool get TONEMAPPING;
	@override
	external set TONEMAPPING(bool value);
	
	@override
	external bool get TONEMAPPING_ACES;
	@override
	external set TONEMAPPING_ACES(bool value);
	
	@override
	external bool get CONTRAST;
	@override
	external set CONTRAST(bool value);
	
	@override
	external bool get COLORCURVES;
	@override
	external set COLORCURVES(bool value);
	
	@override
	external bool get COLORGRADING;
	@override
	external set COLORGRADING(bool value);
	
	@override
	external bool get COLORGRADING3D;
	@override
	external set COLORGRADING3D(bool value);
	
	@override
	external bool get SAMPLER3DGREENDEPTH;
	@override
	external set SAMPLER3DGREENDEPTH(bool value);
	
	@override
	external bool get SAMPLER3DBGRMAP;
	@override
	external set SAMPLER3DBGRMAP(bool value);
	
	@override
	external bool get IMAGEPROCESSINGPOSTPROCESS;
	@override
	external set IMAGEPROCESSINGPOSTPROCESS(bool value);
	
	external bool get MULTIVIEW;
	external set MULTIVIEW(bool value);
	
	/// If the reflection texture on this material is in linear color space
	/// @hidden
	external bool get IS_REFLECTION_LINEAR;
	external set IS_REFLECTION_LINEAR(bool value);
	
	/// If the refraction texture on this material is in linear color space
	/// @hidden
	external bool get IS_REFRACTION_LINEAR;
	external set IS_REFRACTION_LINEAR(bool value);
	
	@override
	external bool get EXPOSURE;
	@override
	external set EXPOSURE(bool value);
	
	external void setReflectionMode(String modeToEnable);
}

/// This is the default material used in Babylon. It is the best trade off between quality
/// and performances.
/// @see https://doc.babylonjs.com/babylon101/materials
@JS()
class StandardMaterial extends PushMaterial {
	
	/// Instantiates a new standard material.
	/// This is the default material used in Babylon. It is the best trade off between quality
	/// and performances.
	/// @see https://doc.babylonjs.com/babylon101/materials
	/// @param name Define the name of the material in the scene
	/// @param scene Define the scene the material belong to
	external factory StandardMaterial(String name, Scene scene);
	
	/// The basic texture of the material as viewed under a light.
	external BaseTexture? get diffuseTexture;
	external set diffuseTexture(BaseTexture? value);
	
	/// AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.
	external BaseTexture? get ambientTexture;
	external set ambientTexture(BaseTexture? value);
	
	/// Define the transparency of the material from a texture.
	/// The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)
	/// or from the luminance or the current texel (if texture.getAlphaFromRGB is true)
	external BaseTexture? get opacityTexture;
	external set opacityTexture(BaseTexture? value);
	
	/// Define the texture used to display the reflection.
	/// @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
	external BaseTexture? get reflectionTexture;
	external set reflectionTexture(BaseTexture? value);
	
	/// Define texture of the material as if self lit.
	/// This will be mixed in the final result even in the absence of light.
	external BaseTexture? get emissiveTexture;
	external set emissiveTexture(BaseTexture? value);
	
	/// Define how the color and intensity of the highlight given by the light in the material.
	external BaseTexture? get specularTexture;
	external set specularTexture(BaseTexture? value);
	
	/// Bump mapping is a technique to simulate bump and dents on a rendered surface.
	/// These are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.
	/// @see https://doc.babylonjs.com/how_to/more_materials#bump-map
	external BaseTexture? get bumpTexture;
	external set bumpTexture(BaseTexture? value);
	
	/// Complex lighting can be computationally expensive to compute at runtime.
	/// To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.
	/// @see https://doc.babylonjs.com/babylon101/lights#lightmaps
	external BaseTexture? get lightmapTexture;
	external set lightmapTexture(BaseTexture? value);
	
	/// Define the texture used to display the refraction.
	/// @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
	external BaseTexture? get refractionTexture;
	external set refractionTexture(BaseTexture? value);
	
	/// The color of the material lit by the environmental background lighting.
	/// @see https://doc.babylonjs.com/babylon101/materials#ambient-color-example
	external Color3 get ambientColor;
	external set ambientColor(Color3 value);
	
	/// The basic color of the material as viewed under a light.
	external Color3 get diffuseColor;
	external set diffuseColor(Color3 value);
	
	/// Define how the color and intensity of the highlight given by the light in the material.
	external Color3 get specularColor;
	external set specularColor(Color3 value);
	
	/// Define the color of the material as if self lit.
	/// This will be mixed in the final result even in the absence of light.
	external Color3 get emissiveColor;
	external set emissiveColor(Color3 value);
	
	/// Defines how sharp are the highlights in the material.
	/// The bigger the value the sharper giving a more glossy feeling to the result.
	/// Reversely, the smaller the value the blurrier giving a more rough feeling to the result.
	external num get specularPower;
	external set specularPower(num value);
	
	/// Does the transparency come from the diffuse texture alpha channel.
	external bool get useAlphaFromDiffuseTexture;
	external set useAlphaFromDiffuseTexture(bool value);
	
	/// If true, the emissive value is added into the end result, otherwise it is multiplied in.
	external bool get useEmissiveAsIllumination;
	external set useEmissiveAsIllumination(bool value);
	
	/// If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing
	/// the emissive level when the final color is close to one.
	external bool get linkEmissiveWithDiffuse;
	external set linkEmissiveWithDiffuse(bool value);
	
	/// Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).
	/// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
	external bool get useSpecularOverAlpha;
	external set useSpecularOverAlpha(bool value);
	
	/// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
	/// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
	external bool get useReflectionOverAlpha;
	external set useReflectionOverAlpha(bool value);
	
	/// Does lights from the scene impacts this material.
	/// It can be a nice trick for performance to disable lighting on a fully emissive material.
	external bool get disableLighting;
	external set disableLighting(bool value);
	
	/// Allows using an object space normal map (instead of tangent space).
	external bool get useObjectSpaceNormalMap;
	external set useObjectSpaceNormalMap(bool value);
	
	/// Is parallax enabled or not.
	/// @see https://doc.babylonjs.com/how_to/using_parallax_mapping
	external bool get useParallax;
	external set useParallax(bool value);
	
	/// Is parallax occlusion enabled or not.
	/// If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.
	/// @see https://doc.babylonjs.com/how_to/using_parallax_mapping
	external bool get useParallaxOcclusion;
	external set useParallaxOcclusion(bool value);
	
	/// Apply a scaling factor that determine which "depth" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.
	external num get parallaxScaleBias;
	external set parallaxScaleBias(num value);
	
	/// Helps to define how blurry the reflections should appears in the material.
	external num get roughness;
	external set roughness(num value);
	
	/// In case of refraction, define the value of the index of refraction.
	/// @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
	external num get indexOfRefraction;
	external set indexOfRefraction(num value);
	
	/// Invert the refraction texture alongside the y axis.
	/// It can be useful with procedural textures or probe for instance.
	/// @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
	external bool get invertRefractionY;
	external set invertRefractionY(bool value);
	
	/// Defines the alpha limits in alpha test mode.
	external num get alphaCutOff;
	external set alphaCutOff(num value);
	
	/// In case of light mapping, define whether the map contains light or shadow informations.
	external bool get useLightmapAsShadowmap;
	external set useLightmapAsShadowmap(bool value);
	
	/// Define the diffuse fresnel parameters of the material.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
	external FresnelParameters get diffuseFresnelParameters;
	external set diffuseFresnelParameters(FresnelParameters value);
	
	/// Define the opacity fresnel parameters of the material.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
	external FresnelParameters get opacityFresnelParameters;
	external set opacityFresnelParameters(FresnelParameters value);
	
	/// Define the reflection fresnel parameters of the material.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
	external FresnelParameters get reflectionFresnelParameters;
	external set reflectionFresnelParameters(FresnelParameters value);
	
	/// Define the refraction fresnel parameters of the material.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
	external FresnelParameters get refractionFresnelParameters;
	external set refractionFresnelParameters(FresnelParameters value);
	
	/// Define the emissive fresnel parameters of the material.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
	external FresnelParameters get emissiveFresnelParameters;
	external set emissiveFresnelParameters(FresnelParameters value);
	
	/// If true automatically deducts the fresnels values from the material specularity.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
	external bool get useReflectionFresnelFromSpecular;
	external set useReflectionFresnelFromSpecular(bool value);
	
	/// Defines if the glossiness/roughness of the material should be read from the specular map alpha channel
	external bool get useGlossinessFromSpecularMapAlpha;
	external set useGlossinessFromSpecularMapAlpha(bool value);
	
	/// Defines the maximum number of lights that can be used in the material
	external num get maxSimultaneousLights;
	external set maxSimultaneousLights(num value);
	
	/// If sets to true, x component of normal map value will invert (x = 1.0 - x).
	external bool get invertNormalMapX;
	external set invertNormalMapX(bool value);
	
	/// If sets to true, y component of normal map value will invert (y = 1.0 - y).
	external bool get invertNormalMapY;
	external set invertNormalMapY(bool value);
	
	/// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
	external bool get twoSidedLighting;
	external set twoSidedLighting(bool value);
	
	/// Gets the image processing configuration used either in this material.
	external ImageProcessingConfiguration get imageProcessingConfiguration;
	
	/// Sets the Default image processing configuration used either in the this material.
	/// 
	/// If sets to null, the scene one is in use.
	external set imageProcessingConfiguration(ImageProcessingConfiguration value);
	
	/// Defines additionnal PrePass parameters for the material.
	external PrePassConfiguration get prePassConfiguration;
	
	/// Gets wether the color curves effect is enabled.
	external bool get cameraColorCurvesEnabled;
	
	/// Sets wether the color curves effect is enabled.
	external set cameraColorCurvesEnabled(bool value);
	
	/// Gets wether the color grading effect is enabled.
	external bool get cameraColorGradingEnabled;
	
	/// Gets wether the color grading effect is enabled.
	external set cameraColorGradingEnabled(bool value);
	
	/// Gets wether tonemapping is enabled or not.
	external bool get cameraToneMappingEnabled;
	
	/// Sets wether tonemapping is enabled or not
	external set cameraToneMappingEnabled(bool value);
	
	/// The camera exposure used on this material.
	/// This property is here and not in the camera to allow controlling exposure without full screen post process.
	/// This corresponds to a photographic exposure.
	external num get cameraExposure;
	
	/// The camera exposure used on this material.
	/// This property is here and not in the camera to allow controlling exposure without full screen post process.
	/// This corresponds to a photographic exposure.
	external set cameraExposure(num value);
	
	/// Gets The camera contrast used on this material.
	external num get cameraContrast;
	
	/// Sets The camera contrast used on this material.
	external set cameraContrast(num value);
	
	/// Gets the Color Grading 2D Lookup Texture.
	external BaseTexture? get cameraColorGradingTexture;
	
	/// Sets the Color Grading 2D Lookup Texture.
	external set cameraColorGradingTexture(BaseTexture? value);
	
	/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
	/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
	/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
	/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
	external ColorCurves? get cameraColorCurves;
	
	/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
	/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
	/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
	/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
	external set cameraColorCurves(ColorCurves? value);
	
	/// Can this material render to several textures at once
	@override
	external bool get canRenderToMRT;
	
	/// Defines the detail map parameters for the material.
	external DetailMapConfiguration get detailMap;
	
	/// Gets a boolean indicating that current material needs to register RTT
	@override
	external bool get hasRenderTargetTextures;
	
	/// Gets the current class name of the material e.g. "StandardMaterial"
	/// Mainly use in serialization.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)
	/// You can try switching to logarithmic depth.
	/// @see https://doc.babylonjs.com/how_to/using_logarithmic_depth_buffer
	external bool get useLogarithmicDepth;
	
	external set useLogarithmicDepth(bool value);
	
	/// Specifies if the material will require alpha blending
	/// @returns a boolean specifying if alpha blending is needed
	@override
	external bool needAlphaBlending();
	
	/// Specifies if this material should be rendered in alpha test mode
	/// @returns a boolean specifying if an alpha test is needed.
	@override
	external bool needAlphaTesting();
	
	/// Get the texture used for alpha test purpose.
	/// @returns the diffuse texture in case of the standard material.
	@override
	external BaseTexture? getAlphaTestTexture();
	
	/// Get if the submesh is ready to be used and all its information available.
	/// Child classes can use it to update shaders
	/// @param mesh defines the mesh to check
	/// @param subMesh defines which submesh to check
	/// @param useInstances specifies that instances should be used
	/// @returns a boolean indicating that the submesh is ready or not
	@override
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Builds the material UBO layouts.
	/// Used internally during the effect preparation.
	external void buildUniformLayout();
	
	/// Unbinds the material from the mesh
	@override
	external void unbind();
	
	/// Binds the submesh to this material by preparing the effect and shader to draw
	/// @param world defines the world transformation matrix
	/// @param mesh defines the mesh containing the submesh
	/// @param subMesh defines the submesh to bind the material to
	@override
	external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
	
	/// Get the list of animatables in the material.
	/// @returns the list of animatables object used in the material
	external List<IAnimatable> getAnimatables();
	
	/// Gets the active textures from the material
	/// @returns an array of textures
	@override
	external List<BaseTexture> getActiveTextures();
	
	/// Specifies if the material uses a texture
	/// @param texture defines the texture to check against the material
	/// @returns a boolean specifying if the material uses the texture
	@override
	external bool hasTexture(BaseTexture texture);
	
	/// Disposes the material
	/// @param forceDisposeEffect specifies if effects should be forcefully disposed
	/// @param forceDisposeTextures specifies if textures should be forcefully disposed
	@override
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? notBoundToMesh]);
	
	/// Makes a duplicate of the material, and gives it a new name
	/// @param name defines the new name for the duplicated material
	/// @returns the cloned material
	@override
	external StandardMaterial? clone(String name);
	
	/// Serializes this material in a JSON representation
	/// @returns the serialized material object
	@override
	external dynamic serialize();
	
	/// Creates a standard material from parsed material data
	/// @param source defines the JSON representation of the material
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a new standard material
	@override
	external static StandardMaterial? Parse(dynamic source, Scene scene, String rootUrl);
	
	/// Are diffuse textures enabled in the application.
	external static bool get DiffuseTextureEnabled;
	
	external static set DiffuseTextureEnabled(bool value);
	
	/// Are detail textures enabled in the application.
	external static bool get DetailTextureEnabled;
	
	external static set DetailTextureEnabled(bool value);
	
	/// Are ambient textures enabled in the application.
	external static bool get AmbientTextureEnabled;
	
	external static set AmbientTextureEnabled(bool value);
	
	/// Are opacity textures enabled in the application.
	external static bool get OpacityTextureEnabled;
	
	external static set OpacityTextureEnabled(bool value);
	
	/// Are reflection textures enabled in the application.
	external static bool get ReflectionTextureEnabled;
	
	external static set ReflectionTextureEnabled(bool value);
	
	/// Are emissive textures enabled in the application.
	external static bool get EmissiveTextureEnabled;
	
	external static set EmissiveTextureEnabled(bool value);
	
	/// Are specular textures enabled in the application.
	external static bool get SpecularTextureEnabled;
	
	external static set SpecularTextureEnabled(bool value);
	
	/// Are bump textures enabled in the application.
	external static bool get BumpTextureEnabled;
	
	external static set BumpTextureEnabled(bool value);
	
	/// Are lightmap textures enabled in the application.
	external static bool get LightmapTextureEnabled;
	
	external static set LightmapTextureEnabled(bool value);
	
	/// Are refraction textures enabled in the application.
	external static bool get RefractionTextureEnabled;
	
	external static set RefractionTextureEnabled(bool value);
	
	/// Are color grading textures enabled in the application.
	external static bool get ColorGradingTextureEnabled;
	
	external static set ColorGradingTextureEnabled(bool value);
	
	/// Are fresnels enabled in the application.
	external static bool get FresnelEnabled;
	
	external static set FresnelEnabled(bool value);
}

/* var */
/// @hidden
@JS()
external dynamic get rgbdDecodePixelShader;

/// Class used to host RGBD texture specific utilities
@JS()
class RGBDTextureTools {
	external factory RGBDTextureTools();
	
	/// Expand the RGBD Texture from RGBD to Half Float if possible.
	/// @param texture the texture to expand.
	external static void ExpandRGBDTexture(Texture texture);
}

/// Class used to host texture specific utilities
@JS()
class BRDFTextureTools {
	external factory BRDFTextureTools();
	
	/// Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
	/// @param scene defines the hosting scene
	/// @returns the environment BRDF texture
	external static BaseTexture GetEnvironmentBRDFTexture(Scene scene);
}

/// @hidden
@JS()
abstract class IMaterialClearCoatDefines {
	
	external bool get CLEARCOAT;
	external set CLEARCOAT(bool value);
	
	external bool get CLEARCOAT_DEFAULTIOR;
	external set CLEARCOAT_DEFAULTIOR(bool value);
	
	external bool get CLEARCOAT_TEXTURE;
	external set CLEARCOAT_TEXTURE(bool value);
	
	external bool get CLEARCOAT_TEXTURE_ROUGHNESS;
	external set CLEARCOAT_TEXTURE_ROUGHNESS(bool value);
	
	external num get CLEARCOAT_TEXTUREDIRECTUV;
	external set CLEARCOAT_TEXTUREDIRECTUV(num value);
	
	external num get CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV;
	external set CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV(num value);
	
	external bool get CLEARCOAT_BUMP;
	external set CLEARCOAT_BUMP(bool value);
	
	external num get CLEARCOAT_BUMPDIRECTUV;
	external set CLEARCOAT_BUMPDIRECTUV(num value);
	
	external bool get CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE;
	external set CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE(bool value);
	
	external bool get CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;
	external set CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL(bool value);
	
	external bool get CLEARCOAT_REMAP_F0;
	external set CLEARCOAT_REMAP_F0(bool value);
	
	external bool get CLEARCOAT_TINT;
	external set CLEARCOAT_TINT(bool value);
	
	external bool get CLEARCOAT_TINT_TEXTURE;
	external set CLEARCOAT_TINT_TEXTURE(bool value);
	
	external num get CLEARCOAT_TINT_TEXTUREDIRECTUV;
	external set CLEARCOAT_TINT_TEXTUREDIRECTUV(num value);
}

/// Define the code related to the clear coat parameters of the pbr material.
@JS()
class PBRClearCoatConfiguration {
	
	/// Instantiate a new istance of clear coat configuration.
	/// @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
	external factory PBRClearCoatConfiguration(void Function() markAllSubMeshesAsTexturesDirty);
	
	/// Defines if the clear coat is enabled in the material.
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Defines the clear coat layer strength (between 0 and 1) it defaults to 1.
	external num get intensity;
	external set intensity(num value);
	
	/// Defines the clear coat layer roughness.
	external num get roughness;
	external set roughness(num value);
	
	/// Defines the index of refraction of the clear coat.
	/// This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence
	/// The default fits with a polyurethane material.
	/// Changing the default value is more performance intensive.
	external num get indexOfRefraction;
	external set indexOfRefraction(num value);
	
	/// Stores the clear coat values in a texture (red channel is intensity and green channel is roughness)
	/// If useRoughnessFromMainTexture is false, the green channel of texture is not used and the green channel of textureRoughness is used instead
	/// if textureRoughness is not empty, else no texture roughness is used
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Indicates that the green channel of the texture property will be used for roughness (default: true)
	/// If false, the green channel from textureRoughness is used for roughness
	external bool get useRoughnessFromMainTexture;
	external set useRoughnessFromMainTexture(bool value);
	
	/// Stores the clear coat roughness in a texture (green channel)
	/// Not used if useRoughnessFromMainTexture is true
	external BaseTexture? get textureRoughness;
	external set textureRoughness(BaseTexture? value);
	
	/// Defines if the F0 value should be remapped to account for the interface change in the material.
	external bool get remapF0OnInterfaceChange;
	external set remapF0OnInterfaceChange(bool value);
	
	/// Define the clear coat specific bump texture.
	external BaseTexture? get bumpTexture;
	external set bumpTexture(BaseTexture? value);
	
	/// Defines if the clear coat tint is enabled in the material.
	external bool get isTintEnabled;
	external set isTintEnabled(bool value);
	
	/// Defines the clear coat tint of the material.
	/// This is only use if tint is enabled
	external Color3 get tintColor;
	external set tintColor(Color3 value);
	
	/// Defines the distance at which the tint color should be found in the
	/// clear coat media.
	/// This is only use if tint is enabled
	external num get tintColorAtDistance;
	external set tintColorAtDistance(num value);
	
	/// Defines the clear coat layer thickness.
	/// This is only use if tint is enabled
	external num get tintThickness;
	external set tintThickness(num value);
	
	/// Stores the clear tint values in a texture.
	/// rgb is tint
	/// a is a thickness factor
	external BaseTexture? get tintTexture;
	external set tintTexture(BaseTexture? value);
	
	/// Gets wehter the submesh is ready to be used or not.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	/// @param engine defines the engine the material belongs to.
	/// @param disableBumpMap defines wether the material disables bump or not.
	/// @returns - boolean indicating that the submesh is ready or not.
	external bool isReadyForSubMesh(IMaterialClearCoatDefines defines, Scene scene, Engine engine, bool disableBumpMap);
	
	/// Checks to see if a texture is used in the material.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene to the material belongs to.
	external void prepareDefines(IMaterialClearCoatDefines defines, Scene scene);
	
	/// Binds the material data.
	/// @param uniformBuffer defines the Uniform buffer to fill in.
	/// @param scene defines the scene the material belongs to.
	/// @param engine defines the engine the material belongs to.
	/// @param disableBumpMap defines wether the material disables bump or not.
	/// @param isFrozen defines wether the material is frozen or not.
	/// @param invertNormalMapX If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
	/// @param invertNormalMapY If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
	/// @param subMesh the submesh to bind data for
	external void bindForSubMesh(UniformBuffer uniformBuffer, Scene scene, Engine engine, bool disableBumpMap, bool isFrozen, bool invertNormalMapX, bool invertNormalMapY, [SubMesh? subMesh]);
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	external bool hasTexture(BaseTexture texture);
	
	/// Returns an array of the actively used textures.
	/// @param activeTextures Array of BaseTextures
	external void getActiveTextures(List<BaseTexture> activeTextures);
	
	/// Returns the animatable textures.
	/// @param animatables Array of animatable textures.
	external void getAnimatables(List<IAnimatable> animatables);
	
	/// Disposes the resources of the material.
	/// @param forceDisposeTextures - Forces the disposal of all textures.
	external void dispose([bool? forceDisposeTextures]);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "PBRClearCoatConfiguration"
	external String getClassName();
	
	/// Add fallbacks to the effect fallbacks list.
	/// @param defines defines the Base texture to use.
	/// @param fallbacks defines the current fallback list.
	/// @param currentRank defines the current fallback rank.
	/// @returns the new fallback rank.
	external static num AddFallbacks(IMaterialClearCoatDefines defines, EffectFallbacks fallbacks, num currentRank);
	
	/// Add the required uniforms to the current list.
	/// @param uniforms defines the current uniform list.
	external static void AddUniforms(List<String> uniforms);
	
	/// Add the required samplers to the current list.
	/// @param samplers defines the current sampler list.
	external static void AddSamplers(List<String> samplers);
	
	/// Add the required uniforms to the current buffer.
	/// @param uniformBuffer defines the current uniform buffer.
	external static void PrepareUniformBuffer(UniformBuffer uniformBuffer);
	
	/// Makes a duplicate of the current configuration into another one.
	/// @param clearCoatConfiguration define the config where to copy the info
	external void copyTo(PBRClearCoatConfiguration clearCoatConfiguration);
	
	/// Serializes this clear coat configuration.
	/// @returns - An object with the serialized config.
	external dynamic serialize();
	
	/// Parses a anisotropy Configuration from a serialized object.
	/// @param source - Serialized object.
	/// @param scene Defines the scene we are parsing for
	/// @param rootUrl Defines the rootUrl to load from
	external void parse(dynamic source, Scene scene, String rootUrl);
}

/// @hidden
@JS()
abstract class IMaterialAnisotropicDefines {
	
	external bool get ANISOTROPIC;
	external set ANISOTROPIC(bool value);
	
	external bool get ANISOTROPIC_TEXTURE;
	external set ANISOTROPIC_TEXTURE(bool value);
	
	external num get ANISOTROPIC_TEXTUREDIRECTUV;
	external set ANISOTROPIC_TEXTUREDIRECTUV(num value);
	
	external bool get MAINUV1;
	external set MAINUV1(bool value);
}

/// Define the code related to the anisotropic parameters of the pbr material.
@JS()
class PBRAnisotropicConfiguration {
	
	/// Instantiate a new istance of anisotropy configuration.
	/// @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
	external factory PBRAnisotropicConfiguration(void Function() markAllSubMeshesAsTexturesDirty);
	
	/// Defines if the anisotropy is enabled in the material.
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Defines the anisotropy strength (between 0 and 1) it defaults to 1.
	external num get intensity;
	external set intensity(num value);
	
	/// Defines if the effect is along the tangents, bitangents or in between.
	/// By default, the effect is "strectching" the highlights along the tangents.
	external Vector2 get direction;
	external set direction(Vector2 value);
	
	/// Stores the anisotropy values in a texture.
	/// rg is direction (like normal from -1 to 1)
	/// b is a intensity
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Specifies that the submesh is ready to be used.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	/// @returns - boolean indicating that the submesh is ready or not.
	external bool isReadyForSubMesh(IMaterialAnisotropicDefines defines, Scene scene);
	
	/// Checks to see if a texture is used in the material.
	/// @param defines the list of "defines" to update.
	/// @param mesh the mesh we are preparing the defines for.
	/// @param scene defines the scene the material belongs to.
	external void prepareDefines(IMaterialAnisotropicDefines defines, AbstractMesh mesh, Scene scene);
	
	/// Binds the material data.
	/// @param uniformBuffer defines the Uniform buffer to fill in.
	/// @param scene defines the scene the material belongs to.
	/// @param isFrozen defines wether the material is frozen or not.
	external void bindForSubMesh(UniformBuffer uniformBuffer, Scene scene, bool isFrozen);
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	external bool hasTexture(BaseTexture texture);
	
	/// Returns an array of the actively used textures.
	/// @param activeTextures Array of BaseTextures
	external void getActiveTextures(List<BaseTexture> activeTextures);
	
	/// Returns the animatable textures.
	/// @param animatables Array of animatable textures.
	external void getAnimatables(List<IAnimatable> animatables);
	
	/// Disposes the resources of the material.
	/// @param forceDisposeTextures - Forces the disposal of all textures.
	external void dispose([bool? forceDisposeTextures]);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "PBRAnisotropicConfiguration"
	external String getClassName();
	
	/// Add fallbacks to the effect fallbacks list.
	/// @param defines defines the Base texture to use.
	/// @param fallbacks defines the current fallback list.
	/// @param currentRank defines the current fallback rank.
	/// @returns the new fallback rank.
	external static num AddFallbacks(IMaterialAnisotropicDefines defines, EffectFallbacks fallbacks, num currentRank);
	
	/// Add the required uniforms to the current list.
	/// @param uniforms defines the current uniform list.
	external static void AddUniforms(List<String> uniforms);
	
	/// Add the required uniforms to the current buffer.
	/// @param uniformBuffer defines the current uniform buffer.
	external static void PrepareUniformBuffer(UniformBuffer uniformBuffer);
	
	/// Add the required samplers to the current list.
	/// @param samplers defines the current sampler list.
	external static void AddSamplers(List<String> samplers);
	
	/// Makes a duplicate of the current configuration into another one.
	/// @param anisotropicConfiguration define the config where to copy the info
	external void copyTo(PBRAnisotropicConfiguration anisotropicConfiguration);
	
	/// Serializes this anisotropy configuration.
	/// @returns - An object with the serialized config.
	external dynamic serialize();
	
	/// Parses a anisotropy Configuration from a serialized object.
	/// @param source - Serialized object.
	/// @param scene Defines the scene we are parsing for
	/// @param rootUrl Defines the rootUrl to load from
	external void parse(dynamic source, Scene scene, String rootUrl);
}

/// @hidden
@JS()
abstract class IMaterialBRDFDefines {
	
	external bool get BRDF_V_HEIGHT_CORRELATED;
	external set BRDF_V_HEIGHT_CORRELATED(bool value);
	
	external bool get MS_BRDF_ENERGY_CONSERVATION;
	external set MS_BRDF_ENERGY_CONSERVATION(bool value);
	
	external bool get SPHERICAL_HARMONICS;
	external set SPHERICAL_HARMONICS(bool value);
	
	external bool get SPECULAR_GLOSSINESS_ENERGY_CONSERVATION;
	external set SPECULAR_GLOSSINESS_ENERGY_CONSERVATION(bool value);
}

/// Define the code related to the BRDF parameters of the pbr material.
@JS()
class PBRBRDFConfiguration {
	
	/// Instantiate a new istance of clear coat configuration.
	/// @param markAllSubMeshesAsMiscDirty Callback to flag the material to dirty
	external factory PBRBRDFConfiguration(void Function() markAllSubMeshesAsMiscDirty);
	
	/// Default value used for the energy conservation.
	/// This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.
	external static bool get DEFAULT_USE_ENERGY_CONSERVATION;
	external static set DEFAULT_USE_ENERGY_CONSERVATION(bool value);
	
	/// Default value used for the Smith Visibility Height Correlated mode.
	/// This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.
	external static bool get DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
	external static set DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED(bool value);
	
	/// Default value used for the IBL diffuse part.
	/// This can help switching back to the polynomials mode globally which is a tiny bit
	/// less GPU intensive at the drawback of a lower quality.
	external static bool get DEFAULT_USE_SPHERICAL_HARMONICS;
	external static set DEFAULT_USE_SPHERICAL_HARMONICS(bool value);
	
	/// Default value used for activating energy conservation for the specular workflow.
	/// If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).
	/// If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.
	external static bool get DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
	external static set DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION(bool value);
	
	/// Defines if the material uses energy conservation.
	external bool get useEnergyConservation;
	external set useEnergyConservation(bool value);
	
	/// LEGACY Mode set to false
	/// Defines if the material uses height smith correlated visibility term.
	/// If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR
	/// You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png
	/// or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision
	/// Not relying on height correlated will also disable energy conservation.
	external bool get useSmithVisibilityHeightCorrelated;
	external set useSmithVisibilityHeightCorrelated(bool value);
	
	/// LEGACY Mode set to false
	/// Defines if the material uses spherical harmonics vs spherical polynomials for the
	/// diffuse part of the IBL.
	/// The harmonics despite a tiny bigger cost has been proven to provide closer results
	/// to the ground truth.
	external bool get useSphericalHarmonics;
	external set useSphericalHarmonics(bool value);
	
	/// Defines if the material uses energy conservation, when the specular workflow is active.
	/// If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).
	/// If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.
	/// In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.
	external bool get useSpecularGlossinessInputEnergyConservation;
	external set useSpecularGlossinessInputEnergyConservation(bool value);
	
	/// Checks to see if a texture is used in the material.
	/// @param defines the list of "defines" to update.
	external void prepareDefines(IMaterialBRDFDefines defines);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "PBRClearCoatConfiguration"
	external String getClassName();
	
	/// Makes a duplicate of the current configuration into another one.
	/// @param brdfConfiguration define the config where to copy the info
	external void copyTo(PBRBRDFConfiguration brdfConfiguration);
	
	/// Serializes this BRDF configuration.
	/// @returns - An object with the serialized config.
	external dynamic serialize();
	
	/// Parses a anisotropy Configuration from a serialized object.
	/// @param source - Serialized object.
	/// @param scene Defines the scene we are parsing for
	/// @param rootUrl Defines the rootUrl to load from
	external void parse(dynamic source, Scene scene, String rootUrl);
}

/// @hidden
@JS()
abstract class IMaterialSheenDefines {
	
	external bool get SHEEN;
	external set SHEEN(bool value);
	
	external bool get SHEEN_TEXTURE;
	external set SHEEN_TEXTURE(bool value);
	
	external bool get SHEEN_TEXTURE_ROUGHNESS;
	external set SHEEN_TEXTURE_ROUGHNESS(bool value);
	
	external num get SHEEN_TEXTUREDIRECTUV;
	external set SHEEN_TEXTUREDIRECTUV(num value);
	
	external num get SHEEN_TEXTURE_ROUGHNESSDIRECTUV;
	external set SHEEN_TEXTURE_ROUGHNESSDIRECTUV(num value);
	
	external bool get SHEEN_LINKWITHALBEDO;
	external set SHEEN_LINKWITHALBEDO(bool value);
	
	external bool get SHEEN_ROUGHNESS;
	external set SHEEN_ROUGHNESS(bool value);
	
	external bool get SHEEN_ALBEDOSCALING;
	external set SHEEN_ALBEDOSCALING(bool value);
	
	external bool get SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE;
	external set SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE(bool value);
	
	external bool get SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;
	external set SHEEN_TEXTURE_ROUGHNESS_IDENTICAL(bool value);
}

/// Define the code related to the Sheen parameters of the pbr material.
@JS()
class PBRSheenConfiguration {
	
	/// Instantiate a new istance of clear coat configuration.
	/// @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
	external factory PBRSheenConfiguration(void Function() markAllSubMeshesAsTexturesDirty);
	
	/// Defines if the material uses sheen.
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Defines if the sheen is linked to the sheen color.
	external bool get linkSheenWithAlbedo;
	external set linkSheenWithAlbedo(bool value);
	
	/// Defines the sheen intensity.
	external num get intensity;
	external set intensity(num value);
	
	/// Defines the sheen color.
	external Color3 get color;
	external set color(Color3 value);
	
	/// Stores the sheen tint values in a texture.
	/// rgb is tint
	/// a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)
	/// If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness
	external BaseTexture? get texture;
	external set texture(BaseTexture? value);
	
	/// Indicates that the alpha channel of the texture property will be used for roughness.
	/// Has no effect if the roughness (and texture!) property is not defined
	external bool get useRoughnessFromMainTexture;
	external set useRoughnessFromMainTexture(bool value);
	
	/// Defines the sheen roughness.
	/// It is not taken into account if linkSheenWithAlbedo is true.
	/// To stay backward compatible, material roughness is used instead if sheen roughness = null
	external num? get roughness;
	external set roughness(num? value);
	
	/// Stores the sheen roughness in a texture.
	/// alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true
	external BaseTexture? get textureRoughness;
	external set textureRoughness(BaseTexture? value);
	
	/// If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.
	/// It allows the strength of the sheen effect to not depend on the base color of the material,
	/// making it easier to setup and tweak the effect
	external bool get albedoScaling;
	external set albedoScaling(bool value);
	
	/// Specifies that the submesh is ready to be used.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	/// @returns - boolean indicating that the submesh is ready or not.
	external bool isReadyForSubMesh(IMaterialSheenDefines defines, Scene scene);
	
	/// Checks to see if a texture is used in the material.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	external void prepareDefines(IMaterialSheenDefines defines, Scene scene);
	
	/// Binds the material data.
	/// @param uniformBuffer defines the Uniform buffer to fill in.
	/// @param scene defines the scene the material belongs to.
	/// @param isFrozen defines wether the material is frozen or not.
	/// @param subMesh the submesh to bind data for
	external void bindForSubMesh(UniformBuffer uniformBuffer, Scene scene, bool isFrozen, [SubMesh? subMesh]);
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	external bool hasTexture(BaseTexture texture);
	
	/// Returns an array of the actively used textures.
	/// @param activeTextures Array of BaseTextures
	external void getActiveTextures(List<BaseTexture> activeTextures);
	
	/// Returns the animatable textures.
	/// @param animatables Array of animatable textures.
	external void getAnimatables(List<IAnimatable> animatables);
	
	/// Disposes the resources of the material.
	/// @param forceDisposeTextures - Forces the disposal of all textures.
	external void dispose([bool? forceDisposeTextures]);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "PBRSheenConfiguration"
	external String getClassName();
	
	/// Add fallbacks to the effect fallbacks list.
	/// @param defines defines the Base texture to use.
	/// @param fallbacks defines the current fallback list.
	/// @param currentRank defines the current fallback rank.
	/// @returns the new fallback rank.
	external static num AddFallbacks(IMaterialSheenDefines defines, EffectFallbacks fallbacks, num currentRank);
	
	/// Add the required uniforms to the current list.
	/// @param uniforms defines the current uniform list.
	external static void AddUniforms(List<String> uniforms);
	
	/// Add the required uniforms to the current buffer.
	/// @param uniformBuffer defines the current uniform buffer.
	external static void PrepareUniformBuffer(UniformBuffer uniformBuffer);
	
	/// Add the required samplers to the current list.
	/// @param samplers defines the current sampler list.
	external static void AddSamplers(List<String> samplers);
	
	/// Makes a duplicate of the current configuration into another one.
	/// @param sheenConfiguration define the config where to copy the info
	external void copyTo(PBRSheenConfiguration sheenConfiguration);
	
	/// Serializes this BRDF configuration.
	/// @returns - An object with the serialized config.
	external dynamic serialize();
	
	/// Parses a anisotropy Configuration from a serialized object.
	/// @param source - Serialized object.
	/// @param scene Defines the scene we are parsing for
	/// @param rootUrl Defines the rootUrl to load from
	external void parse(dynamic source, Scene scene, String rootUrl);
}

/// @hidden
@JS()
abstract class IMaterialSubSurfaceDefines {
	
	external bool get SUBSURFACE;
	external set SUBSURFACE(bool value);
	
	external bool get SS_REFRACTION;
	external set SS_REFRACTION(bool value);
	
	external bool get SS_TRANSLUCENCY;
	external set SS_TRANSLUCENCY(bool value);
	
	external bool get SS_SCATTERING;
	external set SS_SCATTERING(bool value);
	
	external bool get SS_THICKNESSANDMASK_TEXTURE;
	external set SS_THICKNESSANDMASK_TEXTURE(bool value);
	
	external num get SS_THICKNESSANDMASK_TEXTUREDIRECTUV;
	external set SS_THICKNESSANDMASK_TEXTUREDIRECTUV(num value);
	
	external bool get SS_REFRACTIONMAP_3D;
	external set SS_REFRACTIONMAP_3D(bool value);
	
	external bool get SS_REFRACTIONMAP_OPPOSITEZ;
	external set SS_REFRACTIONMAP_OPPOSITEZ(bool value);
	
	external bool get SS_LODINREFRACTIONALPHA;
	external set SS_LODINREFRACTIONALPHA(bool value);
	
	external bool get SS_GAMMAREFRACTION;
	external set SS_GAMMAREFRACTION(bool value);
	
	external bool get SS_RGBDREFRACTION;
	external set SS_RGBDREFRACTION(bool value);
	
	external bool get SS_LINEARSPECULARREFRACTION;
	external set SS_LINEARSPECULARREFRACTION(bool value);
	
	external bool get SS_LINKREFRACTIONTOTRANSPARENCY;
	external set SS_LINKREFRACTIONTOTRANSPARENCY(bool value);
	
	external bool get SS_ALBEDOFORREFRACTIONTINT;
	external set SS_ALBEDOFORREFRACTIONTINT(bool value);
	
	external bool get SS_MASK_FROM_THICKNESS_TEXTURE;
	external set SS_MASK_FROM_THICKNESS_TEXTURE(bool value);
	
	external bool get SS_MASK_FROM_THICKNESS_TEXTURE_GLTF;
	external set SS_MASK_FROM_THICKNESS_TEXTURE_GLTF(bool value);
}

/// Define the code related to the sub surface parameters of the pbr material.
@JS()
class PBRSubSurfaceConfiguration {
	
	/// Instantiate a new istance of sub surface configuration.
	/// @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
	/// @param markScenePrePassDirty Callback to flag the scene as prepass dirty
	/// @param scene The scene
	external factory PBRSubSurfaceConfiguration(void Function() markAllSubMeshesAsTexturesDirty, void Function() markScenePrePassDirty, Scene scene);
	
	/// Defines if the refraction is enabled in the material.
	external bool get isRefractionEnabled;
	external set isRefractionEnabled(bool value);
	
	/// Defines if the translucency is enabled in the material.
	external bool get isTranslucencyEnabled;
	external set isTranslucencyEnabled(bool value);
	
	/// Defines if the sub surface scattering is enabled in the material.
	external bool get isScatteringEnabled;
	external set isScatteringEnabled(bool value);
	
	/// Diffusion profile for subsurface scattering.
	/// Useful for better scattering in the skins or foliages.
	external Color3? get scatteringDiffusionProfile;
	
	external set scatteringDiffusionProfile(Color3? value);
	
	/// Defines the refraction intensity of the material.
	/// The refraction when enabled replaces the Diffuse part of the material.
	/// The intensity helps transitionning between diffuse and refraction.
	external num get refractionIntensity;
	external set refractionIntensity(num value);
	
	/// Defines the translucency intensity of the material.
	/// When translucency has been enabled, this defines how much of the "translucency"
	/// is addded to the diffuse part of the material.
	external num get translucencyIntensity;
	external set translucencyIntensity(num value);
	
	/// When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)
	external bool get useAlbedoToTintRefraction;
	external set useAlbedoToTintRefraction(bool value);
	
	/// Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).
	/// The red channel of the texture should contain the thickness remapped between 0 and 1.
	/// 0 would mean minimumThickness
	/// 1 would mean maximumThickness
	/// The other channels might be use as a mask to vary the different effects intensity.
	external BaseTexture? get thicknessTexture;
	external set thicknessTexture(BaseTexture? value);
	
	/// Defines the texture to use for refraction.
	external BaseTexture? get refractionTexture;
	external set refractionTexture(BaseTexture? value);
	
	/// Index of refraction of the material base layer.
	/// https://en.wikipedia.org/wiki/List_of_refractive_indices
	/// 
	/// This does not only impact refraction but also the Base F0 of Dielectric Materials.
	/// 
	/// From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
	external num get indexOfRefraction;
	external set indexOfRefraction(num value);
	
	/// Index of refraction of the material's volume.
	/// https://en.wikipedia.org/wiki/List_of_refractive_indices
	/// 
	/// This ONLY impacts refraction. If not provided or given a non-valid value,
	/// the volume will use the same IOR as the surface.
	external num get volumeIndexOfRefraction;
	
	external set volumeIndexOfRefraction(num value);
	
	/// Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
	external bool get invertRefractionY;
	external set invertRefractionY(bool value);
	
	/// This parameters will make the material used its opacity to control how much it is refracting aginst not.
	/// Materials half opaque for instance using refraction could benefit from this control.
	external bool get linkRefractionWithTransparency;
	external set linkRefractionWithTransparency(bool value);
	
	/// Defines the minimum thickness stored in the thickness map.
	/// If no thickness map is defined, this value will be used to simulate thickness.
	external num get minimumThickness;
	external set minimumThickness(num value);
	
	/// Defines the maximum thickness stored in the thickness map.
	external num get maximumThickness;
	external set maximumThickness(num value);
	
	/// Defines the volume tint of the material.
	/// This is used for both translucency and scattering.
	external Color3 get tintColor;
	external set tintColor(Color3 value);
	
	/// Defines the distance at which the tint color should be found in the media.
	/// This is used for refraction only.
	external num get tintColorAtDistance;
	external set tintColorAtDistance(num value);
	
	/// Defines how far each channel transmit through the media.
	/// It is defined as a color to simplify it selection.
	external Color3 get diffusionDistance;
	external set diffusionDistance(Color3 value);
	
	/// Stores the intensity of the different subsurface effects in the thickness texture.
	/// * the green channel is the translucency intensity.
	/// * the blue channel is the scattering intensity.
	/// * the alpha channel is the refraction intensity.
	external bool get useMaskFromThicknessTexture;
	external set useMaskFromThicknessTexture(bool value);
	
	/// Stores the intensity of the different subsurface effects in the thickness texture. This variation
	/// matches the channel-packing that is used by glTF.
	/// * the red channel is the transmission/translucency intensity.
	/// * the green channel is the thickness.
	external bool get useMaskFromThicknessTextureGltf;
	external set useMaskFromThicknessTextureGltf(bool value);
	
	/// Gets wehter the submesh is ready to be used or not.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene the material belongs to.
	/// @returns - boolean indicating that the submesh is ready or not.
	external bool isReadyForSubMesh(IMaterialSubSurfaceDefines defines, Scene scene);
	
	/// Checks to see if a texture is used in the material.
	/// @param defines the list of "defines" to update.
	/// @param scene defines the scene to the material belongs to.
	external void prepareDefines(IMaterialSubSurfaceDefines defines, Scene scene);
	
	/// Binds the material data.
	/// @param uniformBuffer defines the Uniform buffer to fill in.
	/// @param scene defines the scene the material belongs to.
	/// @param engine defines the engine the material belongs to.
	/// @param isFrozen defines whether the material is frozen or not.
	/// @param lodBasedMicrosurface defines whether the material relies on lod based microsurface or not.
	/// @param realTimeFiltering defines whether the textures should be filtered on the fly.
	external void bindForSubMesh(UniformBuffer uniformBuffer, Scene scene, Engine engine, bool isFrozen, bool lodBasedMicrosurface, bool realTimeFiltering);
	
	/// Unbinds the material from the mesh.
	/// @param activeEffect defines the effect that should be unbound from.
	/// @returns true if unbound, otherwise false
	external bool unbind(Effect activeEffect);
	
	/// Returns true if alpha blending should be disabled.
	external bool get disableAlphaBlending;
	
	/// Fills the list of render target textures.
	/// @param renderTargets the list of render targets to update
	external void fillRenderTargetTextures(SmartArray<RenderTargetTexture> renderTargets);
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	external bool hasTexture(BaseTexture texture);
	
	/// Gets a boolean indicating that current material needs to register RTT
	/// @returns true if this uses a render target otherwise false.
	external bool hasRenderTargetTextures();
	
	/// Returns an array of the actively used textures.
	/// @param activeTextures Array of BaseTextures
	external void getActiveTextures(List<BaseTexture> activeTextures);
	
	/// Returns the animatable textures.
	/// @param animatables Array of animatable textures.
	external void getAnimatables(List<IAnimatable> animatables);
	
	/// Disposes the resources of the material.
	/// @param forceDisposeTextures - Forces the disposal of all textures.
	external void dispose([bool? forceDisposeTextures]);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "PBRSubSurfaceConfiguration"
	external String getClassName();
	
	/// Add fallbacks to the effect fallbacks list.
	/// @param defines defines the Base texture to use.
	/// @param fallbacks defines the current fallback list.
	/// @param currentRank defines the current fallback rank.
	/// @returns the new fallback rank.
	external static num AddFallbacks(IMaterialSubSurfaceDefines defines, EffectFallbacks fallbacks, num currentRank);
	
	/// Add the required uniforms to the current list.
	/// @param uniforms defines the current uniform list.
	external static void AddUniforms(List<String> uniforms);
	
	/// Add the required samplers to the current list.
	/// @param samplers defines the current sampler list.
	external static void AddSamplers(List<String> samplers);
	
	/// Add the required uniforms to the current buffer.
	/// @param uniformBuffer defines the current uniform buffer.
	external static void PrepareUniformBuffer(UniformBuffer uniformBuffer);
	
	/// Makes a duplicate of the current configuration into another one.
	/// @param configuration define the config where to copy the info
	external void copyTo(PBRSubSurfaceConfiguration configuration);
	
	/// Serializes this Sub Surface configuration.
	/// @returns - An object with the serialized config.
	external dynamic serialize();
	
	/// Parses a anisotropy Configuration from a serialized object.
	/// @param source - Serialized object.
	/// @param scene Defines the scene we are parsing for
	/// @param rootUrl Defines the rootUrl to load from
	external void parse(dynamic source, Scene scene, String rootUrl);
}

/// Class representing spherical harmonics coefficients to the 3rd degree
@JS()
class SphericalHarmonics {
	external factory SphericalHarmonics();
	
	/// Defines whether or not the harmonics have been prescaled for rendering.
	external bool get preScaled;
	external set preScaled(bool value);
	
	/// The l0,0 coefficients of the spherical harmonics
	external Vector3 get l00;
	external set l00(Vector3 value);
	
	/// The l1,-1 coefficients of the spherical harmonics
	external Vector3 get l1_1;
	external set l1_1(Vector3 value);
	
	/// The l1,0 coefficients of the spherical harmonics
	external Vector3 get l10;
	external set l10(Vector3 value);
	
	/// The l1,1 coefficients of the spherical harmonics
	external Vector3 get l11;
	external set l11(Vector3 value);
	
	/// The l2,-2 coefficients of the spherical harmonics
	external Vector3 get l2_2;
	external set l2_2(Vector3 value);
	
	/// The l2,-1 coefficients of the spherical harmonics
	external Vector3 get l2_1;
	external set l2_1(Vector3 value);
	
	/// The l2,0 coefficients of the spherical harmonics
	external Vector3 get l20;
	external set l20(Vector3 value);
	
	/// The l2,1 coefficients of the spherical harmonics
	external Vector3 get l21;
	external set l21(Vector3 value);
	
	/// The l2,2 coefficients of the spherical harmonics
	external Vector3 get l22;
	external set l22(Vector3 value);
	
	/// Adds a light to the spherical harmonics
	/// @param direction the direction of the light
	/// @param color the color of the light
	/// @param deltaSolidAngle the delta solid angle of the light
	external void addLight(Vector3 direction, Color3 color, num deltaSolidAngle);
	
	/// Scales the spherical harmonics by the given amount
	/// @param scale the amount to scale
	external void scaleInPlace(num scale);
	
	/// Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.
	/// 
	/// ```
	/// E_lm = A_l * L_lm
	/// ```
	/// 
	/// In spherical harmonics this convolution amounts to scaling factors for each frequency band.
	/// This corresponds to equation 5 in "An Efficient Representation for Irradiance Environment Maps", where
	/// the scaling factors are given in equation 9.
	external void convertIncidentRadianceToIrradiance();
	
	/// Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.
	/// 
	/// ```
	/// L = (1/pi) * E * rho
	/// ```
	/// 
	/// This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.
	external void convertIrradianceToLambertianRadiance();
	
	/// Integrates the reconstruction coefficients directly in to the SH preventing further
	/// required operations at run time.
	/// 
	/// This is simply done by scaling back the SH with Ylm constants parameter.
	/// The trigonometric part being applied by the shader at run time.
	external void preScaleForRendering();
	
	/// Constructs a spherical harmonics from an array.
	/// @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
	/// @returns the spherical harmonics
	external static SphericalHarmonics FromArray(List<List<num>> data);
	
	/// Gets the spherical harmonics from polynomial
	/// @param polynomial the spherical polynomial
	/// @returns the spherical harmonics
	external static SphericalHarmonics FromPolynomial(SphericalPolynomial polynomial);
}

/// Class representing spherical polynomial coefficients to the 3rd degree
@JS()
class SphericalPolynomial {
	external factory SphericalPolynomial();
	
	/// The spherical harmonics used to create the polynomials.
	external SphericalHarmonics get preScaledHarmonics;
	
	/// The x coefficients of the spherical polynomial
	external Vector3 get x;
	external set x(Vector3 value);
	
	/// The y coefficients of the spherical polynomial
	external Vector3 get y;
	external set y(Vector3 value);
	
	/// The z coefficients of the spherical polynomial
	external Vector3 get z;
	external set z(Vector3 value);
	
	/// The xx coefficients of the spherical polynomial
	external Vector3 get xx;
	external set xx(Vector3 value);
	
	/// The yy coefficients of the spherical polynomial
	external Vector3 get yy;
	external set yy(Vector3 value);
	
	/// The zz coefficients of the spherical polynomial
	external Vector3 get zz;
	external set zz(Vector3 value);
	
	/// The xy coefficients of the spherical polynomial
	external Vector3 get xy;
	external set xy(Vector3 value);
	
	/// The yz coefficients of the spherical polynomial
	external Vector3 get yz;
	external set yz(Vector3 value);
	
	/// The zx coefficients of the spherical polynomial
	external Vector3 get zx;
	external set zx(Vector3 value);
	
	/// Adds an ambient color to the spherical polynomial
	/// @param color the color to add
	external void addAmbient(Color3 color);
	
	/// Scales the spherical polynomial by the given amount
	/// @param scale the amount to scale
	external void scaleInPlace(num scale);
	
	/// Gets the spherical polynomial from harmonics
	/// @param harmonics the spherical harmonics
	/// @returns the spherical polynomial
	external static SphericalPolynomial FromHarmonics(SphericalHarmonics harmonics);
	
	/// Constructs a spherical polynomial from an array.
	/// @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)
	/// @returns the spherical polynomial
	external static SphericalPolynomial FromArray(List<List<num>> data);
}

/// CubeMap information grouping all the data for each faces as well as the cubemap size.
@JS()
@anonymous
class CubeMapInfo {
	
	external factory CubeMapInfo({dynamic? front, dynamic? back, dynamic? left, dynamic? right, dynamic? up, dynamic? down, num size, num format, num type, bool gammaSpace});
	
	/// The pixel array for the front face.
	/// This is stored in format, left to right, up to down format.
	external dynamic? get front;
	external set front( dynamic? value );
	
	/// The pixel array for the back face.
	/// This is stored in format, left to right, up to down format.
	external dynamic? get back;
	external set back( dynamic? value );
	
	/// The pixel array for the left face.
	/// This is stored in format, left to right, up to down format.
	external dynamic? get left;
	external set left( dynamic? value );
	
	/// The pixel array for the right face.
	/// This is stored in format, left to right, up to down format.
	external dynamic? get right;
	external set right( dynamic? value );
	
	/// The pixel array for the up face.
	/// This is stored in format, left to right, up to down format.
	external dynamic? get up;
	external set up( dynamic? value );
	
	/// The pixel array for the down face.
	/// This is stored in format, left to right, up to down format.
	external dynamic? get down;
	external set down( dynamic? value );
	
	/// The size of the cubemap stored.
	/// 
	/// Each faces will be size * size pixels.
	external num get size;
	external set size( num value );
	
	/// The format of the texture.
	/// 
	/// RGBA, RGB.
	external num get format;
	external set format( num value );
	
	/// The type of the texture data.
	/// 
	/// UNSIGNED_INT, FLOAT.
	external num get type;
	external set type( num value );
	
	/// Specifies whether the texture is in gamma space.
	external bool get gammaSpace;
	external set gammaSpace( bool value );
}

/// Helper class useful to convert panorama picture to their cubemap representation in 6 faces.
@JS()
class PanoramaToCubeMapTools {
	external factory PanoramaToCubeMapTools();
	
	/// Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).
	/// 
	/// @param float32Array The source data.
	/// @param inputWidth The width of the input panorama.
	/// @param inputHeight The height of the input panorama.
	/// @param size The willing size of the generated cubemap (each faces will be size * size pixels)
	/// @return The cubemap data
	external static CubeMapInfo ConvertPanoramaToCubemap(Float32List float32Array, num inputWidth, num inputHeight, num size);
}

/// Helper class dealing with the extraction of spherical polynomial dataArray
/// from a cube map.
@JS()
class CubeMapToSphericalPolynomialTools {
	external factory CubeMapToSphericalPolynomialTools();
	
	/// Converts a texture to the according Spherical Polynomial data.
	/// This extracts the first 3 orders only as they are the only one used in the lighting.
	/// 
	/// @param texture The texture to extract the information from.
	/// @return The Spherical Polynomial data.
	external static SphericalPolynomial? ConvertCubeMapTextureToSphericalPolynomial(BaseTexture texture);
	
	/// Converts a cubemap to the according Spherical Polynomial data.
	/// This extracts the first 3 orders only as they are the only one used in the lighting.
	/// 
	/// @param cubeInfo The Cube map to extract the information from.
	/// @return The Spherical Polynomial data.
	external static SphericalPolynomial ConvertCubeMapToSphericalPolynomial(CubeMapInfo cubeInfo);
}

/* var */
/// @hidden
@JS()
external dynamic get pbrFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get pbrUboDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get pbrFragmentExtraDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get pbrFragmentSamplersDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get subSurfaceScatteringFunctions;

/* var */
/// @hidden
@JS()
external dynamic get importanceSampling;

/* var */
/// @hidden
@JS()
external dynamic get pbrHelperFunctions;

/* var */
/// @hidden
@JS()
external dynamic get harmonicsFunctions;

/* var */
/// @hidden
@JS()
external dynamic get pbrDirectLightingSetupFunctions;

/* var */
/// @hidden
@JS()
external dynamic get pbrDirectLightingFalloffFunctions;

/* var */
/// @hidden
@JS()
external dynamic get pbrBRDFFunctions;

/* var */
/// @hidden
@JS()
external dynamic get hdrFilteringFunctions;

/* var */
/// @hidden
@JS()
external dynamic get pbrDirectLightingFunctions;

/* var */
/// @hidden
@JS()
external dynamic get pbrIBLFunctions;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockAlbedoOpacity;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockReflectivity;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockAmbientOcclusion;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockAlphaFresnel;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockAnisotropic;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockReflection;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockSheen;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockClearcoat;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockSubSurface;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockNormalGeometric;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockNormalFinal;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockLightmapInit;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockGeometryInfo;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockReflectance0;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockReflectance;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockDirectLighting;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockFinalLitComponents;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockFinalUnlitComponents;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockFinalColorComposition;

/* var */
/// @hidden
@JS()
external dynamic get pbrBlockImageProcessing;

/* var */
/// @hidden
@JS()
external dynamic get pbrDebug;

/* var */
/// @hidden
@JS()
external dynamic get pbrPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get pbrVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get pbrVertexShader;

/// Manages the defines for the PBR Material.
/// @hidden
@JS()
class PBRMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines, IMaterialClearCoatDefines, IMaterialAnisotropicDefines, IMaterialBRDFDefines, IMaterialSheenDefines, IMaterialSubSurfaceDefines, IMaterialDetailMapDefines {
	
	/// Initializes the PBR Material defines.
	external factory PBRMaterialDefines();
	
	external bool get PBR;
	external set PBR(bool value);
	
	external String get NUM_SAMPLES;
	external set NUM_SAMPLES(String value);
	
	external bool get REALTIME_FILTERING;
	external set REALTIME_FILTERING(bool value);
	
	@override
	external bool get MAINUV1;
	@override
	external set MAINUV1(bool value);
	
	external bool get MAINUV2;
	external set MAINUV2(bool value);
	
	external bool get UV1;
	external set UV1(bool value);
	
	external bool get UV2;
	external set UV2(bool value);
	
	external bool get ALBEDO;
	external set ALBEDO(bool value);
	
	external bool get GAMMAALBEDO;
	external set GAMMAALBEDO(bool value);
	
	external num get ALBEDODIRECTUV;
	external set ALBEDODIRECTUV(num value);
	
	external bool get VERTEXCOLOR;
	external set VERTEXCOLOR(bool value);
	
	@override
	external bool get DETAIL;
	@override
	external set DETAIL(bool value);
	
	@override
	external num get DETAILDIRECTUV;
	@override
	external set DETAILDIRECTUV(num value);
	
	@override
	external num get DETAIL_NORMALBLENDMETHOD;
	@override
	external set DETAIL_NORMALBLENDMETHOD(num value);
	
	external bool get AMBIENT;
	external set AMBIENT(bool value);
	
	external num get AMBIENTDIRECTUV;
	external set AMBIENTDIRECTUV(num value);
	
	external bool get AMBIENTINGRAYSCALE;
	external set AMBIENTINGRAYSCALE(bool value);
	
	external bool get OPACITY;
	external set OPACITY(bool value);
	
	external bool get VERTEXALPHA;
	external set VERTEXALPHA(bool value);
	
	external num get OPACITYDIRECTUV;
	external set OPACITYDIRECTUV(num value);
	
	external bool get OPACITYRGB;
	external set OPACITYRGB(bool value);
	
	external bool get ALPHATEST;
	external set ALPHATEST(bool value);
	
	external bool get DEPTHPREPASS;
	external set DEPTHPREPASS(bool value);
	
	external bool get ALPHABLEND;
	external set ALPHABLEND(bool value);
	
	external bool get ALPHAFROMALBEDO;
	external set ALPHAFROMALBEDO(bool value);
	
	external String get ALPHATESTVALUE;
	external set ALPHATESTVALUE(String value);
	
	external bool get SPECULAROVERALPHA;
	external set SPECULAROVERALPHA(bool value);
	
	external bool get RADIANCEOVERALPHA;
	external set RADIANCEOVERALPHA(bool value);
	
	external bool get ALPHAFRESNEL;
	external set ALPHAFRESNEL(bool value);
	
	external bool get LINEARALPHAFRESNEL;
	external set LINEARALPHAFRESNEL(bool value);
	
	external bool get PREMULTIPLYALPHA;
	external set PREMULTIPLYALPHA(bool value);
	
	external bool get EMISSIVE;
	external set EMISSIVE(bool value);
	
	external num get EMISSIVEDIRECTUV;
	external set EMISSIVEDIRECTUV(num value);
	
	external bool get REFLECTIVITY;
	external set REFLECTIVITY(bool value);
	
	external num get REFLECTIVITYDIRECTUV;
	external set REFLECTIVITYDIRECTUV(num value);
	
	external bool get SPECULARTERM;
	external set SPECULARTERM(bool value);
	
	external bool get MICROSURFACEFROMREFLECTIVITYMAP;
	external set MICROSURFACEFROMREFLECTIVITYMAP(bool value);
	
	external bool get MICROSURFACEAUTOMATIC;
	external set MICROSURFACEAUTOMATIC(bool value);
	
	external bool get LODBASEDMICROSFURACE;
	external set LODBASEDMICROSFURACE(bool value);
	
	external bool get MICROSURFACEMAP;
	external set MICROSURFACEMAP(bool value);
	
	external num get MICROSURFACEMAPDIRECTUV;
	external set MICROSURFACEMAPDIRECTUV(num value);
	
	external bool get METALLICWORKFLOW;
	external set METALLICWORKFLOW(bool value);
	
	external bool get ROUGHNESSSTOREINMETALMAPALPHA;
	external set ROUGHNESSSTOREINMETALMAPALPHA(bool value);
	
	external bool get ROUGHNESSSTOREINMETALMAPGREEN;
	external set ROUGHNESSSTOREINMETALMAPGREEN(bool value);
	
	external bool get METALLNESSSTOREINMETALMAPBLUE;
	external set METALLNESSSTOREINMETALMAPBLUE(bool value);
	
	external bool get AOSTOREINMETALMAPRED;
	external set AOSTOREINMETALMAPRED(bool value);
	
	external bool get METALLIC_REFLECTANCE;
	external set METALLIC_REFLECTANCE(bool value);
	
	external num get METALLIC_REFLECTANCEDIRECTUV;
	external set METALLIC_REFLECTANCEDIRECTUV(num value);
	
	external bool get ENVIRONMENTBRDF;
	external set ENVIRONMENTBRDF(bool value);
	
	external bool get ENVIRONMENTBRDF_RGBD;
	external set ENVIRONMENTBRDF_RGBD(bool value);
	
	external bool get NORMAL;
	external set NORMAL(bool value);
	
	external bool get TANGENT;
	external set TANGENT(bool value);
	
	external bool get BUMP;
	external set BUMP(bool value);
	
	external num get BUMPDIRECTUV;
	external set BUMPDIRECTUV(num value);
	
	external bool get OBJECTSPACE_NORMALMAP;
	external set OBJECTSPACE_NORMALMAP(bool value);
	
	external bool get PARALLAX;
	external set PARALLAX(bool value);
	
	external bool get PARALLAXOCCLUSION;
	external set PARALLAXOCCLUSION(bool value);
	
	external bool get NORMALXYSCALE;
	external set NORMALXYSCALE(bool value);
	
	external bool get LIGHTMAP;
	external set LIGHTMAP(bool value);
	
	external num get LIGHTMAPDIRECTUV;
	external set LIGHTMAPDIRECTUV(num value);
	
	external bool get USELIGHTMAPASSHADOWMAP;
	external set USELIGHTMAPASSHADOWMAP(bool value);
	
	external bool get GAMMALIGHTMAP;
	external set GAMMALIGHTMAP(bool value);
	
	external bool get RGBDLIGHTMAP;
	external set RGBDLIGHTMAP(bool value);
	
	external bool get REFLECTION;
	external set REFLECTION(bool value);
	
	external bool get REFLECTIONMAP_3D;
	external set REFLECTIONMAP_3D(bool value);
	
	external bool get REFLECTIONMAP_SPHERICAL;
	external set REFLECTIONMAP_SPHERICAL(bool value);
	
	external bool get REFLECTIONMAP_PLANAR;
	external set REFLECTIONMAP_PLANAR(bool value);
	
	external bool get REFLECTIONMAP_CUBIC;
	external set REFLECTIONMAP_CUBIC(bool value);
	
	external bool get USE_LOCAL_REFLECTIONMAP_CUBIC;
	external set USE_LOCAL_REFLECTIONMAP_CUBIC(bool value);
	
	external bool get REFLECTIONMAP_PROJECTION;
	external set REFLECTIONMAP_PROJECTION(bool value);
	
	external bool get REFLECTIONMAP_SKYBOX;
	external set REFLECTIONMAP_SKYBOX(bool value);
	
	external bool get REFLECTIONMAP_EXPLICIT;
	external set REFLECTIONMAP_EXPLICIT(bool value);
	
	external bool get REFLECTIONMAP_EQUIRECTANGULAR;
	external set REFLECTIONMAP_EQUIRECTANGULAR(bool value);
	
	external bool get REFLECTIONMAP_EQUIRECTANGULAR_FIXED;
	external set REFLECTIONMAP_EQUIRECTANGULAR_FIXED(bool value);
	
	external bool get REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED;
	external set REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED(bool value);
	
	external bool get INVERTCUBICMAP;
	external set INVERTCUBICMAP(bool value);
	
	external bool get USESPHERICALFROMREFLECTIONMAP;
	external set USESPHERICALFROMREFLECTIONMAP(bool value);
	
	external bool get USEIRRADIANCEMAP;
	external set USEIRRADIANCEMAP(bool value);
	
	@override
	external bool get SPHERICAL_HARMONICS;
	@override
	external set SPHERICAL_HARMONICS(bool value);
	
	external bool get USESPHERICALINVERTEX;
	external set USESPHERICALINVERTEX(bool value);
	
	external bool get REFLECTIONMAP_OPPOSITEZ;
	external set REFLECTIONMAP_OPPOSITEZ(bool value);
	
	external bool get LODINREFLECTIONALPHA;
	external set LODINREFLECTIONALPHA(bool value);
	
	external bool get GAMMAREFLECTION;
	external set GAMMAREFLECTION(bool value);
	
	external bool get RGBDREFLECTION;
	external set RGBDREFLECTION(bool value);
	
	external bool get LINEARSPECULARREFLECTION;
	external set LINEARSPECULARREFLECTION(bool value);
	
	external bool get RADIANCEOCCLUSION;
	external set RADIANCEOCCLUSION(bool value);
	
	external bool get HORIZONOCCLUSION;
	external set HORIZONOCCLUSION(bool value);
	
	external bool get INSTANCES;
	external set INSTANCES(bool value);
	
	external bool get THIN_INSTANCES;
	external set THIN_INSTANCES(bool value);
	
	external bool get PREPASS;
	external set PREPASS(bool value);
	
	external bool get PREPASS_IRRADIANCE;
	external set PREPASS_IRRADIANCE(bool value);
	
	external num get PREPASS_IRRADIANCE_INDEX;
	external set PREPASS_IRRADIANCE_INDEX(num value);
	
	external bool get PREPASS_ALBEDO;
	external set PREPASS_ALBEDO(bool value);
	
	external num get PREPASS_ALBEDO_INDEX;
	external set PREPASS_ALBEDO_INDEX(num value);
	
	external bool get PREPASS_DEPTHNORMAL;
	external set PREPASS_DEPTHNORMAL(bool value);
	
	external num get PREPASS_DEPTHNORMAL_INDEX;
	external set PREPASS_DEPTHNORMAL_INDEX(num value);
	
	external bool get PREPASS_POSITION;
	external set PREPASS_POSITION(bool value);
	
	external num get PREPASS_POSITION_INDEX;
	external set PREPASS_POSITION_INDEX(num value);
	
	external bool get PREPASS_VELOCITY;
	external set PREPASS_VELOCITY(bool value);
	
	external num get PREPASS_VELOCITY_INDEX;
	external set PREPASS_VELOCITY_INDEX(num value);
	
	external bool get PREPASS_REFLECTIVITY;
	external set PREPASS_REFLECTIVITY(bool value);
	
	external num get PREPASS_REFLECTIVITY_INDEX;
	external set PREPASS_REFLECTIVITY_INDEX(num value);
	
	external num get SCENE_MRT_COUNT;
	external set SCENE_MRT_COUNT(num value);
	
	external num get NUM_BONE_INFLUENCERS;
	external set NUM_BONE_INFLUENCERS(num value);
	
	external num get BonesPerMesh;
	external set BonesPerMesh(num value);
	
	external bool get BONETEXTURE;
	external set BONETEXTURE(bool value);
	
	external bool get BONES_VELOCITY_ENABLED;
	external set BONES_VELOCITY_ENABLED(bool value);
	
	external bool get NONUNIFORMSCALING;
	external set NONUNIFORMSCALING(bool value);
	
	external bool get MORPHTARGETS;
	external set MORPHTARGETS(bool value);
	
	external bool get MORPHTARGETS_NORMAL;
	external set MORPHTARGETS_NORMAL(bool value);
	
	external bool get MORPHTARGETS_TANGENT;
	external set MORPHTARGETS_TANGENT(bool value);
	
	external bool get MORPHTARGETS_UV;
	external set MORPHTARGETS_UV(bool value);
	
	external num get NUM_MORPH_INFLUENCERS;
	external set NUM_MORPH_INFLUENCERS(num value);
	
	@override
	external bool get IMAGEPROCESSING;
	@override
	external set IMAGEPROCESSING(bool value);
	
	@override
	external bool get VIGNETTE;
	@override
	external set VIGNETTE(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEMULTIPLY;
	@override
	external set VIGNETTEBLENDMODEMULTIPLY(bool value);
	
	@override
	external bool get VIGNETTEBLENDMODEOPAQUE;
	@override
	external set VIGNETTEBLENDMODEOPAQUE(bool value);
	
	@override
	external bool get TONEMAPPING;
	@override
	external set TONEMAPPING(bool value);
	
	@override
	external bool get TONEMAPPING_ACES;
	@override
	external set TONEMAPPING_ACES(bool value);
	
	@override
	external bool get CONTRAST;
	@override
	external set CONTRAST(bool value);
	
	@override
	external bool get COLORCURVES;
	@override
	external set COLORCURVES(bool value);
	
	@override
	external bool get COLORGRADING;
	@override
	external set COLORGRADING(bool value);
	
	@override
	external bool get COLORGRADING3D;
	@override
	external set COLORGRADING3D(bool value);
	
	@override
	external bool get SAMPLER3DGREENDEPTH;
	@override
	external set SAMPLER3DGREENDEPTH(bool value);
	
	@override
	external bool get SAMPLER3DBGRMAP;
	@override
	external set SAMPLER3DBGRMAP(bool value);
	
	@override
	external bool get IMAGEPROCESSINGPOSTPROCESS;
	@override
	external set IMAGEPROCESSINGPOSTPROCESS(bool value);
	
	@override
	external bool get EXPOSURE;
	@override
	external set EXPOSURE(bool value);
	
	external bool get MULTIVIEW;
	external set MULTIVIEW(bool value);
	
	external bool get USEPHYSICALLIGHTFALLOFF;
	external set USEPHYSICALLIGHTFALLOFF(bool value);
	
	external bool get USEGLTFLIGHTFALLOFF;
	external set USEGLTFLIGHTFALLOFF(bool value);
	
	external bool get TWOSIDEDLIGHTING;
	external set TWOSIDEDLIGHTING(bool value);
	
	external bool get SHADOWFLOAT;
	external set SHADOWFLOAT(bool value);
	
	external bool get CLIPPLANE;
	external set CLIPPLANE(bool value);
	
	external bool get CLIPPLANE2;
	external set CLIPPLANE2(bool value);
	
	external bool get CLIPPLANE3;
	external set CLIPPLANE3(bool value);
	
	external bool get CLIPPLANE4;
	external set CLIPPLANE4(bool value);
	
	external bool get CLIPPLANE5;
	external set CLIPPLANE5(bool value);
	
	external bool get CLIPPLANE6;
	external set CLIPPLANE6(bool value);
	
	external bool get POINTSIZE;
	external set POINTSIZE(bool value);
	
	external bool get FOG;
	external set FOG(bool value);
	
	external bool get LOGARITHMICDEPTH;
	external set LOGARITHMICDEPTH(bool value);
	
	external bool get FORCENORMALFORWARD;
	external set FORCENORMALFORWARD(bool value);
	
	external bool get SPECULARAA;
	external set SPECULARAA(bool value);
	
	@override
	external bool get CLEARCOAT;
	@override
	external set CLEARCOAT(bool value);
	
	@override
	external bool get CLEARCOAT_DEFAULTIOR;
	@override
	external set CLEARCOAT_DEFAULTIOR(bool value);
	
	@override
	external bool get CLEARCOAT_TEXTURE;
	@override
	external set CLEARCOAT_TEXTURE(bool value);
	
	@override
	external bool get CLEARCOAT_TEXTURE_ROUGHNESS;
	@override
	external set CLEARCOAT_TEXTURE_ROUGHNESS(bool value);
	
	@override
	external num get CLEARCOAT_TEXTUREDIRECTUV;
	@override
	external set CLEARCOAT_TEXTUREDIRECTUV(num value);
	
	@override
	external num get CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV;
	@override
	external set CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV(num value);
	
	@override
	external bool get CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE;
	@override
	external set CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE(bool value);
	
	@override
	external bool get CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;
	@override
	external set CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL(bool value);
	
	@override
	external bool get CLEARCOAT_BUMP;
	@override
	external set CLEARCOAT_BUMP(bool value);
	
	@override
	external num get CLEARCOAT_BUMPDIRECTUV;
	@override
	external set CLEARCOAT_BUMPDIRECTUV(num value);
	
	@override
	external bool get CLEARCOAT_REMAP_F0;
	@override
	external set CLEARCOAT_REMAP_F0(bool value);
	
	@override
	external bool get CLEARCOAT_TINT;
	@override
	external set CLEARCOAT_TINT(bool value);
	
	@override
	external bool get CLEARCOAT_TINT_TEXTURE;
	@override
	external set CLEARCOAT_TINT_TEXTURE(bool value);
	
	@override
	external num get CLEARCOAT_TINT_TEXTUREDIRECTUV;
	@override
	external set CLEARCOAT_TINT_TEXTUREDIRECTUV(num value);
	
	@override
	external bool get ANISOTROPIC;
	@override
	external set ANISOTROPIC(bool value);
	
	@override
	external bool get ANISOTROPIC_TEXTURE;
	@override
	external set ANISOTROPIC_TEXTURE(bool value);
	
	@override
	external num get ANISOTROPIC_TEXTUREDIRECTUV;
	@override
	external set ANISOTROPIC_TEXTUREDIRECTUV(num value);
	
	@override
	external bool get BRDF_V_HEIGHT_CORRELATED;
	@override
	external set BRDF_V_HEIGHT_CORRELATED(bool value);
	
	@override
	external bool get MS_BRDF_ENERGY_CONSERVATION;
	@override
	external set MS_BRDF_ENERGY_CONSERVATION(bool value);
	
	@override
	external bool get SPECULAR_GLOSSINESS_ENERGY_CONSERVATION;
	@override
	external set SPECULAR_GLOSSINESS_ENERGY_CONSERVATION(bool value);
	
	@override
	external bool get SHEEN;
	@override
	external set SHEEN(bool value);
	
	@override
	external bool get SHEEN_TEXTURE;
	@override
	external set SHEEN_TEXTURE(bool value);
	
	@override
	external bool get SHEEN_TEXTURE_ROUGHNESS;
	@override
	external set SHEEN_TEXTURE_ROUGHNESS(bool value);
	
	@override
	external num get SHEEN_TEXTUREDIRECTUV;
	@override
	external set SHEEN_TEXTUREDIRECTUV(num value);
	
	@override
	external num get SHEEN_TEXTURE_ROUGHNESSDIRECTUV;
	@override
	external set SHEEN_TEXTURE_ROUGHNESSDIRECTUV(num value);
	
	@override
	external bool get SHEEN_LINKWITHALBEDO;
	@override
	external set SHEEN_LINKWITHALBEDO(bool value);
	
	@override
	external bool get SHEEN_ROUGHNESS;
	@override
	external set SHEEN_ROUGHNESS(bool value);
	
	@override
	external bool get SHEEN_ALBEDOSCALING;
	@override
	external set SHEEN_ALBEDOSCALING(bool value);
	
	@override
	external bool get SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE;
	@override
	external set SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE(bool value);
	
	@override
	external bool get SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;
	@override
	external set SHEEN_TEXTURE_ROUGHNESS_IDENTICAL(bool value);
	
	@override
	external bool get SUBSURFACE;
	@override
	external set SUBSURFACE(bool value);
	
	@override
	external bool get SS_REFRACTION;
	@override
	external set SS_REFRACTION(bool value);
	
	@override
	external bool get SS_TRANSLUCENCY;
	@override
	external set SS_TRANSLUCENCY(bool value);
	
	@override
	external bool get SS_SCATTERING;
	@override
	external set SS_SCATTERING(bool value);
	
	@override
	external bool get SS_THICKNESSANDMASK_TEXTURE;
	@override
	external set SS_THICKNESSANDMASK_TEXTURE(bool value);
	
	@override
	external num get SS_THICKNESSANDMASK_TEXTUREDIRECTUV;
	@override
	external set SS_THICKNESSANDMASK_TEXTUREDIRECTUV(num value);
	
	@override
	external bool get SS_REFRACTIONMAP_3D;
	@override
	external set SS_REFRACTIONMAP_3D(bool value);
	
	@override
	external bool get SS_REFRACTIONMAP_OPPOSITEZ;
	@override
	external set SS_REFRACTIONMAP_OPPOSITEZ(bool value);
	
	@override
	external bool get SS_LODINREFRACTIONALPHA;
	@override
	external set SS_LODINREFRACTIONALPHA(bool value);
	
	@override
	external bool get SS_GAMMAREFRACTION;
	@override
	external set SS_GAMMAREFRACTION(bool value);
	
	@override
	external bool get SS_RGBDREFRACTION;
	@override
	external set SS_RGBDREFRACTION(bool value);
	
	@override
	external bool get SS_LINEARSPECULARREFRACTION;
	@override
	external set SS_LINEARSPECULARREFRACTION(bool value);
	
	@override
	external bool get SS_LINKREFRACTIONTOTRANSPARENCY;
	@override
	external set SS_LINKREFRACTIONTOTRANSPARENCY(bool value);
	
	@override
	external bool get SS_ALBEDOFORREFRACTIONTINT;
	@override
	external set SS_ALBEDOFORREFRACTIONTINT(bool value);
	
	@override
	external bool get SS_MASK_FROM_THICKNESS_TEXTURE;
	@override
	external set SS_MASK_FROM_THICKNESS_TEXTURE(bool value);
	
	@override
	external bool get SS_MASK_FROM_THICKNESS_TEXTURE_GLTF;
	@override
	external set SS_MASK_FROM_THICKNESS_TEXTURE_GLTF(bool value);
	
	external bool get UNLIT;
	external set UNLIT(bool value);
	
	external num get DEBUGMODE;
	external set DEBUGMODE(num value);
	
	/// Resets the PBR Material defines.
	@override
	external void reset();
}

/// The Physically based material base class of BJS.
/// 
/// This offers the main features of a standard PBR material.
/// For more information, please refer to the documentation :
/// https://doc.babylonjs.com/how_to/physically_based_rendering
@JS()
abstract class PBRBaseMaterial extends PushMaterial {
	
	/// Instantiates a new PBRMaterial instance.
	/// 
	/// @param name The material name
	/// @param scene The scene the material will be use in.
	external factory PBRBaseMaterial(String name, Scene scene);
	
	/// PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
	external static num get PBRMATERIAL_OPAQUE;
	
	/// PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
	external static num get PBRMATERIAL_ALPHATEST;
	
	/// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
	external static num get PBRMATERIAL_ALPHABLEND;
	
	/// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
	/// They are also discarded below the alpha cutoff threshold to improve performances.
	external static num get PBRMATERIAL_ALPHATESTANDBLEND;
	
	/// Defines the default value of how much AO map is occluding the analytical lights
	/// (point spot...).
	external static num get DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
	external static set DEFAULT_AO_ON_ANALYTICAL_LIGHTS(num value);
	
	/// PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.
	external static num get LIGHTFALLOFF_PHYSICAL;
	
	/// PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document
	/// to enhance interoperability with other engines.
	external static num get LIGHTFALLOFF_GLTF;
	
	/// PBRMaterialLightFalloff Standard: light is falling off like in the standard material
	/// to enhance interoperability with other materials.
	external static num get LIGHTFALLOFF_STANDARD;
	
	/// Enables realtime filtering on the texture.
	external bool get realTimeFiltering;
	
	external set realTimeFiltering(bool value);
	
	/// Quality switch for realtime filtering
	external num get realTimeFilteringQuality;
	
	external set realTimeFilteringQuality(num value);
	
	/// Can this material render to several textures at once
	@override
	external bool get canRenderToMRT;
	
	/// @hidden
	/// This is reserved for the inspector.
	/// Defines the material debug mode.
	/// It helps seeing only some components of the material while troubleshooting.
	external num get debugMode;
	external set debugMode(num value);
	
	/// Defines the clear coat layer parameters for the material.
	external PBRClearCoatConfiguration get clearCoat;
	
	/// Defines the anisotropic parameters for the material.
	external PBRAnisotropicConfiguration get anisotropy;
	
	/// Defines the BRDF parameters for the material.
	external PBRBRDFConfiguration get brdf;
	
	/// Defines the Sheen parameters for the material.
	external PBRSheenConfiguration get sheen;
	
	/// Defines the SubSurface parameters for the material.
	external PBRSubSurfaceConfiguration get subSurface;
	
	/// Defines additionnal PrePass parameters for the material.
	external PrePassConfiguration get prePassConfiguration;
	
	/// Defines the detail map parameters for the material.
	external DetailMapConfiguration get detailMap;
	
	/// Gets a boolean indicating that current material needs to register RTT
	@override
	external bool get hasRenderTargetTextures;
	
	/// Gets the name of the material class.
	@override
	external String getClassName();
	
	/// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
	external bool get useLogarithmicDepth;
	
	/// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
	external set useLogarithmicDepth(bool value);
	
	/// Specifies whether or not this material should be rendered in alpha blend mode.
	@override
	external bool needAlphaBlending();
	
	/// Specifies whether or not this material should be rendered in alpha test mode.
	@override
	external bool needAlphaTesting();
	
	/// Gets the texture used for the alpha test.
	@override
	external BaseTexture? getAlphaTestTexture();
	
	/// Specifies that the submesh is ready to be used.
	/// @param mesh - BJS mesh.
	/// @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
	/// @param useInstances - Specifies that instances should be used.
	/// @returns - boolean indicating that the submesh is ready or not.
	@override
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Specifies if the material uses metallic roughness workflow.
	/// @returns boolean specifiying if the material uses metallic roughness workflow.
	external bool isMetallicWorkflow();
	
	/// Force shader compilation
	@override
	external void forceCompilation(AbstractMesh mesh, [void Function(Material material)? onCompiled, IMaterialCompilationOptions? options, void Function(String reason)? onError]);
	
	/// Initializes the uniform buffer layout for the shader.
	external void buildUniformLayout();
	
	/// Unbinds the material from the mesh
	@override
	external void unbind();
	
	/// Binds the submesh data.
	/// @param world - The world matrix.
	/// @param mesh - The BJS mesh.
	/// @param subMesh - A submesh of the BJS mesh.
	@override
	external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
	
	/// Returns the animatable textures.
	/// @returns - Array of animatable textures.
	external List<IAnimatable> getAnimatables();
	
	/// Returns an array of the actively used textures.
	/// @returns - Array of BaseTextures
	@override
	external List<BaseTexture> getActiveTextures();
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	@override
	external bool hasTexture(BaseTexture texture);
	
	/// Sets the required values to the prepass renderer.
	/// @param prePassRenderer defines the prepass renderer to setup
	@override
	external bool setPrePassRenderer(PrePassRenderer prePassRenderer);
	
	/// Disposes the resources of the material.
	/// @param forceDisposeEffect - Forces the disposal of effects.
	/// @param forceDisposeTextures - Forces the disposal of all textures.
	@override
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? notBoundToMesh]);
}

/// The Physically based material of BJS.
/// 
/// This offers the main features of a standard PBR material.
/// For more information, please refer to the documentation :
/// https://doc.babylonjs.com/how_to/physically_based_rendering
@JS()
class PBRMaterial extends PBRBaseMaterial {
	
	/// Instantiates a new PBRMaterial instance.
	/// 
	/// @param name The material name
	/// @param scene The scene the material will be use in.
	external factory PBRMaterial(String name, Scene scene);
	
	/// PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
	@override
	external static num get PBRMATERIAL_OPAQUE;
	
	/// PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
	@override
	external static num get PBRMATERIAL_ALPHATEST;
	
	/// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
	@override
	external static num get PBRMATERIAL_ALPHABLEND;
	
	/// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
	/// They are also discarded below the alpha cutoff threshold to improve performances.
	@override
	external static num get PBRMATERIAL_ALPHATESTANDBLEND;
	
	/// Defines the default value of how much AO map is occluding the analytical lights
	/// (point spot...).
	@override
	external static num get DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
	@override
	external static set DEFAULT_AO_ON_ANALYTICAL_LIGHTS(num value);
	
	/// Intensity of the direct lights e.g. the four lights available in your scene.
	/// This impacts both the direct diffuse and specular highlights.
	external num get directIntensity;
	external set directIntensity(num value);
	
	/// Intensity of the emissive part of the material.
	/// This helps controlling the emissive effect without modifying the emissive color.
	external num get emissiveIntensity;
	external set emissiveIntensity(num value);
	
	/// Intensity of the environment e.g. how much the environment will light the object
	/// either through harmonics for rough material or through the refelction for shiny ones.
	external num get environmentIntensity;
	external set environmentIntensity(num value);
	
	/// This is a special control allowing the reduction of the specular highlights coming from the
	/// four lights of the scene. Those highlights may not be needed in full environment lighting.
	external num get specularIntensity;
	external set specularIntensity(num value);
	
	/// Debug Control allowing disabling the bump map on this material.
	external bool get disableBumpMap;
	external set disableBumpMap(bool value);
	
	/// AKA Diffuse Texture in standard nomenclature.
	external BaseTexture get albedoTexture;
	external set albedoTexture(BaseTexture value);
	
	/// AKA Occlusion Texture in other nomenclature.
	external BaseTexture get ambientTexture;
	external set ambientTexture(BaseTexture value);
	
	/// AKA Occlusion Texture Intensity in other nomenclature.
	external num get ambientTextureStrength;
	external set ambientTextureStrength(num value);
	
	/// Defines how much the AO map is occluding the analytical lights (point spot...).
	/// 1 means it completely occludes it
	/// 0 mean it has no impact
	external num get ambientTextureImpactOnAnalyticalLights;
	external set ambientTextureImpactOnAnalyticalLights(num value);
	
	/// Stores the alpha values in a texture. Use luminance if texture.getAlphaFromRGB is true.
	external BaseTexture get opacityTexture;
	external set opacityTexture(BaseTexture value);
	
	/// Stores the reflection values in a texture.
	external BaseTexture? get reflectionTexture;
	external set reflectionTexture(BaseTexture? value);
	
	/// Stores the emissive values in a texture.
	external BaseTexture get emissiveTexture;
	external set emissiveTexture(BaseTexture value);
	
	/// AKA Specular texture in other nomenclature.
	external BaseTexture get reflectivityTexture;
	external set reflectivityTexture(BaseTexture value);
	
	/// Used to switch from specular/glossiness to metallic/roughness workflow.
	external BaseTexture get metallicTexture;
	external set metallicTexture(BaseTexture value);
	
	/// Specifies the metallic scalar of the metallic/roughness workflow.
	/// Can also be used to scale the metalness values of the metallic texture.
	external num? get metallic;
	external set metallic(num? value);
	
	/// Specifies the roughness scalar of the metallic/roughness workflow.
	/// Can also be used to scale the roughness values of the metallic texture.
	external num? get roughness;
	external set roughness(num? value);
	
	/// In metallic workflow, specifies an F0 factor to help configuring the material F0.
	/// By default the indexOfrefraction is used to compute F0;
	/// 
	/// This is used as a factor against the default reflectance at normal incidence to tweak it.
	/// 
	/// F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;
	/// F90 = metallicReflectanceColor;
	external num get metallicF0Factor;
	external set metallicF0Factor(num value);
	
	/// In metallic workflow, specifies an F90 color to help configuring the material F90.
	/// By default the F90 is always 1;
	/// 
	/// Please note that this factor is also used as a factor against the default reflectance at normal incidence.
	/// 
	/// F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor
	/// F90 = metallicReflectanceColor;
	external Color3 get metallicReflectanceColor;
	external set metallicReflectanceColor(Color3 value);
	
	/// Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A
	/// This is multiply against the scalar values defined in the material.
	external BaseTexture? get metallicReflectanceTexture;
	external set metallicReflectanceTexture(BaseTexture? value);
	
	/// Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.
	/// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
	external BaseTexture get microSurfaceTexture;
	external set microSurfaceTexture(BaseTexture value);
	
	/// Stores surface normal data used to displace a mesh in a texture.
	external BaseTexture get bumpTexture;
	external set bumpTexture(BaseTexture value);
	
	/// Stores the pre-calculated light information of a mesh in a texture.
	external BaseTexture get lightmapTexture;
	external set lightmapTexture(BaseTexture value);
	
	/// Stores the refracted light information in a texture.
	external BaseTexture? get refractionTexture;
	
	external set refractionTexture(BaseTexture? value);
	
	/// The color of a material in ambient lighting.
	external Color3 get ambientColor;
	external set ambientColor(Color3 value);
	
	/// AKA Diffuse Color in other nomenclature.
	external Color3 get albedoColor;
	external set albedoColor(Color3 value);
	
	/// AKA Specular Color in other nomenclature.
	external Color3 get reflectivityColor;
	external set reflectivityColor(Color3 value);
	
	/// The color reflected from the material.
	external Color3 get reflectionColor;
	external set reflectionColor(Color3 value);
	
	/// The color emitted from the material.
	external Color3 get emissiveColor;
	external set emissiveColor(Color3 value);
	
	/// AKA Glossiness in other nomenclature.
	external num get microSurface;
	external set microSurface(num value);
	
	/// Index of refraction of the material base layer.
	/// https://en.wikipedia.org/wiki/List_of_refractive_indices
	/// 
	/// This does not only impact refraction but also the Base F0 of Dielectric Materials.
	/// 
	/// From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
	external num get indexOfRefraction;
	
	external set indexOfRefraction(num value);
	
	/// Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
	external bool get invertRefractionY;
	
	external set invertRefractionY(bool value);
	
	/// This parameters will make the material used its opacity to control how much it is refracting aginst not.
	/// Materials half opaque for instance using refraction could benefit from this control.
	external bool get linkRefractionWithTransparency;
	
	external set linkRefractionWithTransparency(bool value);
	
	/// If true, the light map contains occlusion information instead of lighting info.
	external bool get useLightmapAsShadowmap;
	external set useLightmapAsShadowmap(bool value);
	
	/// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
	external bool get useAlphaFromAlbedoTexture;
	external set useAlphaFromAlbedoTexture(bool value);
	
	/// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
	external bool get forceAlphaTest;
	external set forceAlphaTest(bool value);
	
	/// Defines the alpha limits in alpha test mode.
	external num get alphaCutOff;
	external set alphaCutOff(num value);
	
	/// Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).
	/// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
	external bool get useSpecularOverAlpha;
	external set useSpecularOverAlpha(bool value);
	
	/// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
	external bool get useMicroSurfaceFromReflectivityMapAlpha;
	external set useMicroSurfaceFromReflectivityMapAlpha(bool value);
	
	/// Specifies if the metallic texture contains the roughness information in its alpha channel.
	external bool get useRoughnessFromMetallicTextureAlpha;
	external set useRoughnessFromMetallicTextureAlpha(bool value);
	
	/// Specifies if the metallic texture contains the roughness information in its green channel.
	external bool get useRoughnessFromMetallicTextureGreen;
	external set useRoughnessFromMetallicTextureGreen(bool value);
	
	/// Specifies if the metallic texture contains the metallness information in its blue channel.
	external bool get useMetallnessFromMetallicTextureBlue;
	external set useMetallnessFromMetallicTextureBlue(bool value);
	
	/// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
	external bool get useAmbientOcclusionFromMetallicTextureRed;
	external set useAmbientOcclusionFromMetallicTextureRed(bool value);
	
	/// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
	external bool get useAmbientInGrayScale;
	external set useAmbientInGrayScale(bool value);
	
	/// In case the reflectivity map does not contain the microsurface information in its alpha channel,
	/// The material will try to infer what glossiness each pixel should be.
	external bool get useAutoMicroSurfaceFromReflectivityMap;
	external set useAutoMicroSurfaceFromReflectivityMap(bool value);
	
	/// BJS is using an harcoded light falloff based on a manually sets up range.
	/// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
	/// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
	external bool get usePhysicalLightFalloff;
	
	/// BJS is using an harcoded light falloff based on a manually sets up range.
	/// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
	/// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
	external set usePhysicalLightFalloff(bool value);
	
	/// In order to support the falloff compatibility with gltf, a special mode has been added
	/// to reproduce the gltf light falloff.
	external bool get useGLTFLightFalloff;
	
	/// In order to support the falloff compatibility with gltf, a special mode has been added
	/// to reproduce the gltf light falloff.
	external set useGLTFLightFalloff(bool value);
	
	/// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
	/// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
	external bool get useRadianceOverAlpha;
	external set useRadianceOverAlpha(bool value);
	
	/// Allows using an object space normal map (instead of tangent space).
	external bool get useObjectSpaceNormalMap;
	external set useObjectSpaceNormalMap(bool value);
	
	/// Allows using the bump map in parallax mode.
	external bool get useParallax;
	external set useParallax(bool value);
	
	/// Allows using the bump map in parallax occlusion mode.
	external bool get useParallaxOcclusion;
	external set useParallaxOcclusion(bool value);
	
	/// Controls the scale bias of the parallax mode.
	external num get parallaxScaleBias;
	external set parallaxScaleBias(num value);
	
	/// If sets to true, disables all the lights affecting the material.
	external bool get disableLighting;
	external set disableLighting(bool value);
	
	/// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
	external bool get forceIrradianceInFragment;
	external set forceIrradianceInFragment(bool value);
	
	/// Number of Simultaneous lights allowed on the material.
	external num get maxSimultaneousLights;
	external set maxSimultaneousLights(num value);
	
	/// If sets to true, x component of normal map value will invert (x = 1.0 - x).
	external bool get invertNormalMapX;
	external set invertNormalMapX(bool value);
	
	/// If sets to true, y component of normal map value will invert (y = 1.0 - y).
	external bool get invertNormalMapY;
	external set invertNormalMapY(bool value);
	
	/// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
	external bool get twoSidedLighting;
	external set twoSidedLighting(bool value);
	
	/// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
	/// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
	external bool get useAlphaFresnel;
	external set useAlphaFresnel(bool value);
	
	/// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
	/// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
	external bool get useLinearAlphaFresnel;
	external set useLinearAlphaFresnel(bool value);
	
	/// Let user defines the brdf lookup texture used for IBL.
	/// A default 8bit version is embedded but you could point at :
	/// * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png
	/// * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds
	/// * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png
	/// * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds
	external BaseTexture? get environmentBRDFTexture;
	external set environmentBRDFTexture(BaseTexture? value);
	
	/// Force normal to face away from face.
	external bool get forceNormalForward;
	external set forceNormalForward(bool value);
	
	/// Enables specular anti aliasing in the PBR shader.
	/// It will both interacts on the Geometry for analytical and IBL lighting.
	/// It also prefilter the roughness map based on the bump values.
	external bool get enableSpecularAntiAliasing;
	external set enableSpecularAntiAliasing(bool value);
	
	/// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
	/// makes the reflect vector face the model (under horizon).
	external bool get useHorizonOcclusion;
	external set useHorizonOcclusion(bool value);
	
	/// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
	/// too much the area relying on ambient texture to define their ambient occlusion.
	external bool get useRadianceOcclusion;
	external set useRadianceOcclusion(bool value);
	
	/// If set to true, no lighting calculations will be applied.
	external bool get unlit;
	external set unlit(bool value);
	
	/// Gets the image processing configuration used either in this material.
	external ImageProcessingConfiguration get imageProcessingConfiguration;
	
	/// Sets the Default image processing configuration used either in the this material.
	/// 
	/// If sets to null, the scene one is in use.
	external set imageProcessingConfiguration(ImageProcessingConfiguration value);
	
	/// Gets wether the color curves effect is enabled.
	external bool get cameraColorCurvesEnabled;
	
	/// Sets wether the color curves effect is enabled.
	external set cameraColorCurvesEnabled(bool value);
	
	/// Gets wether the color grading effect is enabled.
	external bool get cameraColorGradingEnabled;
	
	/// Gets wether the color grading effect is enabled.
	external set cameraColorGradingEnabled(bool value);
	
	/// Gets wether tonemapping is enabled or not.
	external bool get cameraToneMappingEnabled;
	
	/// Sets wether tonemapping is enabled or not
	external set cameraToneMappingEnabled(bool value);
	
	/// The camera exposure used on this material.
	/// This property is here and not in the camera to allow controlling exposure without full screen post process.
	/// This corresponds to a photographic exposure.
	external num get cameraExposure;
	
	/// The camera exposure used on this material.
	/// This property is here and not in the camera to allow controlling exposure without full screen post process.
	/// This corresponds to a photographic exposure.
	external set cameraExposure(num value);
	
	/// Gets The camera contrast used on this material.
	external num get cameraContrast;
	
	/// Sets The camera contrast used on this material.
	external set cameraContrast(num value);
	
	/// Gets the Color Grading 2D Lookup Texture.
	external BaseTexture? get cameraColorGradingTexture;
	
	/// Sets the Color Grading 2D Lookup Texture.
	external set cameraColorGradingTexture(BaseTexture? value);
	
	/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
	/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
	/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
	/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
	external ColorCurves? get cameraColorCurves;
	
	/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
	/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
	/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
	/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
	external set cameraColorCurves(ColorCurves? value);
	
	/// Returns the name of this material class.
	@override
	external String getClassName();
	
	/// Makes a duplicate of the current material.
	/// @param name - name to use for the new material.
	@override
	external PBRMaterial? clone(String name);
	
	/// Serializes this PBR Material.
	/// @returns - An object with the serialized material.
	@override
	external dynamic serialize();
	
	/// Parses a PBR Material from a serialized object.
	/// @param source - Serialized object.
	/// @param scene - BJS scene instance.
	/// @param rootUrl - url for the scene object
	/// @returns - PBRMaterial
	@override
	external static PBRMaterial? Parse(dynamic source, Scene scene, String rootUrl);
}

/* var */
/// @hidden
@JS()
external dynamic get mrtFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get geometryPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get geometryVertexShader;

/// @hidden
@JS()
@anonymous
class ISavedTransformationMatrix {
	
	external factory ISavedTransformationMatrix({Matrix world, Matrix viewProjection});
	
	external Matrix get world;
	external set world( Matrix value );
	
	external Matrix get viewProjection;
	external set viewProjection( Matrix value );
}

/// This renderer is helpfull to fill one of the render target with a geometry buffer.
@JS()
class GeometryBufferRenderer {
	
	/// Creates a new G Buffer for the scene
	/// @param scene The scene the buffer belongs to
	/// @param ratio How big is the buffer related to the main canvas.
	external factory GeometryBufferRenderer(Scene scene, [num? ratio]);
	
	/// Constant used to retrieve the depth + normal texture index in the G-Buffer textures array
	/// using getIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_INDEX)
	external static num get DEPTHNORMAL_TEXTURE_TYPE;
	
	/// Constant used to retrieve the position texture index in the G-Buffer textures array
	/// using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)
	external static num get POSITION_TEXTURE_TYPE;
	
	/// Constant used to retrieve the velocity texture index in the G-Buffer textures array
	/// using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)
	external static num get VELOCITY_TEXTURE_TYPE;
	
	/// Constant used to retrieve the reflectivity texture index in the G-Buffer textures array
	/// using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)
	external static num get REFLECTIVITY_TEXTURE_TYPE;
	
	/// Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).
	/// Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).
	external List<AbstractMesh> get excludedSkinnedMeshesFromVelocity;
	external set excludedSkinnedMeshesFromVelocity(List<AbstractMesh> value);
	
	/// Gets or sets a boolean indicating if transparent meshes should be rendered
	external bool get renderTransparentMeshes;
	external set renderTransparentMeshes(bool value);
	
	/// Gets the render list (meshes to be rendered) used in the G buffer.
	external List<AbstractMesh>? get renderList;
	
	/// Set the render list (meshes to be rendered) used in the G buffer.
	external set renderList(List<AbstractMesh>? value);
	
	/// Gets wether or not G buffer are supported by the running hardware.
	/// This requires draw buffer supports
	external bool get isSupported;
	
	/// Returns the index of the given texture type in the G-Buffer textures array
	/// @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
	/// @returns the index of the given texture type in the G-Buffer textures array
	external num getTextureIndex(num textureType);
	
	/// Gets a boolean indicating if objects positions are enabled for the G buffer.
	external bool get enablePosition;
	
	/// Sets whether or not objects positions are enabled for the G buffer.
	external set enablePosition(bool value);
	
	/// Gets a boolean indicating if objects velocities are enabled for the G buffer.
	external bool get enableVelocity;
	
	/// Sets wether or not objects velocities are enabled for the G buffer.
	external set enableVelocity(bool value);
	
	/// Gets a boolean indicating if objects roughness are enabled in the G buffer.
	external bool get enableReflectivity;
	
	/// Sets wether or not objects roughness are enabled for the G buffer.
	external set enableReflectivity(bool value);
	
	/// Gets the scene associated with the buffer.
	external Scene get scene;
	
	/// Gets the ratio used by the buffer during its creation.
	/// How big is the buffer related to the main canvas.
	external num get ratio;
	
	/// Checks wether everything is ready to render a submesh to the G buffer.
	/// @param subMesh the submesh to check readiness for
	/// @param useInstances is the mesh drawn using instance or not
	/// @returns true if ready otherwise false
	external bool isReady(SubMesh subMesh, bool useInstances);
	
	/// Gets the current underlying G Buffer.
	/// @returns the buffer
	external MultiRenderTarget getGBuffer();
	
	/// Gets the number of samples used to render the buffer (anti aliasing).
	external num get samples;
	
	/// Sets the number of samples used to render the buffer (anti aliasing).
	external set samples(num value);
	
	/// Disposes the renderer and frees up associated resources.
	external void dispose();
}

/// Renders a pre pass of the scene
/// This means every mesh in the scene will be rendered to a render target texture
/// And then this texture will be composited to the rendering canvas with post processes
/// It is necessary for effects like subsurface scattering or deferred shading
@JS()
class PrePassRenderer {
	
	/// Instanciates a prepass renderer
	/// @param scene The scene
	external factory PrePassRenderer(Scene scene);
	
	/// To save performance, we can excluded skinned meshes from the prepass
	external List<AbstractMesh> get excludedSkinnedMesh;
	external set excludedSkinnedMesh(List<AbstractMesh> value);
	
	/// Force material to be excluded from the prepass
	/// Can be useful when `useGeometryBufferFallback` is set to `true`
	/// and you don't want a material to show in the effect.
	external List<Material> get excludedMaterials;
	external set excludedMaterials(List<Material> value);
	
	/// Number of textures in the multi render target texture where the scene is directly rendered
	external num get mrtCount;
	external set mrtCount(num value);
	
	/// The render target where the scene is directly rendered
	external MultiRenderTarget get prePassRT;
	external set prePassRT(MultiRenderTarget value);
	
	/// Image processing post process for composition
	external ImageProcessingPostProcess get imageProcessingPostProcess;
	external set imageProcessingPostProcess(ImageProcessingPostProcess value);
	
	/// Indicates if the prepass is enabled
	external bool get enabled;
	
	/// How many samples are used for MSAA of the scene render target
	external num get samples;
	
	external set samples(num value);
	
	/// Uses the geometry buffer renderer as a fallback for non prepass capable effects
	external bool get useGeometryBufferFallback;
	
	external set useGeometryBufferFallback(bool value);
	
	/// Set to true to disable gamma transform in PrePass.
	/// Can be useful in case you already proceed to gamma transform on a material level
	/// and your post processes don't need to be in linear color space.
	external bool get disableGammaTransform;
	external set disableGammaTransform(bool value);
	
	/// Indicates if rendering a prepass is supported
	external bool get isSupported;
	
	/// Sets the proper output textures to draw in the engine.
	/// @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.
	/// @param subMesh Submesh on which the effect is applied
	external void bindAttachmentsForEffect(Effect effect, SubMesh subMesh);
	
	/// Restores attachments for single texture draw.
	external void restoreAttachments();
	
	/// Clears the scene render target (in the sense of settings pixels to the scene clear color value)
	external void clear();
	
	/// Adds an effect configuration to the prepass.
	/// If an effect has already been added, it won't add it twice and will return the configuration
	/// already present.
	/// @param cfg the effect configuration
	/// @return the effect configuration now used by the prepass
	external PrePassEffectConfiguration addEffectConfiguration(PrePassEffectConfiguration cfg);
	
	/// Returns the index of a texture in the multi render target texture array.
	/// @param type Texture type
	/// @return The index
	external num getIndex(num type);
	
	/// Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.
	external void markAsDirty();
	
	/// Disposes the prepass renderer.
	external void dispose();
}

/// PostProcess can be used to apply a shader to a texture after it has been rendered
/// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
@JS()
class PostProcess {
	
	/// Creates a new instance PostProcess
	/// @param name The name of the PostProcess.
	/// @param fragmentUrl The url of the fragment shader to be used.
	/// @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.
	/// @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.
	/// @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param defines String of defines that will be set when running the fragment shader. (default: null)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param vertexUrl The url of the vertex shader to be used. (default: "postprocess")
	/// @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
	/// @param blockCompilation If the shader should not be compiled immediatly. (default: false)
	/// @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
	external factory PostProcess(String name, String fragmentUrl, List<String>? parameters, List<String>? samplers, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, String? defines, num? textureType, String? vertexUrl, dynamic? indexParameters, bool? blockCompilation, num? textureFormat]);
	
	/// Gets or sets the unique id of the post process
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Name of the PostProcess.
	external String get name;
	external set name(String value);
	
	/// Width of the texture to apply the post process on
	external num get width;
	external set width(num value);
	
	/// Height of the texture to apply the post process on
	external num get height;
	external set height(num value);
	
	/// Gets the node material used to create this postprocess (null if the postprocess was manually created)
	external NodeMaterial? get nodeMaterialSource;
	external set nodeMaterialSource(NodeMaterial? value);
	
	/// Sampling mode used by the shader
	/// See https://doc.babylonjs.com/classes/3.1/texture
	external num get renderTargetSamplingMode;
	external set renderTargetSamplingMode(num value);
	
	/// Clear color to use when screen clearing
	external Color4 get clearColor;
	external set clearColor(Color4 value);
	
	/// If the buffer needs to be cleared before applying the post process. (default: true)
	/// Should be set to false if shader will overwrite all previous pixels.
	external bool get autoClear;
	external set autoClear(bool value);
	
	/// Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
	external num get alphaMode;
	external set alphaMode(num value);
	
	/// Sets the setAlphaBlendConstants of the babylon engine
	external Color4 get alphaConstants;
	external set alphaConstants(Color4 value);
	
	/// Animations to be used for the post processing
	external List<Animation> get animations;
	external set animations(List<Animation> value);
	
	/// Enable Pixel Perfect mode where texture is not scaled to be power of 2.
	/// Can only be used on a single postprocess or on the last one of a chain. (default: false)
	external bool get enablePixelPerfectMode;
	external set enablePixelPerfectMode(bool value);
	
	/// Force the postprocess to be applied without taking in account viewport
	external bool get forceFullscreenViewport;
	external set forceFullscreenViewport(bool value);
	
	/// List of inspectable custom properties (used by the Inspector)
	/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
	external List<IInspectable> get inspectableCustomProperties;
	external set inspectableCustomProperties(List<IInspectable> value);
	
	/// Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
	/// 
	/// | Value | Type                                | Description |
	/// | ----- | ----------------------------------- | ----------- |
	/// | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |
	/// | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |
	/// | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |
	/// 
	external num get scaleMode;
	external set scaleMode(num value);
	
	/// Force textures to be a power of two (default: false)
	external bool get alwaysForcePOT;
	external set alwaysForcePOT(bool value);
	
	/// Number of sample textures (default: 1)
	external num get samples;
	
	external set samples(num value);
	
	/// Modify the scale of the post process to be the same as the viewport (default: false)
	external bool get adaptScaleToCurrentViewport;
	external set adaptScaleToCurrentViewport(bool value);
	
	/// Returns the fragment url or shader name used in the post process.
	/// @returns the fragment url or name in the shader store.
	external String getEffectName();
	
	/// An event triggered when the postprocess is activated.
	external Observable<Camera> get onActivateObservable;
	external set onActivateObservable(Observable<Camera> value);
	
	/// A function that is added to the onActivateObservable
	external set onActivate(void Function(Camera camera)? value);
	
	/// An event triggered when the postprocess changes its size.
	external Observable<PostProcess> get onSizeChangedObservable;
	external set onSizeChangedObservable(Observable<PostProcess> value);
	
	/// A function that is added to the onSizeChangedObservable
	external set onSizeChanged(void Function(PostProcess postProcess) value);
	
	/// An event triggered when the postprocess applies its effect.
	external Observable<Effect> get onApplyObservable;
	external set onApplyObservable(Observable<Effect> value);
	
	/// A function that is added to the onApplyObservable
	external set onApply(void Function(Effect effect) value);
	
	/// An event triggered before rendering the postprocess
	external Observable<Effect> get onBeforeRenderObservable;
	external set onBeforeRenderObservable(Observable<Effect> value);
	
	/// A function that is added to the onBeforeRenderObservable
	external set onBeforeRender(void Function(Effect effect) value);
	
	/// An event triggered after rendering the postprocess
	external Observable<Effect> get onAfterRenderObservable;
	external set onAfterRenderObservable(Observable<Effect> value);
	
	/// A function that is added to the onAfterRenderObservable
	external set onAfterRender(void Function(Effect efect) value);
	
	/// The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
	/// render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
	external InternalTexture get inputTexture;
	
	external set inputTexture(InternalTexture value);
	
	/// Since inputTexture should always be defined, if we previously manually set `inputTexture`,
	/// the only way to unset it is to use this function to restore its internal state
	external void restoreDefaultInputTexture();
	
	/// Gets the camera which post process is applied to.
	/// @returns The camera the post process is applied to.
	external Camera getCamera();
	
	/// Gets the texel size of the postprocess.
	/// See https://en.wikipedia.org/wiki/Texel_(graphics)
	external Vector2 get texelSize;
	
	/// Gets a string identifying the name of the class
	/// @returns "PostProcess" string
	external String getClassName();
	
	/// Gets the engine which this post process belongs to.
	/// @returns The engine the post process was enabled with.
	external Engine getEngine();
	
	/// The effect that is created when initializing the post process.
	/// @returns The created effect corresponding the the postprocess.
	external Effect getEffect();
	
	/// To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.
	/// @param postProcess The post process to share the output with.
	/// @returns This post process.
	external PostProcess shareOutputWith(PostProcess postProcess);
	
	/// Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
	/// This should be called if the post process that shares output with this post process is disabled/disposed.
	external void useOwnOutput();
	
	/// Updates the effect with the current post process compile time values and recompiles the shader.
	/// @param defines Define statements that should be added at the beginning of the shader. (default: null)
	/// @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
	/// @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
	/// @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
	/// @param onCompiled Called when the shader has been compiled.
	/// @param onError Called if there is an error when compiling a shader.
	/// @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
	/// @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
	external void updateEffect([String? defines, List<String>? uniforms, List<String>? samplers, dynamic? indexParameters, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, String? vertexUrl, String? fragmentUrl]);
	
	/// The post process is reusable if it can be used multiple times within one frame.
	/// @returns If the post process is reusable
	external bool isReusable();
	
	/// invalidate frameBuffer to hint the postprocess to create a depth buffer
	external void markTextureDirty();
	
	/// Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
	/// When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.
	/// @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.
	/// @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)
	/// @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)
	/// @returns The target texture that was bound to be written to.
	external InternalTexture activate(Camera? camera, [InternalTexture? sourceTexture, bool? forceDepthStencil]);
	
	/// If the post process is supported.
	external bool get isSupported;
	
	/// The aspect ratio of the output texture.
	external num get aspectRatio;
	
	/// Get a value indicating if the post-process is ready to be used
	/// @returns true if the post-process is ready (shader is compiled)
	external bool isReady();
	
	/// Binds all textures and uniforms to the shader, this will be run on every pass.
	/// @returns the effect corresponding to this post process. Null if not compiled or not ready.
	external Effect? apply();
	
	/// Sets the required values to the prepass renderer.
	/// @param prePassRenderer defines the prepass renderer to setup.
	/// @returns true if the pre pass is needed.
	external bool setPrePassRenderer(PrePassRenderer prePassRenderer);
	
	/// Disposes the post process.
	/// @param camera The camera to dispose the post process on.
	external void dispose([Camera? camera]);
	
	/// Serializes the particle system to a JSON object
	/// @returns the JSON object
	external dynamic serialize();
	
	/// Creates a material from parsed material data
	/// @param parsedPostProcess defines parsed post process data
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures
	/// @returns a new post process
	external static PostProcess? Parse(dynamic parsedPostProcess, Scene scene, String rootUrl);
}

/* var */
/// @hidden
@JS()
external dynamic get kernelBlurVaryingDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get packingFunctions;

/* var */
/// @hidden
@JS()
external dynamic get kernelBlurFragment;

/* var */
/// @hidden
@JS()
external dynamic get kernelBlurFragment2;

/* var */
/// @hidden
@JS()
external dynamic get kernelBlurPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get kernelBlurVertex;

/* var */
/// @hidden
@JS()
external dynamic get kernelBlurVertexShader;

/// The Blur Post Process which blurs an image based on a kernel and direction.
/// Can be used twice in x and y directions to perform a guassian blur in two passes.
@JS()
class BlurPostProcess extends PostProcess {
	
	/// Creates a new instance BlurPostProcess
	/// @param name The name of the effect.
	/// @param direction The direction in which to blur the image.
	/// @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
	/// @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory BlurPostProcess(String name, Vector2 direction, num kernel, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, String? defines, bool? blockCompilation]);
	
	/// The direction in which to blur the image.
	external Vector2 get direction;
	external set direction(Vector2 value);
	
	/// Sets the length in pixels of the blur sample region
	external set kernel(num value);
	
	/// Gets the length in pixels of the blur sample region
	external num get kernel;
	
	/// Sets wether or not the blur needs to unpack/repack floats
	external set packedFloat(bool value);
	
	/// Gets wether or not the blur is unpacking/repacking floats
	external bool get packedFloat;
	
	/// Gets a string identifying the name of the class
	/// @returns "BlurPostProcess" string
	@override
	external String getClassName();
	
	/// Updates the effect with the current post process compile time values and recompiles the shader.
	/// @param defines Define statements that should be added at the beginning of the shader. (default: null)
	/// @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
	/// @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
	/// @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
	/// @param onCompiled Called when the shader has been compiled.
	/// @param onError Called if there is an error when compiling a shader.
	@override
	external void updateEffect([String? defines, List<String>? uniforms, List<String>? samplers, dynamic? indexParameters, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, String? vertexUrl, String? fragmentUrl]);
}

/// Mirror texture can be used to simulate the view from a mirror in a scene.
/// It will dynamically be rendered every frame to adapt to the camera point of view.
/// You can then easily use it as a reflectionTexture on a flat surface.
/// In case the surface is not a plane, please consider relying on reflection probes.
/// @see https://doc.babylonjs.com/how_to/reflect#mirrors
@JS()
class MirrorTexture extends RenderTargetTexture {
	
	/// Instantiates a Mirror Texture.
	/// Mirror texture can be used to simulate the view from a mirror in a scene.
	/// It will dynamically be rendered every frame to adapt to the camera point of view.
	/// You can then easily use it as a reflectionTexture on a flat surface.
	/// In case the surface is not a plane, please consider relying on reflection probes.
	/// @see https://doc.babylonjs.com/how_to/reflect#mirrors
	/// @param name
	/// @param size
	/// @param scene
	/// @param generateMipMaps
	/// @param type
	/// @param samplingMode
	/// @param generateDepthBuffer
	external factory MirrorTexture(String name, dynamic size, Scene scene, [bool? generateMipMaps, num? type, num? samplingMode, bool? generateDepthBuffer]);
	
	/// Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.
	/// It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.
	/// @see https://doc.babylonjs.com/how_to/reflect#mirrors
	external Plane get mirrorPlane;
	external set mirrorPlane(Plane value);
	
	/// Define the blur ratio used to blur the reflection if needed.
	external set blurRatio(num value);
	
	external num get blurRatio;
	
	/// Define the adaptive blur kernel used to blur the reflection if needed.
	/// This will autocompute the closest best match for the `blurKernel`
	external set adaptiveBlurKernel(num value);
	
	/// Define the blur kernel used to blur the reflection if needed.
	/// Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
	external set blurKernel(num value);
	
	/// Define the blur kernel on the X Axis used to blur the reflection if needed.
	/// Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
	external set blurKernelX(num value);
	
	external num get blurKernelX;
	
	/// Define the blur kernel on the Y Axis used to blur the reflection if needed.
	/// Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
	external set blurKernelY(num value);
	
	external num get blurKernelY;
	
	/// Clone the mirror texture.
	/// @returns the cloned texture
	@override
	external MirrorTexture? clone();
	
	/// Serialize the texture to a JSON representation you could use in Parse later on
	/// @returns the serialized JSON representation
	@override
	external dynamic serialize();
	
	/// Dispose the texture and release its associated resources.
	@override
	external void dispose();
}

/// This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
/// @see https://doc.babylonjs.com/babylon101/materials#texture
@JS()
class Texture extends BaseTexture {
	
	/// Instantiates a new texture.
	/// This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
	/// @see https://doc.babylonjs.com/babylon101/materials#texture
	/// @param url defines the url of the picture to load as a texture
	/// @param sceneOrEngine defines the scene or engine the texture will belong to
	/// @param noMipmap defines if the texture will require mip maps or not
	/// @param invertY defines if the texture needs to be inverted on the y axis during loading
	/// @param samplingMode defines the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
	/// @param onLoad defines a callback triggered when the texture has been loaded
	/// @param onError defines a callback triggered when an error occurred during the loading session
	/// @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation
	/// @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load
	/// @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
	/// @param mimeType defines an optional mime type information
	/// @param loaderOptions options to be passed to the loader
	external factory Texture(String? url, dynamic? sceneOrEngine, [bool? noMipmap, bool? invertY, num? samplingMode, void Function()? onLoad, void Function([String? message, dynamic? exception])? onError, dynamic? buffer, bool? deleteBuffer, num? format, String? mimeType, dynamic? loaderOptions]);
	
	/// Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process
	external static bool get SerializeBuffers;
	external static set SerializeBuffers(bool value);
	
	/// Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.
	/// If no buffer exists, one will be created as base64 string from the internal webgl data.
	external static bool get ForceSerializeBuffers;
	external static set ForceSerializeBuffers(bool value);
	
	/// nearest is mag = nearest and min = nearest and mip = linear
	external static num get NEAREST_SAMPLINGMODE;
	
	/// nearest is mag = nearest and min = nearest and mip = linear
	external static num get NEAREST_NEAREST_MIPLINEAR;
	
	/// Bilinear is mag = linear and min = linear and mip = nearest
	external static num get BILINEAR_SAMPLINGMODE;
	
	/// Bilinear is mag = linear and min = linear and mip = nearest
	external static num get LINEAR_LINEAR_MIPNEAREST;
	
	/// Trilinear is mag = linear and min = linear and mip = linear
	external static num get TRILINEAR_SAMPLINGMODE;
	
	/// Trilinear is mag = linear and min = linear and mip = linear
	external static num get LINEAR_LINEAR_MIPLINEAR;
	
	/// mag = nearest and min = nearest and mip = nearest
	external static num get NEAREST_NEAREST_MIPNEAREST;
	
	/// mag = nearest and min = linear and mip = nearest
	external static num get NEAREST_LINEAR_MIPNEAREST;
	
	/// mag = nearest and min = linear and mip = linear
	external static num get NEAREST_LINEAR_MIPLINEAR;
	
	/// mag = nearest and min = linear and mip = none
	external static num get NEAREST_LINEAR;
	
	/// mag = nearest and min = nearest and mip = none
	external static num get NEAREST_NEAREST;
	
	/// mag = linear and min = nearest and mip = nearest
	external static num get LINEAR_NEAREST_MIPNEAREST;
	
	/// mag = linear and min = nearest and mip = linear
	external static num get LINEAR_NEAREST_MIPLINEAR;
	
	/// mag = linear and min = linear and mip = none
	external static num get LINEAR_LINEAR;
	
	/// mag = linear and min = nearest and mip = none
	external static num get LINEAR_NEAREST;
	
	/// Explicit coordinates mode
	external static num get EXPLICIT_MODE;
	
	/// Spherical coordinates mode
	external static num get SPHERICAL_MODE;
	
	/// Planar coordinates mode
	external static num get PLANAR_MODE;
	
	/// Cubic coordinates mode
	external static num get CUBIC_MODE;
	
	/// Projection coordinates mode
	external static num get PROJECTION_MODE;
	
	/// Inverse Cubic coordinates mode
	external static num get SKYBOX_MODE;
	
	/// Inverse Cubic coordinates mode
	external static num get INVCUBIC_MODE;
	
	/// Equirectangular coordinates mode
	external static num get EQUIRECTANGULAR_MODE;
	
	/// Equirectangular Fixed coordinates mode
	external static num get FIXED_EQUIRECTANGULAR_MODE;
	
	/// Equirectangular Fixed Mirrored coordinates mode
	external static num get FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
	
	/// Texture is not repeating outside of 0..1 UVs
	external static num get CLAMP_ADDRESSMODE;
	
	/// Texture is repeating outside of 0..1 UVs
	external static num get WRAP_ADDRESSMODE;
	
	/// Texture is repeating and mirrored
	external static num get MIRROR_ADDRESSMODE;
	
	/// Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
	external static bool get UseSerializedUrlIfAny;
	external static set UseSerializedUrlIfAny(bool value);
	
	/// Define the url of the texture.
	external String? get url;
	external set url(String? value);
	
	/// Define an offset on the texture to offset the u coordinates of the UVs
	/// @see https://doc.babylonjs.com/how_to/more_materials#offsetting
	external num get uOffset;
	external set uOffset(num value);
	
	/// Define an offset on the texture to offset the v coordinates of the UVs
	/// @see https://doc.babylonjs.com/how_to/more_materials#offsetting
	external num get vOffset;
	external set vOffset(num value);
	
	/// Define an offset on the texture to scale the u coordinates of the UVs
	/// @see https://doc.babylonjs.com/how_to/more_materials#tiling
	external num get uScale;
	external set uScale(num value);
	
	/// Define an offset on the texture to scale the v coordinates of the UVs
	/// @see https://doc.babylonjs.com/how_to/more_materials#tiling
	external num get vScale;
	external set vScale(num value);
	
	/// Define an offset on the texture to rotate around the u coordinates of the UVs
	/// @see https://doc.babylonjs.com/how_to/more_materials
	external num get uAng;
	external set uAng(num value);
	
	/// Define an offset on the texture to rotate around the v coordinates of the UVs
	/// @see https://doc.babylonjs.com/how_to/more_materials
	external num get vAng;
	external set vAng(num value);
	
	/// Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)
	/// @see https://doc.babylonjs.com/how_to/more_materials
	external num get wAng;
	external set wAng(num value);
	
	/// Defines the center of rotation (U)
	external num get uRotationCenter;
	external set uRotationCenter(num value);
	
	/// Defines the center of rotation (V)
	external num get vRotationCenter;
	external set vRotationCenter(num value);
	
	/// Defines the center of rotation (W)
	external num get wRotationCenter;
	external set wRotationCenter(num value);
	
	/// Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling
	external bool get homogeneousRotationInUVTransform;
	external set homogeneousRotationInUVTransform(bool value);
	
	/// Are mip maps generated for this texture or not.
	@override
	external bool get noMipmap;
	
	/// List of inspectable custom properties (used by the Inspector)
	/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
	external List<IInspectable>? get inspectableCustomProperties;
	external set inspectableCustomProperties(List<IInspectable>? value);
	
	/// Returns the texture mime type if it was defined by a loader (undefined else)
	external String? get mimeType;
	
	/// Observable triggered once the texture has been loaded.
	external Observable<Texture> get onLoadObservable;
	external set onLoadObservable(Observable<Texture> value);
	
	/// Is the texture preventing material to render while loading.
	/// If false, a default texture will be used instead of the loading one during the preparation step.
	external set isBlocking(bool value);
	
	@override
	external bool get isBlocking;
	
	/// Get the current sampling mode associated with the texture.
	external num get samplingMode;
	
	/// Gets a boolean indicating if the texture needs to be inverted on the y axis during loading
	external bool get invertY;
	
	/// Update the url (and optional buffer) of this texture if url was null during construction.
	/// @param url the url of the texture
	/// @param buffer the buffer of the texture (defaults to null)
	/// @param onLoad callback called when the texture is loaded  (defaults to null)
	external void updateURL(String url, [dynamic? buffer, void Function()? onLoad]);
	
	/// Finish the loading sequence of a texture flagged as delayed load.
	/// @hidden
	@override
	external void delayLoad();
	
	/// Checks if the texture has the same transform matrix than another texture
	/// @param texture texture to check against
	/// @returns true if the transforms are the same, else false
	@override
	/* Manual Fix 29 */
	external bool checkTransformsAreIdentical(BaseTexture? texture);
	
	/// Get the current texture matrix which includes the requested offsetting, tiling and rotation components.
	/// @returns the transform matrix of the texture.
	@override
	external Matrix getTextureMatrix([num? uBase]);
	
	/// Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.
	/// @returns The reflection texture transform
	@override
	external Matrix getReflectionTextureMatrix();
	
	/// Clones the texture.
	/// @returns the cloned texture
	@override
	external Texture? clone();
	
	/// Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
	/// @returns The JSON representation of the texture
	@override
	external dynamic serialize();
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "Texture"
	@override
	external String getClassName();
	
	/// Dispose the texture and release its associated resources.
	@override
	external void dispose();
	
	/// Parse the JSON representation of a texture in order to recreate the texture in the given scene.
	/// @param parsedTexture Define the JSON representation of the texture
	/// @param scene Define the scene the parsed texture should be instantiated in
	/// @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
	/// @returns The parsed texture if successful
	external static BaseTexture? Parse(dynamic parsedTexture, Scene scene, String rootUrl);
	
	/// Creates a texture from its base 64 representation.
	/// @param data Define the base64 payload without the data: prefix
	/// @param name Define the name of the texture in the scene useful fo caching purpose for instance
	/// @param scene Define the scene the texture should belong to
	/// @param noMipmap Forces the texture to not create mip map information if true
	/// @param invertY define if the texture needs to be inverted on the y axis during loading
	/// @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
	/// @param onLoad define a callback triggered when the texture has been loaded
	/// @param onError define a callback triggered when an error occurred during the loading session
	/// @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
	/// @returns the created texture
	external static Texture CreateFromBase64String(String data, String name, Scene scene, [bool? noMipmap, bool? invertY, num? samplingMode, void Function()? onLoad, void Function()? onError, num? format]);
	
	/// Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)
	/// @param data Define the base64 payload without the data: prefix
	/// @param name Define the name of the texture in the scene useful fo caching purpose for instance
	/// @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation
	/// @param scene Define the scene the texture should belong to
	/// @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load
	/// @param noMipmap Forces the texture to not create mip map information if true
	/// @param invertY define if the texture needs to be inverted on the y axis during loading
	/// @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
	/// @param onLoad define a callback triggered when the texture has been loaded
	/// @param onError define a callback triggered when an error occurred during the loading session
	/// @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
	/// @returns the created texture
	external static Texture LoadFromDataString(String name, dynamic buffer, Scene scene, [bool? deleteBuffer, bool? noMipmap, bool? invertY, num? samplingMode, void Function()? onLoad, void Function([String? message, dynamic? exception])? onError, num? format]);
}

/// ThinSprite Class used to represent a thin sprite
/// This is the base class for sprites but can also directly be used with ThinEngine
/// @see https://doc.babylonjs.com/babylon101/sprites
@JS()
class ThinSprite {
	
	/// Creates a new Thin Sprite
	external factory ThinSprite();
	
	/// Gets or sets the cell index in the sprite sheet
	external num get cellIndex;
	external set cellIndex(num value);
	
	/// Gets or sets the cell reference in the sprite sheet, uses sprite's filename when added to sprite sheet
	external String get cellRef;
	external set cellRef(String value);
	
	/// Gets or sets the current world position
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// Gets or sets the main color
	external Color4 get color;
	external set color(Color4 value);
	
	/// Gets or sets the width
	external num get width;
	external set width(num value);
	
	/// Gets or sets the height
	external num get height;
	external set height(num value);
	
	/// Gets or sets rotation angle
	external num get angle;
	external set angle(num value);
	
	/// Gets or sets a boolean indicating if UV coordinates should be inverted in U axis
	external bool get invertU;
	external set invertU(bool value);
	
	/// Gets or sets a boolean indicating if UV coordinates should be inverted in B axis
	external bool get invertV;
	external set invertV(bool value);
	
	/// Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true
	external bool get isVisible;
	external set isVisible(bool value);
	
	/// Returns a boolean indicating if the animation is started
	external bool get animationStarted;
	
	/// Gets the initial key for the animation (setting it will restart the animation)
	external num get fromIndex;
	
	/// Gets or sets the end key for the animation (setting it will restart the animation)
	external num get toIndex;
	
	/// Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)
	external bool get loopAnimation;
	
	/// Gets or sets the delay between cell changes (setting it will restart the animation)
	external num get delay;
	
	/// Starts an animation
	/// @param from defines the initial key
	/// @param to defines the end key
	/// @param loop defines if the animation must loop
	/// @param delay defines the start delay (in ms)
	/// @param onAnimationEnd defines a callback for when the animation ends
	external void playAnimation(num from, num to, bool loop, num delay, void Function()? onAnimationEnd);
	
	/// Stops current animation (if any)
	external void stopAnimation();
}

/* var */
/// @hidden
@JS()
external dynamic get imageProcessingCompatibility;

/* var */
/// @hidden
@JS()
external dynamic get spritesPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get spritesVertexShader;

/// Class used to render sprites.
/// 
/// It can be used either to render Sprites or ThinSriptes with ThinEngine only.
@JS()
class SpriteRenderer {
	
	/// Creates a new sprite Renderer
	/// @param engine defines the engine the renderer works with
	/// @param capacity defines the maximum allowed number of sprites
	/// @param epsilon defines the epsilon value to align texture (0.01 by default)
	/// @param scene defines the hosting scene
	external factory SpriteRenderer(ThinEngine engine, num capacity, [num? epsilon, Scene? scene]);
	
	/// Defines the texture of the spritesheet
	external ThinTexture? get texture;
	external set texture(ThinTexture? value);
	
	/// Defines the default width of a cell in the spritesheet
	external num get cellWidth;
	external set cellWidth(num value);
	
	/// Defines the default height of a cell in the spritesheet
	external num get cellHeight;
	external set cellHeight(num value);
	
	/// Blend mode use to render the particle, it can be any of
	/// the static Constants.ALPHA_x properties provided in this class.
	/// Default value is Constants.ALPHA_COMBINE
	external num get blendMode;
	external set blendMode(num value);
	
	/// Gets or sets a boolean indicating if alpha mode is automatically
	/// reset.
	external bool get autoResetAlpha;
	external set autoResetAlpha(bool value);
	
	/// Disables writing to the depth buffer when rendering the sprites.
	/// It can be handy to disable depth writing when using textures without alpha channel
	/// and setting some specific blend modes.
	external bool get disableDepthWrite;
	external set disableDepthWrite(bool value);
	
	/// Gets or sets a boolean indicating if the manager must consider scene fog when rendering
	external bool get fogEnabled;
	external set fogEnabled(bool value);
	
	/// Gets the capacity of the manager
	external num get capacity;
	
	/// Render all child sprites
	/// @param sprites defines the list of sprites to render
	/// @param deltaTime defines the time since last frame
	/// @param viewMatrix defines the viewMatrix to use to render the sprites
	/// @param projectionMatrix defines the projectionMatrix to use to render the sprites
	/// @param customSpriteUpdate defines a custom function to update the sprites data before they render
	external void render(List<ThinSprite> sprites, num deltaTime, Matrix viewMatrix, Matrix projectionMatrix, [void Function(ThinSprite sprite, ISize baseSize)? customSpriteUpdate]);
	
	/// Release associated resources
	external void dispose();
}

/// Defines the minimum interface to fullfil in order to be a sprite manager.
@JS()
abstract class ISpriteManager implements IDisposable {
	
	/// Gets manager's name
	external String get name;
	external set name(String value);
	
	/// Restricts the camera to viewing objects with the same layerMask.
	/// A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0
	external num get layerMask;
	external set layerMask(num value);
	
	/// Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
	external bool get isPickable;
	external set isPickable(bool value);
	
	/// Gets the hosting scene
	external Scene get scene;
	external set scene(Scene value);
	
	/// Specifies the rendering group id for this mesh (0 by default)
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
	external num get renderingGroupId;
	external set renderingGroupId(num value);
	
	/// Defines the list of sprites managed by the manager.
	external List<Sprite> get sprites;
	external set sprites(List<Sprite> value);
	
	/// Gets or sets the spritesheet texture
	external Texture get texture;
	external set texture(Texture value);
	
	/// Defines the default width of a cell in the spritesheet
	external num get cellWidth;
	external set cellWidth(num value);
	
	/// Defines the default height of a cell in the spritesheet
	external num get cellHeight;
	external set cellHeight(num value);
	
	/// Tests the intersection of a sprite with a specific ray.
	/// @param ray The ray we are sending to test the collision
	/// @param camera The camera space we are sending rays in
	/// @param predicate A predicate allowing excluding sprites from the list of object to test
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @returns picking info or null.
	external PickingInfo? intersects(Ray ray, Camera camera, [bool Function(Sprite sprite)? predicate, bool? fastCheck]);
	
	/// Intersects the sprites with a ray
	/// @param ray defines the ray to intersect with
	/// @param camera defines the current active camera
	/// @param predicate defines a predicate used to select candidate sprites
	/// @returns null if no hit or a PickingInfo array
	external List<PickingInfo>? multiIntersects(Ray ray, Camera camera, [bool Function(Sprite sprite)? predicate]);
	
	/// Renders the list of sprites on screen.
	external void render();
}

/// Class used to manage multiple sprites on the same spritesheet
/// @see https://doc.babylonjs.com/babylon101/sprites
@JS()
class SpriteManager implements ISpriteManager {
	
	/// Creates a new sprite manager
	/// @param name defines the manager's name
	/// @param imgUrl defines the sprite sheet url
	/// @param capacity defines the maximum allowed number of sprites
	/// @param cellSize defines the size of a sprite cell
	/// @param scene defines the hosting scene
	/// @param epsilon defines the epsilon value to align texture (0.01 by default)
	/// @param samplingMode defines the smapling mode to use with spritesheet
	/// @param fromPacked set to false; do not alter
	/// @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter
	external factory SpriteManager(String name, String imgUrl, num capacity, dynamic cellSize, Scene scene, [num? epsilon, num? samplingMode, bool? fromPacked, dynamic? spriteJSON]);
	
	/// defines the manager's name
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Define the Url to load snippets
	external static String get SnippetUrl;
	external static set SnippetUrl(String value);
	
	/// Snippet ID if the manager was created from the snippet server
	external String get snippetId;
	external set snippetId(String value);
	
	/// Gets the list of sprites
	@override
	external List<Sprite> get sprites;
	@override
	external set sprites(List<Sprite> value);
	
	/// Gets or sets the rendering group id (0 by default)
	@override
	external num get renderingGroupId;
	@override
	external set renderingGroupId(num value);
	
	/// Gets or sets camera layer mask
	@override
	external num get layerMask;
	@override
	external set layerMask(num value);
	
	/// Gets or sets a boolean indicating if the sprites are pickable
	@override
	external bool get isPickable;
	@override
	external set isPickable(bool value);
	
	/// An event triggered when the manager is disposed.
	external Observable<SpriteManager> get onDisposeObservable;
	external set onDisposeObservable(Observable<SpriteManager> value);
	
	/// Callback called when the manager is disposed
	external set onDispose(void Function() value);
	
	/// Gets or sets the unique id of the sprite
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Gets the array of sprites
	external List<Sprite> get children;
	
	/// Gets the capacity of the manager
	external num get capacity;
	
	/// Gets or sets a boolean indicating if the manager must consider scene fog when rendering
	external bool get fogEnabled;
	
	external set fogEnabled(bool value);
	
	/// Blend mode use to render the particle, it can be any of
	/// the static Constants.ALPHA_x properties provided in this class.
	/// Default value is Constants.ALPHA_COMBINE
	external num get blendMode;
	
	external set blendMode(num value);
	
	/// Disables writing to the depth buffer when rendering the sprites.
	/// It can be handy to disable depth writing when using textures without alpha channel
	/// and setting some specific blend modes.
	external bool get disableDepthWrite;
	external set disableDepthWrite(bool value);
	
	/// Returns the string "SpriteManager"
	/// @returns "SpriteManager"
	external String getClassName();
	
	/// Intersects the sprites with a ray
	/// @param ray defines the ray to intersect with
	/// @param camera defines the current active camera
	/// @param predicate defines a predicate used to select candidate sprites
	/// @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)
	/// @returns null if no hit or a PickingInfo
	@override
	external PickingInfo? intersects(Ray ray, Camera camera, [bool Function(Sprite sprite)? predicate, bool? fastCheck]);
	
	/// Intersects the sprites with a ray
	/// @param ray defines the ray to intersect with
	/// @param camera defines the current active camera
	/// @param predicate defines a predicate used to select candidate sprites
	/// @returns null if no hit or a PickingInfo array
	@override
	external List<PickingInfo>? multiIntersects(Ray ray, Camera camera, [bool Function(Sprite sprite)? predicate]);
	
	/// Render all child sprites
	@override
	external void render();
	
	/// Release associated resources
	@override
	external void dispose();
	
	/// Serializes the sprite manager to a JSON object
	/// @param serializeTexture defines if the texture must be serialized as well
	/// @returns the JSON object
	external dynamic serialize([bool? serializeTexture]);
	
	/// Parses a JSON object to create a new sprite manager.
	/// @param parsedManager The JSON object to parse
	/// @param scene The scene to create the sprite managerin
	/// @param rootUrl The root url to use to load external dependencies like texture
	/// @returns the new sprite manager
	external static SpriteManager Parse(dynamic parsedManager, Scene scene, String rootUrl);
	
	/// Creates a sprite manager from a snippet saved in a remote file
	/// @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)
	/// @param url defines the url to load from
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a promise that will resolve to the new sprite manager
	external static Promise<SpriteManager> ParseFromFileAsync(String? name, String url, Scene scene, [String? rootUrl]);
	
	/// Creates a sprite manager from a snippet saved by the sprite editor
	/// @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a promise that will resolve to the new sprite manager
	external static Promise<SpriteManager> CreateFromSnippetAsync(String snippetId, Scene scene, [String? rootUrl]);
	
	/// Gets the hosting scene
	external Scene get scene;
	external set scene(Scene value);
	
	/// Gets or sets the spritesheet texture
	external Texture get texture;
	external set texture(Texture value);
	
	/// Defines the default width of a cell in the spritesheet
	external num get cellWidth;
	external set cellWidth(num value);
	
	/// Defines the default height of a cell in the spritesheet
	external num get cellHeight;
	external set cellHeight(num value);
}

/// Class used to represent a sprite
/// @see https://doc.babylonjs.com/babylon101/sprites
@JS()
class Sprite extends ThinSprite implements IAnimatable {
	
	/// Creates a new Sprite
	/// @param name defines the name
	/// @param manager defines the manager
	external factory Sprite(String name, ISpriteManager manager);
	
	/// defines the name
	external String get name;
	external set name(String value);
	
	/// Gets or sets the current world position
	@override
	external Vector3 get position;
	@override
	external set position(Vector3 value);
	
	/// Gets or sets the main color
	@override
	external Color4 get color;
	@override
	external set color(Color4 value);
	
	/// Gets or sets a boolean indicating that this sprite should be disposed after animation ends
	external bool get disposeWhenFinishedAnimating;
	external set disposeWhenFinishedAnimating(bool value);
	
	/// Gets the list of attached animations
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// Gets or sets a boolean indicating if the sprite can be picked
	external bool get isPickable;
	external set isPickable(bool value);
	
	/// Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default)
	external bool get useAlphaForPicking;
	external set useAlphaForPicking(bool value);
	
	/// Gets or sets the associated action manager
	external ActionManager? get actionManager;
	external set actionManager(ActionManager? value);
	
	/// An event triggered when the control has been disposed
	external Observable<Sprite> get onDisposeObservable;
	external set onDisposeObservable(Observable<Sprite> value);
	
	/// Gets or sets the sprite size
	external num get size;
	
	external set size(num value);
	
	/// Gets or sets the unique id of the sprite
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Gets the manager of this sprite
	external ISpriteManager get manager;
	
	/// Returns the string "Sprite"
	/// @returns "Sprite"
	external String getClassName();
	
	/// Gets or sets the initial key for the animation (setting it will restart the animation)
	@override
	external num get fromIndex;
	
	external set fromIndex(num value);
	
	/// Gets or sets the end key for the animation (setting it will restart the animation)
	@override
	external num get toIndex;
	
	external set toIndex(num value);
	
	/// Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)
	@override
	external bool get loopAnimation;
	
	external set loopAnimation(bool value);
	
	/// Gets or sets the delay between cell changes (setting it will restart the animation)
	@override
	external num get delay;
	
	external set delay(num value);
	
	/// Starts an animation
	/// @param from defines the initial key
	/// @param to defines the end key
	/// @param loop defines if the animation must loop
	/// @param delay defines the start delay (in ms)
	/// @param onAnimationEnd defines a callback to call when animation ends
	@override
	external void playAnimation(num from, num to, bool loop, num delay, [void Function()? onAnimationEnd]);
	
	/// Release associated resources
	external void dispose();
	
	/// Serializes the sprite to a JSON object
	/// @returns the JSON object
	external dynamic serialize();
	
	/// Parses a JSON object to create a new sprite
	/// @param parsedSprite The JSON object to parse
	/// @param manager defines the hosting manager
	/// @returns the new sprite
	external static Sprite Parse(dynamic parsedSprite, SpriteManager manager);
}

/// Information about the result of picking within a scene
/// @see https://doc.babylonjs.com/babylon101/picking_collisions
@JS()
class PickingInfo {
	external factory PickingInfo();
	
	/// If the pick collided with an object
	external bool get hit;
	external set hit(bool value);
	
	/// Distance away where the pick collided
	external num get distance;
	external set distance(num value);
	
	/// The location of pick collision
	external Vector3? get pickedPoint;
	external set pickedPoint(Vector3? value);
	
	/// The mesh corresponding the the pick collision
	external AbstractMesh? get pickedMesh;
	external set pickedMesh(AbstractMesh? value);
	
	/// (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.
	external num get bu;
	external set bu(num value);
	
	/// (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.
	external num get bv;
	external set bv(num value);
	
	/// The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh
	external num get faceId;
	external set faceId(num value);
	
	/// The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh
	external num get subMeshFaceId;
	external set subMeshFaceId(num value);
	
	/// Id of the the submesh that was picked
	external num get subMeshId;
	external set subMeshId(num value);
	
	/// If a sprite was picked, this will be the sprite the pick collided with
	external Sprite? get pickedSprite;
	external set pickedSprite(Sprite? value);
	
	/// If we are pikcing a mesh with thin instance, this will give you the picked thin instance
	external num get thinInstanceIndex;
	external set thinInstanceIndex(num value);
	
	/// If a mesh was used to do the picking (eg. 6dof controller) this will be populated.
	external AbstractMesh? get originMesh;
	external set originMesh(AbstractMesh? value);
	
	/// The ray that was used to perform the picking.
	external Ray? get ray;
	external set ray(Ray? value);
	
	/// Gets the normal correspodning to the face the pick collided with
	/// @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)
	/// @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map
	/// @returns The normal correspodning to the face the pick collided with
	external Vector3? getNormal([bool? useWorldCoordinates, bool? useVerticesNormals]);
	
	/// Gets the texture coordinates of where the pick occured
	/// @returns the vector containing the coordnates of the texture
	external Vector2? getTextureCoordinates();
}

/// Gather the list of pointer event types as constants.
@JS()
class PointerEventTypes {
	external factory PointerEventTypes();
	
	/// The pointerdown event is fired when a pointer becomes active. For mouse, it is fired when the device transitions from no buttons depressed to at least one button depressed. For touch, it is fired when physical contact is made with the digitizer. For pen, it is fired when the stylus makes physical contact with the digitizer.
	external static num get POINTERDOWN;
	
	/// The pointerup event is fired when a pointer is no longer active.
	external static num get POINTERUP;
	
	/// The pointermove event is fired when a pointer changes coordinates.
	external static num get POINTERMOVE;
	
	/// The pointerwheel event is fired when a mouse wheel has been rotated.
	external static num get POINTERWHEEL;
	
	/// The pointerpick event is fired when a mesh or sprite has been picked by the pointer.
	external static num get POINTERPICK;
	
	/// The pointertap event is fired when a the object has been touched and released without drag.
	external static num get POINTERTAP;
	
	/// The pointerdoubletap event is fired when a the object has been touched and released twice without drag.
	external static num get POINTERDOUBLETAP;
}

/// Base class of pointer info types.
@JS()
class PointerInfoBase {
	
	/// Instantiates the base class of pointers info.
	/// @param type Defines the type of event (PointerEventTypes)
	/// @param event Defines the related dom event
	external factory PointerInfoBase(num type, dynamic event);
	
	/// Defines the type of event (PointerEventTypes)
	external num get type;
	external set type(num value);
	
	/// Defines the related dom event
	external dynamic get event;
	external set event(dynamic value);
}

/// This class is used to store pointer related info for the onPrePointerObservable event.
/// Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
@JS()
class PointerInfoPre extends PointerInfoBase {
	
	/// Instantiates a PointerInfoPre to store pointer related info to the onPrePointerObservable event.
	/// @param type Defines the type of event (PointerEventTypes)
	/// @param event Defines the related dom event
	/// @param localX Defines the local x coordinates of the pointer when the event occured
	/// @param localY Defines the local y coordinates of the pointer when the event occured
	external factory PointerInfoPre(num type, dynamic event, num localX, num localY);
	
	/// Ray from a pointer if availible (eg. 6dof controller)
	external Ray? get ray;
	external set ray(Ray? value);
	
	/// Defines the local position of the pointer on the canvas.
	external Vector2 get localPosition;
	external set localPosition(Vector2 value);
	
	/// Defines whether the engine should skip the next OnPointerObservable associated to this pre.
	external bool get skipOnPointerObservable;
	external set skipOnPointerObservable(bool value);
}

/// This type contains all the data related to a pointer event in Babylon.js.
/// The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
@JS()
class PointerInfo extends PointerInfoBase {
	
	/// Instantiates a PointerInfo to store pointer related info to the onPointerObservable event.
	/// @param type Defines the type of event (PointerEventTypes)
	/// @param event Defines the related dom event
	/// @param pickInfo Defines the picking info associated to the info (if any)\
	external factory PointerInfo(num type, dynamic event, PickingInfo? pickInfo);
	
	/// Defines the picking info associated to the info (if any)\
	external PickingInfo? get pickInfo;
	external set pickInfo(PickingInfo? value);
}

/// Data relating to a touch event on the screen.
@JS()
@anonymous
class PointerTouch {
	
	external factory PointerTouch({num x, num y, num pointerId, dynamic type});
	
	/// X coordinate of touch.
	external num get x;
	external set x( num value );
	
	/// Y coordinate of touch.
	external num get y;
	external set y( num value );
	
	/// Id of touch. Unique for each finger.
	external num get pointerId;
	external set pointerId( num value );
	
	/// Event type passed from DOM.
	external dynamic get type;
	external set type( dynamic value );
}

/// Manage the mouse inputs to control the movement of a free camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraMouseInput implements ICameraInput<FreeCamera> {
	
	/// Manage the mouse inputs to control the movement of a free camera.
	/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
	/// @param touchEnabled Defines if touch is enabled or not
	external factory FreeCameraMouseInput([bool? touchEnabled]);
	
	/// Define if touch is enabled in the mouse input
	external bool get touchEnabled;
	external set touchEnabled(bool value);
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 16 */
	@override
	external FreeCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines the buttons associated with the input to handle camera move.
	external List<num> get buttons;
	external set buttons(List<num> value);
	
	/// Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.
	external num get angularSensibility;
	external set angularSensibility(num value);
	
	/// Observable for when a pointer move event occurs containing the move offset
	external Observable<FreeCameraMouseInputOnPointerMovedObservable> get onPointerMovedObservable;
	external set onPointerMovedObservable(Observable<FreeCameraMouseInputOnPointerMovedObservable> value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Called on JS contextmenu event.
	/// Override this method to provide functionality.
	external void onContextMenu(HTML.PointerEvent evt);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Base class for mouse wheel input..
/// See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts
/// for example usage.
@JS()
abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {
	external factory BaseCameraMouseWheelInput();
	
	/// Defines the camera the input is attached to.
	@override
	external Camera? get camera;
	@override
	external set camera(Camera? value);
	
	/// How fast is the camera moves in relation to X axis mouseWheel events.
	/// Use negative value to reverse direction.
	external num get wheelPrecisionX;
	external set wheelPrecisionX(num value);
	
	/// How fast is the camera moves in relation to Y axis mouseWheel events.
	/// Use negative value to reverse direction.
	external num get wheelPrecisionY;
	external set wheelPrecisionY(num value);
	
	/// How fast is the camera moves in relation to Z axis mouseWheel events.
	/// Use negative value to reverse direction.
	external num get wheelPrecisionZ;
	external set wheelPrecisionZ(num value);
	
	/// Observable for when a mouse wheel move event occurs.
	external Observable<BaseCameraMouseWheelInputOnChangedObservable> get onChangedObservable;
	external set onChangedObservable(Observable<BaseCameraMouseWheelInputOnChangedObservable> value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls
	/// should call preventdefault().
	/// (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Manage the mouse wheel inputs to control a free camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {
	external factory FreeCameraMouseWheelInput();
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 16 */
	@override
	external FreeCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Gets the class name of the current input.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Set which movement axis (relative to camera's orientation) the mouse
	/// wheel's X axis controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelXMoveRelative(int? value);
	
	/// Get the configured movement axis (relative to camera's orientation) the
	/// mouse wheel's X axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelXMoveRelative;
	
	/// Set which movement axis (relative to camera's orientation) the mouse
	/// wheel's Y axis controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelYMoveRelative(int? value);
	
	/// Get the configured movement axis (relative to camera's orientation) the
	/// mouse wheel's Y axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelYMoveRelative;
	
	/// Set which movement axis (relative to camera's orientation) the mouse
	/// wheel's Z axis controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelZMoveRelative(int? value);
	
	/// Get the configured movement axis (relative to camera's orientation) the
	/// mouse wheel's Z axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelZMoveRelative;
	
	/// Set which rotation axis (relative to camera's orientation) the mouse
	/// wheel's X axis controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelXRotateRelative(int? value);
	
	/// Get the configured rotation axis (relative to camera's orientation) the
	/// mouse wheel's X axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelXRotateRelative;
	
	/// Set which rotation axis (relative to camera's orientation) the mouse
	/// wheel's Y axis controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelYRotateRelative(int? value);
	
	/// Get the configured rotation axis (relative to camera's orientation) the
	/// mouse wheel's Y axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelYRotateRelative;
	
	/// Set which rotation axis (relative to camera's orientation) the mouse
	/// wheel's Z axis controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelZRotateRelative(int? value);
	
	/// Get the configured rotation axis (relative to camera's orientation) the
	/// mouse wheel's Z axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelZRotateRelative;
	
	/// Set which movement axis (relative to the scene) the mouse wheel's X axis
	/// controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelXMoveScene(int? value);
	
	/// Get the configured movement axis (relative to the scene) the mouse wheel's
	/// X axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelXMoveScene;
	
	/// Set which movement axis (relative to the scene) the mouse wheel's Y axis
	/// controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelYMoveScene(int? value);
	
	/// Get the configured movement axis (relative to the scene) the mouse wheel's
	/// Y axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelYMoveScene;
	
	/// Set which movement axis (relative to the scene) the mouse wheel's Z axis
	/// controls.
	/// @param axis The axis to be moved. Set null to clear.
	external set wheelZMoveScene(int? value);
	
	/// Get the configured movement axis (relative to the scene) the mouse wheel's
	/// Z axis controls.
	/// @returns The configured axis or null if none.
	external int? get wheelZMoveScene;
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Manage the touch inputs to control the movement of a free camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraTouchInput implements ICameraInput<FreeCamera> {
	
	/// Manage the touch inputs to control the movement of a free camera.
	/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
	/// @param allowMouse Defines if mouse events can be treated as touch events
	external factory FreeCameraTouchInput([bool? allowMouse]);
	
	/// Define if mouse events can be treated as touch events
	external bool get allowMouse;
	external set allowMouse(bool value);
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 16 */
	@override
	external FreeCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines the touch sensibility for rotation.
	/// The higher the faster.
	external num get touchAngularSensibility;
	external set touchAngularSensibility(num value);
	
	/// Defines the touch sensibility for move.
	/// The higher the faster.
	external num get touchMoveSensibility;
	external set touchMoveSensibility(num value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Default Inputs manager for the FreeCamera.
/// It groups all the default supported inputs for ease of use.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {
	
	/// Instantiates a new FreeCameraInputsManager.
	/// @param camera Defines the camera the inputs belong to
	external factory FreeCameraInputsManager(FreeCamera camera);
	
	/// Add keyboard input support to the input manager.
	/// @returns the current input manager
	external FreeCameraInputsManager addKeyboard();
	
	/// Add mouse input support to the input manager.
	/// @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)
	/// @returns the current input manager
	external FreeCameraInputsManager addMouse([bool? touchEnabled]);
	
	/// Removes the mouse input support from the manager
	/// @returns the current input manager
	external FreeCameraInputsManager removeMouse();
	
	/// Add mouse wheel input support to the input manager.
	/// @returns the current input manager
	external FreeCameraInputsManager addMouseWheel();
	
	/// Removes the mouse wheel input support from the manager
	/// @returns the current input manager
	external FreeCameraInputsManager removeMouseWheel();
	
	/// Add touch input support to the input manager.
	/// @returns the current input manager
	external FreeCameraInputsManager addTouch();
	
	/// Remove all attached input methods from a camera
	@override
	external void clear();
	
	/// Add orientation input support to the input manager.
	/// @returns the current input manager
	external FreeCameraInputsManager addDeviceOrientation();
	
	/// Add virtual joystick input support to the input manager.
	/// @returns the current input manager
	external FreeCameraInputsManager addVirtualJoystick();
	
	/// Adds gamepad input support to the FreeCameraInputsManager.
	/// @returns the FreeCameraInputsManager
	external FreeCameraInputsManager addGamepad();
}

/// This represents a free type of camera. It can be useful in First Person Shooter game for instance.
/// Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.
/// @see https://doc.babylonjs.com/features/cameras#universal-camera
@JS()
class FreeCamera extends TargetCamera {
	
	/// Instantiates a Free Camera.
	/// This represents a free type of camera. It can be useful in First Person Shooter game for instance.
	/// Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.
	/// @see https://doc.babylonjs.com/features/cameras#universal-camera
	/// @param name Define the name of the camera in the scene
	/// @param position Define the start position of the camera in the scene
	/// @param scene Define the scene the camera belongs to
	/// @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
	external factory FreeCamera(String name, Vector3 position, Scene scene, [bool? setActiveOnSceneIfNoneActive]);
	
	/// Define the collision ellipsoid of the camera.
	/// This is helpful to simulate a camera body like the player body around the camera
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
	external Vector3 get ellipsoid;
	external set ellipsoid(Vector3 value);
	
	/// Define an offset for the position of the ellipsoid around the camera.
	/// This can be helpful to determine the center of the body near the gravity center of the body
	/// instead of its head.
	external Vector3 get ellipsoidOffset;
	external set ellipsoidOffset(Vector3 value);
	
	/// Enable or disable collisions of the camera with the rest of the scene objects.
	external bool get checkCollisions;
	external set checkCollisions(bool value);
	
	/// Enable or disable gravity on the camera.
	external bool get applyGravity;
	external set applyGravity(bool value);
	
	/* Manual Fix 8 */
	
	/// Define the input manager associated to the camera.
	@override
	external FreeCameraInputsManager get inputs;
	@override
	external set inputs(CameraInputsManager<Camera> value);
	
	/// Gets the input sensibility for a mouse input. (default is 2000.0)
	/// Higher values reduce sensitivity.
	external num get angularSensibility;
	
	/// Sets the input sensibility for a mouse input. (default is 2000.0)
	/// Higher values reduce sensitivity.
	external set angularSensibility(num value);
	
	/// Gets or Set the list of keyboard keys used to control the forward move of the camera.
	external List<num> get keysUp;
	
	external set keysUp(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the upward move of the camera.
	external List<num> get keysUpward;
	
	external set keysUpward(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the backward move of the camera.
	external List<num> get keysDown;
	
	external set keysDown(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the downward move of the camera.
	external List<num> get keysDownward;
	
	external set keysDownward(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
	external List<num> get keysLeft;
	
	external set keysLeft(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
	external List<num> get keysRight;
	
	external set keysRight(List<num> value);
	
	/// Event raised when the camera collide with a mesh in the scene.
	external void Function(AbstractMesh collidedMesh) get onCollide;
	external set onCollide(void Function(AbstractMesh collidedMesh) value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Define a collision mask to limit the list of object the camera can collide with
	external num get collisionMask;
	
	external set collisionMask(num value);
	
	/// Destroy the camera and release the current resources hold by it.
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/// Represents a gamepad control stick position
@JS()
class StickValues {
	
	/// Initializes the gamepad x and y control stick values
	/// @param x The x component of the gamepad control stick value
	/// @param y The y component of the gamepad control stick value
	external factory StickValues(num x, num y);
	
	/// The x component of the control stick
	external num get x;
	external set x(num value);
	
	/// The y component of the control stick
	external num get y;
	external set y(num value);
}

/// An interface which manages callbacks for gamepad button changes
@JS()
@anonymous
class GamepadButtonChanges {
	
	external factory GamepadButtonChanges({bool changed, bool pressChanged, bool touchChanged, bool valueChanged});
	
	/// Called when a gamepad has been changed
	external bool get changed;
	external set changed( bool value );
	
	/// Called when a gamepad press event has been triggered
	external bool get pressChanged;
	external set pressChanged( bool value );
	
	/// Called when a touch event has been triggered
	external bool get touchChanged;
	external set touchChanged( bool value );
	
	/// Called when a value has changed
	external bool get valueChanged;
	external set valueChanged( bool value );
}

/// Represents a gamepad
@JS()
class Gamepad {
	
	/// Initializes the gamepad
	/// @param id The id of the gamepad
	/// @param index The index of the gamepad
	/// @param browserGamepad The browser gamepad
	/// @param leftStickX The x component of the left joystick
	/// @param leftStickY The y component of the left joystick
	/// @param rightStickX The x component of the right joystick
	/// @param rightStickY The y component of the right joystick
	external factory Gamepad(String id, num index, dynamic browserGamepad, [num? leftStickX, num? leftStickY, num? rightStickX, num? rightStickY]);
	
	/// The id of the gamepad
	external String get id;
	external set id(String value);
	
	/// The index of the gamepad
	external num get index;
	external set index(num value);
	
	/// The browser gamepad
	external dynamic get browserGamepad;
	external set browserGamepad(dynamic value);
	
	/// Specifies what type of gamepad this represents
	external num get type;
	external set type(num value);
	
	/// Represents a gamepad controller
	external static num get GAMEPAD;
	external static set GAMEPAD(num value);
	
	/// Represents a generic controller
	external static num get GENERIC;
	external static set GENERIC(num value);
	
	/// Represents an XBox controller
	external static num get XBOX;
	external static set XBOX(num value);
	
	/// Represents a pose-enabled controller
	external static num get POSE_ENABLED;
	external static set POSE_ENABLED(num value);
	
	/// Represents an Dual Shock controller
	external static num get DUALSHOCK;
	external static set DUALSHOCK(num value);
	
	/// Specifies if the gamepad has been connected
	external bool get isConnected;
	
	/// Callback triggered when the left joystick has changed
	/// @param callback
	external void onleftstickchanged(void Function(StickValues values) callback);
	
	/// Callback triggered when the right joystick has changed
	/// @param callback
	external void onrightstickchanged(void Function(StickValues values) callback);
	
	/// Gets the left joystick
	external StickValues get leftStick;
	
	/// Sets the left joystick values
	external set leftStick(StickValues value);
	
	/// Gets the right joystick
	external StickValues get rightStick;
	
	/// Sets the right joystick value
	external set rightStick(StickValues value);
	
	/// Updates the gamepad joystick positions
	external void update();
	
	/// Disposes the gamepad
	external void dispose();
}

/// Represents a generic gamepad
@JS()
class GenericPad extends Gamepad {
	
	/// Initializes the generic gamepad
	/// @param id The id of the generic gamepad
	/// @param index The index of the generic gamepad
	/// @param browserGamepad The browser gamepad
	external factory GenericPad(String id, num index, dynamic browserGamepad);
	
	/// Observable triggered when a button has been pressed
	external Observable<num> get onButtonDownObservable;
	external set onButtonDownObservable(Observable<num> value);
	
	/// Observable triggered when a button has been released
	external Observable<num> get onButtonUpObservable;
	external set onButtonUpObservable(Observable<num> value);
	
	/// Callback triggered when a button has been pressed
	/// @param callback Called when a button has been pressed
	external void onbuttondown(void Function(num buttonPressed) callback);
	
	/// Callback triggered when a button has been released
	/// @param callback Called when a button has been released
	external void onbuttonup(void Function(num buttonReleased) callback);
	
	/// Updates the generic gamepad
	@override
	external void update();
	
	/// Disposes the generic gamepad
	@override
	external void dispose();
}

/// Defines a runtime animation
@JS()
class RuntimeAnimation {
	
	/// Create a new RuntimeAnimation object
	/// @param target defines the target of the animation
	/// @param animation defines the source animation object
	/// @param scene defines the hosting scene
	/// @param host defines the initiating Animatable
	external factory RuntimeAnimation(dynamic target, Animation animation, Scene scene, Animatable host);
	
	/// Gets the current frame of the runtime animation
	external num get currentFrame;
	
	/// Gets the weight of the runtime animation
	external num get weight;
	
	/// Gets the current value of the runtime animation
	external dynamic get currentValue;
	
	/// Gets the target path of the runtime animation
	external String get targetPath;
	
	/// Gets the actual target of the runtime animation
	external dynamic get target;
	
	/// Gets the additive state of the runtime animation
	external bool get isAdditive;
	
	/// Gets the animation from the runtime animation
	external Animation get animation;
	
	/// Resets the runtime animation to the beginning
	/// @param restoreOriginal defines whether to restore the target property to the original value
	external void reset([bool? restoreOriginal]);
	
	/// Specifies if the runtime animation is stopped
	/// @returns Boolean specifying if the runtime animation is stopped
	external bool isStopped();
	
	/// Disposes of the runtime animation
	external void dispose();
	
	/// Apply the interpolated value to the target
	/// @param currentValue defines the value computed by the animation
	/// @param weight defines the weight to apply to this value (Defaults to 1.0)
	external void setValue(dynamic currentValue, num weight);
	
	/// Move the current animation to a given frame
	/// @param frame defines the frame to move to
	external void goToFrame(num frame);
	
	/// Execute the current animation
	/// @param delay defines the delay to add to the current frame
	/// @param from defines the lower bound of the animation range
	/// @param to defines the upper bound of the animation range
	/// @param loop defines if the current animation must loop
	/// @param speedRatio defines the current speed ratio
	/// @param weight defines the weight of the animation (default is -1 so no weight)
	/// @param onLoop optional callback called when animation loops
	/// @returns a boolean indicating if the animation is running
	external bool animate(num delay, num from, num to, bool loop, num speedRatio, [num? weight]);
}

/// Class used to store an actual running animation
@JS()
class Animatable {
	
	/// Creates a new Animatable
	/// @param scene defines the hosting scene
	/// @param target defines the target object
	/// @param fromFrame defines the starting frame number (default is 0)
	/// @param toFrame defines the ending frame number (default is 100)
	/// @param loopAnimation defines if the animation must loop (default is false)
	/// @param speedRatio defines the factor to apply to animation speed (default is 1)
	/// @param onAnimationEnd defines a callback to call when animation ends if it is not looping
	/// @param animations defines a group of animation to add to the new Animatable
	/// @param onAnimationLoop defines a callback to call when animation loops
	/// @param isAdditive defines whether the animation should be evaluated additively
	external factory Animatable(Scene scene, dynamic target, [num? fromFrame, num? toFrame, bool? loopAnimation, num? speedRatio, void Function()? onAnimationEnd, List<Animation>? animations, void Function()? onAnimationLoop, bool? isAdditive]);
	
	/// defines the target object
	external dynamic get target;
	external set target(dynamic value);
	
	/// defines the starting frame number (default is 0)
	external num get fromFrame;
	external set fromFrame(num value);
	
	/// defines the ending frame number (default is 100)
	external num get toFrame;
	external set toFrame(num value);
	
	/// defines if the animation must loop (default is false)
	external bool get loopAnimation;
	external set loopAnimation(bool value);
	
	/// defines a callback to call when animation ends if it is not looping
	external void Function()? get onAnimationEnd;
	external set onAnimationEnd(void Function()? value);
	
	/// defines a callback to call when animation loops
	external void Function()? get onAnimationLoop;
	external set onAnimationLoop(void Function()? value);
	
	/// defines whether the animation should be evaluated additively
	external bool get isAdditive;
	external set isAdditive(bool value);
	
	/// Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.
	/// This will only apply for non looping animation (default is true)
	external bool get disposeOnEnd;
	external set disposeOnEnd(bool value);
	
	/// Gets a boolean indicating if the animation has started
	external bool get animationStarted;
	external set animationStarted(bool value);
	
	/// Observer raised when the animation ends
	external Observable<Animatable> get onAnimationEndObservable;
	external set onAnimationEndObservable(Observable<Animatable> value);
	
	/// Observer raised when the animation loops
	external Observable<Animatable> get onAnimationLoopObservable;
	external set onAnimationLoopObservable(Observable<Animatable> value);
	
	/// Gets the root Animatable used to synchronize and normalize animations
	external Animatable? get syncRoot;
	
	/// Gets the current frame of the first RuntimeAnimation
	/// Used to synchronize Animatables
	external num get masterFrame;
	
	/// Gets or sets the animatable weight (-1.0 by default meaning not weighted)
	external num get weight;
	
	external set weight(num value);
	
	/// Gets or sets the speed ratio to apply to the animatable (1.0 by default)
	external num get speedRatio;
	
	external set speedRatio(num value);
	
	/// Synchronize and normalize current Animatable with a source Animatable
	/// This is useful when using animation weights and when animations are not of the same length
	/// @param root defines the root Animatable to synchronize with
	/// @returns the current Animatable
	external Animatable syncWith(Animatable root);
	
	/// Gets the list of runtime animations
	/// @returns an array of RuntimeAnimation
	external List<RuntimeAnimation> getAnimations();
	
	/// Adds more animations to the current animatable
	/// @param target defines the target of the animations
	/// @param animations defines the new animations to add
	external void appendAnimations(dynamic target, List<Animation> animations);
	
	/// Gets the source animation for a specific property
	/// @param property defines the propertyu to look for
	/// @returns null or the source animation for the given property
	external Animation? getAnimationByTargetProperty(String property);
	
	/// Gets the runtime animation for a specific property
	/// @param property defines the propertyu to look for
	/// @returns null or the runtime animation for the given property
	external RuntimeAnimation? getRuntimeAnimationByTargetProperty(String property);
	
	/// Resets the animatable to its original state
	external void reset();
	
	/// Allows the animatable to blend with current running animations
	/// @see https://doc.babylonjs.com/babylon101/animations#animation-blending
	/// @param blendingSpeed defines the blending speed to use
	external void enableBlending(num blendingSpeed);
	
	/// Disable animation blending
	/// @see https://doc.babylonjs.com/babylon101/animations#animation-blending
	external void disableBlending();
	
	/// Jump directly to a given frame
	/// @param frame defines the frame to jump to
	external void goToFrame(num frame);
	
	/// Pause the animation
	external void pause();
	
	/// Restart the animation
	external void restart();
	
	/// Stop and delete the current animation
	/// @param animationName defines a string used to only stop some of the runtime animations instead of all
	/// @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)
	external void stop([String? animationName, bool Function(dynamic target)? targetMask]);
	
	/// Wait asynchronously for the animation to end
	/// @returns a promise which will be fullfilled when the animation ends
	external Promise<Animatable> waitAsync();
}

/// Class used to store bone information
/// @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
@JS()
class Bone extends Node {
	
	/// Create a new bone
	/// @param name defines the bone name
	/// @param skeleton defines the parent skeleton
	/// @param parentBone defines the parent (can be null if the bone is the root)
	/// @param localMatrix defines the local matrix
	/// @param restPose defines the rest pose matrix
	/// @param baseMatrix defines the base matrix
	/// @param index defines index of the bone in the hiearchy
	external factory Bone(String name, Skeleton skeleton, [Bone? parentBone, Matrix? localMatrix, Matrix? restPose, Matrix? baseMatrix, num? index]);
	
	/// defines the bone name
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Gets the list of child bones
	external List<Bone> get children;
	external set children(List<Bone> value);
	
	/// Gets the animations associated with this bone
	@override
	external List<Animation> get animations;
	@override
	external set animations(List<Animation> value);
	
	/// Gets or sets bone length
	external num get length;
	external set length(num value);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
	
	/// Gets the parent skeleton
	/// @returns a skeleton
	external Skeleton getSkeleton();
	
	/// Gets parent bone
	/// @returns a bone or null if the bone is the root of the bone hierarchy
	external Bone? getParent();
	
	/// Returns an array containing the root bones
	/// @returns an array containing the root bones
	@override
	external List<Bone> getChildren([bool Function(Node node)? predicate, bool? directDescendantsOnly]);
	
	/// Gets the node index in matrix array generated for rendering
	/// @returns the node index
	external num getIndex();
	
	/// Sets the parent bone
	/// @param parent defines the parent (can be null if the bone is the root)
	/// @param updateDifferenceMatrix defines if the difference matrix must be updated
	external void setParent(Bone? parent, [bool? updateDifferenceMatrix]);
	
	/// Gets the local matrix
	/// @returns a matrix
	external Matrix getLocalMatrix();
	
	/// Gets the base matrix (initial matrix which remains unchanged)
	/// @returns a matrix
	external Matrix getBaseMatrix();
	
	/// Gets the rest pose matrix
	/// @returns a matrix
	external Matrix getRestPose();
	
	/// Sets the rest pose matrix
	/// @param matrix the local-space rest pose to set for this bone
	external void setRestPose(Matrix matrix);
	
	/// Gets the bind pose matrix
	/// @returns the bind pose matrix
	external Matrix getBindPose();
	
	/// Sets the bind pose matrix
	/// @param matrix the local-space bind pose to set for this bone
	external void setBindPose(Matrix matrix);
	
	/// Gets a matrix used to store world matrix (ie. the matrix sent to shaders)
	@override
	external Matrix getWorldMatrix();
	
	/// Sets the local matrix to rest pose matrix
	external void returnToRest();
	
	/// Gets the inverse of the absolute transform matrix.
	/// This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)
	/// @returns a matrix
	external Matrix getInvertedAbsoluteTransform();
	
	/// Gets the absolute transform matrix (ie base matrix * parent world matrix)
	/// @returns a matrix
	external Matrix getAbsoluteTransform();
	
	/// Links with the given transform node.
	/// The local matrix of this bone is copied from the transform node every frame.
	/// @param transformNode defines the transform node to link to
	external void linkTransformNode(TransformNode? transformNode);
	
	/// Gets the node used to drive the bone's transformation
	/// @returns a transform node or null
	external TransformNode? getTransformNode();
	
	/// Gets or sets current position (in local space)
	external Vector3 get position;
	
	external set position(Vector3 value);
	
	/// Gets or sets current rotation (in local space)
	external Vector3 get rotation;
	
	external set rotation(Vector3 value);
	
	/// Gets or sets current rotation quaternion (in local space)
	external Quaternion get rotationQuaternion;
	
	external set rotationQuaternion(Quaternion value);
	
	/// Gets or sets current scaling (in local space)
	external Vector3 get scaling;
	
	external set scaling(Vector3 value);
	
	/// Gets the animation properties override
	@override
	external AnimationPropertiesOverride? get animationPropertiesOverride;
	
	/// Update the base and local matrices
	/// @param matrix defines the new base or local matrix
	/// @param updateDifferenceMatrix defines if the difference matrix must be updated
	/// @param updateLocalMatrix defines if the local matrix should be updated
	external void updateMatrix(Matrix matrix, [bool? updateDifferenceMatrix, bool? updateLocalMatrix]);
	
	/// Flag the bone as dirty (Forcing it to update everything)
	external void markAsDirty();
	
	/// Translate the bone in local or world space
	/// @param vec The amount to translate the bone
	/// @param space The space that the translation is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	external void translate(Vector3 vec, [int? space, AbstractMesh? mesh]);
	
	/// Set the postion of the bone in local or world space
	/// @param position The position to set the bone
	/// @param space The space that the position is in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	external void setPosition(Vector3 position, [int? space, AbstractMesh? mesh]);
	
	/// Set the absolute position of the bone (world space)
	/// @param position The position to set the bone
	/// @param mesh The mesh that this bone is attached to
	external void setAbsolutePosition(Vector3 position, [AbstractMesh? mesh]);
	
	/// Scale the bone on the x, y and z axes (in local space)
	/// @param x The amount to scale the bone on the x axis
	/// @param y The amount to scale the bone on the y axis
	/// @param z The amount to scale the bone on the z axis
	/// @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)
	external void scale(num x, num y, num z, [bool? scaleChildren]);
	
	/// Set the bone scaling in local space
	/// @param scale defines the scaling vector
	external void setScale(Vector3 scale);
	
	/// Gets the current scaling in local space
	/// @returns the current scaling vector
	external Vector3 getScale();
	
	/// Gets the current scaling in local space and stores it in a target vector
	/// @param result defines the target vector
	external void getScaleToRef(Vector3 result);
	
	/// Set the yaw, pitch, and roll of the bone in local or world space
	/// @param yaw The rotation of the bone on the y axis
	/// @param pitch The rotation of the bone on the x axis
	/// @param roll The rotation of the bone on the z axis
	/// @param space The space that the axes of rotation are in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	external void setYawPitchRoll(num yaw, num pitch, num roll, [int? space, AbstractMesh? mesh]);
	
	/// Add a rotation to the bone on an axis in local or world space
	/// @param axis The axis to rotate the bone on
	/// @param amount The amount to rotate the bone
	/// @param space The space that the axis is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	external void rotate(Vector3 axis, num amount, [int? space, AbstractMesh? mesh]);
	
	/// Set the rotation of the bone to a particular axis angle in local or world space
	/// @param axis The axis to rotate the bone on
	/// @param angle The angle that the bone should be rotated to
	/// @param space The space that the axis is in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	external void setAxisAngle(Vector3 axis, num angle, [int? space, AbstractMesh? mesh]);
	
	/// Set the euler rotation of the bone in local or world space
	/// @param rotation The euler rotation that the bone should be set to
	/// @param space The space that the rotation is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	external void setRotation(Vector3 rotation, [int? space, AbstractMesh? mesh]);
	
	/// Set the quaternion rotation of the bone in local or world space
	/// @param quat The quaternion rotation that the bone should be set to
	/// @param space The space that the rotation is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	external void setRotationQuaternion(Quaternion quat, [int? space, AbstractMesh? mesh]);
	
	/// Set the rotation matrix of the bone in local or world space
	/// @param rotMat The rotation matrix that the bone should be set to
	/// @param space The space that the rotation is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	external void setRotationMatrix(Matrix rotMat, [int? space, AbstractMesh? mesh]);
	
	/// Get the position of the bone in local or world space
	/// @param space The space that the returned position is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	/// @returns The position of the bone
	external Vector3 getPosition([int? space, AbstractMesh? mesh]);
	
	/// Copy the position of the bone to a vector3 in local or world space
	/// @param space The space that the returned position is in
	/// @param mesh The mesh that this bone is attached to. This is only used in world space
	/// @param result The vector3 to copy the position to
	external void getPositionToRef(int? space, AbstractMesh? mesh, Vector3 result);
	
	/// Get the absolute position of the bone (world space)
	/// @param mesh The mesh that this bone is attached to
	/// @returns The absolute position of the bone
	external Vector3 getAbsolutePosition([AbstractMesh? mesh]);
	
	/// Copy the absolute position of the bone (world space) to the result param
	/// @param mesh The mesh that this bone is attached to
	/// @param result The vector3 to copy the absolute position to
	external void getAbsolutePositionToRef(AbstractMesh mesh, Vector3 result);
	
	/// Compute the absolute transforms of this bone and its children
	external void computeAbsoluteTransforms();
	
	/// Get the world direction from an axis that is in the local space of the bone
	/// @param localAxis The local direction that is used to compute the world direction
	/// @param mesh The mesh that this bone is attached to
	/// @returns The world direction
	external Vector3 getDirection(Vector3 localAxis, [AbstractMesh? mesh]);
	
	/// Copy the world direction to a vector3 from an axis that is in the local space of the bone
	/// @param localAxis The local direction that is used to compute the world direction
	/// @param mesh The mesh that this bone is attached to
	/// @param result The vector3 that the world direction will be copied to
	external void getDirectionToRef(Vector3 localAxis, AbstractMesh? mesh, Vector3 result);
	
	/// Get the euler rotation of the bone in local or world space
	/// @param space The space that the rotation should be in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	/// @returns The euler rotation
	external Vector3 getRotation([int? space, AbstractMesh? mesh]);
	
	/// Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space
	/// @param space The space that the rotation should be in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	/// @param result The vector3 that the rotation should be copied to
	external void getRotationToRef(int? space, AbstractMesh? mesh, Vector3 result);
	
	/// Get the quaternion rotation of the bone in either local or world space
	/// @param space The space that the rotation should be in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	/// @returns The quaternion rotation
	external Quaternion getRotationQuaternion([int? space, AbstractMesh? mesh]);
	
	/// Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space
	/// @param space The space that the rotation should be in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	/// @param result The quaternion that the rotation should be copied to
	external void getRotationQuaternionToRef(int? space, AbstractMesh? mesh, Quaternion result);
	
	/// Get the rotation matrix of the bone in local or world space
	/// @param space The space that the rotation should be in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	/// @returns The rotation matrix
	external Matrix getRotationMatrix(int? space, AbstractMesh mesh);
	
	/// Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space
	/// @param space The space that the rotation should be in
	/// @param mesh The mesh that this bone is attached to.  This is only used in world space
	/// @param result The quaternion that the rotation should be copied to
	external void getRotationMatrixToRef(int? space, AbstractMesh mesh, Matrix result);
	
	/// Get the world position of a point that is in the local space of the bone
	/// @param position The local position
	/// @param mesh The mesh that this bone is attached to
	/// @returns The world position
	external Vector3 getAbsolutePositionFromLocal(Vector3 position, [AbstractMesh? mesh]);
	
	/// Get the world position of a point that is in the local space of the bone and copy it to the result param
	/// @param position The local position
	/// @param mesh The mesh that this bone is attached to
	/// @param result The vector3 that the world position should be copied to
	external void getAbsolutePositionFromLocalToRef(Vector3 position, AbstractMesh? mesh, Vector3 result);
	
	/// Get the local position of a point that is in world space
	/// @param position The world position
	/// @param mesh The mesh that this bone is attached to
	/// @returns The local position
	external Vector3 getLocalPositionFromAbsolute(Vector3 position, [AbstractMesh? mesh]);
	
	/// Get the local position of a point that is in world space and copy it to the result param
	/// @param position The world position
	/// @param mesh The mesh that this bone is attached to
	/// @param result The vector3 that the local position should be copied to
	external void getLocalPositionFromAbsoluteToRef(Vector3 position, AbstractMesh? mesh, Vector3 result);
	
	/// Set the current local matrix as the restPose for this bone.
	external void setCurrentPoseAsRest();
	
	/// Copy an animation range from another bone
	/// @param source defines the source bone
	/// @param rangeName defines the range name to copy
	/// @param frameOffset defines the frame offset
	/// @param rescaleAsRequired defines if rescaling must be applied if required
	/// @param skelDimensionsRatio defines the scaling ratio
	/// @returns true if operation was successful
	external bool copyAnimationRange(Bone source, String rangeName, num frameOffset, bool rescaleAsRequired, Vector3? skelDimensionsRatio);
}

/// Class used to override all child animations of a given target
@JS()
class AnimationPropertiesOverride {
	external factory AnimationPropertiesOverride();
	
	/// Gets or sets a value indicating if animation blending must be used
	external bool get enableBlending;
	external set enableBlending(bool value);
	
	/// Gets or sets the blending speed to use when enableBlending is true
	external num get blendingSpeed;
	external set blendingSpeed(num value);
	
	/// Gets or sets the default loop mode to use
	external num get loopMode;
	external set loopMode(num value);
}

/// Class used to handle skinning animations
/// @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
@JS()
class Skeleton implements IAnimatable {
	
	/// Creates a new skeleton
	/// @param name defines the skeleton name
	/// @param id defines the skeleton Id
	/// @param scene defines the hosting scene
	external factory Skeleton(String name, String id, Scene scene);
	
	/// defines the skeleton name
	external String get name;
	external set name(String value);
	
	/// defines the skeleton Id
	external String get id;
	external set id(String value);
	
	/// Defines the list of child bones
	external List<Bone> get bones;
	external set bones(List<Bone> value);
	
	/// Defines an estimate of the dimension of the skeleton at rest
	external Vector3 get dimensionsAtRest;
	external set dimensionsAtRest(Vector3 value);
	
	/// Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)
	external bool get needInitialSkinMatrix;
	external set needInitialSkinMatrix(bool value);
	
	/// Defines a mesh that override the matrix used to get the world matrix (null by default).
	external AbstractMesh? get overrideMesh;
	external set overrideMesh(AbstractMesh? value);
	
	/// Gets the list of animations attached to this skeleton
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// Specifies if the skeleton should be serialized
	external bool get doNotSerialize;
	external set doNotSerialize(bool value);
	
	/// Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).
	/// Please note that this option is not available if the hardware does not support it
	external bool get useTextureToStoreBoneMatrices;
	
	external set useTextureToStoreBoneMatrices(bool value);
	
	/// Gets or sets the animation properties override
	external AnimationPropertiesOverride? get animationPropertiesOverride;
	
	external set animationPropertiesOverride(AnimationPropertiesOverride? value);
	
	/// List of inspectable custom properties (used by the Inspector)
	/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
	external List<IInspectable> get inspectableCustomProperties;
	external set inspectableCustomProperties(List<IInspectable> value);
	
	/// An observable triggered before computing the skeleton's matrices
	external Observable<Skeleton> get onBeforeComputeObservable;
	external set onBeforeComputeObservable(Observable<Skeleton> value);
	
	/// Gets a boolean indicating that the skeleton effectively stores matrices into a texture
	external bool get isUsingTextureForMatrices;
	
	/// Gets the unique ID of this skeleton
	external num get uniqueId;
	
	/// Gets the current object class name.
	/// @return the class name
	external String getClassName();
	
	/// Returns an array containing the root bones
	/// @returns an array containing the root bones
	external List<Bone> getChildren();
	
	/// Gets the list of transform matrices to send to shaders (one matrix per bone)
	/// @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
	/// @returns a Float32Array containing matrices data
	external Float32List getTransformMatrices(AbstractMesh mesh);
	
	/// Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)
	/// @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
	/// @returns a raw texture containing the data
	external RawTexture? getTransformMatrixTexture(AbstractMesh mesh);
	
	/// Gets the current hosting scene
	/// @returns a scene object
	external Scene getScene();
	
	/// Gets a string representing the current skeleton data
	/// @param fullDetails defines a boolean indicating if we want a verbose version
	/// @returns a string representing the current skeleton data
	external String toString([bool? fullDetails]);
	
	/// Get bone's index searching by name
	/// @param name defines bone's name to search for
	/// @return the indice of the bone. Returns -1 if not found
	external num getBoneIndexByName(String name);
	
	/// Creater a new animation range
	/// @param name defines the name of the range
	/// @param from defines the start key
	/// @param to defines the end key
	external void createAnimationRange(String name, num from, num to);
	
	/// Delete a specific animation range
	/// @param name defines the name of the range
	/// @param deleteFrames defines if frames must be removed as well
	external void deleteAnimationRange(String name, [bool? deleteFrames]);
	
	/// Gets a specific animation range
	/// @param name defines the name of the range to look for
	/// @returns the requested animation range or null if not found
	external AnimationRange? getAnimationRange(String name);
	
	/// Gets the list of all animation ranges defined on this skeleton
	/// @returns an array
	external List<AnimationRange>? getAnimationRanges();
	
	/// Copy animation range from a source skeleton.
	/// This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
	/// @param source defines the source skeleton
	/// @param name defines the name of the range to copy
	/// @param rescaleAsRequired defines if rescaling must be applied if required
	/// @returns true if operation was successful
	external bool copyAnimationRange(Skeleton source, String name, [bool? rescaleAsRequired]);
	
	/// Forces the skeleton to go to rest pose
	external void returnToRest();
	
	/// Begin a specific animation range
	/// @param name defines the name of the range to start
	/// @param loop defines if looping must be turned on (false by default)
	/// @param speedRatio defines the speed ratio to apply (1 by default)
	/// @param onAnimationEnd defines a callback which will be called when animation will end
	/// @returns a new animatable
	external Animatable? beginAnimation(String name, [bool? loop, num? speedRatio, void Function()? onAnimationEnd]);
	
	/// Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.
	/// @param skeleton defines the Skeleton containing the animation range to convert
	/// @param referenceFrame defines the frame that keyframes in the range will be relative to
	/// @param range defines the name of the AnimationRange belonging to the Skeleton to convert
	/// @returns the original skeleton
	external static Skeleton? MakeAnimationAdditive(Skeleton skeleton, num? referenceFrame, String range);
	
	/// Build all resources required to render a skeleton
	external void prepare();
	
	/// Gets the list of animatables currently running for this skeleton
	/// @returns an array of animatables
	external List<IAnimatable> getAnimatables();
	
	/// Clone the current skeleton
	/// @param name defines the name of the new skeleton
	/// @param id defines the id of the new skeleton
	/// @returns the new skeleton
	external Skeleton clone(String name, [String? id]);
	
	/// Enable animation blending for this skeleton
	/// @param blendingSpeed defines the blending speed to apply
	/// @see https://doc.babylonjs.com/babylon101/animations#animation-blending
	external void enableBlending([num? blendingSpeed]);
	
	/// Releases all resources associated with the current skeleton
	external void dispose();
	
	/// Serialize the skeleton in a JSON object
	/// @returns a JSON object
	external dynamic serialize();
	
	/// Creates a new skeleton from serialized data
	/// @param parsedSkeleton defines the serialized data
	/// @param scene defines the hosting scene
	/// @returns a new skeleton
	external static Skeleton Parse(dynamic parsedSkeleton, Scene scene);
	
	/// Compute all node absolute transforms
	/// @param forceUpdate defines if computation must be done even if cache is up to date
	external void computeAbsoluteTransforms([bool? forceUpdate]);
	
	/// Gets the root pose matrix
	/// @returns a matrix
	external Matrix? getPoseMatrix();
	
	/// Sorts bones per internal index
	external void sortBones();
	
	/// Set the current local matrix as the restPose for all bones in the skeleton.
	external void setCurrentPoseAsRest();
}

/// A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.
/// @see https://doc.babylonjs.com/how_to/transformnode
@JS()
class TransformNode extends Node {
	
	external factory TransformNode(String name, [Scene? scene, bool? isPure]);
	
	/// Object will not rotate to face the camera
	external static num get BILLBOARDMODE_NONE;
	external static set BILLBOARDMODE_NONE(num value);
	
	/// Object will rotate to face the camera but only on the x axis
	external static num get BILLBOARDMODE_X;
	external static set BILLBOARDMODE_X(num value);
	
	/// Object will rotate to face the camera but only on the y axis
	external static num get BILLBOARDMODE_Y;
	external static set BILLBOARDMODE_Y(num value);
	
	/// Object will rotate to face the camera but only on the z axis
	external static num get BILLBOARDMODE_Z;
	external static set BILLBOARDMODE_Z(num value);
	
	/// Object will rotate to face the camera
	external static num get BILLBOARDMODE_ALL;
	external static set BILLBOARDMODE_ALL(num value);
	
	/// Object will rotate to face the camera's position instead of orientation
	external static num get BILLBOARDMODE_USE_POSITION;
	external static set BILLBOARDMODE_USE_POSITION(num value);
	
	/// Gets or sets the billboard mode. Default is 0.
	/// 
	/// | Value | Type | Description |
	/// | --- | --- | --- |
	/// | 0 | BILLBOARDMODE_NONE |  |
	/// | 1 | BILLBOARDMODE_X |  |
	/// | 2 | BILLBOARDMODE_Y |  |
	/// | 4 | BILLBOARDMODE_Z |  |
	/// | 7 | BILLBOARDMODE_ALL |  |
	/// 
	external num get billboardMode;
	
	external set billboardMode(num value);
	
	/// Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.
	/// This could be useful for glTF objects where parent rotation helps converting from right handed to left handed
	external bool get preserveParentRotationForBillboard;
	
	external set preserveParentRotationForBillboard(bool value);
	
	/// Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube
	external num get scalingDeterminant;
	external set scalingDeterminant(num value);
	
	/// Gets or sets the distance of the object to max, often used by skybox
	external bool get infiniteDistance;
	
	external set infiniteDistance(bool value);
	
	/// Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.
	/// By default the system will update normals to compensate
	external bool get ignoreNonUniformScaling;
	external set ignoreNonUniformScaling(bool value);
	
	/// Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both
	external bool get reIntegrateRotationIntoRotationQuaternion;
	external set reIntegrateRotationIntoRotationQuaternion(bool value);
	
	/// An event triggered after the world matrix is updated
	external Observable<TransformNode> get onAfterWorldMatrixUpdateObservable;
	external set onAfterWorldMatrixUpdateObservable(Observable<TransformNode> value);
	
	/// Gets a string identifying the name of the class
	/// @returns "TransformNode" string
	@override
	external String getClassName();
	
	/// Gets or set the node position (default is (0.0, 0.0, 0.0))
	external Vector3 get position;
	
	external set position(Vector3 value);
	
	/// Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).
	/// If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion
	external Vector3 get rotation;
	
	external set rotation(Vector3 value);
	
	/// Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (0.0, 0.0, 0.0)).
	external Vector3 get scaling;
	
	external set scaling(Vector3 value);
	
	/// Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).
	/// If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)
	external Quaternion? get rotationQuaternion;
	
	external set rotationQuaternion(Quaternion? value);
	
	/// The forward direction of that transform in world space.
	external Vector3 get forward;
	
	/// The up direction of that transform in world space.
	external Vector3 get up;
	
	/// The right direction of that transform in world space.
	external Vector3 get right;
	
	/// Copies the parameter passed Matrix into the mesh Pose matrix.
	/// @param matrix the matrix to copy the pose from
	/// @returns this TransformNode.
	external TransformNode updatePoseMatrix(Matrix matrix);
	
	/// Returns the mesh Pose matrix.
	/// @returns the pose matrix
	external Matrix getPoseMatrix();
	
	/// Flag the transform node as dirty (Forcing it to update everything)
	/// @param property if set to "rotation" the objects rotationQuaternion will be set to null
	/// @returns this transform node
	external TransformNode markAsDirty(String property);
	
	/// Returns the current mesh absolute position.
	/// Returns a Vector3.
	external Vector3 get absolutePosition;
	
	/// Returns the current mesh absolute scaling.
	/// Returns a Vector3.
	external Vector3 get absoluteScaling;
	
	/// Returns the current mesh absolute rotation.
	/// Returns a Quaternion.
	external Quaternion get absoluteRotationQuaternion;
	
	/// Sets a new matrix to apply before all other transformation
	/// @param matrix defines the transform matrix
	/// @returns the current TransformNode
	external TransformNode setPreTransformMatrix(Matrix matrix);
	
	/// Sets a new pivot matrix to the current node
	/// @param matrix defines the new pivot matrix to use
	/// @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect
	/// @returns the current TransformNode
	external TransformNode setPivotMatrix(Matrix matrix, [bool? postMultiplyPivotMatrix]);
	
	/// Returns the mesh pivot matrix.
	/// Default : Identity.
	/// @returns the matrix
	external Matrix getPivotMatrix();
	
	/// Instantiate (when possible) or clone that node with its hierarchy
	/// @param newParent defines the new parent to use for the instance (or clone)
	/// @param options defines options to configure how copy is done
	/// @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
	/// @returns an instance (or a clone) of the current node with its hiearchy
	external TransformNode? instantiateHierarchy([TransformNode? newParent, TransformNodeInstantiateHierarchyOptions? options, void Function(TransformNode source, TransformNode clone)? onNewNodeCreated]);
	
	/// Prevents the World matrix to be computed any longer
	/// @param newWorldMatrix defines an optional matrix to use as world matrix
	/// @returns the TransformNode.
	external TransformNode freezeWorldMatrix([Matrix? newWorldMatrix]);
	
	/// Allows back the World matrix computation.
	/// @returns the TransformNode.
	external dynamic unfreezeWorldMatrix();
	
	/// True if the World matrix has been frozen.
	external bool get isWorldMatrixFrozen;
	
	/// Retuns the mesh absolute position in the World.
	/// @returns a Vector3.
	external Vector3 getAbsolutePosition();
	
	/// Sets the mesh absolute position in the World from a Vector3 or an Array(3).
	/// @param absolutePosition the absolute position to set
	/// @returns the TransformNode.
	external TransformNode setAbsolutePosition(Vector3 absolutePosition);
	
	/// Sets the mesh position in its local space.
	/// @param vector3 the position to set in localspace
	/// @returns the TransformNode.
	external TransformNode setPositionWithLocalVector(Vector3 vector3);
	
	/// Returns the mesh position in the local space from the current World matrix values.
	/// @returns a new Vector3.
	external Vector3 getPositionExpressedInLocalSpace();
	
	/// Translates the mesh along the passed Vector3 in its local space.
	/// @param vector3 the distance to translate in localspace
	/// @returns the TransformNode.
	external TransformNode locallyTranslate(Vector3 vector3);
	
	/// Orients a mesh towards a target point. Mesh must be drawn facing user.
	/// @param targetPoint the position (must be in same space as current mesh) to look at
	/// @param yawCor optional yaw (y-axis) correction in radians
	/// @param pitchCor optional pitch (x-axis) correction in radians
	/// @param rollCor optional roll (z-axis) correction in radians
	/// @param space the choosen space of the target
	/// @returns the TransformNode.
	external TransformNode lookAt(Vector3 targetPoint, [num? yawCor, num? pitchCor, num? rollCor, int? space]);
	
	/// Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
	/// This Vector3 is expressed in the World space.
	/// @param localAxis axis to rotate
	/// @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
	external Vector3 getDirection(Vector3 localAxis);
	
	/// Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
	/// localAxis is expressed in the mesh local space.
	/// result is computed in the Wordl space from the mesh World matrix.
	/// @param localAxis axis to rotate
	/// @param result the resulting transformnode
	/// @returns this TransformNode.
	external TransformNode getDirectionToRef(Vector3 localAxis, Vector3 result);
	
	/// Sets this transform node rotation to the given local axis.
	/// @param localAxis the axis in local space
	/// @param yawCor optional yaw (y-axis) correction in radians
	/// @param pitchCor optional pitch (x-axis) correction in radians
	/// @param rollCor optional roll (z-axis) correction in radians
	/// @returns this TransformNode
	external TransformNode setDirection(Vector3 localAxis, [num? yawCor, num? pitchCor, num? rollCor]);
	
	/// Sets a new pivot point to the current node
	/// @param point defines the new pivot point to use
	/// @param space defines if the point is in world or local space (local by default)
	/// @returns the current TransformNode
	external TransformNode setPivotPoint(Vector3 point, [int? space]);
	
	/// Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
	/// @returns the pivot point
	external Vector3 getPivotPoint();
	
	/// Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
	/// @param result the vector3 to store the result
	/// @returns this TransformNode.
	external TransformNode getPivotPointToRef(Vector3 result);
	
	/// Returns a new Vector3 set with the mesh pivot point World coordinates.
	/// @returns a new Vector3 set with the mesh pivot point World coordinates.
	external Vector3 getAbsolutePivotPoint();
	
	/// Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
	/// @param result vector3 to store the result
	/// @returns this TransformNode.
	external TransformNode getAbsolutePivotPointToRef(Vector3 result);
	
	/// Defines the passed node as the parent of the current node.
	/// The node will remain exactly where it is and its position / rotation will be updated accordingly
	/// @see https://doc.babylonjs.com/how_to/parenting
	/// @param node the node ot set as the parent
	/// @returns this TransformNode.
	external TransformNode setParent(Node? node);
	
	/// True if the scaling property of this object is non uniform eg. (1,2,1)
	external bool get nonUniformScaling;
	
	/// Attach the current TransformNode to another TransformNode associated with a bone
	/// @param bone Bone affecting the TransformNode
	/// @param affectedTransformNode TransformNode associated with the bone
	/// @returns this object
	external TransformNode attachToBone(Bone bone, TransformNode affectedTransformNode);
	
	/// Detach the transform node if its associated with a bone
	/// @returns this object
	external TransformNode detachFromBone();
	
	/// Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
	/// space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
	/// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
	/// The passed axis is also normalized.
	/// @param axis the axis to rotate around
	/// @param amount the amount to rotate in radians
	/// @param space Space to rotate in (Default: local)
	/// @returns the TransformNode.
	external TransformNode rotate(Vector3 axis, num amount, [int? space]);
	
	/// Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
	/// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
	/// The passed axis is also normalized. .
	/// Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
	/// @param point the point to rotate around
	/// @param axis the axis to rotate around
	/// @param amount the amount to rotate in radians
	/// @returns the TransformNode
	external TransformNode rotateAround(Vector3 point, Vector3 axis, num amount);
	
	/// Translates the mesh along the axis vector for the passed distance in the given space.
	/// space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
	/// @param axis the axis to translate in
	/// @param distance the distance to translate
	/// @param space Space to rotate in (Default: local)
	/// @returns the TransformNode.
	external TransformNode translate(Vector3 axis, num distance, [int? space]);
	
	/// Adds a rotation step to the mesh current rotation.
	/// x, y, z are Euler angles expressed in radians.
	/// This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
	/// This means this rotation is made in the mesh local space only.
	/// It's useful to set a custom rotation order different from the BJS standard one YXZ.
	/// Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
	/// ```javascript
	/// mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
	/// ```
	/// Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
	/// Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
	/// @param x Rotation to add
	/// @param y Rotation to add
	/// @param z Rotation to add
	/// @returns the TransformNode.
	external TransformNode addRotation(num x, num y, num z);
	
	/// Computes the world matrix of the node
	/// @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
	/// @returns the world matrix
	@override
	external Matrix computeWorldMatrix([bool? force]);
	
	/// Resets this nodeTransform's local matrix to Matrix.Identity().
	/// @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.
	external void resetLocalMatrix([bool? independentOfChildren]);
	
	/// If you'd like to be called back after the mesh position, rotation or scaling has been updated.
	/// @param func callback function to add
	/// 
	/// @returns the TransformNode.
	external TransformNode registerAfterWorldMatrixUpdate(void Function(TransformNode mesh) func);
	
	/// Removes a registered callback function.
	/// @param func callback function to remove
	/// @returns the TransformNode.
	external TransformNode unregisterAfterWorldMatrixUpdate(void Function(TransformNode mesh) func);
	
	/// Gets the position of the current mesh in camera space
	/// @param camera defines the camera to use
	/// @returns a position
	external Vector3 getPositionInCameraSpace([Camera? camera]);
	
	/// Returns the distance from the mesh to the active camera
	/// @param camera defines the camera to use
	/// @returns the distance
	external num getDistanceToCamera([Camera? camera]);
	
	/// Clone the current transform node
	/// @param name Name of the new clone
	/// @param newParent New parent for the clone
	/// @param doNotCloneChildren Do not clone children hierarchy
	/// @returns the new transform node
	external TransformNode? clone(String? name, Node? newParent, [bool? doNotCloneChildren]);
	
	/// Serializes the objects information.
	/// @param currentSerializationObject defines the object to serialize in
	/// @returns the serialized object
	external dynamic serialize([dynamic? currentSerializationObject]);
	
	/// Returns a new TransformNode object parsed from the source provided.
	/// @param parsedTransformNode is the source.
	/// @param scene the scne the object belongs to
	/// @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with
	/// @returns a new TransformNode object parsed from the source provided.
	external static TransformNode Parse(dynamic parsedTransformNode, Scene scene, String rootUrl);
	
	/// Get all child-transformNodes of this node
	/// @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
	/// @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
	/// @returns an array of TransformNode
	external List<TransformNode> getChildTransformNodes([bool? directDescendantsOnly, bool Function(Node node)? predicate]);
	
	/// Releases resources associated with this transform node.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
	/// @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
	/// @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
	/// @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
	/// @returns the current mesh
	external TransformNode normalizeToUnitCube([bool? includeDescendants, bool? ignoreRotation, bool Function(AbstractMesh node)? predicate]);
}

/* enum */
abstract class PoseEnabledControllerType {
	
	/// HTC Vive
	static const int VIVE = 1;
	
	/// Oculus Rift
	static const int OCULUS = 2;
	
	/// Windows mixed reality
	static const int WINDOWS = 3;
	
	/// Samsung gear VR
	static const int GEAR_VR = 4;
	
	/// Google Daydream
	static const int DAYDREAM = 5;
	
	/// Generic
	static const int GENERIC = 6;
}

/// Defines the MutableGamepadButton interface for the state of a gamepad button
@JS()
@anonymous
class MutableGamepadButton {
	
	external factory MutableGamepadButton({num value, bool touched, bool pressed});
	
	/// Value of the button/trigger
	external num get value;
	external set value( num value );
	
	/// If the button/trigger is currently touched
	external bool get touched;
	external set touched( bool value );
	
	/// If the button/trigger is currently pressed
	external bool get pressed;
	external set pressed( bool value );
}

/// Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller
/// @hidden
@JS()
@anonymous
class ExtendedGamepadButton {
	
	external factory ExtendedGamepadButton({bool pressed, bool touched, num value});
	
	/// If the button/trigger is currently pressed
	external bool get pressed;
	external set pressed( bool value );
	
	/// If the button/trigger is currently touched
	external bool get touched;
	external set touched( bool value );
	
	/// Value of the button/trigger
	external num get value;
	external set value( num value );
}

/// Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
@JS()
class PoseEnabledControllerHelper {
	external factory PoseEnabledControllerHelper();
	
	/// Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
	/// @param vrGamepad the gamepad to initialized
	/// @returns a vr controller of the type the gamepad identified as
	external static Gamepad InitiateController(dynamic vrGamepad);
}

/// Defines the PoseEnabledController object that contains state of a vr capable controller
@JS()
class PoseEnabledController extends Gamepad implements PoseControlled {
	
	/// Creates a new PoseEnabledController from a gamepad
	/// @param browserGamepad the gamepad that the PoseEnabledController should be created from
	external factory PoseEnabledController(dynamic browserGamepad);
	
	/// If the controller is used in a webXR session
	external bool get isXR;
	external set isXR(bool value);
	
	/// The device position in babylon space
	@override
	external Vector3 get devicePosition;
	@override
	external set devicePosition(Vector3 value);
	
	/// The device rotation in babylon space
	@override
	external Quaternion get deviceRotationQuaternion;
	@override
	external set deviceRotationQuaternion(Quaternion value);
	
	/// The scale factor of the device in babylon space
	@override
	external num get deviceScaleFactor;
	@override
	external set deviceScaleFactor(num value);
	
	/// (Likely devicePosition should be used instead) The device position in its room space
	@override
	external Vector3 get position;
	@override
	external set position(Vector3 value);
	
	/// (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space
	@override
	external Quaternion get rotationQuaternion;
	@override
	external set rotationQuaternion(Quaternion value);
	
	/// The type of controller (Eg. Windows mixed reality)
	external int get controllerType;
	external set controllerType(int value);
	
	/// The raw pose from the device
	@override
	external DevicePose? get rawPose;
	@override
	external set rawPose(DevicePose? value);
	
	/// Name of the child mesh that can be used to cast a ray from the controller
	external static String get POINTING_POSE;
	
	/// Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
	@override
	external void update();
	
	/// Updates the state of the pose enbaled controller based on the raw pose data from the device
	/// @param poseData raw pose fromthe device
	@override
	external void updateFromDevice(DevicePose poseData);
	
	/// Attaches a mesh to the controller
	/// @param mesh the mesh to be attached
	external void attachToMesh(AbstractMesh mesh);
	
	/// Attaches the controllers mesh to a camera
	/// @param camera the camera the mesh should be attached to
	external void attachToPoseControlledCamera(TargetCamera camera);
	
	/// Disposes of the controller
	@override
	external void dispose();
	
	/// The mesh that is attached to the controller
	external AbstractMesh? get mesh;
	
	/// Gets the ray of the controller in the direction the controller is pointing
	/// @param length the length the resulting ray should be
	/// @returns a ray in the direction the controller is pointing
	external Ray getForwardRay([num? length]);
}

/// Defines the WebVRController object that represents controllers tracked in 3D space
@JS()
abstract class WebVRController extends PoseEnabledController {
	
	/// Creates a new WebVRController from a gamepad
	/// @param vrGamepad the gamepad that the WebVRController should be created from
	external factory WebVRController(dynamic vrGamepad);
	
	/// Fired when the trigger state has changed
	external Observable<ExtendedGamepadButton> get onTriggerStateChangedObservable;
	external set onTriggerStateChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the main button state has changed
	external Observable<ExtendedGamepadButton> get onMainButtonStateChangedObservable;
	external set onMainButtonStateChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the secondary button state has changed
	external Observable<ExtendedGamepadButton> get onSecondaryButtonStateChangedObservable;
	external set onSecondaryButtonStateChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the pad state has changed
	external Observable<ExtendedGamepadButton> get onPadStateChangedObservable;
	external set onPadStateChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when controllers stick values have changed
	external Observable<StickValues> get onPadValuesChangedObservable;
	external set onPadValuesChangedObservable(Observable<StickValues> value);
	
	/// Fired when a controller button's state has changed
	/// @param callback the callback containing the button that was modified
	external void onButtonStateChange(void Function(num controlledIndex, num buttonIndex, ExtendedGamepadButton state) callback);
	
	/// X and Y axis corresponding to the controllers joystick
	external StickValues get pad;
	external set pad(StickValues value);
	
	/// 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum
	external String get hand;
	external set hand(String value);
	
	/// The default controller model for the controller
	external AbstractMesh? get defaultModel;
	
	/// Updates the state of the controller and mesh based on the current position and rotation of the controller
	@override
	external void update();
	
	/// Loads a mesh and attaches it to the controller
	/// @param scene the scene the mesh should be added to
	/// @param meshLoaded callback for when the mesh has been loaded
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded]);
	
	/// Disposes of th webVRCOntroller
	@override
	external void dispose();
}

/// The HemisphericLight simulates the ambient environment light,
/// so the passed direction is the light reflection direction, not the incoming direction.
@JS()
class HemisphericLight extends Light {
	
	/// Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
	/// The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
	/// The HemisphericLight can't cast shadows.
	/// Documentation : https://doc.babylonjs.com/babylon101/lights
	/// @param name The friendly name of the light
	/// @param direction The direction of the light reflection
	/// @param scene The scene the light belongs to
	external factory HemisphericLight(String name, Vector3 direction, Scene scene);
	
	/// The groundColor is the light in the opposite direction to the one specified during creation.
	/// You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.
	external Color3 get groundColor;
	external set groundColor(Color3 value);
	
	/// The light reflection direction, not the incoming direction.
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// Returns the string "HemisphericLight".
	/// @return The class name
	@override
	external String getClassName();
	
	/// Sets the HemisphericLight direction towards the passed target (Vector3).
	/// Returns the updated direction.
	/// @param target The target the direction should point to
	/// @return The computed direction
	external Vector3 setDirectionToTarget(Vector3 target);
	
	/// Returns the shadow generator associated to the light.
	/// @returns Always null for hemispheric lights because it does not support shadows.
	@override
	external IShadowGenerator? getShadowGenerator();
	
	/// Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The hemispheric light
	@override
	external HemisphericLight transferToEffect(Effect effect, String lightIndex);
	
	/* Manual Fix 10 */
	
	@override
	external Light transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);
	
	/// Computes the world matrix of the node
	/// @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
	/// @param useWasUpdatedFlag defines a reserved property
	/// @returns the world matrix
	@override
	external Matrix computeWorldMatrix([bool? force]);
	
	/// Returns the integer 3.
	/// @return The light Type id as a constant defines in Light.LIGHTTYPEID_x
	@override
	external num getTypeID();
	
	/// Prepares the list of defines specific to the light type.
	/// @param defines the list of defines
	/// @param lightIndex defines the index of the light for the effect
	@override
	external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

/* var */
/// @hidden
@JS()
external dynamic get vrMultiviewToSingleviewPixelShader;

/// Renders to multiple views with a single draw call
/// @see https://www.khronos.org/registry/webgl/extensions/WEBGL_multiview/
@JS()
class MultiviewRenderTarget extends RenderTargetTexture {
	
	/// Creates a multiview render target
	/// @param scene scene used with the render target
	/// @param size the size of the render target (used for each view)
	external factory MultiviewRenderTarget(Scene scene, [dynamic? size]);
	
	/// Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
	/// @returns the view count
	@override
	external num getViewCount();
}

/// The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
@JS()
class Engine extends ThinEngine {
	
	/// Creates a new engine
	/// @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context
	/// @param antialias defines enable antialiasing (default: false)
	/// @param options defines further options to be sent to the getContext() function
	/// @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
	external factory Engine(dynamic? canvasOrContext, [bool? antialias, EngineOptions? options, bool? adaptToDeviceRatio]);
	
	/// Defines that alpha blending is disabled
	external static num get ALPHA_DISABLE;
	
	/// Defines that alpha blending to SRC ALPHA * SRC + DEST
	external static num get ALPHA_ADD;
	
	/// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST
	external static num get ALPHA_COMBINE;
	
	/// Defines that alpha blending to DEST - SRC * DEST
	external static num get ALPHA_SUBTRACT;
	
	/// Defines that alpha blending to SRC * DEST
	external static num get ALPHA_MULTIPLY;
	
	/// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST
	external static num get ALPHA_MAXIMIZED;
	
	/// Defines that alpha blending to SRC + DEST
	external static num get ALPHA_ONEONE;
	
	/// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
	external static num get ALPHA_PREMULTIPLIED;
	
	/// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
	/// Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
	external static num get ALPHA_PREMULTIPLIED_PORTERDUFF;
	
	/// Defines that alpha blending to CST * SRC + (1 - CST) * DEST
	external static num get ALPHA_INTERPOLATE;
	
	/// Defines that alpha blending to SRC + (1 - SRC) * DEST
	/// Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
	external static num get ALPHA_SCREENMODE;
	
	/// Defines that the ressource is not delayed
	external static num get DELAYLOADSTATE_NONE;
	
	/// Defines that the ressource was successfully delay loaded
	external static num get DELAYLOADSTATE_LOADED;
	
	/// Defines that the ressource is currently delay loading
	external static num get DELAYLOADSTATE_LOADING;
	
	/// Defines that the ressource is delayed and has not started loading
	external static num get DELAYLOADSTATE_NOTLOADED;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn
	external static num get NEVER;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn
	external static num get ALWAYS;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value
	external static num get LESS;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value
	external static num get EQUAL;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value
	external static num get LEQUAL;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value
	external static num get GREATER;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value
	external static num get GEQUAL;
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value
	external static num get NOTEQUAL;
	
	/// Passed to stencilOperation to specify that stencil value must be kept
	external static num get KEEP;
	
	/// Passed to stencilOperation to specify that stencil value must be replaced
	external static num get REPLACE;
	
	/// Passed to stencilOperation to specify that stencil value must be incremented
	external static num get INCR;
	
	/// Passed to stencilOperation to specify that stencil value must be decremented
	external static num get DECR;
	
	/// Passed to stencilOperation to specify that stencil value must be inverted
	external static num get INVERT;
	
	/// Passed to stencilOperation to specify that stencil value must be incremented with wrapping
	external static num get INCR_WRAP;
	
	/// Passed to stencilOperation to specify that stencil value must be decremented with wrapping
	external static num get DECR_WRAP;
	
	/// Texture is not repeating outside of 0..1 UVs
	external static num get TEXTURE_CLAMP_ADDRESSMODE;
	
	/// Texture is repeating outside of 0..1 UVs
	external static num get TEXTURE_WRAP_ADDRESSMODE;
	
	/// Texture is repeating and mirrored
	external static num get TEXTURE_MIRROR_ADDRESSMODE;
	
	/// ALPHA
	external static num get TEXTUREFORMAT_ALPHA;
	
	/// LUMINANCE
	external static num get TEXTUREFORMAT_LUMINANCE;
	
	/// LUMINANCE_ALPHA
	external static num get TEXTUREFORMAT_LUMINANCE_ALPHA;
	
	/// RGB
	external static num get TEXTUREFORMAT_RGB;
	
	/// RGBA
	external static num get TEXTUREFORMAT_RGBA;
	
	/// RED
	external static num get TEXTUREFORMAT_RED;
	
	/// RED (2nd reference)
	external static num get TEXTUREFORMAT_R;
	
	/// RG
	external static num get TEXTUREFORMAT_RG;
	
	/// RED_INTEGER
	external static num get TEXTUREFORMAT_RED_INTEGER;
	
	/// RED_INTEGER (2nd reference)
	external static num get TEXTUREFORMAT_R_INTEGER;
	
	/// RG_INTEGER
	external static num get TEXTUREFORMAT_RG_INTEGER;
	
	/// RGB_INTEGER
	external static num get TEXTUREFORMAT_RGB_INTEGER;
	
	/// RGBA_INTEGER
	external static num get TEXTUREFORMAT_RGBA_INTEGER;
	
	/// UNSIGNED_BYTE
	external static num get TEXTURETYPE_UNSIGNED_BYTE;
	
	/// UNSIGNED_BYTE (2nd reference)
	external static num get TEXTURETYPE_UNSIGNED_INT;
	
	/// FLOAT
	external static num get TEXTURETYPE_FLOAT;
	
	/// HALF_FLOAT
	external static num get TEXTURETYPE_HALF_FLOAT;
	
	/// BYTE
	external static num get TEXTURETYPE_BYTE;
	
	/// SHORT
	external static num get TEXTURETYPE_SHORT;
	
	/// UNSIGNED_SHORT
	external static num get TEXTURETYPE_UNSIGNED_SHORT;
	
	/// INT
	external static num get TEXTURETYPE_INT;
	
	/// UNSIGNED_INT
	external static num get TEXTURETYPE_UNSIGNED_INTEGER;
	
	/// UNSIGNED_SHORT_4_4_4_4
	external static num get TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4;
	
	/// UNSIGNED_SHORT_5_5_5_1
	external static num get TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1;
	
	/// UNSIGNED_SHORT_5_6_5
	external static num get TEXTURETYPE_UNSIGNED_SHORT_5_6_5;
	
	/// UNSIGNED_INT_2_10_10_10_REV
	external static num get TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV;
	
	/// UNSIGNED_INT_24_8
	external static num get TEXTURETYPE_UNSIGNED_INT_24_8;
	
	/// UNSIGNED_INT_10F_11F_11F_REV
	external static num get TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;
	
	/// UNSIGNED_INT_5_9_9_9_REV
	external static num get TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV;
	
	/// FLOAT_32_UNSIGNED_INT_24_8_REV
	external static num get TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV;
	
	/// nearest is mag = nearest and min = nearest and mip = linear
	external static num get TEXTURE_NEAREST_SAMPLINGMODE;
	
	/// Bilinear is mag = linear and min = linear and mip = nearest
	external static num get TEXTURE_BILINEAR_SAMPLINGMODE;
	
	/// Trilinear is mag = linear and min = linear and mip = linear
	external static num get TEXTURE_TRILINEAR_SAMPLINGMODE;
	
	/// nearest is mag = nearest and min = nearest and mip = linear
	external static num get TEXTURE_NEAREST_NEAREST_MIPLINEAR;
	
	/// Bilinear is mag = linear and min = linear and mip = nearest
	external static num get TEXTURE_LINEAR_LINEAR_MIPNEAREST;
	
	/// Trilinear is mag = linear and min = linear and mip = linear
	external static num get TEXTURE_LINEAR_LINEAR_MIPLINEAR;
	
	/// mag = nearest and min = nearest and mip = nearest
	external static num get TEXTURE_NEAREST_NEAREST_MIPNEAREST;
	
	/// mag = nearest and min = linear and mip = nearest
	external static num get TEXTURE_NEAREST_LINEAR_MIPNEAREST;
	
	/// mag = nearest and min = linear and mip = linear
	external static num get TEXTURE_NEAREST_LINEAR_MIPLINEAR;
	
	/// mag = nearest and min = linear and mip = none
	external static num get TEXTURE_NEAREST_LINEAR;
	
	/// mag = nearest and min = nearest and mip = none
	external static num get TEXTURE_NEAREST_NEAREST;
	
	/// mag = linear and min = nearest and mip = nearest
	external static num get TEXTURE_LINEAR_NEAREST_MIPNEAREST;
	
	/// mag = linear and min = nearest and mip = linear
	external static num get TEXTURE_LINEAR_NEAREST_MIPLINEAR;
	
	/// mag = linear and min = linear and mip = none
	external static num get TEXTURE_LINEAR_LINEAR;
	
	/// mag = linear and min = nearest and mip = none
	external static num get TEXTURE_LINEAR_NEAREST;
	
	/// Explicit coordinates mode
	external static num get TEXTURE_EXPLICIT_MODE;
	
	/// Spherical coordinates mode
	external static num get TEXTURE_SPHERICAL_MODE;
	
	/// Planar coordinates mode
	external static num get TEXTURE_PLANAR_MODE;
	
	/// Cubic coordinates mode
	external static num get TEXTURE_CUBIC_MODE;
	
	/// Projection coordinates mode
	external static num get TEXTURE_PROJECTION_MODE;
	
	/// Skybox coordinates mode
	external static num get TEXTURE_SKYBOX_MODE;
	
	/// Inverse Cubic coordinates mode
	external static num get TEXTURE_INVCUBIC_MODE;
	
	/// Equirectangular coordinates mode
	external static num get TEXTURE_EQUIRECTANGULAR_MODE;
	
	/// Equirectangular Fixed coordinates mode
	external static num get TEXTURE_FIXED_EQUIRECTANGULAR_MODE;
	
	/// Equirectangular Fixed Mirrored coordinates mode
	external static num get TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
	
	/// Defines that texture rescaling will use a floor to find the closer power of 2 size
	external static num get SCALEMODE_FLOOR;
	
	/// Defines that texture rescaling will look for the nearest power of 2 size
	external static num get SCALEMODE_NEAREST;
	
	/// Defines that texture rescaling will use a ceil to find the closer power of 2 size
	external static num get SCALEMODE_CEILING;
	
	/// Returns the current npm package of the sdk
	@override
	external static String get NpmPackage;
	
	/// Returns the current version of the framework
	@override
	external static String get Version;
	
	/// Gets the list of created engines
	external static List<Engine> get Instances;
	
	/// Gets the latest created engine
	external static Engine? get LastCreatedEngine;
	
	/// Gets the latest created scene
	external static Scene? get LastCreatedScene;
	
	/// Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation
	/// @param flag defines which part of the materials must be marked as dirty
	/// @param predicate defines a predicate used to filter which materials should be affected
	external static void MarkAllMaterialsAsDirty(num flag, [bool Function(Material mat)? predicate]);
	
	/// Method called to create the default loading screen.
	/// This can be overriden in your own app.
	/// @param canvas The rendering canvas element
	/// @returns The loading screen
	external static ILoadingScreen DefaultLoadingScreenFactory(HTML.CanvasElement canvas);
	
	/// Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest
	/// 
	external bool get enableOfflineSupport;
	external set enableOfflineSupport(bool value);
	
	/// Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)
	/// 
	external bool get disableManifestCheck;
	external set disableManifestCheck(bool value);
	
	/// Gets the list of created scenes
	external List<Scene> get scenes;
	external set scenes(List<Scene> value);
	
	/// Event raised when a new scene is created
	external Observable<Scene> get onNewSceneAddedObservable;
	external set onNewSceneAddedObservable(Observable<Scene> value);
	
	/// Gets the list of created postprocesses
	external List<PostProcess> get postProcesses;
	external set postProcesses(List<PostProcess> value);
	
	/// Gets a boolean indicating if the pointer is currently locked
	external bool get isPointerLock;
	external set isPointerLock(bool value);
	
	/// Observable event triggered each time the rendering canvas is resized
	external Observable<Engine> get onResizeObservable;
	external set onResizeObservable(Observable<Engine> value);
	
	/// Observable event triggered each time the canvas loses focus
	external Observable<Engine> get onCanvasBlurObservable;
	external set onCanvasBlurObservable(Observable<Engine> value);
	
	/// Observable event triggered each time the canvas gains focus
	external Observable<Engine> get onCanvasFocusObservable;
	external set onCanvasFocusObservable(Observable<Engine> value);
	
	/// Observable event triggered each time the canvas receives pointerout event
	external Observable<HTML.PointerEvent> get onCanvasPointerOutObservable;
	external set onCanvasPointerOutObservable(Observable<HTML.PointerEvent> value);
	
	/// Observable raised when the engine begins a new frame
	external Observable<Engine> get onBeginFrameObservable;
	external set onBeginFrameObservable(Observable<Engine> value);
	
	/// If set, will be used to request the next animation frame for the render loop
	external ICustomAnimationFrameRequester? get customAnimationFrameRequester;
	external set customAnimationFrameRequester(ICustomAnimationFrameRequester? value);
	
	/// Observable raised when the engine ends the current frame
	external Observable<Engine> get onEndFrameObservable;
	external set onEndFrameObservable(Observable<Engine> value);
	
	/// Observable raised when the engine is about to compile a shader
	external Observable<Engine> get onBeforeShaderCompilationObservable;
	external set onBeforeShaderCompilationObservable(Observable<Engine> value);
	
	/// Observable raised when the engine has jsut compiled a shader
	external Observable<Engine> get onAfterShaderCompilationObservable;
	external set onAfterShaderCompilationObservable(Observable<Engine> value);
	
	/// Gets the audio engine
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
	/// @ignorenaming
	external static IAudioEngine get audioEngine;
	external static set audioEngine(IAudioEngine value);
	
	/// Default AudioEngine factory responsible of creating the Audio Engine.
	/// By default, this will create a BabylonJS Audio Engine if the workload has been embedded.
	external static IAudioEngine Function(HTML.Element? hostElement) get AudioEngineFactory;
	external static set AudioEngineFactory(IAudioEngine Function(HTML.Element? hostElement) value);
	
	/// Default offline support factory responsible of creating a tool used to store data locally.
	/// By default, this will create a Database object if the workload has been embedded.
	external static IOfflineProvider Function(String urlToScene, dynamic Function(bool checked) callbackManifestChecked, bool disableManifestCheck) get OfflineProviderFactory;
	external static set OfflineProviderFactory(IOfflineProvider Function(String urlToScene, dynamic Function(bool checked) callbackManifestChecked, bool disableManifestCheck) value);
	
	/// Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events
	external num get canvasTabIndex;
	external set canvasTabIndex(num value);
	
	/// Turn this value on if you want to pause FPS computation when in background
	external bool get disablePerformanceMonitorInBackground;
	external set disablePerformanceMonitorInBackground(bool value);
	
	/// Gets the performance monitor attached to this engine
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
	external PerformanceMonitor get performanceMonitor;
	
	/// Gets the HTML element used to attach event listeners
	/// @returns a HTML element
	external HTML.Element? getInputElement();
	
	/// Gets current aspect ratio
	/// @param viewportOwner defines the camera to use to get the aspect ratio
	/// @param useScreen defines if screen size must be used (or the current render target if any)
	/// @returns a number defining the aspect ratio
	external num getAspectRatio(IViewportOwnerLike viewportOwner, [bool? useScreen]);
	
	/// Gets current screen aspect ratio
	/// @returns a number defining the aspect ratio
	external num getScreenAspectRatio();
	
	/// Gets the client rect of the HTML canvas attached with the current webGL context
	/// @returns a client rectanglee
	external Math.Rectangle<num>? getRenderingCanvasClientRect();
	
	/// Gets the client rect of the HTML element used for events
	/// @returns a client rectanglee
	external Math.Rectangle<num>? getInputElementClientRect();
	
	/// Gets a boolean indicating that the engine is running in deterministic lock step mode
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @returns true if engine is in deterministic lock step mode
	external bool isDeterministicLockStep();
	
	/// Gets the max steps when engine is running in deterministic lock step
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @returns the max steps
	external num getLockstepMaxSteps();
	
	/// Returns the time in ms between steps when using deterministic lock step.
	/// @returns time step in (ms)
	external num getTimeStep();
	
	/// Force the mipmap generation for the given render target texture
	/// @param texture defines the render target texture to use
	/// @param unbind defines whether or not to unbind the texture after generation. Defaults to true.
	external void generateMipMapsForCubemap(InternalTexture texture, [bool? unbind]);
	
	/// Set various states to the webGL context
	/// @param culling defines backface culling state
	/// @param zOffset defines the value to apply to zOffset (0 by default)
	/// @param force defines if states must be applied even if cache is up to date
	/// @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)
	external void setState(bool culling, [num? zOffset, bool? force, bool? reverseSide]);
	
	/// Set the z offset to apply to current rendering
	/// @param value defines the offset to apply
	external void setZOffset(num value);
	
	/// Gets the current value of the zOffset
	/// @returns the current zOffset state
	external num getZOffset();
	
	/// Enable or disable depth buffering
	/// @param enable defines the state to set
	external void setDepthBuffer(bool enable);
	
	/// Gets a boolean indicating if depth writing is enabled
	/// @returns the current depth writing state
	external bool getDepthWrite();
	
	/// Enable or disable depth writing
	/// @param enable defines the state to set
	external void setDepthWrite(bool enable);
	
	/// Gets a boolean indicating if stencil buffer is enabled
	/// @returns the current stencil buffer state
	external bool getStencilBuffer();
	
	/// Enable or disable the stencil buffer
	/// @param enable defines if the stencil buffer must be enabled or disabled
	external void setStencilBuffer(bool enable);
	
	/// Gets the current stencil mask
	/// @returns a number defining the new stencil mask to use
	external num getStencilMask();
	
	/// Sets the current stencil mask
	/// @param mask defines the new stencil mask to use
	external void setStencilMask(num mask);
	
	/// Gets the current stencil function
	/// @returns a number defining the stencil function to use
	external num getStencilFunction();
	
	/// Gets the current stencil reference value
	/// @returns a number defining the stencil reference value to use
	external num getStencilFunctionReference();
	
	/// Gets the current stencil mask
	/// @returns a number defining the stencil mask to use
	external num getStencilFunctionMask();
	
	/// Sets the current stencil function
	/// @param stencilFunc defines the new stencil function to use
	external void setStencilFunction(num stencilFunc);
	
	/// Sets the current stencil reference
	/// @param reference defines the new stencil reference to use
	external void setStencilFunctionReference(num reference);
	
	/// Sets the current stencil mask
	/// @param mask defines the new stencil mask to use
	external void setStencilFunctionMask(num mask);
	
	/// Gets the current stencil operation when stencil fails
	/// @returns a number defining stencil operation to use when stencil fails
	external num getStencilOperationFail();
	
	/// Gets the current stencil operation when depth fails
	/// @returns a number defining stencil operation to use when depth fails
	external num getStencilOperationDepthFail();
	
	/// Gets the current stencil operation when stencil passes
	/// @returns a number defining stencil operation to use when stencil passes
	external num getStencilOperationPass();
	
	/// Sets the stencil operation to use when stencil fails
	/// @param operation defines the stencil operation to use when stencil fails
	external void setStencilOperationFail(num operation);
	
	/// Sets the stencil operation to use when depth fails
	/// @param operation defines the stencil operation to use when depth fails
	external void setStencilOperationDepthFail(num operation);
	
	/// Sets the stencil operation to use when stencil passes
	/// @param operation defines the stencil operation to use when stencil passes
	external void setStencilOperationPass(num operation);
	
	/// Sets a boolean indicating if the dithering state is enabled or disabled
	/// @param value defines the dithering state
	external void setDitheringState(bool value);
	
	/// Sets a boolean indicating if the rasterizer state is enabled or disabled
	/// @param value defines the rasterizer state
	external void setRasterizerState(bool value);
	
	/// Gets the current depth function
	/// @returns a number defining the depth function
	external num? getDepthFunction();
	
	/// Sets the current depth function
	/// @param depthFunc defines the function to use
	external void setDepthFunction(num depthFunc);
	
	/// Sets the current depth function to GREATER
	external void setDepthFunctionToGreater();
	
	/// Sets the current depth function to GEQUAL
	external void setDepthFunctionToGreaterOrEqual();
	
	/// Sets the current depth function to LESS
	external void setDepthFunctionToLess();
	
	/// Sets the current depth function to LEQUAL
	external void setDepthFunctionToLessOrEqual();
	
	/// Caches the the state of the stencil buffer
	external void cacheStencilState();
	
	/// Restores the state of the stencil buffer
	external void restoreStencilState();
	
	/// Directly set the WebGL Viewport
	/// @param x defines the x coordinate of the viewport (in screen space)
	/// @param y defines the y coordinate of the viewport (in screen space)
	/// @param width defines the width of the viewport (in screen space)
	/// @param height defines the height of the viewport (in screen space)
	/// @return the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state
	external Viewport? setDirectViewport(num x, num y, num width, num height);
	
	/// Executes a scissor clear (ie. a clear on a specific portion of the screen)
	/// @param x defines the x-coordinate of the top left corner of the clear rectangle
	/// @param y defines the y-coordinate of the corner of the clear rectangle
	/// @param width defines the width of the clear rectangle
	/// @param height defines the height of the clear rectangle
	/// @param clearColor defines the clear color
	external void scissorClear(num x, num y, num width, num height, Color4 clearColor);
	
	/// Enable scissor test on a specific rectangle (ie. render will only be executed on a specific portion of the screen)
	/// @param x defines the x-coordinate of the top left corner of the clear rectangle
	/// @param y defines the y-coordinate of the corner of the clear rectangle
	/// @param width defines the width of the clear rectangle
	/// @param height defines the height of the clear rectangle
	external void enableScissor(num x, num y, num width, num height);
	
	/// Disable previously set scissor test rectangle
	external void disableScissor();
	
	/// Initializes a webVR display and starts listening to display change events
	/// The onVRDisplayChangedObservable will be notified upon these changes
	/// @returns The onVRDisplayChangedObservable
	external Observable<IDisplayChangedEventArgs> initWebVR();
	
	/// Call this function to leave webVR mode
	/// Will do nothing if webVR is not supported or if there is no webVR device
	/// @see https://doc.babylonjs.com/how_to/webvr_camera
	external void disableVR();
	
	/// Gets a boolean indicating that the system is in VR mode and is presenting
	/// @returns true if VR mode is engaged
	external bool isVRPresenting();
	
	/// Gets the source code of the vertex shader associated with a specific webGL program
	/// @param program defines the program to use
	/// @returns a string containing the source code of the vertex shader associated with the program
	external String? getVertexShaderSource(WebGL.Program program);
	
	/// Gets the source code of the fragment shader associated with a specific webGL program
	/// @param program defines the program to use
	/// @returns a string containing the source code of the fragment shader associated with the program
	external String? getFragmentShaderSource(WebGL.Program program);
	
	/// Sets a depth stencil texture from a render target to the according uniform.
	/// @param channel The texture channel
	/// @param uniform The uniform to set
	/// @param texture The render target texture containing the depth stencil texture to apply
	external void setDepthStencilTexture(num channel, WebGL.UniformLocation? uniform, RenderTargetTexture? texture);
	
	/// Sets a texture to the webGL context from a postprocess
	/// @param channel defines the channel to use
	/// @param postProcess defines the source postprocess
	external void setTextureFromPostProcess(num channel, PostProcess? postProcess);
	
	/// Binds the output of the passed in post process to the texture channel specified
	/// @param channel The channel the texture should be bound to
	/// @param postProcess The post process which's output should be bound
	external void setTextureFromPostProcessOutput(num channel, PostProcess? postProcess);
	
	/// Toggle full screen mode
	/// @param requestPointerLock defines if a pointer lock should be requested from the user
	external void switchFullscreen(bool requestPointerLock);
	
	/// Enters full screen mode
	/// @param requestPointerLock defines if a pointer lock should be requested from the user
	external void enterFullscreen(bool requestPointerLock);
	
	/// Exits full screen mode
	external void exitFullscreen();
	
	/// Enters Pointerlock mode
	external void enterPointerlock();
	
	/// Exits Pointerlock mode
	external void exitPointerlock();
	
	/// Begin a new frame
	@override
	external void beginFrame();
	
	/// Enf the current frame
	@override
	external void endFrame();
	
	@override
	external void resize();
	
	/// Force a specific size of the canvas
	/// @param width defines the new canvas' width
	/// @param height defines the new canvas' height
	/// @returns true if the size was changed
	@override
	external bool setSize(num width, num height);
	
	@override
	external WebGL.Program createShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, String? defines, [WebGL.RenderingContext? context, List<String>? transformFeedbackVaryings]);
	
	/// Gets the current framerate
	/// @returns a number representing the framerate
	external num getFps();
	
	/// Gets the time spent between current and previous frame
	/// @returns a number representing the delta time in ms
	external num getDeltaTime();
	
	/// Updates the sample count of a render target texture
	/// @see https://doc.babylonjs.com/features/webgl2#multisample-render-targets
	/// @param texture defines the texture to update
	/// @param samples defines the sample count to set
	/// @returns the effective sample count (could be 0 if multisample render targets are not supported)
	external num updateRenderTargetTextureSampleCount(InternalTexture? texture, num samples);
	
	/// Updates a depth texture Comparison Mode and Function.
	/// If the comparison Function is equal to 0, the mode will be set to none.
	/// Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.
	/// @param texture The texture to set the comparison function for
	/// @param comparisonFunction The comparison function to set, 0 if no comparison required
	external void updateTextureComparisonFunction(InternalTexture texture, num comparisonFunction);
	
	/// Creates a webGL buffer to use with instanciation
	/// @param capacity defines the size of the buffer
	/// @returns the webGL buffer
	external DataBuffer createInstancesBuffer(num capacity);
	
	/// Delete a webGL buffer used with instanciation
	/// @param buffer defines the webGL buffer to delete
	external void deleteInstancesBuffer(WebGL.Buffer buffer);
	
	@override
	external void dispose();
	
	/// Display the loading screen
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external void displayLoadingUI();
	
	/// Hide the loading screen
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external void hideLoadingUI();
	
	/// Gets the current loading screen object
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external ILoadingScreen get loadingScreen;
	
	/// Sets the current loading screen object
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external set loadingScreen(ILoadingScreen value);
	
	/// Sets the current loading screen text
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external set loadingUIText(String value);
	
	/// Sets the current loading screen background color
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external set loadingUIBackgroundColor(String value);
	
	/// Creates a new multiview render target
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @returns the created multiview texture
	external InternalTexture createMultiviewRenderTargetTexture(num width, num height);
	
	/// Binds a multiview framebuffer to be drawn to
	/// @param multiviewTexture texture to bind
	external void bindMultiviewFramebuffer(InternalTexture multiviewTexture);
	
	/// Observable signaled when VR display mode changes
	external Observable<IDisplayChangedEventArgs> get onVRDisplayChangedObservable;
	external set onVRDisplayChangedObservable(Observable<IDisplayChangedEventArgs> value);
	
	/// Observable signaled when VR request present is complete
	external Observable<bool> get onVRRequestPresentComplete;
	external set onVRRequestPresentComplete(Observable<bool> value);
	
	/// Observable signaled when VR request present starts
	external Observable<Engine> get onVRRequestPresentStart;
	external set onVRRequestPresentStart(Observable<Engine> value);
	
	/// Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers
	/// @see https://docs.microsoft.com/en-us/microsoft-edge/webvr/essentials#mouse-input
	external bool get isInVRExclusivePointerMode;
	external set isInVRExclusivePointerMode(bool value);
	
	/// Gets a boolean indicating if a webVR device was detected
	/// @returns true if a webVR device was detected
	external bool isVRDevicePresent();
	
	/// Gets the current webVR device
	/// @returns the current webVR device (or null)
	external dynamic getVRDevice();
	
	/// Initializes a webVR display and starts listening to display change events
	/// The onVRDisplayChangedObservable will be notified upon these changes
	/// @returns A promise containing a VRDisplay and if vr is supported
	external Promise<IDisplayChangedEventArgs> initWebVRAsync();
	
	/// Gets or sets the presentation attributes used to configure VR rendering
	external IVRPresentationAttributes get vrPresentationAttributes;
	external set vrPresentationAttributes(IVRPresentationAttributes value);
	
	/// Call this function to switch to webVR mode
	/// Will do nothing if webVR is not supported or if there is no webVR device
	/// @param options the webvr options provided to the camera. mainly used for multiview
	/// @see https://doc.babylonjs.com/how_to/webvr_camera
	external void enableVR(WebVROptions options);
	
	/// Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)
	/// @return the new query
	external WebGL.Query createQuery();
	
	/// Delete and release a webGL query
	/// @param query defines the query to delete
	/// @return the current engine
	external Engine deleteQuery(WebGL.Query query);
	
	/// Check if a given query has resolved and got its value
	/// @param query defines the query to check
	/// @returns true if the query got its value
	external bool isQueryResultAvailable(WebGL.Query query);
	
	/// Gets the value of a given query
	/// @param query defines the query to check
	/// @returns the value of the query
	external num getQueryResult(WebGL.Query query);
	
	/// Initiates an occlusion query
	/// @param algorithmType defines the algorithm to use
	/// @param query defines the query to use
	/// @returns the current engine
	/// @see https://doc.babylonjs.com/features/occlusionquery
	external Engine beginOcclusionQuery(num algorithmType, WebGL.Query query);
	
	/// Ends an occlusion query
	/// @see https://doc.babylonjs.com/features/occlusionquery
	/// @param algorithmType defines the algorithm to use
	/// @returns the current engine
	external Engine endOcclusionQuery(num algorithmType);
	
	/// Starts a time query (used to measure time spent by the GPU on a specific frame)
	/// Please note that only one query can be issued at a time
	/// @returns a time token used to track the time span
	external dynamic /* private _TimeToken */? startTimeQuery();
	
	/// Ends a time query
	/// @param token defines the token used to measure the time span
	/// @returns the time spent (in ns)
	external dynamic endTimeQuery(dynamic /* private _TimeToken */ token);
	
	/// Creates a webGL transform feedback object
	/// Please makes sure to check webGLVersion property to check if you are running webGL 2+
	/// @returns the webGL transform feedback object
	external WebGL.TransformFeedback createTransformFeedback();
	
	/// Delete a webGL transform feedback object
	/// @param value defines the webGL transform feedback object to delete
	external void deleteTransformFeedback(WebGL.TransformFeedback value);
	
	/// Bind a webGL transform feedback object to the webgl context
	/// @param value defines the webGL transform feedback object to bind
	external void bindTransformFeedback(WebGL.TransformFeedback? value);
	
	/// Begins a transform feedback operation
	/// @param usePoints defines if points or triangles must be used
	external void beginTransformFeedback(bool usePoints);
	
	/// Ends a transform feedback operation
	external void endTransformFeedback();
	
	/// Specify the varyings to use with transform feedback
	/// @param program defines the associated webGL program
	/// @param value defines the list of strings representing the varying names
	external void setTranformFeedbackVaryings(WebGL.Program program, List<String> value);
	
	/// Bind a webGL buffer for a transform feedback operation
	/// @param value defines the webGL buffer to bind
	external void bindTransformFeedbackBuffer(DataBuffer? value);
	
	/// Gets or sets the  HTML element to use for attaching events
	external HTML.Element? get inputElement;
	external set inputElement(HTML.Element? value);
	
	/// Gets the current engine view
	/// @see https://doc.babylonjs.com/how_to/multi_canvases
	external EngineView? get activeView;
	external set activeView(EngineView? value);
	
	/// Gets or sets the list of views
	external List<EngineView> get views;
	external set views(List<EngineView> value);
	
	/// Register a new child canvas
	/// @param canvas defines the canvas to register
	/// @param camera defines an optional camera to use with this canvas (it will overwrite the scene.camera for this view)
	/// @returns the associated view
	external EngineView registerView(HTML.CanvasElement canvas, [Camera? camera]);
	
	/// Remove a registered child canvas
	/// @param canvas defines the canvas to remove
	/// @returns the current engine
	external Engine unRegisterView(HTML.CanvasElement canvas);
	
	/// Gets the list of texture formats supported
	external List<String> get texturesSupported;
	
	/// Gets the texture format in use
	external String? get textureFormatInUse;
	
	/// Set the compressed texture extensions or file names to skip.
	/// 
	/// @param skippedFiles defines the list of those texture files you want to skip
	/// Example: [".dds", ".env", "myfile.png"]
	external void setCompressedTextureExclusions(List<String> skippedFiles);
	
	/// Set the compressed texture format to use, based on the formats you have, and the formats
	/// supported by the hardware / browser.
	/// 
	/// Khronos Texture Container (.ktx) files are used to support this.  This format has the
	/// advantage of being specifically designed for OpenGL.  Header elements directly correspond
	/// to API arguments needed to compressed textures.  This puts the burden on the container
	/// generator to house the arcane code for determining these for current & future formats.
	/// 
	/// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
	/// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
	/// 
	/// Note: The result of this call is not taken into account when a texture is base64.
	/// 
	/// @param formatsAvailable defines the list of those format families you have created
	/// on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)
	/// 
	/// Current families are astc, dxt, pvrtc, etc2, & etc1.
	/// @returns The extension selected.
	external String? setTextureFormatToUse(List<String> formatsAvailable);
	
	/// Create an effect to use with particle systems.
	/// Please note that some parameters like animation sheets or not being billboard are not supported in this configuration, except if you pass
	/// the particle system for which you want to create a custom effect in the last parameter
	/// @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)
	/// @param uniformsNames defines a list of attribute names
	/// @param samplers defines an array of string used to represent textures
	/// @param defines defines the string containing the defines to use to compile the shaders
	/// @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails
	/// @param onCompiled defines a function to call when the effect creation is successful
	/// @param onError defines a function to call when the effect creation has failed
	/// @param particleSystem the particle system you want to create the effect for
	/// @returns the new Effect
	external Effect createEffectForParticles(String fragmentName, List<String> uniformsNames, List<String> samplers, String defines, [EffectFallbacks? fallbacks, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, IParticleSystem? particleSystem]);
}

/// This is the base class of all the camera used in the application.
/// @see https://doc.babylonjs.com/features/cameras
@JS()
class Camera extends Node {
	
	/// Instantiates a new camera object.
	/// This should not be used directly but through the inherited cameras: ArcRotate, Free...
	/// @see https://doc.babylonjs.com/features/cameras
	/// @param name Defines the name of the camera in the scene
	/// @param position Defines the position of the camera
	/// @param scene Defines the scene the camera belongs too
	/// @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
	external factory Camera(String name, Vector3 position, Scene scene, [bool? setActiveOnSceneIfNoneActive]);
	
	/// This is the default projection mode used by the cameras.
	/// It helps recreating a feeling of perspective and better appreciate depth.
	/// This is the best way to simulate real life cameras.
	external static num get PERSPECTIVE_CAMERA;
	
	/// This helps creating camera with an orthographic mode.
	/// Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.
	external static num get ORTHOGRAPHIC_CAMERA;
	
	/// This is the default FOV mode for perspective cameras.
	/// This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
	external static num get FOVMODE_VERTICAL_FIXED;
	
	/// This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
	external static num get FOVMODE_HORIZONTAL_FIXED;
	
	/// This specifies ther is no need for a camera rig.
	/// Basically only one eye is rendered corresponding to the camera.
	external static num get RIG_MODE_NONE;
	
	/// Simulates a camera Rig with one blue eye and one red eye.
	/// This can be use with 3d blue and red glasses.
	external static num get RIG_MODE_STEREOSCOPIC_ANAGLYPH;
	
	/// Defines that both eyes of the camera will be rendered side by side with a parallel target.
	external static num get RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL;
	
	/// Defines that both eyes of the camera will be rendered side by side with a none parallel target.
	external static num get RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
	
	/// Defines that both eyes of the camera will be rendered over under each other.
	external static num get RIG_MODE_STEREOSCOPIC_OVERUNDER;
	
	/// Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.
	external static num get RIG_MODE_STEREOSCOPIC_INTERLACED;
	
	/// Defines that both eyes of the camera should be renderered in a VR mode (carbox).
	external static num get RIG_MODE_VR;
	
	/// Defines that both eyes of the camera should be renderered in a VR mode (webVR).
	external static num get RIG_MODE_WEBVR;
	
	/// Custom rig mode allowing rig cameras to be populated manually with any number of cameras
	external static num get RIG_MODE_CUSTOM;
	
	/// Defines if by default attaching controls should prevent the default javascript event to continue.
	external static bool get ForceAttachControlToAlwaysPreventDefault;
	external static set ForceAttachControlToAlwaysPreventDefault(bool value);
	
	/// Define the input manager associated with the camera.
	external CameraInputsManager<Camera> get inputs;
	external set inputs(CameraInputsManager<Camera> value);
	
	/// Define the current local position of the camera in the scene
	external Vector3 get position;
	
	external set position(Vector3 value);
	
	/// The vector the camera should consider as up.
	/// (default is Vector3(0, 1, 0) aka Vector3.Up())
	external set upVector(Vector3 value);
	
	external Vector3 get upVector;
	
	/// Define the current limit on the left side for an orthographic camera
	/// In scene unit
	external num? get orthoLeft;
	external set orthoLeft(num? value);
	
	/// Define the current limit on the right side for an orthographic camera
	/// In scene unit
	external num? get orthoRight;
	external set orthoRight(num? value);
	
	/// Define the current limit on the bottom side for an orthographic camera
	/// In scene unit
	external num? get orthoBottom;
	external set orthoBottom(num? value);
	
	/// Define the current limit on the top side for an orthographic camera
	/// In scene unit
	external num? get orthoTop;
	external set orthoTop(num? value);
	
	/// Field Of View is set in Radians. (default is 0.8)
	external num get fov;
	external set fov(num value);
	
	/// Define the minimum distance the camera can see from.
	/// This is important to note that the depth buffer are not infinite and the closer it starts
	/// the more your scene might encounter depth fighting issue.
	external num get minZ;
	external set minZ(num value);
	
	/// Define the maximum distance the camera can see to.
	/// This is important to note that the depth buffer are not infinite and the further it end
	/// the more your scene might encounter depth fighting issue.
	external num get maxZ;
	external set maxZ(num value);
	
	/// Define the default inertia of the camera.
	/// This helps giving a smooth feeling to the camera movement.
	external num get inertia;
	external set inertia(num value);
	
	/// Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
	external num get mode;
	external set mode(num value);
	
	/// Define whether the camera is intermediate.
	/// This is useful to not present the output directly to the screen in case of rig without post process for instance
	external bool get isIntermediate;
	external set isIntermediate(bool value);
	
	/// Define the viewport of the camera.
	/// This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.
	external Viewport get viewport;
	external set viewport(Viewport value);
	
	/// Restricts the camera to viewing objects with the same layerMask.
	/// A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0
	external num get layerMask;
	external set layerMask(num value);
	
	/// fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)
	external num get fovMode;
	external set fovMode(num value);
	
	/// Rig mode of the camera.
	/// This is useful to create the camera with two "eyes" instead of one to create VR or stereoscopic scenes.
	/// This is normally controlled byt the camera themselves as internal use.
	external num get cameraRigMode;
	external set cameraRigMode(num value);
	
	/// Defines the distance between both "eyes" in case of a RIG
	external num get interaxialDistance;
	external set interaxialDistance(num value);
	
	/// Defines if stereoscopic rendering is done side by side or over under.
	external bool get isStereoscopicSideBySide;
	external set isStereoscopicSideBySide(bool value);
	
	/// Defines the list of custom render target which are rendered to and then used as the input to this camera's render. Eg. display another camera view on a TV in the main scene
	/// This is pretty helpfull if you wish to make a camera render to a texture you could reuse somewhere
	/// else in the scene. (Eg. security camera)
	/// 
	/// To change the final output target of the camera, camera.outputRenderTarget should be used instead (eg. webXR renders to a render target corrisponding to an HMD)
	external List<RenderTargetTexture> get customRenderTargets;
	external set customRenderTargets(List<RenderTargetTexture> value);
	
	/// When set, the camera will render to this render target instead of the default canvas
	/// 
	/// If the desire is to use the output of a camera as a texture in the scene consider using camera.customRenderTargets instead
	external RenderTargetTexture? get outputRenderTarget;
	external set outputRenderTarget(RenderTargetTexture? value);
	
	/// Observable triggered when the camera view matrix has changed.
	external Observable<Camera> get onViewMatrixChangedObservable;
	external set onViewMatrixChangedObservable(Observable<Camera> value);
	
	/// Observable triggered when the camera Projection matrix has changed.
	external Observable<Camera> get onProjectionMatrixChangedObservable;
	external set onProjectionMatrixChangedObservable(Observable<Camera> value);
	
	/// Observable triggered when the inputs have been processed.
	external Observable<Camera> get onAfterCheckInputsObservable;
	external set onAfterCheckInputsObservable(Observable<Camera> value);
	
	/// Observable triggered when reset has been called and applied to the camera.
	external Observable<Camera> get onRestoreStateObservable;
	external set onRestoreStateObservable(Observable<Camera> value);
	
	/// Is this camera a part of a rig system?
	external bool get isRigCamera;
	external set isRigCamera(bool value);
	
	/// If isRigCamera set to true this will be set with the parent camera.
	/// The parent camera is not (!) necessarily the .parent of this camera (like in the case of XR)
	external Camera get rigParent;
	external set rigParent(Camera value);
	
	/// Store current camera state (fov, position, etc..)
	/// @returns the camera
	external Camera storeState();
	
	/// Restored camera state. You must call storeState() first.
	/// @returns true if restored and false otherwise
	external bool restoreState();
	
	/// Gets the class name of the camera.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets a string representation of the camera useful for debug purpose.
	/// @param fullDetails Defines that a more verboe level of logging is required
	/// @returns the string representation
	external String toString([bool? fullDetails]);
	
	/// Gets the current world space position of the camera.
	external Vector3 get globalPosition;
	
	/// Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
	/// @returns the active meshe list
	external SmartArray<AbstractMesh> getActiveMeshes();
	
	/// Check whether a mesh is part of the current active mesh list of the camera
	/// @param mesh Defines the mesh to check
	/// @returns true if active, false otherwise
	external bool isActiveMesh(Mesh mesh);
	
	/// Is this camera ready to be used/rendered
	/// @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
	/// @return true if the camera is ready
	@override
	external bool isReady([bool? completeCheck]);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	external void detachControl();
	
	/// Update the camera state according to the different inputs gathered during the frame.
	external void update();
	
	/// @hidden
	external List<Camera> get rigCameras;
	
	/// Gets the post process used by the rig cameras
	external PostProcess? get rigPostProcess;
	
	/// Attach a post process to the camera.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#attach-postprocess
	/// @param postProcess The post process to attach to the camera
	/// @param insertAt The position of the post process in case several of them are in use in the scene
	/// @returns the position the post process has been inserted at
	external num attachPostProcess(PostProcess postProcess, [num? insertAt]);
	
	/// Detach a post process to the camera.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#attach-postprocess
	/// @param postProcess The post process to detach from the camera
	external void detachPostProcess(PostProcess postProcess);
	
	/// Gets the current world matrix of the camera
	@override
	external Matrix getWorldMatrix();
	
	/// Gets the current view matrix of the camera.
	/// @param force forces the camera to recompute the matrix without looking at the cached state
	/// @returns the view matrix
	external Matrix getViewMatrix([bool? force]);
	
	/// Freeze the projection matrix.
	/// It will prevent the cache check of the camera projection compute and can speed up perf
	/// if no parameter of the camera are meant to change
	/// @param projection Defines manually a projection if necessary
	external void freezeProjectionMatrix([Matrix? projection]);
	
	/// Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
	external void unfreezeProjectionMatrix();
	
	/// Gets the current projection matrix of the camera.
	/// @param force forces the camera to recompute the matrix without looking at the cached state
	/// @returns the projection matrix
	external Matrix getProjectionMatrix([bool? force]);
	
	/// Gets the transformation matrix (ie. the multiplication of view by projection matrices)
	/// @returns a Matrix
	external Matrix getTransformationMatrix();
	
	/// Checks if a cullable object (mesh...) is in the camera frustum
	/// This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
	/// @param target The object to check
	/// @param checkRigCameras If the rig cameras should be checked (eg. with webVR camera both eyes should be checked) (Default: false)
	/// @returns true if the object is in frustum otherwise false
	external bool isInFrustum(ICullable target, [bool? checkRigCameras]);
	
	/// Checks if a cullable object (mesh...) is in the camera frustum
	/// Unlike isInFrustum this cheks the full bounding box
	/// @param target The object to check
	/// @returns true if the object is in frustum otherwise false
	external bool isCompletelyInFrustum(ICullable target);
	
	/// Gets a ray in the forward direction from the camera.
	/// @param length Defines the length of the ray to create
	/// @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray
	/// @param origin Defines the start point of the ray which defaults to the camera position
	/// @returns the forward ray
	external Ray getForwardRay([num? length, Matrix? transform, Vector3? origin]);
	
	/// Gets a ray in the forward direction from the camera.
	/// @param refRay the ray to (re)use when setting the values
	/// @param length Defines the length of the ray to create
	/// @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray
	/// @param origin Defines the start point of the ray which defaults to the camera position
	/// @returns the forward ray
	external Ray getForwardRayToRef(Ray refRay, [num? length, Matrix? transform, Vector3? origin]);
	
	/// Releases resources associated with this node.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Gets the left camera of a rig setup in case of Rigged Camera
	external bool get isLeftCamera;
	
	/// Gets the right camera of a rig setup in case of Rigged Camera
	external bool get isRightCamera;
	
	/// Gets the left camera of a rig setup in case of Rigged Camera
	external FreeCamera? get leftCamera;
	
	/// Gets the right camera of a rig setup in case of Rigged Camera
	external FreeCamera? get rightCamera;
	
	/// Gets the left camera target of a rig setup in case of Rigged Camera
	/// @returns the target position
	external Vector3? getLeftTarget();
	
	/// Gets the right camera target of a rig setup in case of Rigged Camera
	/// @returns the target position
	external Vector3? getRightTarget();
	
	/// @hidden
	external void setCameraRigMode(num mode, dynamic rigParams);
	
	/// @hidden
	external void setCameraRigParameter(String name, dynamic value);
	
	/// needs to be overridden by children so sub has required properties to be copied
	/// @hidden
	external Camera? createRigCamera(String name, num cameraIndex);
	
	/// Serialiaze the camera setup to a json represention
	/// @returns the JSON representation
	external dynamic serialize();
	
	/// Clones the current camera.
	/// @param name The cloned camera name
	/// @returns the cloned camera
	external Camera clone(String name);
	
	/// Gets the direction of the camera relative to a given local axis.
	/// @param localAxis Defines the reference axis to provide a relative direction.
	/// @return the direction
	external Vector3 getDirection(Vector3 localAxis);
	
	/// Returns the current camera absolute rotation
	external Quaternion get absoluteRotation;
	
	/// Gets the direction of the camera relative to a given local axis into a passed vector.
	/// @param localAxis Defines the reference axis to provide a relative direction.
	/// @param result Defines the vector to store the result in
	external void getDirectionToRef(Vector3 localAxis, Vector3 result);
	
	/// Gets a camera constructor for a given camera type
	/// @param type The type of the camera to construct (should be equal to one of the camera class name)
	/// @param name The name of the camera the result will be able to instantiate
	/// @param scene The scene the result will construct the camera in
	/// @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
	/// @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
	/// @returns a factory method to construc the camera
	external static Camera Function() GetConstructorFromName(String type, String name, Scene scene, [num? interaxial_distance, bool? isStereoscopicSideBySide]);
	
	/// Compute the world  matrix of the camera.
	/// @returns the camera world matrix
	@override
	external Matrix computeWorldMatrix([bool? force]);
	
	/// Parse a JSON and creates the camera from the parsed information
	/// @param parsedCamera The JSON to parse
	/// @param scene The scene to instantiate the camera in
	/// @returns the newly constructed camera
	external static Camera Parse(dynamic parsedCamera, Scene scene);
}

/// VRMultiviewToSingleview used to convert multiview texture arrays to standard textures for scenarios such as webVR
/// This will not be used for webXR as it supports displaying texture arrays directly
@JS()
class VRMultiviewToSingleviewPostProcess extends PostProcess {
	
	/// Initializes a VRMultiviewToSingleview
	/// @param name name of the post process
	/// @param camera camera to be applied to
	/// @param scaleFactor scaling factor to the size of the output texture
	external factory VRMultiviewToSingleviewPostProcess(String name, Camera camera, num scaleFactor);
	
	/// Gets a string identifying the name of the class
	/// @returns "VRMultiviewToSingleviewPostProcess" string
	@override
	external String getClassName();
}

/// Interface used to define additional presentation attributes
@JS()
@anonymous
class IVRPresentationAttributes {
	
	external factory IVRPresentationAttributes({bool highRefreshRate, num foveationLevel});
	
	/// Defines a boolean indicating that we want to get 72hz mode on Oculus Browser (default is off eg. 60hz)
	external bool get highRefreshRate;
	external set highRefreshRate( bool value );
	
	/// Enables foveation in VR to improve perf. 0 none, 1 low, 2 medium, 3 high (Default is 1)
	external num get foveationLevel;
	external set foveationLevel( num value );
}

/// This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose
/// IMPORTANT!! The data is right-hand data.
/// @export
/// @interface DevicePose
@JS()
@anonymous
class DevicePose {
	
	external factory DevicePose({Float32List? position, Float32List? linearVelocity, Float32List? linearAcceleration, Float32List? orientation, Float32List? angularVelocity, Float32List? angularAcceleration});
	
	/// The position of the device, values in array are [x,y,z].
	external Float32List? get position;
	external set position( Float32List? value );
	
	/// The linearVelocity of the device, values in array are [x,y,z].
	external Float32List? get linearVelocity;
	external set linearVelocity( Float32List? value );
	
	/// The linearAcceleration of the device, values in array are [x,y,z].
	external Float32List? get linearAcceleration;
	external set linearAcceleration( Float32List? value );
	
	/// The orientation of the device in a quaternion array, values in array are [x,y,z,w].
	external Float32List? get orientation;
	external set orientation( Float32List? value );
	
	/// The angularVelocity of the device, values in array are [x,y,z].
	external Float32List? get angularVelocity;
	external set angularVelocity( Float32List? value );
	
	/// The angularAcceleration of the device, values in array are [x,y,z].
	external Float32List? get angularAcceleration;
	external set angularAcceleration( Float32List? value );
}

/// Interface representing a pose controlled object in Babylon.
/// A pose controlled object has both regular pose values as well as pose values
/// from an external device such as a VR head mounted display
@JS()
abstract class PoseControlled {
	
	/// The position of the object in babylon space.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// The rotation quaternion of the object in babylon space.
	external Quaternion get rotationQuaternion;
	external set rotationQuaternion(Quaternion value);
	
	/// The position of the device in babylon space.
	external Vector3 get devicePosition;
	external set devicePosition(Vector3 value);
	
	/// The rotation quaternion of the device in babylon space.
	external Quaternion get deviceRotationQuaternion;
	external set deviceRotationQuaternion(Quaternion value);
	
	/// The raw pose coming from the device.
	external DevicePose? get rawPose;
	external set rawPose(DevicePose? value);
	
	/// The scale of the device to be used when translating from device space to babylon space.
	external num get deviceScaleFactor;
	external set deviceScaleFactor(num value);
	
	/// Updates the poseControlled values based on the input device pose.
	/// @param poseData the pose data to update the object with
	external void updateFromDevice(DevicePose poseData);
}

/// Set of options to customize the webVRCamera
@JS()
abstract class WebVROptions {
	
	/// Sets if the webVR camera should be tracked to the vrDevice. (default: true)
	external bool get trackPosition;
	external set trackPosition(bool value);
	
	/// Sets the scale of the vrDevice in babylon space. (default: 1)
	external num get positionScale;
	external set positionScale(num value);
	
	/// If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)
	external String get displayName;
	external set displayName(String value);
	
	/// Should the native controller meshes be initialized. (default: true)
	external bool get controllerMeshes;
	external set controllerMeshes(bool value);
	
	/// Creating a default HemiLight only on controllers. (default: true)
	external bool get defaultLightingOnControllers;
	external set defaultLightingOnControllers(bool value);
	
	/// If you don't want to use the default VR button of the helper. (default: false)
	external bool get useCustomVRButton;
	external set useCustomVRButton(bool value);
	
	/// If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)
	external HTML.ButtonElement get customVRButton;
	external set customVRButton(HTML.ButtonElement value);
	
	/// To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)
	external num get rayLength;
	external set rayLength(num value);
	
	/// To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)
	external num get defaultHeight;
	external set defaultHeight(num value);
	
	/// If multiview should be used if availible (default: false)
	external bool get useMultiview;
	external set useMultiview(bool value);
}

/// This represents a WebVR camera.
/// The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
/// @example https://doc.babylonjs.com/how_to/webvr_camera
@JS()
class WebVRFreeCamera extends FreeCamera implements PoseControlled {
	
	/// Instantiates a WebVRFreeCamera.
	/// @param name The name of the WebVRFreeCamera
	/// @param position The starting anchor position for the camera
	/// @param scene The scene the camera belongs to
	/// @param webVROptions a set of customizable options for the webVRCamera
	external factory WebVRFreeCamera(String name, Vector3 position, Scene scene, [WebVROptions? webVROptions]);
	
	/// The rawPose of the vrDevice.
	@override
	external DevicePose? get rawPose;
	@override
	external set rawPose(DevicePose? value);
	
	/// Represents device position in babylon space.
	@override
	external Vector3 get devicePosition;
	@override
	external set devicePosition(Vector3 value);
	
	/// Represents device rotation in babylon space.
	@override
	external Quaternion get deviceRotationQuaternion;
	@override
	external set deviceRotationQuaternion(Quaternion value);
	
	/// The scale of the device to be used when translating from device space to babylon space.
	@override
	external num get deviceScaleFactor;
	@override
	external set deviceScaleFactor(num value);
	
	/// References to the webVR controllers for the vrDevice.
	external List<WebVRController> get controllers;
	external set controllers(List<WebVRController> value);
	
	/// Emits an event when a controller is attached.
	external Observable<List<WebVRController>> get onControllersAttachedObservable;
	external set onControllersAttachedObservable(Observable<List<WebVRController>> value);
	
	/// Emits an event when a controller's mesh has been loaded;
	external Observable<WebVRController> get onControllerMeshLoadedObservable;
	external set onControllerMeshLoadedObservable(Observable<WebVRController> value);
	
	/// Emits an event when the HMD's pose has been updated.
	external Observable<dynamic> get onPoseUpdatedFromDeviceObservable;
	external set onPoseUpdatedFromDeviceObservable(Observable<dynamic> value);
	
	/// If the rig cameras be used as parent instead of this camera.
	external bool get rigParenting;
	external set rigParenting(bool value);
	
	/// Gets the device distance from the ground in meters.
	/// @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.
	external num deviceDistanceToRoomGround();
	
	/// Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
	/// @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.
	external void useStandingMatrix([void Function(bool bool)? callback]);
	
	/// Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
	/// @returns A promise with a boolean set to if the standing matrix is supported.
	external Promise<bool> useStandingMatrixAsync();
	
	/// Disposes the camera
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Gets a vrController by name.
	/// @param name The name of the controller to retreive
	/// @returns the controller matching the name specified or null if not found
	external WebVRController? getControllerByName(String name);
	
	/// The controller corresponding to the users left hand.
	external WebVRController? get leftController;
	
	/// The controller corresponding to the users right hand.
	external WebVRController? get rightController;
	
	/// Casts a ray forward from the vrCamera's gaze.
	/// @param length Length of the ray (default: 100)
	/// @returns the ray corresponding to the gaze
	@override
	external Ray getForwardRay([num? length, Matrix? transform, Vector3? origin]);
	
	/// Updates the poseControlled values based on the input device pose.
	/// @param poseData Pose coming from the device
	@override
	external void updateFromDevice(DevicePose poseData);
	
	/// WebVR's attach control will start broadcasting frames to the device.
	/// Note that in certain browsers (chrome for example) this function must be called
	/// within a user-interaction callback. Example:
	/// <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>
	/// 
	/// @param noPreventDefault prevent the default html element operation when attaching the vrDevice
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// @returns the name of this class
	@override
	external String getClassName();
	
	/// Calls resetPose on the vrDisplay
	/// See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
	external void resetToCurrentRotation();
	
	/// Updates the current device position and rotation in the babylon world
	@override
	external void update();
	
	/// Initializes the controllers and their meshes
	external void initControllers();
	
	/// The position of the object in babylon space.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// The rotation quaternion of the object in babylon space.
	external Quaternion get rotationQuaternion;
	external set rotationQuaternion(Quaternion value);
}

/// "Static Class" containing the most commonly used helper while dealing with material for rendering purpose.
/// 
/// It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
/// 
/// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
@JS()
class MaterialHelper {
	external factory MaterialHelper();
	
	/// Bind the current view position to an effect.
	/// @param effect The effect to be bound
	/// @param scene The scene the eyes position is used from
	/// @param variableName name of the shader variable that will hold the eye position
	external static void BindEyePosition(Effect effect, Scene scene, [String? variableName]);
	
	/// Helps preparing the defines values about the UVs in used in the effect.
	/// UVs are shared as much as we can accross channels in the shaders.
	/// @param texture The texture we are preparing the UVs for
	/// @param defines The defines to update
	/// @param key The channel key "diffuse", "specular"... used in the shader
	external static void PrepareDefinesForMergedUV(BaseTexture texture, dynamic defines, String key);
	
	/// Binds a texture matrix value to its corrsponding uniform
	/// @param texture The texture to bind the matrix for
	/// @param uniformBuffer The uniform buffer receivin the data
	/// @param key The channel key "diffuse", "specular"... used in the shader
	external static void BindTextureMatrix(BaseTexture texture, UniformBuffer uniformBuffer, String key);
	
	/// Gets the current status of the fog (should it be enabled?)
	/// @param mesh defines the mesh to evaluate for fog support
	/// @param scene defines the hosting scene
	/// @returns true if fog must be enabled
	external static bool GetFogState(AbstractMesh mesh, Scene scene);
	
	/// Helper used to prepare the list of defines associated with misc. values for shader compilation
	/// @param mesh defines the current mesh
	/// @param scene defines the current scene
	/// @param useLogarithmicDepth defines if logarithmic depth has to be turned on
	/// @param pointsCloud defines if point cloud rendering has to be turned on
	/// @param fogEnabled defines if fog has to be turned on
	/// @param alphaTest defines if alpha testing has to be turned on
	/// @param defines defines the current list of defines
	external static void PrepareDefinesForMisc(AbstractMesh mesh, Scene scene, bool useLogarithmicDepth, bool pointsCloud, bool fogEnabled, bool alphaTest, dynamic defines);
	
	/// Helper used to prepare the list of defines associated with frame values for shader compilation
	/// @param scene defines the current scene
	/// @param engine defines the current engine
	/// @param defines specifies the list of active defines
	/// @param useInstances defines if instances have to be turned on
	/// @param useClipPlane defines if clip plane have to be turned on
	/// @param useInstances defines if instances have to be turned on
	/// @param useThinInstances defines if thin instances have to be turned on
	external static void PrepareDefinesForFrameBoundValues(Scene scene, Engine engine, dynamic defines, bool useInstances, [bool? useClipPlane, bool? useThinInstances]);
	
	/// Prepares the defines for bones
	/// @param mesh The mesh containing the geometry data we will draw
	/// @param defines The defines to update
	external static void PrepareDefinesForBones(AbstractMesh mesh, dynamic defines);
	
	/// Prepares the defines for morph targets
	/// @param mesh The mesh containing the geometry data we will draw
	/// @param defines The defines to update
	external static void PrepareDefinesForMorphTargets(AbstractMesh mesh, dynamic defines);
	
	/// Prepares the defines used in the shader depending on the attributes data available in the mesh
	/// @param mesh The mesh containing the geometry data we will draw
	/// @param defines The defines to update
	/// @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)
	/// @param useBones Precise whether bones should be used or not (override mesh info)
	/// @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)
	/// @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)
	/// @returns false if defines are considered not dirty and have not been checked
	external static bool PrepareDefinesForAttributes(AbstractMesh mesh, dynamic defines, bool useVertexColor, bool useBones, [bool? useMorphTargets, bool? useVertexAlpha]);
	
	/// Prepares the defines related to multiview
	/// @param scene The scene we are intending to draw
	/// @param defines The defines to update
	external static void PrepareDefinesForMultiview(Scene scene, dynamic defines);
	
	/// Prepares the defines related to the prepass
	/// @param scene The scene we are intending to draw
	/// @param defines The defines to update
	/// @param canRenderToMRT Indicates if this material renders to several textures in the prepass
	external static void PrepareDefinesForPrePass(Scene scene, dynamic defines, bool canRenderToMRT);
	
	/// Prepares the defines related to the light information passed in parameter
	/// @param scene The scene we are intending to draw
	/// @param mesh The mesh the effect is compiling for
	/// @param light The light the effect is compiling for
	/// @param lightIndex The index of the light
	/// @param defines The defines to update
	/// @param specularSupported Specifies whether specular is supported or not (override lights data)
	/// @param state Defines the current state regarding what is needed (normals, etc...)
	external static void PrepareDefinesForLight(Scene scene, AbstractMesh mesh, Light light, num lightIndex, dynamic defines, bool specularSupported, MaterialHelperPrepareDefinesForLightState state);
	
	/// Prepares the defines related to the light information passed in parameter
	/// @param scene The scene we are intending to draw
	/// @param mesh The mesh the effect is compiling for
	/// @param defines The defines to update
	/// @param specularSupported Specifies whether specular is supported or not (override lights data)
	/// @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max
	/// @param disableLighting Specifies whether the lighting is disabled (override scene and light)
	/// @returns true if normals will be required for the rest of the effect
	external static bool PrepareDefinesForLights(Scene scene, AbstractMesh mesh, dynamic defines, bool specularSupported, [num? maxSimultaneousLights, bool? disableLighting]);
	
	/// Prepares the uniforms and samplers list to be used in the effect (for a specific light)
	/// @param lightIndex defines the light index
	/// @param uniformsList The uniform list
	/// @param samplersList The sampler list
	/// @param projectedLightTexture defines if projected texture must be used
	/// @param uniformBuffersList defines an optional list of uniform buffers
	/// @param updateOnlyBuffersList True to only update the uniformBuffersList array
	external static void PrepareUniformsAndSamplersForLight(num lightIndex, List<String> uniformsList, List<String> samplersList, [dynamic? projectedLightTexture, List<String>? uniformBuffersList, bool? updateOnlyBuffersList]);
	
	/// Prepares the uniforms and samplers list to be used in the effect
	/// @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information
	/// @param samplersList The sampler list
	/// @param defines The defines helping in the list generation
	/// @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect
	external static void PrepareUniformsAndSamplersList(dynamic uniformsListOrOptions, [List<String>? samplersList, dynamic? defines, num? maxSimultaneousLights]);
	
	/// This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)
	/// @param defines The defines to update while falling back
	/// @param fallbacks The authorized effect fallbacks
	/// @param maxSimultaneousLights The maximum number of lights allowed
	/// @param rank the current rank of the Effect
	/// @returns The newly affected rank
	external static num HandleFallbacksForShadows(dynamic defines, EffectFallbacks fallbacks, [num? maxSimultaneousLights, num? rank]);
	
	/// Prepares the list of attributes required for morph targets according to the effect defines.
	/// @param attribs The current list of supported attribs
	/// @param mesh The mesh to prepare the morph targets attributes for
	/// @param influencers The number of influencers
	external static void PrepareAttributesForMorphTargetsInfluencers(List<String> attribs, AbstractMesh mesh, num influencers);
	
	/// Prepares the list of attributes required for morph targets according to the effect defines.
	/// @param attribs The current list of supported attribs
	/// @param mesh The mesh to prepare the morph targets attributes for
	/// @param defines The current Defines of the effect
	external static void PrepareAttributesForMorphTargets(List<String> attribs, AbstractMesh mesh, dynamic defines);
	
	/// Prepares the list of attributes required for bones according to the effect defines.
	/// @param attribs The current list of supported attribs
	/// @param mesh The mesh to prepare the bones attributes for
	/// @param defines The current Defines of the effect
	/// @param fallbacks The current efffect fallback strategy
	external static void PrepareAttributesForBones(List<String> attribs, AbstractMesh mesh, dynamic defines, EffectFallbacks fallbacks);
	
	/// Check and prepare the list of attributes required for instances according to the effect defines.
	/// @param attribs The current list of supported attribs
	/// @param defines The current MaterialDefines of the effect
	external static void PrepareAttributesForInstances(List<String> attribs, MaterialDefines defines);
	
	/// Add the list of attributes required for instances to the attribs array.
	/// @param attribs The current list of supported attribs
	external static void PushAttributesForInstances(List<String> attribs);
	
	/// Binds the light information to the effect.
	/// @param light The light containing the generator
	/// @param effect The effect we are binding the data to
	/// @param lightIndex The light index in the effect used to render
	external static void BindLightProperties(Light light, Effect effect, num lightIndex);
	
	/// Binds the lights information from the scene to the effect for the given mesh.
	/// @param light Light to bind
	/// @param lightIndex Light index
	/// @param scene The scene where the light belongs to
	/// @param effect The effect we are binding the data to
	/// @param useSpecular Defines if specular is supported
	/// @param rebuildInParallel Specifies whether the shader is rebuilding in parallel
	external static void BindLight(Light light, num lightIndex, Scene scene, Effect effect, bool useSpecular, [bool? rebuildInParallel]);
	
	/// Binds the lights information from the scene to the effect for the given mesh.
	/// @param scene The scene the lights belongs to
	/// @param mesh The mesh we are binding the information to render
	/// @param effect The effect we are binding the data to
	/// @param defines The generated defines for the effect
	/// @param maxSimultaneousLights The maximum number of light that can be bound to the effect
	/// @param rebuildInParallel Specifies whether the shader is rebuilding in parallel
	external static void BindLights(Scene scene, AbstractMesh mesh, Effect effect, dynamic defines, [num? maxSimultaneousLights, bool? rebuildInParallel]);
	
	/// Binds the fog information from the scene to the effect for the given mesh.
	/// @param scene The scene the lights belongs to
	/// @param mesh The mesh we are binding the information to render
	/// @param effect The effect we are binding the data to
	/// @param linearSpace Defines if the fog effect is applied in linear space
	external static void BindFogParameters(Scene scene, AbstractMesh mesh, Effect effect, [bool? linearSpace]);
	
	/// Binds the bones information from the mesh to the effect.
	/// @param mesh The mesh we are binding the information to render
	/// @param effect The effect we are binding the data to
	/// @param prePassConfiguration Configuration for the prepass, in case prepass is activated
	external static void BindBonesParameters([AbstractMesh? mesh, Effect? effect, PrePassConfiguration? prePassConfiguration]);
	
	/// Binds the morph targets information from the mesh to the effect.
	/// @param abstractMesh The mesh we are binding the information to render
	/// @param effect The effect we are binding the data to
	external static void BindMorphTargetParameters(AbstractMesh abstractMesh, Effect effect);
	
	/// Binds the logarithmic depth information from the scene to the effect for the given defines.
	/// @param defines The generated defines used in the effect
	/// @param effect The effect we are binding the data to
	/// @param scene The scene we are willing to render with logarithmic scale for
	external static void BindLogDepth(dynamic defines, Effect effect, Scene scene);
	
	/// Binds the clip plane information from the scene to the effect.
	/// @param scene The scene the clip plane information are extracted from
	/// @param effect The effect we are binding the data to
	external static void BindClipPlane(Effect effect, Scene scene);
}

/* var */
/// @hidden
@JS()
external dynamic get bayerDitherFunctions;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapFragment;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapVertexNormalBias;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapVertexMetric;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapVertexShader;

/* var */
/// @hidden
@JS()
external dynamic get depthBoxBlurPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get shadowMapFragmentSoftTransparentShadow;

/// Creates an instance based on a source mesh.
@JS()
class InstancedMesh extends AbstractMesh {
	
	external factory InstancedMesh(String name, Mesh source);
	
	/// Returns the string "InstancedMesh".
	@override
	external String getClassName();
	
	/// Gets the list of lights affecting that mesh
	@override
	external List<Light> get lightSources;
	
	/// If the source mesh receives shadows
	@override
	external bool get receiveShadows;
	
	/// The material of the source mesh
	@override
	external Material? get material;
	
	/// Visibility of the source mesh
	@override
	external num get visibility;
	
	/// Skeleton of the source mesh
	@override
	external Skeleton? get skeleton;
	
	/// Rendering ground id of the source mesh
	@override
	external num get renderingGroupId;
	
	@override
	external set renderingGroupId(num value);
	
	/// Returns the total number of vertices (integer).
	@override
	external num getTotalVertices();
	
	/// Returns a positive integer : the total number of indices in this mesh geometry.
	/// @returns the numner of indices or zero if the mesh has no geometry.
	@override
	external num getTotalIndices();
	
	/// The source mesh of the instance
	external Mesh get sourceMesh;
	
	/// Creates a new InstancedMesh object from the mesh model.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_instances
	/// @param name defines the name of the new instance
	/// @returns a new InstancedMesh
	external InstancedMesh createInstance(String name);
	
	/// Is this node ready to be used/rendered
	/// @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
	/// @return {boolean} is it ready
	@override
	external bool isReady([bool? completeCheck]);
	
	/// Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
	/// @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)
	/// @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
	/// @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.
	@override
	external dynamic? getVerticesData(String kind, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Sets the vertex data of the mesh geometry for the requested `kind`.
	/// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
	/// The `data` are either a numeric array either a Float32Array.
	/// The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
	/// The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
	/// Note that a new underlying VertexBuffer object is created each call.
	/// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
	/// 
	/// Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// 
	/// Returns the Mesh.
	@override
	external AbstractMesh setVerticesData(String kind, dynamic data, [bool? updatable, num? stride]);
	
	/// Updates the existing vertex data of the mesh geometry for the requested `kind`.
	/// If the mesh has no geometry, it is simply returned as it is.
	/// The `data` are either a numeric array either a Float32Array.
	/// No new underlying VertexBuffer object is created.
	/// If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
	/// If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
	/// 
	/// Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// 
	/// Returns the Mesh.
	@override
	external Mesh updateVerticesData(String kind, dynamic data, [bool? updateExtends, bool? makeItUnique]);
	
	/// Sets the mesh indices.
	/// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
	/// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
	/// This method creates a new index buffer each call.
	/// Returns the Mesh.
	@override
	external Mesh setIndices(dynamic indices, [num? totalVertices, bool? updatable]);
	
	/// Boolean : True if the mesh owns the requested kind of data.
	@override
	external bool isVerticesDataPresent(String kind);
	
	/// Returns an array of indices (IndicesArray).
	@override
	external dynamic? getIndices([bool? copyWhenShared, bool? forceCopy]);
	
	/// This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
	/// This means the mesh underlying bounding box and sphere are recomputed.
	/// @param applySkeleton defines whether to apply the skeleton before computing the bounding info
	/// @returns the current mesh
	@override
	external InstancedMesh refreshBoundingInfo([bool? applySkeleton]);
	
	@override
	external Matrix getWorldMatrix();
	
	@override
	external bool get isAnInstance;
	
	/// Returns the current associated LOD AbstractMesh.
	@override
	external AbstractMesh? getLOD(Camera camera);
	
	/// Creates a new InstancedMesh from the current mesh.
	/// - name (string) : the cloned mesh name
	/// - newParent (optional Node) : the optional Node to parent the clone to.
	/// - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
	/// 
	/// Returns the clone.
	@override
	external InstancedMesh? clone(String? name, [Node? newParent, bool? doNotCloneChildren]);
	
	/// Disposes the InstancedMesh.
	/// Returns nothing.
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
}

/// Class used to represent renderable models
@JS()
class Mesh extends AbstractMesh implements IGetSetVerticesData {
	
	/// @constructor
	/// @param name The value used by scene.getMeshByName() to do a lookup.
	/// @param scene The scene to add this mesh to.
	/// @param parent The parent of this mesh, if it has one
	/// @param source An optional Mesh from which geometry is shared, cloned.
	/// @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
	/// When false, achieved by calling a clone(), also passing False.
	/// This will make creation of children, recursive.
	/// @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.
	external factory Mesh(String name, [Scene? scene, Node? parent, Mesh? source, bool? doNotCloneChildren, bool? clonePhysicsImpostor]);
	
	/// Mesh side orientation : usually the external or front surface
	external static num get FRONTSIDE;
	
	/// Mesh side orientation : usually the internal or back surface
	external static num get BACKSIDE;
	
	/// Mesh side orientation : both internal and external or front and back surfaces
	external static num get DOUBLESIDE;
	
	/// Mesh side orientation : by default, `FRONTSIDE`
	external static num get DEFAULTSIDE;
	
	/// Mesh cap setting : no cap
	external static num get NO_CAP;
	
	/// Mesh cap setting : one cap at the beginning of the mesh
	external static num get CAP_START;
	
	/// Mesh cap setting : one cap at the end of the mesh
	external static num get CAP_END;
	
	/// Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh
	external static num get CAP_ALL;
	
	/// Mesh pattern setting : no flip or rotate
	external static num get NO_FLIP;
	
	/// Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column
	external static num get FLIP_TILE;
	
	/// Mesh pattern setting : rotate (180degs) alternate tiles on each row or column
	external static num get ROTATE_TILE;
	
	/// Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows
	external static num get FLIP_ROW;
	
	/// Mesh pattern setting : rotate (180degs) all tiles on alternate rows
	external static num get ROTATE_ROW;
	
	/// Mesh pattern setting : flip and rotate alternate tiles on each row or column
	external static num get FLIP_N_ROTATE_TILE;
	
	/// Mesh pattern setting : rotate pattern and rotate
	external static num get FLIP_N_ROTATE_ROW;
	
	/// Mesh tile positioning : part tiles same on left/right or top/bottom
	external static num get CENTER;
	
	/// Mesh tile positioning : part tiles on left
	external static num get LEFT;
	
	/// Mesh tile positioning : part tiles on right
	external static num get RIGHT;
	
	/// Mesh tile positioning : part tiles on top
	external static num get TOP;
	
	/// Mesh tile positioning : part tiles on bottom
	external static num get BOTTOM;
	
	@override
	external bool get computeBonesUsingShaders;
	
	@override
	external set computeBonesUsingShaders(bool value);
	
	/// An event triggered before rendering the mesh
	external Observable<Mesh> get onBeforeRenderObservable;
	
	/// An event triggered before binding the mesh
	external Observable<Mesh> get onBeforeBindObservable;
	
	/// An event triggered after rendering the mesh
	external Observable<Mesh> get onAfterRenderObservable;
	
	/// An event triggered before drawing the mesh
	external Observable<Mesh> get onBeforeDrawObservable;
	
	/// Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead
	external set onBeforeDraw(void Function() value);
	
	@override
	external bool get hasInstances;
	
	@override
	external bool get hasThinInstances;
	
	/// Gets the delay loading state of the mesh (when delay loading is turned on)
	/// @see https://doc.babylonjs.com/how_to/using_the_incremental_loading_system
	external num get delayLoadState;
	external set delayLoadState(num value);
	
	/// Gets the list of instances created from this mesh
	/// it is not supposed to be modified manually.
	/// Note also that the order of the InstancedMesh wihin the array is not significant and might change.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_instances
	external List<InstancedMesh> get instances;
	external set instances(List<InstancedMesh> value);
	
	/// Gets the file containing delay loading data for this mesh
	external String get delayLoadingFile;
	external set delayLoadingFile(String value);
	
	/// User defined function used to change how LOD level selection is done
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lod
	external void Function(num distance, Mesh mesh, Mesh? selectedLevel) get onLODLevelSelection;
	external set onLODLevelSelection(void Function(num distance, Mesh mesh, Mesh? selectedLevel) value);
	
	/// Gets or sets the morph target manager
	/// @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets
	external MorphTargetManager? get morphTargetManager;
	
	external set morphTargetManager(MorphTargetManager? value);
	
	/// Use this property to change the original side orientation defined at construction time
	external num? get overrideMaterialSideOrientation;
	external set overrideMaterialSideOrientation(num? value);
	
	/// Gets the source mesh (the one used to clone this one from)
	external Mesh? get source;
	
	/// Gets the list of clones of this mesh
	/// The scene must have been constructed with useClonedMeshMap=true for this to work!
	/// Note that useClonedMeshMap=true is the default setting
	external dynamic /* object */? get cloneMeshMap;
	
	/// Gets or sets a boolean indicating that this mesh does not use index buffer
	external bool get isUnIndexed;
	
	external set isUnIndexed(bool value);
	
	/// Gets the array buffer used to store the instanced buffer used for instances' world matrices
	external Float32List get worldMatrixInstancedBuffer;
	
	/// Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual
	external bool get manualUpdateOfWorldMatrixInstancedBuffer;
	
	external set manualUpdateOfWorldMatrixInstancedBuffer(bool value);
	
	@override
	/* Manual Fix 25 */
	external TransformNode? instantiateHierarchy([TransformNode? newParent, TransformNodeInstantiateHierarchyOptions? options, void Function(TransformNode source, TransformNode clone)? onNewNodeCreated]);
	
	/// Gets the class name
	/// @returns the string "Mesh".
	@override
	external String getClassName();
	
	/// Returns a description of this mesh
	/// @param fullDetails define if full details about this mesh must be used
	/// @returns a descriptive string representing this mesh
	@override
	external String toString([bool? fullDetails]);
	
	/// Gets a boolean indicating if this mesh has LOD
	external bool get hasLODLevels;
	
	/// Gets the list of MeshLODLevel associated with the current mesh
	/// @returns an array of MeshLODLevel
	external List<MeshLODLevel> getLODLevels();
	
	/// Add a mesh as LOD level triggered at the given distance.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lod
	/// @param distance The distance from the center of the object to show this level
	/// @param mesh The mesh to be added as LOD level (can be null)
	/// @return This mesh (for chaining)
	external Mesh addLODLevel(num distance, Mesh? mesh);
	
	/// Returns the LOD level mesh at the passed distance or null if not found.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lod
	/// @param distance The distance from the center of the object to show this level
	/// @returns a Mesh or `null`
	external Mesh? getLODLevelAtDistance(num distance);
	
	/// Remove a mesh from the LOD array
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lod
	/// @param mesh defines the mesh to be removed
	/// @return This mesh (for chaining)
	external Mesh removeLODLevel(Mesh mesh);
	
	/// Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lod
	/// @param camera defines the camera to use to compute distance
	/// @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh
	/// @return This mesh (for chaining)
	@override
	external AbstractMesh? getLOD(Camera camera, [BoundingSphere? boundingSphere]);
	
	/// Gets the mesh internal Geometry object
	external Geometry? get geometry;
	
	/// Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
	/// @returns the total number of vertices
	@override
	external num getTotalVertices();
	
	/// Returns the content of an associated vertex buffer
	/// @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one
	/// @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
	/// @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.
	@override
	external dynamic? getVerticesData(String kind, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Returns the mesh VertexBuffer object from the requested `kind`
	/// @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.NormalKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @returns a FloatArray or null if the mesh has no vertex buffer for this kind.
	external VertexBuffer? getVertexBuffer(String kind);
	
	/// Tests if a specific vertex buffer is associated with this mesh
	/// @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.NormalKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @returns a boolean
	@override
	external bool isVerticesDataPresent(String kind);
	
	/// Returns a boolean defining if the vertex data for the requested `kind` is updatable.
	/// @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @returns a boolean
	external bool isVertexBufferUpdatable(String kind);
	
	/// Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.
	/// @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.NormalKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @returns an array of strings
	external List<String> getVerticesDataKinds();
	
	/// Returns a positive integer : the total number of indices in this mesh geometry.
	/// @returns the numner of indices or zero if the mesh has no geometry.
	@override
	external num getTotalIndices();
	
	/// Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
	/// @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
	/// @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
	/// @returns the indices array or an empty array if the mesh has no geometry
	@override
	external dynamic? getIndices([bool? copyWhenShared, bool? forceCopy]);
	
	@override
	external bool get isBlocked;
	
	/// Determine if the current mesh is ready to be rendered
	/// @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
	/// @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)
	/// @returns true if all associated assets are ready (material, textures, shaders)
	@override
	external bool isReady([bool? completeCheck, bool? forceInstanceSupport]);
	
	/// Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.
	external bool get areNormalsFrozen;
	
	/// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.
	/// @returns the current mesh
	external Mesh freezeNormals();
	
	/// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen
	/// @returns the current mesh
	external Mesh unfreezeNormals();
	
	/// Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
	external set overridenInstanceCount(num value);
	
	/// This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
	/// This means the mesh underlying bounding box and sphere are recomputed.
	/// @param applySkeleton defines whether to apply the skeleton before computing the bounding info
	/// @returns the current mesh
	@override
	external Mesh refreshBoundingInfo([bool? applySkeleton]);
	
	/// This function will subdivide the mesh into multiple submeshes
	/// @param count defines the expected number of submeshes
	external void subdivide(num count);
	
	/// Copy a FloatArray into a specific associated vertex buffer
	/// @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @param data defines the data source
	/// @param updatable defines if the updated vertex buffer must be flagged as updatable
	/// @param stride defines the data stride size (can be null)
	/// @returns the current mesh
	@override
	external AbstractMesh setVerticesData(String kind, dynamic data, [bool? updatable, num? stride]);
	
	/// Delete a vertex buffer associated with this mesh
	/// @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	external void removeVerticesData(String kind);
	
	/// Flags an associated vertex buffer as updatable
	/// @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @param updatable defines if the updated vertex buffer must be flagged as updatable
	external void markVerticesDataAsUpdatable(String kind, [bool? updatable]);
	
	/// Sets the mesh global Vertex Buffer
	/// @param buffer defines the buffer to use
	/// @returns the current mesh
	external Mesh setVerticesBuffer(VertexBuffer buffer);
	
	/// Update a specific associated vertex buffer
	/// @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @param data defines the data source
	/// @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
	/// @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)
	/// @returns the current mesh
	@override
	external AbstractMesh updateVerticesData(String kind, dynamic data, [bool? updateExtends, bool? makeItUnique]);
	
	/// This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.
	/// @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions
	/// @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything
	/// @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update
	/// @returns the current mesh
	external Mesh updateMeshPositions(void Function(dynamic data) positionFunction, [bool? computeNormals]);
	
	/// Creates a un-shared specific occurence of the geometry for the mesh.
	/// @returns the current mesh
	external Mesh makeGeometryUnique();
	
	/// Set the index buffer of this mesh
	/// @param indices defines the source data
	/// @param totalVertices defines the total number of vertices referenced by this index data (can be null)
	/// @param updatable defines if the updated index buffer must be flagged as updatable (default is false)
	/// @returns the current mesh
	@override
	external AbstractMesh setIndices(dynamic indices, [num? totalVertices, bool? updatable]);
	
	/// Update the current index buffer
	/// @param indices defines the source data
	/// @param offset defines the offset in the index buffer where to store the new data (can be null)
	/// @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
	/// @returns the current mesh
	@override
	external AbstractMesh updateIndices(dynamic indices, [num? offset, bool? gpuMemoryOnly]);
	
	/// Invert the geometry to move from a right handed system to a left handed one.
	/// @returns the current mesh
	external Mesh toLeftHanded();
	
	/// Registers for this mesh a javascript function called just before the rendering process
	/// @param func defines the function to call before rendering this mesh
	/// @returns the current mesh
	external Mesh registerBeforeRender(void Function(AbstractMesh mesh) func);
	
	/// Disposes a previously registered javascript function called before the rendering
	/// @param func defines the function to remove
	/// @returns the current mesh
	external Mesh unregisterBeforeRender(void Function(AbstractMesh mesh) func);
	
	/// Registers for this mesh a javascript function called just after the rendering is complete
	/// @param func defines the function to call after rendering this mesh
	/// @returns the current mesh
	external Mesh registerAfterRender(void Function(AbstractMesh mesh) func);
	
	/// Disposes a previously registered javascript function called after the rendering.
	/// @param func defines the function to remove
	/// @returns the current mesh
	external Mesh unregisterAfterRender(void Function(AbstractMesh mesh) func);
	
	/// Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
	/// @param subMesh defines the subMesh to render
	/// @param enableAlphaMode defines if alpha mode can be changed
	/// @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
	/// @returns the current mesh
	external Mesh render(SubMesh subMesh, bool enableAlphaMode, [AbstractMesh? effectiveMeshReplacement]);
	
	/// Renormalize the mesh and patch it up if there are no weights
	/// Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.
	/// However in the case of zero weights then we set just a single influence to 1.
	/// We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.
	external void cleanMatrixWeights();
	
	/// ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,
	/// or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let
	/// the user know there was an issue with importing the mesh
	/// @returns a validation object with skinned, valid and report string
	external MeshValidateSkinning validateSkinning();
	
	/// Returns `true` if the mesh is within the frustum defined by the passed array of planes.
	/// A mesh is in the frustum if its bounding box intersects the frustum
	/// @param frustumPlanes defines the frustum to test
	/// @returns true if the mesh is in the frustum planes
	@override
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// Sets the mesh material by the material or multiMaterial `id` property
	/// @param id is a string identifying the material or the multiMaterial
	/// @returns the current mesh
	external Mesh setMaterialByID(String id);
	
	/// Returns as a new array populated with the mesh material and/or skeleton, if any.
	/// @returns an array of IAnimatable
	external List<IAnimatable> getAnimatables();
	
	/// Modifies the mesh geometry according to the passed transformation matrix.
	/// This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.
	/// The mesh normals are modified using the same transformation.
	/// Note that, under the hood, this method sets a new VertexBuffer each call.
	/// @param transform defines the transform matrix to use
	/// @see https://doc.babylonjs.com/resources/baking_transformations
	/// @returns the current mesh
	external Mesh bakeTransformIntoVertices(Matrix transform);
	
	/// Modifies the mesh geometry according to its own current World Matrix.
	/// The mesh World Matrix is then reset.
	/// This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
	/// Note that, under the hood, this method sets a new VertexBuffer each call.
	/// @see https://doc.babylonjs.com/resources/baking_transformations
	/// @param bakeIndependenlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking
	/// @returns the current mesh
	external Mesh bakeCurrentTransformIntoVertices([bool? bakeIndependenlyOfChildren]);
	
	/// Returns a new Mesh object generated from the current mesh properties.
	/// This method must not get confused with createInstance()
	/// @param name is a string, the name given to the new mesh
	/// @param newParent can be any Node object (default `null`)
	/// @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)
	/// @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)
	/// @returns a new mesh
	@override
	external Mesh? clone([String? name, Node? newParent, bool? doNotCloneChildren, bool? clonePhysicsImpostor]);
	
	/// Releases resources associated with this mesh.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Modifies the mesh geometry according to a displacement map.
	/// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
	/// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
	/// @param url is a string, the URL from the image file is to be downloaded.
	/// @param minHeight is the lower limit of the displacement.
	/// @param maxHeight is the upper limit of the displacement.
	/// @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
	/// @param uvOffset is an optional vector2 used to offset UV.
	/// @param uvScale is an optional vector2 used to scale UV.
	/// @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.
	/// @returns the Mesh.
	external Mesh applyDisplacementMap(String url, num minHeight, num maxHeight, [void Function(Mesh mesh)? onSuccess, Vector2? uvOffset, Vector2? uvScale, bool? forceUpdate]);
	
	/// Modifies the mesh geometry according to a displacementMap buffer.
	/// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
	/// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
	/// @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.
	/// @param heightMapWidth is the width of the buffer image.
	/// @param heightMapHeight is the height of the buffer image.
	/// @param minHeight is the lower limit of the displacement.
	/// @param maxHeight is the upper limit of the displacement.
	/// @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
	/// @param uvOffset is an optional vector2 used to offset UV.
	/// @param uvScale is an optional vector2 used to scale UV.
	/// @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.
	/// @returns the Mesh.
	external Mesh applyDisplacementMapFromBuffer(Uint8List buffer, num heightMapWidth, num heightMapHeight, num minHeight, num maxHeight, [Vector2? uvOffset, Vector2? uvScale, bool? forceUpdate]);
	
	/// Modify the mesh to get a flat shading rendering.
	/// This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
	/// Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
	/// @returns current mesh
	external Mesh convertToFlatShadedMesh();
	
	/// This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
	/// In other words, more vertices, no more indices and a single bigger VBO.
	/// The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
	/// @returns current mesh
	external Mesh convertToUnIndexedMesh();
	
	/// Inverses facet orientations.
	/// Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
	/// @param flipNormals will also inverts the normals
	/// @returns current mesh
	external Mesh flipFaces([bool? flipNormals]);
	
	/// Increase the number of facets and hence vertices in a mesh
	/// Vertex normals are interpolated from existing vertex normals
	/// Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
	/// @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1
	external void increaseVertices(num numberPerEdge);
	
	/// Force adjacent facets to share vertices and remove any facets that have all vertices in a line
	/// This will undo any application of covertToFlatShadedMesh
	/// Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
	external void forceSharedVertices();
	
	/// Creates a new InstancedMesh object from the mesh model.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_instances
	/// @param name defines the name of the new instance
	/// @returns a new InstancedMesh
	external InstancedMesh createInstance(String name);
	
	/// Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
	/// After this call, all the mesh instances have the same submeshes than the current mesh.
	/// @returns the current mesh
	external Mesh synchronizeInstances();
	
	/// Optimization of the mesh's indices, in case a mesh has duplicated vertices.
	/// The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
	/// This should be used together with the simplification to avoid disappearing triangles.
	/// @param successCallback an optional success callback to be called after the optimization finished.
	/// @returns the current mesh
	external Mesh optimizeIndices([void Function([Mesh? mesh])? successCallback]);
	
	/// Serialize current mesh
	/// @param serializationObject defines the object which will receive the serialization data
	@override
	external void serialize([dynamic? serializationObject]);
	
	/// Returns a new Mesh object parsed from the source provided.
	/// @param parsedMesh is the source
	/// @param scene defines the hosting scene
	/// @param rootUrl is the root URL to prefix the `delayLoadingFile` property with
	/// @returns a new Mesh
	@override
	external static Mesh Parse(dynamic parsedMesh, Scene scene, String rootUrl);
	
	/// Creates a ribbon mesh. Please consider using the same method from the MeshBuilder class instead
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @param name defines the name of the mesh to create
	/// @param pathArray is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.
	/// @param closeArray creates a seam between the first and the last paths of the path array (default is false)
	/// @param closePath creates a seam between the first and the last points of each path of the path array
	/// @param offset is taken in account only if the `pathArray` is containing a single path
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @param instance defines an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#ribbon)
	/// @returns a new Mesh
	external static Mesh CreateRibbon(String name, List<List<Vector3>> pathArray, bool closeArray, bool closePath, num offset, [Scene? scene, bool? updatable, num? sideOrientation, Mesh? instance]);
	
	/// Creates a plane polygonal mesh.  By default, this is a disc. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param radius sets the radius size (float) of the polygon (default 0.5)
	/// @param tessellation sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateDisc(String name, num radius, num tessellation, [Scene? scene, bool? updatable, num? sideOrientation]);
	
	/// Creates a box mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param size sets the size (float) of each box side (default 1)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateBox(String name, num size, [Scene? scene, bool? updatable, num? sideOrientation]);
	
	/// Creates a sphere mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param segments sets the sphere number of horizontal stripes (positive integer, default 32)
	/// @param diameter sets the diameter size (float) of the sphere (default 1)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateSphere(String name, num segments, num diameter, [Scene? scene, bool? updatable, num? sideOrientation]);
	
	/// Creates a hemisphere mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param segments sets the sphere number of horizontal stripes (positive integer, default 32)
	/// @param diameter sets the diameter size (float) of the sphere (default 1)
	/// @param scene defines the hosting scene
	/// @returns a new Mesh
	external static Mesh CreateHemisphere(String name, num segments, num diameter, [Scene? scene]);
	
	/// Creates a cylinder or a cone mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param height sets the height size (float) of the cylinder/cone (float, default 2)
	/// @param diameterTop set the top cap diameter (floats, default 1)
	/// @param diameterBottom set the bottom cap diameter (floats, default 1). This value can't be zero
	/// @param tessellation sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance
	/// @param subdivisions sets the number of rings along the cylinder height (positive integer, default 1)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateCylinder(String name, num height, num diameterTop, num diameterBottom, num tessellation, dynamic subdivisions, [Scene? scene, dynamic? updatable, num? sideOrientation]);
	
	/// Creates a torus mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param diameter sets the diameter size (float) of the torus (default 1)
	/// @param thickness sets the diameter size of the tube of the torus (float, default 0.5)
	/// @param tessellation sets the number of torus sides (postive integer, default 16)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateTorus(String name, num diameter, num thickness, num tessellation, [Scene? scene, bool? updatable, num? sideOrientation]);
	
	/// Creates a torus knot mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param radius sets the global radius size (float) of the torus knot (default 2)
	/// @param tube sets the diameter size of the tube of the torus (float, default 0.5)
	/// @param radialSegments sets the number of sides on each tube segments (positive integer, default 32)
	/// @param tubularSegments sets the number of tubes to decompose the knot into (positive integer, default 32)
	/// @param p the number of windings on X axis (positive integers, default 2)
	/// @param q the number of windings on Y axis (positive integers, default 3)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateTorusKnot(String name, num radius, num tube, num radialSegments, num tubularSegments, num p, num q, [Scene? scene, bool? updatable, num? sideOrientation]);
	
	/// Creates a line mesh. Please consider using the same method from the MeshBuilder class instead.
	/// @param name defines the name of the mesh to create
	/// @param points is an array successive Vector3
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines).
	/// @returns a new Mesh
	external static LinesMesh CreateLines(String name, List<Vector3> points, [Scene? scene, bool? updatable, LinesMesh? instance]);
	
	/// Creates a dashed line mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param points is an array successive Vector3
	/// @param dashSize is the size of the dashes relatively the dash number (positive float, default 3)
	/// @param gapSize is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
	/// @param dashNb is the intended total number of dashes (positive integer, default 200)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines)
	/// @returns a new Mesh
	external static LinesMesh CreateDashedLines(String name, List<Vector3> points, num dashSize, num gapSize, num dashNb, [Scene? scene, bool? updatable, LinesMesh? instance]);
	
	/// Creates a polygon mesh.Please consider using the same method from the MeshBuilder class instead
	/// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
	/// The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
	/// You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// Remember you can only change the shape positions, not their number when updating a polygon.
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon
	/// @param name defines the name of the mesh to create
	/// @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
	/// @param scene defines the hosting scene
	/// @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @param earcutInjection can be used to inject your own earcut reference
	/// @returns a new Mesh
	external static Mesh CreatePolygon(String name, List<Vector3> shape, Scene scene, [List<List<Vector3>>? holes, bool? updatable, num? sideOrientation, dynamic? earcutInjection]);
	
	/// Creates an extruded polygon mesh, with depth in the Y direction. Please consider using the same method from the MeshBuilder class instead.
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-non-regular-polygon
	/// @param name defines the name of the mesh to create
	/// @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
	/// @param depth defines the height of extrusion
	/// @param scene defines the hosting scene
	/// @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @param earcutInjection can be used to inject your own earcut reference
	/// @returns a new Mesh
	external static Mesh ExtrudePolygon(String name, List<Vector3> shape, num depth, Scene scene, [List<List<Vector3>>? holes, bool? updatable, num? sideOrientation, dynamic? earcutInjection]);
	
	/// Creates an extruded shape mesh.
	/// The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters. Please consider using the same method from the MeshBuilder class instead
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
	/// @param name defines the name of the mesh to create
	/// @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis
	/// @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along
	/// @param scale is the value to scale the shape
	/// @param rotation is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve
	/// @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#extruded-shape)
	/// @returns a new Mesh
	external static Mesh ExtrudeShape(String name, List<Vector3> shape, List<Vector3> path, num scale, num rotation, num cap, [Scene? scene, bool? updatable, num? sideOrientation, Mesh? instance]);
	
	/// Creates an custom extruded shape mesh.
	/// The custom extrusion is a parametric shape.
	/// It has no predefined shape. Its final shape will depend on the input parameters.
	/// Please consider using the same method from the MeshBuilder class instead
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
	/// @param name defines the name of the mesh to create
	/// @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis
	/// @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along
	/// @param scaleFunction is a custom Javascript function called on each path point
	/// @param rotationFunction is a custom Javascript function called on each path point
	/// @param ribbonCloseArray forces the extrusion underlying ribbon to close all the paths in its `pathArray`
	/// @param ribbonClosePath forces the extrusion underlying ribbon to close its `pathArray`
	/// @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape)
	/// @returns a new Mesh
	external static Mesh ExtrudeShapeCustom(String name, List<Vector3> shape, List<Vector3> path, Function scaleFunction, Function rotationFunction, bool ribbonCloseArray, bool ribbonClosePath, num cap, Scene scene, [bool? updatable, num? sideOrientation, Mesh? instance]);
	
	/// Creates lathe mesh.
	/// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.
	/// Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param shape is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
	/// @param radius is the radius value of the lathe
	/// @param tessellation is the side number of the lathe.
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreateLathe(String name, List<Vector3> shape, num radius, num tessellation, Scene scene, [bool? updatable, num? sideOrientation]);
	
	/// Creates a plane mesh. Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param size sets the size (float) of both sides of the plane at once (default 1)
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @returns a new Mesh
	external static Mesh CreatePlane(String name, num size, Scene scene, [bool? updatable, num? sideOrientation]);
	
	/// Creates a ground mesh.
	/// Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param width set the width of the ground
	/// @param height set the height of the ground
	/// @param subdivisions sets the number of subdivisions per side
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @returns a new Mesh
	external static Mesh CreateGround(String name, num width, num height, num subdivisions, [Scene? scene, bool? updatable]);
	
	/// Creates a tiled ground mesh.
	/// Please consider using the same method from the MeshBuilder class instead
	/// @param name defines the name of the mesh to create
	/// @param xmin set the ground minimum X coordinate
	/// @param zmin set the ground minimum Y coordinate
	/// @param xmax set the ground maximum X coordinate
	/// @param zmax set the ground maximum Z coordinate
	/// @param subdivisions is an object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
	/// @param precision is an object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @returns a new Mesh
	external static Mesh CreateTiledGround(String name, num xmin, num zmin, num xmax, num zmax, MeshCreateTiledGroundSubdivisions subdivisions, MeshCreateTiledGroundPrecision precision, Scene scene, [bool? updatable]);
	
	/// Creates a ground mesh from a height map.
	/// Please consider using the same method from the MeshBuilder class instead
	/// @see https://doc.babylonjs.com/babylon101/height_map
	/// @param name defines the name of the mesh to create
	/// @param url sets the URL of the height map image resource
	/// @param width set the ground width size
	/// @param height set the ground height size
	/// @param subdivisions sets the number of subdivision per side
	/// @param minHeight is the minimum altitude on the ground
	/// @param maxHeight is the maximum altitude on the ground
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param onReady  is a callback function that will be called  once the mesh is built (the height map download can last some time)
	/// @param alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
	/// @returns a new Mesh
	external static GroundMesh CreateGroundFromHeightMap(String name, String url, num width, num height, num subdivisions, num minHeight, num maxHeight, Scene scene, [bool? updatable, void Function(GroundMesh mesh)? onReady, num? alphaFilter]);
	
	/// Creates a tube mesh.
	/// The tube is a parametric shape.
	/// It has no predefined shape. Its final shape will depend on the input parameters.
	/// Please consider using the same method from the MeshBuilder class instead
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @param name defines the name of the mesh to create
	/// @param path is a required array of successive Vector3. It is the curve used as the axis of the tube
	/// @param radius sets the tube radius size
	/// @param tessellation is the number of sides on the tubular surface
	/// @param radiusFunction is a custom function. If it is not null, it overwrittes the parameter `radius`. This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path
	/// @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
	/// @param scene defines the hosting scene
	/// @param updatable defines if the mesh must be flagged as updatable
	/// @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
	/// @param instance is an instance of an existing Tube object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#tube)
	/// @returns a new Mesh
	external static Mesh CreateTube(String name, List<Vector3> path, num radius, num tessellation, num Function(num i, num distance) radiusFunction, num cap, Scene scene, [bool? updatable, num? sideOrientation, Mesh? instance]);
	
	/// Creates a polyhedron mesh.
	/// Please consider using the same method from the MeshBuilder class instead.
	/// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
	/// * The parameter `size` (positive float, default 1) sets the polygon size
	/// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
	/// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
	/// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
	/// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
	/// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
	/// * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh to create
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns a new Mesh
	external static Mesh CreatePolyhedron(String name, MeshCreatePolyhedronOptions options, Scene scene);
	
	/// Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
	/// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
	/// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
	/// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
	/// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
	/// * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns a new Mesh
	/// @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
	external static Mesh CreateIcoSphere(String name, MeshCreateIcoSphereOptions options, Scene scene);
	
	/// Creates a decal mesh.
	/// Please consider using the same method from the MeshBuilder class instead.
	/// A decal is a mesh usually applied as a model onto the surface of another mesh
	/// @param name  defines the name of the mesh
	/// @param sourceMesh defines the mesh receiving the decal
	/// @param position sets the position of the decal in world coordinates
	/// @param normal sets the normal of the mesh where the decal is applied onto in world coordinates
	/// @param size sets the decal scaling
	/// @param angle sets the angle to rotate the decal
	/// @returns a new Mesh
	external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, Vector3 position, Vector3 normal, Vector3 size, num angle);
	
	/// Creates a Capsule Mesh
	/// @param name defines the name of the mesh.
	/// @param options the constructors options used to shape the mesh.
	/// @param scene defines the scene the mesh is scoped to.
	/// @returns the capsule mesh
	/// @see https://doc.babylonjs.com/how_to/capsule_shape
	external static Mesh CreateCapsule(String name, ICreateCapsuleOptions options, Scene scene);
	
	/// Prepare internal position array for software CPU skinning
	/// @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh
	external Float32List setPositionsForCPUSkinning();
	
	/// Prepare internal normal array for software CPU skinning
	/// @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.
	external Float32List setNormalsForCPUSkinning();
	
	/// Updates the vertex buffer by applying transformation from the bones
	/// @param skeleton defines the skeleton to apply to current mesh
	/// @returns the current mesh
	external Mesh applySkeleton(Skeleton skeleton);
	
	/// Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates
	/// @param meshes defines the list of meshes to scan
	/// @returns an object `{min:` Vector3`, max:` Vector3`}`
	external static MeshMinMax MinMax(List<AbstractMesh> meshes);
	
	/// Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array
	/// @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object
	/// @returns a vector3
	external static Vector3 Center(dynamic meshesOrMinMaxVector);
	
	/// Merge the array of meshes into a single mesh for performance reasons.
	/// @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty
	/// @param disposeSource when true (default), dispose of the vertices from the source meshes
	/// @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true
	/// @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.
	/// @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.
	/// @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.
	/// @returns a new mesh
	external static Mesh? MergeMeshes(List<Mesh> meshes, [bool? disposeSource, bool? allow32BitsIndices, Mesh? meshSubclass, bool? subdivideWithSubMeshes, bool? multiMultiMaterials]);
	
	/// @hidden
	external void addInstance(InstancedMesh instance);
	
	/// @hidden
	external void removeInstance(InstancedMesh instance);
	
	/// Register a custom buffer that will be instanced
	/// @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers
	/// @param kind defines the buffer kind
	/// @param stride defines the stride in floats
	external void registerInstancedBuffer(String kind, num stride);
	
	/// true to use the edge renderer for all instances of this mesh
	external bool get edgesShareWithInstances;
	external set edgesShareWithInstances(bool value);
	
	/// Simplify the mesh according to the given array of settings.
	/// Function will return immediately and will simplify async
	/// @param settings a collection of simplification settings
	/// @param parallelProcessing should all levels calculate parallel or one after the other
	/// @param simplificationType the type of simplification to run
	/// @param successCallback optional success callback to be called after the simplification finished processing all settings
	/// @returns the current mesh
	external Mesh simplify(List<ISimplificationSettings> settings, [bool? parallelProcessing, int? simplificationType, void Function([Mesh? mesh, num? submeshIndex])? successCallback]);
	
	/// Gets or sets a boolean defining if we want picking to pick thin instances as well
	external bool get thinInstanceEnablePicking;
	external set thinInstanceEnablePicking(bool value);
	
	/// Creates a new thin instance
	/// @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create
	/// @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
	/// @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc
	external num thinInstanceAdd(dynamic matrix, bool refresh);
	
	/// Adds the transformation (matrix) of the current mesh as a thin instance
	/// @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
	/// @returns the thin instance index number
	external num thinInstanceAddSelf(bool refresh);
	
	/// Registers a custom attribute to be used with thin instances
	/// @param kind name of the attribute
	/// @param stride size in floats of the attribute
	external void thinInstanceRegisterAttribute(String kind, num stride);
	
	/// Sets the matrix of a thin instance
	/// @param index index of the thin instance
	/// @param matrix matrix to set
	/// @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
	external void thinInstanceSetMatrixAt(num index, Matrix matrix, bool refresh);
	
	/// Sets the value of a custom attribute for a thin instance
	/// @param kind name of the attribute
	/// @param index index of the thin instance
	/// @param value value to set
	/// @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
	external void thinInstanceSetAttributeAt(String kind, num index, List<num> value, bool refresh);
	
	/// Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.
	external num get thinInstanceCount;
	external set thinInstanceCount(num value);
	
	/// Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly
	/// @param kind name of the attribute. Use "matrix" to setup the buffer of matrices
	/// @param buffer buffer to set
	/// @param stride size in floats of each value of the buffer
	/// @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)
	external void thinInstanceSetBuffer(String kind, Float32List? buffer, num stride, bool staticBuffer);
	
	/// Gets the list of world matrices
	/// @return an array containing all the world matrices from the thin instances
	external List<Matrix> thinInstanceGetWorldMatrices();
	
	/// Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer
	/// @param kind name of the attribute to update. Use "matrix" to update the buffer of matrices
	external void thinInstanceBufferUpdated(String kind);
	
	/// Applies a partial update to a buffer directly on the GPU
	/// Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method
	/// @param kind name of the attribute to update. Use "matrix" to update the buffer of matrices
	/// @param data the data to set in the GPU buffer
	/// @param offset the offset in the GPU buffer where to update the data
	external void thinInstancePartialBufferUpdate(String kind, Float32List data, num offset);
	
	/// Refreshes the bounding info, taking into account all the thin instances defined
	/// @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info
	external void thinInstanceRefreshBoundingInfo(bool forceRefreshParentInfo);
	
	/// Returns an array populated with IParticleSystem objects whose the mesh is the emitter
	/// @returns an array of IParticleSystem
	external List<IParticleSystem> getEmittedParticleSystems();
	
	/// Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter
	/// @returns an array of IParticleSystem
	external List<IParticleSystem> getHierarchyEmittedParticleSystems();
}

/// Class used to store all common mesh properties
@JS()
class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {
	
	/// Creates a new AbstractMesh
	/// @param name defines the name of the mesh
	/// @param scene defines the hosting scene
	external factory AbstractMesh(String name, [Scene? scene]);
	
	/// No occlusion
	external static num get OCCLUSION_TYPE_NONE;
	external static set OCCLUSION_TYPE_NONE(num value);
	
	/// Occlusion set to optimisitic
	external static num get OCCLUSION_TYPE_OPTIMISTIC;
	external static set OCCLUSION_TYPE_OPTIMISTIC(num value);
	
	/// Occlusion set to strict
	external static num get OCCLUSION_TYPE_STRICT;
	external static set OCCLUSION_TYPE_STRICT(num value);
	
	/// Use an accurante occlusion algorithm
	external static num get OCCLUSION_ALGORITHM_TYPE_ACCURATE;
	external static set OCCLUSION_ALGORITHM_TYPE_ACCURATE(num value);
	
	/// Use a conservative occlusion algorithm
	external static num get OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
	external static set OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE(num value);
	
	/// Default culling strategy : this is an exclusion test and it's the more accurate.
	/// Test order :
	/// Is the bounding sphere outside the frustum ?
	/// If not, are the bounding box vertices outside the frustum ?
	/// It not, then the cullable object is in the frustum.
	external static num get CULLINGSTRATEGY_STANDARD;
	
	/// Culling strategy : Bounding Sphere Only.
	/// This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.
	/// It's also less accurate than the standard because some not visible objects can still be selected.
	/// Test : is the bounding sphere outside the frustum ?
	/// If not, then the cullable object is in the frustum.
	external static num get CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
	
	/// Culling strategy : Optimistic Inclusion.
	/// This in an inclusion test first, then the standard exclusion test.
	/// This can be faster when a cullable object is expected to be almost always in the camera frustum.
	/// This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.
	/// Anyway, it's as accurate as the standard strategy.
	/// Test :
	/// Is the cullable object bounding sphere center in the frustum ?
	/// If not, apply the default culling strategy.
	external static num get CULLINGSTRATEGY_OPTIMISTIC_INCLUSION;
	
	/// Culling strategy : Optimistic Inclusion then Bounding Sphere Only.
	/// This in an inclusion test first, then the bounding sphere only exclusion test.
	/// This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.
	/// This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.
	/// It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.
	/// Test :
	/// Is the cullable object bounding sphere center in the frustum ?
	/// If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.
	external static num get CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;
	
	/// No billboard
	@override
	external static num get BILLBOARDMODE_NONE;
	
	/// Billboard on X axis
	@override
	external static num get BILLBOARDMODE_X;
	
	/// Billboard on Y axis
	@override
	external static num get BILLBOARDMODE_Y;
	
	/// Billboard on Z axis
	@override
	external static num get BILLBOARDMODE_Z;
	
	/// Billboard on all axes
	@override
	external static num get BILLBOARDMODE_ALL;
	
	/// Billboard on using position instead of orientation
	@override
	external static num get BILLBOARDMODE_USE_POSITION;
	
	/// The culling strategy to use to check whether the mesh must be rendered or not.
	/// This value can be changed at any time and will be used on the next render mesh selection.
	/// The possible values are :
	/// - AbstractMesh.CULLINGSTRATEGY_STANDARD
	/// - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
	/// - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
	/// - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
	/// Please read each static variable documentation to get details about the culling process.
	/// 
	external num get cullingStrategy;
	external set cullingStrategy(num value);
	
	/// Gets the number of facets in the mesh
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
	external num get facetNb;
	
	/// Gets or set the number (integer) of subdivisions per axis in the partioning space
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
	external num get partitioningSubdivisions;
	
	external set partitioningSubdivisions(num value);
	
	/// The ratio (float) to apply to the bouding box size to set to the partioning space.
	/// Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
	external num get partitioningBBoxRatio;
	
	external set partitioningBBoxRatio(num value);
	
	/// Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
	/// Works only for updatable meshes.
	/// Doesn't work with multi-materials
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
	external bool get mustDepthSortFacets;
	
	external set mustDepthSortFacets(bool value);
	
	/// The location (Vector3) where the facet depth sort must be computed from.
	/// By default, the active camera position.
	/// Used only when facet depth sort is enabled
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
	external Vector3 get facetDepthSortFrom;
	
	external set facetDepthSortFrom(Vector3 value);
	
	/// gets a boolean indicating if facetData is enabled
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
	external bool get isFacetDataEnabled;
	
	/// An event triggered when this mesh collides with another one
	external Observable<AbstractMesh> get onCollideObservable;
	external set onCollideObservable(Observable<AbstractMesh> value);
	
	/// Set a function to call when this mesh collides with another one
	external set onCollide(void Function() value);
	
	/// An event triggered when the collision's position changes
	external Observable<Vector3> get onCollisionPositionChangeObservable;
	external set onCollisionPositionChangeObservable(Observable<Vector3> value);
	
	/// Set a function to call when the collision's position changes
	external set onCollisionPositionChange(void Function() value);
	
	/// An event triggered when material is changed
	external Observable<AbstractMesh> get onMaterialChangedObservable;
	external set onMaterialChangedObservable(Observable<AbstractMesh> value);
	
	/// Gets or sets the orientation for POV movement & rotation
	external bool get definedFacingForward;
	external set definedFacingForward(bool value);
	
	/// Gets or sets mesh visibility between 0 and 1 (default is 1)
	external num get visibility;
	
	/// Gets or sets mesh visibility between 0 and 1 (default is 1)
	external set visibility(num value);
	
	/// Gets or sets the alpha index used to sort transparent meshes
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index
	external num get alphaIndex;
	external set alphaIndex(num value);
	
	/// Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
	external bool get isVisible;
	external set isVisible(bool value);
	
	/// Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
	external bool get isPickable;
	external set isPickable(bool value);
	
	/// Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default)
	external bool get showSubMeshesBoundingBox;
	external set showSubMeshesBoundingBox(bool value);
	
	/// Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
	external bool get isBlocker;
	external set isBlocker(bool value);
	
	/// Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)
	external bool get enablePointerMoveEvents;
	external set enablePointerMoveEvents(bool value);
	
	/// Specifies the rendering group id for this mesh (0 by default)
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
	external num get renderingGroupId;
	
	external set renderingGroupId(num value);
	
	/// Gets or sets current material
	external Material? get material;
	
	external set material(Material? value);
	
	/// Gets or sets a boolean indicating that this mesh can receive realtime shadows
	/// @see https://doc.babylonjs.com/babylon101/shadows
	external bool get receiveShadows;
	
	external set receiveShadows(bool value);
	
	/// Defines color to use when rendering outline
	external Color3 get outlineColor;
	external set outlineColor(Color3 value);
	
	/// Define width to use when rendering outline
	external num get outlineWidth;
	external set outlineWidth(num value);
	
	/// Defines color to use when rendering overlay
	external Color3 get overlayColor;
	external set overlayColor(Color3 value);
	
	/// Defines alpha to use when rendering overlay
	external num get overlayAlpha;
	external set overlayAlpha(num value);
	
	/// Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values
	external bool get hasVertexAlpha;
	
	external set hasVertexAlpha(bool value);
	
	/// Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry)
	external bool get useVertexColors;
	
	external set useVertexColors(bool value);
	
	/// Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)
	external bool get computeBonesUsingShaders;
	
	external set computeBonesUsingShaders(bool value);
	
	/// Gets or sets the number of allowed bone influences per vertex (4 by default)
	external num get numBoneInfluencers;
	
	external set numBoneInfluencers(num value);
	
	/// Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default)
	external bool get applyFog;
	
	external set applyFog(bool value);
	
	/// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default)
	external bool get useOctreeForRenderingSelection;
	external set useOctreeForRenderingSelection(bool value);
	
	/// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default)
	external bool get useOctreeForPicking;
	external set useOctreeForPicking(bool value);
	
	/// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default)
	external bool get useOctreeForCollisions;
	external set useOctreeForCollisions(bool value);
	
	/// Gets or sets the current layer mask (default is 0x0FFFFFFF)
	/// @see https://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures
	external num get layerMask;
	
	external set layerMask(num value);
	
	/// True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)
	external bool get alwaysSelectAsActiveMesh;
	external set alwaysSelectAsActiveMesh(bool value);
	
	/// Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)
	external bool get doNotSyncBoundingInfo;
	external set doNotSyncBoundingInfo(bool value);
	
	/// Gets or sets the current action manager
	/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
	external AbstractActionManager? get actionManager;
	external set actionManager(AbstractActionManager? value);
	
	/// Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	external Vector3 get ellipsoid;
	external set ellipsoid(Vector3 value);
	
	/// Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	external Vector3 get ellipsoidOffset;
	external set ellipsoidOffset(Vector3 value);
	
	/// Gets or sets a collision mask used to mask collisions (default is -1).
	/// A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
	external num get collisionMask;
	
	external set collisionMask(num value);
	
	/// Gets or sets a collision response flag (default is true).
	/// when collisionResponse is false, events are still triggered but colliding entity has no response
	/// This helps creating trigger volume when user wants collision feedback events but not position/velocity
	/// to respond to the collision.
	external bool get collisionResponse;
	
	external set collisionResponse(bool value);
	
	/// Gets or sets the current collision group mask (-1 by default).
	/// A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
	external num get collisionGroup;
	
	external set collisionGroup(num value);
	
	/// Gets or sets current surrounding meshes (null by default).
	/// 
	/// By default collision detection is tested against every mesh in the scene.
	/// It is possible to set surroundingMeshes to a defined list of meshes and then only these specified
	/// meshes will be tested for the collision.
	/// 
	/// Note: if set to an empty array no collision will happen when this mesh is moved.
	external List<AbstractMesh>? get surroundingMeshes;
	
	external set surroundingMeshes(List<AbstractMesh>? value);
	
	/// Defines edge width used when edgesRenderer is enabled
	/// @see https://www.babylonjs-playground.com/#10OJSG#13
	external num get edgesWidth;
	external set edgesWidth(num value);
	
	/// Defines edge color used when edgesRenderer is enabled
	/// @see https://www.babylonjs-playground.com/#10OJSG#13
	external Color4 get edgesColor;
	external set edgesColor(Color4 value);
	
	/// Gets or sets the list of subMeshes
	/// @see https://doc.babylonjs.com/how_to/multi_materials
	external List<SubMesh> get subMeshes;
	external set subMeshes(List<SubMesh> value);
	
	/// Gets the list of lights affecting that mesh
	external List<Light> get lightSources;
	
	/// Gets or sets a skeleton to apply skining transformations
	/// @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
	external set skeleton(Skeleton? value);
	
	external Skeleton? get skeleton;
	
	/// An event triggered when the mesh is rebuilt.
	external Observable<AbstractMesh> get onRebuildObservable;
	external set onRebuildObservable(Observable<AbstractMesh> value);
	
	/// Returns the string "AbstractMesh"
	/// @returns "AbstractMesh"
	@override
	external String getClassName();
	
	/// Gets a string representation of the current mesh
	/// @param fullDetails defines a boolean indicating if full details must be included
	/// @returns a string representation of the current mesh
	external String toString([bool? fullDetails]);
	
	/// Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)
	@override
	external Vector3 get scaling;
	
	@override
	external set scaling(Vector3 value);
	
	/// Returns true if the mesh is blocked. Implemented by child classes
	external bool get isBlocked;
	
	/// Returns the mesh itself by default. Implemented by child classes
	/// @param camera defines the camera to use to pick the right LOD level
	/// @returns the currentAbstractMesh
	external AbstractMesh? getLOD(Camera camera);
	
	/// Returns 0 by default. Implemented by child classes
	/// @returns an integer
	external num getTotalVertices();
	
	/// Returns a positive integer : the total number of indices in this mesh geometry.
	/// @returns the numner of indices or zero if the mesh has no geometry.
	external num getTotalIndices();
	
	/// Returns null by default. Implemented by child classes
	/// @returns null
	@override
	external dynamic? getIndices([bool? copyWhenShared, bool? forceCopy]);
	
	/// Returns the array of the requested vertex data kind. Implemented by child classes
	/// @param kind defines the vertex data kind to use
	/// @returns null
	@override
	external dynamic? getVerticesData(String kind, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Sets the vertex data of the mesh geometry for the requested `kind`.
	/// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
	/// Note that a new underlying VertexBuffer object is created each call.
	/// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
	/// @param kind defines vertex data kind:
	/// * VertexBuffer.PositionKind
	/// * VertexBuffer.UVKind
	/// * VertexBuffer.UV2Kind
	/// * VertexBuffer.UV3Kind
	/// * VertexBuffer.UV4Kind
	/// * VertexBuffer.UV5Kind
	/// * VertexBuffer.UV6Kind
	/// * VertexBuffer.ColorKind
	/// * VertexBuffer.MatricesIndicesKind
	/// * VertexBuffer.MatricesIndicesExtraKind
	/// * VertexBuffer.MatricesWeightsKind
	/// * VertexBuffer.MatricesWeightsExtraKind
	/// @param data defines the data source
	/// @param updatable defines if the data must be flagged as updatable (or static)
	/// @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind
	/// @returns the current mesh
	@override
	external AbstractMesh setVerticesData(String kind, dynamic data, [bool? updatable, num? stride]);
	
	/// Updates the existing vertex data of the mesh geometry for the requested `kind`.
	/// If the mesh has no geometry, it is simply returned as it is.
	/// @param kind defines vertex data kind:
	/// * VertexBuffer.PositionKind
	/// * VertexBuffer.UVKind
	/// * VertexBuffer.UV2Kind
	/// * VertexBuffer.UV3Kind
	/// * VertexBuffer.UV4Kind
	/// * VertexBuffer.UV5Kind
	/// * VertexBuffer.UV6Kind
	/// * VertexBuffer.ColorKind
	/// * VertexBuffer.MatricesIndicesKind
	/// * VertexBuffer.MatricesIndicesExtraKind
	/// * VertexBuffer.MatricesWeightsKind
	/// * VertexBuffer.MatricesWeightsExtraKind
	/// @param data defines the data source
	/// @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed
	/// @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh
	/// @returns the current mesh
	@override
	external AbstractMesh updateVerticesData(String kind, dynamic data, [bool? updateExtends, bool? makeItUnique]);
	
	/// Sets the mesh indices,
	/// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
	/// @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
	/// @param totalVertices Defines the total number of vertices
	/// @returns the current mesh
	@override
	external AbstractMesh setIndices(dynamic indices, num? totalVertices, [bool? updatable]);
	
	/// Gets a boolean indicating if specific vertex data is present
	/// @param kind defines the vertex data kind to use
	/// @returns true is data kind is present
	@override
	external bool isVerticesDataPresent(String kind);
	
	/// Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.
	/// Note that it returns a shallow bounding of the mesh (i.e. it does not include children).
	/// To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.
	/// @returns a BoundingInfo
	external BoundingInfo getBoundingInfo();
	
	/// Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
	/// @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
	/// @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
	/// @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
	/// @returns the current mesh
	@override
	external AbstractMesh normalizeToUnitCube([bool? includeDescendants, bool? ignoreRotation, bool Function(AbstractMesh node)? predicate]);
	
	/// Overwrite the current bounding info
	/// @param boundingInfo defines the new bounding info
	/// @returns the current mesh
	external AbstractMesh setBoundingInfo(BoundingInfo boundingInfo);
	
	/// Gets a boolean indicating if this mesh has skinning data and an attached skeleton
	external bool get useBones;
	
	/// Gets the current world matrix
	/// @returns a Matrix
	@override
	external Matrix getWorldMatrix();
	
	/// Gets a boolean indicating if this mesh is an instance or a regular mesh
	external bool get isAnInstance;
	
	/// Gets a boolean indicating if this mesh has instances
	external bool get hasInstances;
	
	/// Gets a boolean indicating if this mesh has thin instances
	external bool get hasThinInstances;
	
	/// Perform relative position change from the point of view of behind the front of the mesh.
	/// This is performed taking into account the meshes current rotation, so you do not have to care.
	/// Supports definition of mesh facing forward or backward
	/// @param amountRight defines the distance on the right axis
	/// @param amountUp defines the distance on the up axis
	/// @param amountForward defines the distance on the forward axis
	/// @returns the current mesh
	external AbstractMesh movePOV(num amountRight, num amountUp, num amountForward);
	
	/// Calculate relative position change from the point of view of behind the front of the mesh.
	/// This is performed taking into account the meshes current rotation, so you do not have to care.
	/// Supports definition of mesh facing forward or backward
	/// @param amountRight defines the distance on the right axis
	/// @param amountUp defines the distance on the up axis
	/// @param amountForward defines the distance on the forward axis
	/// @returns the new displacement vector
	external Vector3 calcMovePOV(num amountRight, num amountUp, num amountForward);
	
	/// Perform relative rotation change from the point of view of behind the front of the mesh.
	/// Supports definition of mesh facing forward or backward
	/// @param flipBack defines the flip
	/// @param twirlClockwise defines the twirl
	/// @param tiltRight defines the tilt
	/// @returns the current mesh
	external AbstractMesh rotatePOV(num flipBack, num twirlClockwise, num tiltRight);
	
	/// Calculate relative rotation change from the point of view of behind the front of the mesh.
	/// Supports definition of mesh facing forward or backward.
	/// @param flipBack defines the flip
	/// @param twirlClockwise defines the twirl
	/// @param tiltRight defines the tilt
	/// @returns the new rotation vector
	external Vector3 calcRotatePOV(num flipBack, num twirlClockwise, num tiltRight);
	
	/// This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
	/// This means the mesh underlying bounding box and sphere are recomputed.
	/// @param applySkeleton defines whether to apply the skeleton before computing the bounding info
	/// @returns the current mesh
	external AbstractMesh refreshBoundingInfo([bool? applySkeleton]);
	
	/// Returns `true` if the mesh is within the frustum defined by the passed array of planes.
	/// A mesh is in the frustum if its bounding box intersects the frustum
	/// @param frustumPlanes defines the frustum to test
	/// @returns true if the mesh is in the frustum planes
	@override
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
	/// A mesh is completely in the frustum if its bounding box it completely inside the frustum.
	/// @param frustumPlanes defines the frustum to test
	/// @returns true if the mesh is completely in the frustum planes
	@override
	external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
	
	/// True if the mesh intersects another mesh or a SolidParticle object
	/// @param mesh defines a target mesh or SolidParticle to test
	/// @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
	/// @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
	/// @returns true if there is an intersection
	external bool intersectsMesh(dynamic mesh, [bool? precise, bool? includeDescendants]);
	
	/// Returns true if the passed point (Vector3) is inside the mesh bounding box
	/// @param point defines the point to test
	/// @returns true if there is an intersection
	external bool intersectsPoint(Vector3 point);
	
	/// Gets or sets a boolean indicating that this mesh can be used in the collision engine
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	external bool get checkCollisions;
	
	external set checkCollisions(bool value);
	
	/// Gets Collider object used to compute collisions (not physics)
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	external Collider? get collider;
	
	/// Move the mesh using collision engine
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
	/// @param displacement defines the requested displacement vector
	/// @returns the current mesh
	external AbstractMesh moveWithCollisions(Vector3 displacement);
	
	/// Checks if the passed Ray intersects with the mesh
	/// @param ray defines the ray to use
	/// @param fastCheck defines if fast mode (but less precise) must be used (false by default)
	/// @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
	/// @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
	/// @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
	/// @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
	/// @returns the picking info
	/// @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
	external PickingInfo intersects(Ray ray, [bool? fastCheck, dynamic? trianglePredicate, bool? onlyBoundingInfo, Matrix? worldToUse, bool? skipBoundingInfo]);
	
	/// Clones the current mesh
	/// @param name defines the mesh name
	/// @param newParent defines the new mesh parent
	/// @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)
	/// @returns the new mesh
	@override
	external AbstractMesh? clone(String? name, Node? newParent, [bool? doNotCloneChildren]);
	
	/// Disposes all the submeshes of the current meshnp
	/// @returns the current mesh
	external AbstractMesh releaseSubMeshes();
	
	/// Releases resources associated with this abstract mesh.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Adds the passed mesh as a child to the current mesh
	/// @param mesh defines the child mesh
	/// @returns the current mesh
	external AbstractMesh addChild(AbstractMesh mesh);
	
	/// Removes the passed mesh from the current mesh children list
	/// @param mesh defines the child mesh
	/// @returns the current mesh
	external AbstractMesh removeChild(AbstractMesh mesh);
	
	/// Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
	/// This method can be called within the render loop.
	/// You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
	/// @returns the current mesh
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external AbstractMesh updateFacetData();
	
	/// Returns the facetLocalNormals array.
	/// The normals are expressed in the mesh local spac
	/// @returns an array of Vector3
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external List<Vector3> getFacetLocalNormals();
	
	/// Returns the facetLocalPositions array.
	/// The facet positions are expressed in the mesh local space
	/// @returns an array of Vector3
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external List<Vector3> getFacetLocalPositions();
	
	/// Returns the facetLocalPartioning array
	/// @returns an array of array of numbers
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external List<List<num>> getFacetLocalPartitioning();
	
	/// Returns the i-th facet position in the world system.
	/// This method allocates a new Vector3 per call
	/// @param i defines the facet index
	/// @returns a new Vector3
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external Vector3 getFacetPosition(num i);
	
	/// Sets the reference Vector3 with the i-th facet position in the world system
	/// @param i defines the facet index
	/// @param ref defines the target vector
	/// @returns the current mesh
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external AbstractMesh getFacetPositionToRef(num i, Vector3 ref);
	
	/// Returns the i-th facet normal in the world system.
	/// This method allocates a new Vector3 per call
	/// @param i defines the facet index
	/// @returns a new Vector3
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external Vector3 getFacetNormal(num i);
	
	/// Sets the reference Vector3 with the i-th facet normal in the world system
	/// @param i defines the facet index
	/// @param ref defines the target vector
	/// @returns the current mesh
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external dynamic getFacetNormalToRef(num i, Vector3 ref);
	
	/// Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
	/// @param x defines x coordinate
	/// @param y defines y coordinate
	/// @param z defines z coordinate
	/// @returns the array of facet indexes
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external List<num>? getFacetsAtLocalCoordinates(num x, num y, num z);
	
	/// Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
	/// @param projected sets as the (x,y,z) world projection on the facet
	/// @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
	/// @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
	/// @param x defines x coordinate
	/// @param y defines y coordinate
	/// @param z defines z coordinate
	/// @returns the face index if found (or null instead)
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external num? getClosestFacetAtCoordinates(num x, num y, num z, [Vector3? projected, bool? checkFace, bool? facing]);
	
	/// Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
	/// @param projected sets as the (x,y,z) local projection on the facet
	/// @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
	/// @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
	/// @param x defines x coordinate
	/// @param y defines y coordinate
	/// @param z defines z coordinate
	/// @returns the face index if found (or null instead)
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external num? getClosestFacetAtLocalCoordinates(num x, num y, num z, [Vector3? projected, bool? checkFace, bool? facing]);
	
	/// Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
	/// @returns the parameters
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external dynamic getFacetDataParameters();
	
	/// Disables the feature FacetData and frees the related memory
	/// @returns the current mesh
	/// @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
	external AbstractMesh disableFacetData();
	
	/// Updates the AbstractMesh indices array
	/// @param indices defines the data source
	/// @param offset defines the offset in the index buffer where to store the new data (can be null)
	/// @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
	/// @returns the current mesh
	external AbstractMesh updateIndices(dynamic indices, [num? offset, bool? gpuMemoryOnly]);
	
	/// Creates new normals data for the mesh
	/// @param updatable defines if the normal vertex buffer must be flagged as updatable
	/// @returns the current mesh
	external AbstractMesh createNormals(bool updatable);
	
	/// Align the mesh with a normal
	/// @param normal defines the normal to use
	/// @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)
	/// @returns the current mesh
	external AbstractMesh alignWithNormal(Vector3 normal, [Vector3? upDirection]);
	
	/// Disables the mesh edge rendering mode
	/// @returns the currentAbstractMesh
	external AbstractMesh disableEdgesRendering();
	
	/// Enables the edge rendering mode on the mesh.
	/// This mode makes the mesh edges visible
	/// @param epsilon defines the maximal distance between two angles to detect a face
	/// @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
	/// @param options options to the edge renderer
	/// @returns the currentAbstractMesh
	/// @see https://www.babylonjs-playground.com/#19O9TU#0
	external AbstractMesh enableEdgesRendering([num? epsilon, bool? checkVerticesInsteadOfIndices, IEdgesRendererOptions? options]);
	
	/// This function returns all of the particle systems in the scene that use the mesh as an emitter.
	/// @returns an array of particle systems in the scene that use the mesh as an emitter
	external List<IParticleSystem> getConnectedParticleSystems();
	
	/// Object used to store instanced buffers defined by user
	/// @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers
	external dynamic /* object */ get instancedBuffers;
	external set instancedBuffers(dynamic /* object */ value);
	
	/// Gets the edgesRenderer associated with the mesh
	external EdgesRenderer? get edgesRenderer;
	external set edgesRenderer(EdgesRenderer? value);
	
	/// This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
	/// Please note that you must have a decent number of submeshes to get performance improvements when using an octree
	/// @param maxCapacity defines the maximum size of each block (64 by default)
	/// @param maxDepth defines the maximum depth to use (no more than 2 levels by default)
	/// @returns the new octree
	/// @see https://www.babylonjs-playground.com/#NA4OQ#12
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
	external Octree<SubMesh> createOrUpdateSubmeshesOctree([num? maxCapacity, num? maxDepth]);
	
	/// This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retireved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decideds to show or hide the object.
	/// The default value is -1 which means don't break the query and wait till the result
	/// @see https://doc.babylonjs.com/features/occlusionquery
	external num get occlusionRetryCount;
	external set occlusionRetryCount(num value);
	
	/// This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:
	/// * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query whith the Mesh.
	/// * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.
	/// * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.
	/// @see https://doc.babylonjs.com/features/occlusionquery
	external num get occlusionType;
	external set occlusionType(num value);
	
	/// This property determines the type of occlusion query algorithm to run in WebGl, you can use:
	/// * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.
	/// * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.
	/// @see https://doc.babylonjs.com/features/occlusionquery
	external num get occlusionQueryAlgorithmType;
	external set occlusionQueryAlgorithmType(num value);
	
	/// Gets or sets whether the mesh is occluded or not, it is used also to set the intial state of the mesh to be occluded or not
	/// @see https://doc.babylonjs.com/features/occlusionquery
	external bool get isOccluded;
	external set isOccluded(bool value);
	
	/// Flag to check the progress status of the query
	/// @see https://doc.babylonjs.com/features/occlusionquery
	external bool get isOcclusionQueryInProgress;
	external set isOcclusionQueryInProgress(bool value);
	
	/// Gets or sets impostor used for physic simulation
	/// @see https://doc.babylonjs.com/features/physics_engine
	external PhysicsImpostor? get physicsImpostor;
	external set physicsImpostor(PhysicsImpostor? value);
	
	/// Gets the current physics impostor
	/// @see https://doc.babylonjs.com/features/physics_engine
	/// @returns a physics impostor or null
	external PhysicsImpostor? getPhysicsImpostor();
	
	/// Apply a physic impulse to the mesh
	/// @param force defines the force to apply
	/// @param contactPoint defines where to apply the force
	/// @returns the current mesh
	/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
	external AbstractMesh applyImpulse(Vector3 force, Vector3 contactPoint);
	
	/// Creates a physic joint between two meshes
	/// @param otherMesh defines the other mesh to use
	/// @param pivot1 defines the pivot to use on this mesh
	/// @param pivot2 defines the pivot to use on the other mesh
	/// @param options defines additional options (can be plugin dependent)
	/// @returns the current mesh
	/// @see https://www.babylonjs-playground.com/#0BS5U0#0
	external AbstractMesh setPhysicsLinkWith(Mesh otherMesh, Vector3 pivot1, Vector3 pivot2, [dynamic? options]);
	
	/// Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)
	external bool get showBoundingBox;
	external set showBoundingBox(bool value);
	
	/// Gets or sets a boolean indicating if the outline must be rendered as well
	/// @see https://www.babylonjs-playground.com/#10WJ5S#3
	external bool get renderOutline;
	external set renderOutline(bool value);
	
	/// Gets or sets a boolean indicating if the overlay must be rendered as well
	/// @see https://www.babylonjs-playground.com/#10WJ5S#2
	external bool get renderOverlay;
	external set renderOverlay(bool value);
}

/// Defines the options associated with the creation of a shader material.
@JS()
@anonymous
class IShaderMaterialOptions {
	
	external factory IShaderMaterialOptions({bool needAlphaBlending, bool needAlphaTesting, List<String> attributes, List<String> uniforms, List<String> uniformBuffers, List<String> samplers, List<String> defines});
	
	/// Does the material work in alpha blend mode
	external bool get needAlphaBlending;
	external set needAlphaBlending( bool value );
	
	/// Does the material work in alpha test mode
	external bool get needAlphaTesting;
	external set needAlphaTesting( bool value );
	
	/// The list of attribute names used in the shader
	external List<String> get attributes;
	external set attributes( List<String> value );
	
	/// The list of unifrom names used in the shader
	external List<String> get uniforms;
	external set uniforms( List<String> value );
	
	/// The list of UBO names used in the shader
	external List<String> get uniformBuffers;
	external set uniformBuffers( List<String> value );
	
	/// The list of sampler names used in the shader
	external List<String> get samplers;
	external set samplers( List<String> value );
	
	/// The list of defines used in the shader
	external List<String> get defines;
	external set defines( List<String> value );
}

/// The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
/// 
/// This returned material effects how the mesh will look based on the code in the shaders.
/// 
/// @see https://doc.babylonjs.com/how_to/shader_material
@JS()
class ShaderMaterial extends Material {
	
	/// Instantiate a new shader material.
	/// The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
	/// This returned material effects how the mesh will look based on the code in the shaders.
	/// @see https://doc.babylonjs.com/how_to/shader_material
	/// @param name Define the name of the material in the scene
	/// @param scene Define the scene the material belongs to
	/// @param shaderPath Defines  the route to the shader code in one of three ways:
	/// * object: { vertex: "custom", fragment: "custom" }, used with Effect.ShadersStore["customVertexShader"] and Effect.ShadersStore["customFragmentShader"]
	/// * object: { vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode" }, used with shader code in script tags
	/// * object: { vertexSource: "vertex shader code string", fragmentSource: "fragment shader code string" } using with strings containing the shaders code
	/// * string: "./COMMON_NAME", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.
	/// @param options Define the options used to create the shader
	external factory ShaderMaterial(String name, Scene scene, dynamic shaderPath, [IShaderMaterialOptions? options]);
	
	/// Define the Url to load snippets
	external static String get SnippetUrl;
	external static set SnippetUrl(String value);
	
	/// Snippet ID if the material was created from the snippet server
	external String get snippetId;
	external set snippetId(String value);
	
	/// Gets the shader path used to define the shader code
	/// It can be modified to trigger a new compilation
	external dynamic get shaderPath;
	
	/// Sets the shader path used to define the shader code
	/// It can be modified to trigger a new compilation
	external set shaderPath(dynamic value);
	
	/// Gets the options used to compile the shader.
	/// They can be modified to trigger a new compilation
	external IShaderMaterialOptions get options;
	
	/// Gets the current class name of the material e.g. "ShaderMaterial"
	/// Mainly use in serialization.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Specifies if the material will require alpha blending
	/// @returns a boolean specifying if alpha blending is needed
	@override
	external bool needAlphaBlending();
	
	/// Specifies if this material should be rendered in alpha test mode
	/// @returns a boolean specifying if an alpha test is needed.
	@override
	external bool needAlphaTesting();
	
	/// Set a texture in the shader.
	/// @param name Define the name of the uniform samplers as defined in the shader
	/// @param texture Define the texture to bind to this sampler
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setTexture(String name, BaseTexture texture);
	
	/// Set a texture array in the shader.
	/// @param name Define the name of the uniform sampler array as defined in the shader
	/// @param textures Define the list of textures to bind to this sampler
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setTextureArray(String name, List<BaseTexture> textures);
	
	/// Set a float in the shader.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setFloat(String name, num value);
	
	/// Set a int in the shader.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setInt(String name, num value);
	
	/// Set an array of floats in the shader.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setFloats(String name, List<num> value);
	
	/// Set a vec3 in the shader from a Color3.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setColor3(String name, Color3 value);
	
	/// Set a vec3 array in the shader from a Color3 array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setColor3Array(String name, List<Color3> value);
	
	/// Set a vec4 in the shader from a Color4.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setColor4(String name, Color4 value);
	
	/// Set a vec4 array in the shader from a Color4 array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setColor4Array(String name, List<Color4> value);
	
	/// Set a vec2 in the shader from a Vector2.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setVector2(String name, Vector2 value);
	
	/// Set a vec3 in the shader from a Vector3.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setVector3(String name, Vector3 value);
	
	/// Set a vec4 in the shader from a Vector4.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setVector4(String name, Vector4 value);
	
	/// Set a mat4 in the shader from a Matrix.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setMatrix(String name, Matrix value);
	
	/// Set a float32Array in the shader from a matrix array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setMatrices(String name, List<Matrix> value);
	
	/// Set a mat3 in the shader from a Float32Array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setMatrix3x3(String name, dynamic value);
	
	/// Set a mat2 in the shader from a Float32Array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setMatrix2x2(String name, dynamic value);
	
	/// Set a vec2 array in the shader from a number array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setArray2(String name, List<num> value);
	
	/// Set a vec3 array in the shader from a number array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setArray3(String name, List<num> value);
	
	/// Set a vec4 array in the shader from a number array.
	/// @param name Define the name of the uniform as defined in the shader
	/// @param value Define the value to give to the uniform
	/// @return the material itself allowing "fluent" like uniform updates
	external ShaderMaterial setArray4(String name, List<num> value);
	
	/// Specifies that the submesh is ready to be used
	/// @param mesh defines the mesh to check
	/// @param subMesh defines which submesh to check
	/// @param useInstances specifies that instances should be used
	/// @returns a boolean indicating that the submesh is ready or not
	@override
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Checks if the material is ready to render the requested mesh
	/// @param mesh Define the mesh to render
	/// @param useInstances Define whether or not the material is used with instances
	/// @returns true if ready, otherwise false
	@override
	external bool isReady([AbstractMesh? mesh, bool? useInstances]);
	
	/// Binds the world matrix to the material
	/// @param world defines the world transformation matrix
	/// @param effectOverride - If provided, use this effect instead of internal effect
	@override
	external void bindOnlyWorldMatrix(Matrix world, [Effect? effectOverride]);
	
	/// Binds the submesh to this material by preparing the effect and shader to draw
	/// @param world defines the world transformation matrix
	/// @param mesh defines the mesh containing the submesh
	/// @param subMesh defines the submesh to bind the material to
	@override
	external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
	
	/// Binds the material to the mesh
	/// @param world defines the world transformation matrix
	/// @param mesh defines the mesh to bind the material to
	/// @param effectOverride - If provided, use this effect instead of internal effect
	@override
	external void bind(Matrix world, [Mesh? mesh, Effect? effectOverride]);
	
	/// Gets the active textures from the material
	/// @returns an array of textures
	@override
	external List<BaseTexture> getActiveTextures();
	
	/// Specifies if the material uses a texture
	/// @param texture defines the texture to check against the material
	/// @returns a boolean specifying if the material uses the texture
	@override
	external bool hasTexture(BaseTexture texture);
	
	/// Makes a duplicate of the material, and gives it a new name
	/// @param name defines the new name for the duplicated material
	/// @returns the cloned material
	@override
	external ShaderMaterial? clone(String name);
	
	/// Disposes the material
	/// @param forceDisposeEffect specifies if effects should be forcefully disposed
	/// @param forceDisposeTextures specifies if textures should be forcefully disposed
	/// @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
	@override
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? notBoundToMesh]);
	
	/// Serializes this material in a JSON representation
	/// @returns the serialized material object
	@override
	external dynamic serialize();
	
	/// Creates a shader material from parsed shader material data
	/// @param source defines the JSON represnetation of the material
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a new material
	@override
	external static ShaderMaterial? Parse(dynamic source, Scene scene, String rootUrl);
	
	/// Creates a new ShaderMaterial from a snippet saved in a remote file
	/// @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)
	/// @param url defines the url to load from
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a promise that will resolve to the new ShaderMaterial
	external static Promise<ShaderMaterial> ParseFromFileAsync(String? name, String url, Scene scene, [String? rootUrl]);
	
	/// Creates a ShaderMaterial from a snippet saved by the Inspector
	/// @param snippetId defines the snippet to load
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a promise that will resolve to the new ShaderMaterial
	external static Promise<ShaderMaterial> CreateFromSnippetAsync(String snippetId, Scene scene, [String? rootUrl]);
}

/* var */
/// @hidden
@JS()
external dynamic get colorPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get colorVertexShader;

/// Line mesh
/// @see https://doc.babylonjs.com/babylon101/parametric_shapes
@JS()
class LinesMesh extends Mesh {
	
	/// Creates a new LinesMesh
	/// @param name defines the name
	/// @param scene defines the hosting scene
	/// @param parent defines the parent mesh if any
	/// @param source defines the optional source LinesMesh used to clone data from
	/// @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
	/// When false, achieved by calling a clone(), also passing False.
	/// This will make creation of children, recursive.
	/// @param useVertexColor defines if this LinesMesh supports vertex color
	/// @param useVertexAlpha defines if this LinesMesh supports vertex alpha
	external factory LinesMesh(String name, [Scene? scene, Node? parent, LinesMesh? source, bool? doNotCloneChildren, bool? useVertexColor, bool? useVertexAlpha]);
	
	/// If vertex color should be applied to the mesh
	external bool? get useVertexColor;
	
	/// If vertex alpha should be applied to the mesh
	external bool? get useVertexAlpha;
	
	/// Color of the line (Default: White)
	external Color3 get color;
	external set color(Color3 value);
	
	/// Alpha of the line (Default: 1)
	external num get alpha;
	external set alpha(num value);
	
	/// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
	/// This margin is expressed in world space coordinates, so its value may vary.
	/// Default value is 0.1
	external num get intersectionThreshold;
	external set intersectionThreshold(num value);
	
	@override
	external bool isReady([bool? completeCheck, bool? forceInstanceSupport]);
	
	/// Returns the string "LineMesh"
	@override
	external String getClassName();
	
	/// @hidden
	@override
	external Material? get material;
	
	/// @hidden
	@override
	external set material(Material? value);
	
	/// @hidden
	@override
	external bool get checkCollisions;
	
	/// Disposes of the line mesh
	/// @param doNotRecurse If children should be disposed
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Returns a new LineMesh object cloned from the current one.
	@override
	external LinesMesh? clone([String? name, Node? newParent, bool? doNotCloneChildren, bool? clonePhysicsImpostor]);
	
	/// Creates a new InstancedLinesMesh object from the mesh model.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_instances
	/// @param name defines the name of the new instance
	/// @returns a new InstancedLinesMesh
	@override
	external InstancedLinesMesh createInstance(String name);
	
	/// Enables the edge rendering mode on the mesh.
	/// This mode makes the mesh edges visible
	/// @param epsilon defines the maximal distance between two angles to detect a face
	/// @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
	/// @returns the currentAbstractMesh
	/// @see https://www.babylonjs-playground.com/#19O9TU#0
	@override
	external AbstractMesh enableEdgesRendering([num? epsilon, bool? checkVerticesInsteadOfIndices, IEdgesRendererOptions? options]);
}

/// Creates an instance based on a source LinesMesh
@JS()
class InstancedLinesMesh extends InstancedMesh {
	
	external factory InstancedLinesMesh(String name, LinesMesh source);
	
	/// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
	/// This margin is expressed in world space coordinates, so its value may vary.
	/// Initilized with the intersectionThreshold value of the source LinesMesh
	external num get intersectionThreshold;
	external set intersectionThreshold(num value);
	
	/// Returns the string "InstancedLinesMesh".
	@override
	external String getClassName();
	
	/// Enables the edge rendering mode on the mesh.
	/// This mode makes the mesh edges visible
	/// @param epsilon defines the maximal distance between two angles to detect a face
	/// @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
	/// @returns the current InstancedLinesMesh
	/// @see https://www.babylonjs-playground.com/#19O9TU#0
	@override
	external InstancedLinesMesh enableEdgesRendering([num? epsilon, bool? checkVerticesInsteadOfIndices, IEdgesRendererOptions? options]);
}

/* var */
/// @hidden
@JS()
external dynamic get linePixelShader;

/* var */
/// @hidden
@JS()
external dynamic get lineVertexShader;

/// Defines the minimum contract an Edges renderer should follow.
@JS()
abstract class IEdgesRenderer implements IDisposable {
	
	/// Gets or sets a boolean indicating if the edgesRenderer is active
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Renders the edges of the attached mesh,
	external void render();
	
	/// Checks wether or not the edges renderer is ready to render.
	/// @return true if ready, otherwise false.
	external bool isReady();
	
	/// List of instances to render in case the source mesh has instances
	external SmartArray<Matrix> get customInstances;
	external set customInstances(SmartArray<Matrix> value);
}

/// Defines the additional options of the edges renderer
@JS()
@anonymous
class IEdgesRendererOptions {
	
	external factory IEdgesRendererOptions({bool useAlternateEdgeFinder, bool useFastVertexMerger, num epsilonVertexMerge, bool applyTessellation, num epsilonVertexAligned});
	
	/// Gets or sets a boolean indicating that the alternate edge finder algorithm must be used
	/// If not defined, the default value is true
	external bool get useAlternateEdgeFinder;
	external set useAlternateEdgeFinder( bool value );
	
	/// Gets or sets a boolean indicating that the vertex merger fast processing must be used.
	/// If not defined, the default value is true.
	/// You should normally leave it undefined (or set it to true), except if you see some artifacts in the edges rendering (can happen with complex geometries)
	/// This option is used only if useAlternateEdgeFinder = true
	external bool get useFastVertexMerger;
	external set useFastVertexMerger( bool value );
	
	/// During edges processing, the vertices are merged if they are close enough: epsilonVertexMerge is the limit whithin which vertices are considered to be equal.
	/// The default value is 1e-6
	/// This option is used only if useAlternateEdgeFinder = true
	external num get epsilonVertexMerge;
	external set epsilonVertexMerge( num value );
	
	/// Gets or sets a boolean indicating that tessellation should be applied before finding the edges. You may need to activate this option if your geometry is a bit
	/// unusual, like having a vertex of a triangle in-between two vertices of an edge of another triangle. It happens often when using CSG to construct meshes.
	/// This option is used only if useAlternateEdgeFinder = true
	external bool get applyTessellation;
	external set applyTessellation( bool value );
	
	/// The limit under which 3 vertices are considered to be aligned. 3 vertices PQR are considered aligned if distance(PQ) + distance(QR) - distance(PR) < epsilonVertexAligned
	/// The default value is 1e-6
	/// This option is used only if useAlternateEdgeFinder = true
	external num get epsilonVertexAligned;
	external set epsilonVertexAligned( num value );
}

/// This class is used to generate edges of the mesh that could then easily be rendered in a scene.
@JS()
class EdgesRenderer implements IEdgesRenderer {
	
	/// Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.
	/// Beware when you use this class with complex objects as the adjacencies computation can be really long
	/// @param  source Mesh used to create edges
	/// @param  epsilon sum of angles in adjacency to check for edge
	/// @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true
	/// @param  generateEdgesLines - should generate Lines or only prepare resources.
	/// @param  options The options to apply when generating the edges
	external factory EdgesRenderer(AbstractMesh source, [num? epsilon, bool? checkVerticesInsteadOfIndices, bool? generateEdgesLines, IEdgesRendererOptions? options]);
	
	/// Define the size of the edges with an orthographic camera
	external num get edgesWidthScalerForOrthographic;
	external set edgesWidthScalerForOrthographic(num value);
	
	/// Define the size of the edges with a perspective camera
	external num get edgesWidthScalerForPerspective;
	external set edgesWidthScalerForPerspective(num value);
	
	/// Gets or sets a boolean indicating if the edgesRenderer is active
	@override
	external bool get isEnabled;
	@override
	external set isEnabled(bool value);
	
	/// Gets the vertices generated by the edge renderer
	external List<num> get linesPositions;
	
	/// Gets the normals generated by the edge renderer
	external List<num> get linesNormals;
	
	/// Gets the indices generated by the edge renderer
	external List<num> get linesIndices;
	
	/// List of instances to render in case the source mesh has instances
	@override
	external SmartArray<Matrix> get customInstances;
	@override
	external set customInstances(SmartArray<Matrix> value);
	
	/// Releases the required resources for the edges renderer
	@override
	external void dispose();
	
	/// push line into the position, normal and index buffer
	/// @protected
	external void createLine(Vector3 p0, Vector3 p1, num offset);
	
	/// Checks wether or not the edges renderer is ready to render.
	/// @return true if ready, otherwise false.
	@override
	external bool isReady();
	
	/// Renders the edges of the attached mesh,
	@override
	external void render();
}

/// LineEdgesRenderer for LineMeshes to remove unnecessary triangulation
@JS()
class LineEdgesRenderer extends EdgesRenderer {
	
	/// This constructor turns off auto generating edges line in Edges Renderer to make it here.
	/// @param  source LineMesh used to generate edges
	/// @param  epsilon not important (specified angle for edge detection)
	/// @param  checkVerticesInsteadOfIndices not important for LineMesh
	external factory LineEdgesRenderer(AbstractMesh source, [num? epsilon, bool? checkVerticesInsteadOfIndices]);
}

/// This represents the object necessary to create a rendering group.
/// This is exclusively used and created by the rendering manager.
/// To modify the behavior, you use the available helpers in your scene or meshes.
/// @hidden
@JS()
class RenderingGroup {
	
	/// Creates a new rendering group.
	/// @param index The rendering group index
	/// @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied
	/// @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied
	/// @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied
	external factory RenderingGroup(num index, Scene scene, [num Function(SubMesh a, SubMesh b)? opaqueSortCompareFn, num Function(SubMesh a, SubMesh b)? alphaTestSortCompareFn, num Function(SubMesh a, SubMesh b)? transparentSortCompareFn]);
	
	external num get index;
	external set index(num value);
	
	external void Function() get onBeforeTransparentRendering;
	external set onBeforeTransparentRendering(void Function() value);
	
	/// Set the opaque sort comparison function.
	/// If null the sub meshes will be render in the order they were created
	external set opaqueSortCompareFn(num Function(SubMesh a, SubMesh b)? value);
	
	/// Set the alpha test sort comparison function.
	/// If null the sub meshes will be render in the order they were created
	external set alphaTestSortCompareFn(num Function(SubMesh a, SubMesh b)? value);
	
	/// Set the transparent sort comparison function.
	/// If null the sub meshes will be render in the order they were created
	external set transparentSortCompareFn(num Function(SubMesh a, SubMesh b)? value);
	
	/// Render all the sub meshes contained in the group.
	/// @param customRenderFunction Used to override the default render behaviour of the group.
	/// @returns true if rendered some submeshes.
	external void render(void Function(SmartArray<SubMesh> opaqueSubMeshes, SmartArray<SubMesh> transparentSubMeshes, SmartArray<SubMesh> alphaTestSubMeshes, SmartArray<SubMesh> depthOnlySubMeshes)? customRenderFunction, bool renderSprites, bool renderParticles, List<AbstractMesh>? activeMeshes);
	
	/// Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
	/// are rendered back to front if in the same alpha index.
	/// 
	/// @param a The first submesh
	/// @param b The second submesh
	/// @returns The result of the comparison
	external static num defaultTransparentSortCompare(SubMesh a, SubMesh b);
	
	/// Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
	/// are rendered back to front.
	/// 
	/// @param a The first submesh
	/// @param b The second submesh
	/// @returns The result of the comparison
	external static num backToFrontSortCompare(SubMesh a, SubMesh b);
	
	/// Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
	/// are rendered front to back (prevent overdraw).
	/// 
	/// @param a The first submesh
	/// @param b The second submesh
	/// @returns The result of the comparison
	external static num frontToBackSortCompare(SubMesh a, SubMesh b);
	
	/// Resets the different lists of submeshes to prepare a new frame.
	external void prepare();
	
	external void dispose();
	
	/// Inserts the submesh in its correct queue depending on its material.
	/// @param subMesh The submesh to dispatch
	/// @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
	/// @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
	external void dispatch(SubMesh subMesh, [AbstractMesh? mesh, Material? material]);
	
	external void dispatchSprites(ISpriteManager spriteManager);
	
	external void dispatchParticles(IParticleSystem particleSystem);
}

/// Interface describing the different options available in the rendering manager
/// regarding Auto Clear between groups.
@JS()
@anonymous
class IRenderingManagerAutoClearSetup {
	
	external factory IRenderingManagerAutoClearSetup({bool autoClear, bool depth, bool stencil});
	
	/// Defines whether or not autoclear is enable.
	external bool get autoClear;
	external set autoClear( bool value );
	
	/// Defines whether or not to autoclear the depth buffer.
	external bool get depth;
	external set depth( bool value );
	
	/// Defines whether or not to autoclear the stencil buffer.
	external bool get stencil;
	external set stencil( bool value );
}

/// This class is used by the onRenderingGroupObservable
@JS()
class RenderingGroupInfo {
	external factory RenderingGroupInfo();
	
	/// The Scene that being rendered
	external Scene get scene;
	external set scene(Scene value);
	
	/// The camera currently used for the rendering pass
	external Camera? get camera;
	external set camera(Camera? value);
	
	/// The ID of the renderingGroup being processed
	external num get renderingGroupId;
	external set renderingGroupId(num value);
}

/// This is the manager responsible of all the rendering for meshes sprites and particles.
/// It is enable to manage the different groups as well as the different necessary sort functions.
/// This should not be used directly aside of the few static configurations
@JS()
class RenderingManager {
	
	/// Instantiates a new rendering group for a particular scene
	/// @param scene Defines the scene the groups belongs to
	external factory RenderingManager(Scene scene);
	
	/// The max id used for rendering groups (not included)
	external static num get MAX_RENDERINGGROUPS;
	external static set MAX_RENDERINGGROUPS(num value);
	
	/// The min id used for rendering groups (included)
	external static num get MIN_RENDERINGGROUPS;
	external static set MIN_RENDERINGGROUPS(num value);
	
	/// Used to globally prevent autoclearing scenes.
	external static bool get AUTOCLEAR;
	external static set AUTOCLEAR(bool value);
	
	/// Renders the entire managed groups. This is used by the scene or the different rennder targets.
	/// @hidden
	external void render(void Function(SmartArray<SubMesh> opaqueSubMeshes, SmartArray<SubMesh> transparentSubMeshes, SmartArray<SubMesh> alphaTestSubMeshes, SmartArray<SubMesh> depthOnlySubMeshes)? customRenderFunction, List<AbstractMesh>? activeMeshes, bool renderParticles, bool renderSprites);
	
	/// Resets the different information of the group to prepare a new frame
	/// @hidden
	external void reset();
	
	/// Dispose and release the group and its associated resources.
	/// @hidden
	external void dispose();
	
	/// Clear the info related to rendering groups preventing retention points during dispose.
	external void freeRenderingGroups();
	
	/// Add a sprite manager to the rendering manager in order to render it this frame.
	/// @param spriteManager Define the sprite manager to render
	external void dispatchSprites(ISpriteManager spriteManager);
	
	/// Add a particle system to the rendering manager in order to render it this frame.
	/// @param particleSystem Define the particle system to render
	external void dispatchParticles(IParticleSystem particleSystem);
	
	/// Add a submesh to the manager in order to render it this frame
	/// @param subMesh The submesh to dispatch
	/// @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
	/// @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
	external void dispatch(SubMesh subMesh, [AbstractMesh? mesh, Material? material]);
	
	/// Overrides the default sort function applied in the renderging group to prepare the meshes.
	/// This allowed control for front to back rendering or reversly depending of the special needs.
	/// 
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param opaqueSortCompareFn The opaque queue comparison function use to sort.
	/// @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
	/// @param transparentSortCompareFn The transparent queue comparison function use to sort.
	external void setRenderingOrder(num renderingGroupId, [num Function(SubMesh a, SubMesh b)? opaqueSortCompareFn, num Function(SubMesh a, SubMesh b)? alphaTestSortCompareFn, num Function(SubMesh a, SubMesh b)? transparentSortCompareFn]);
	
	/// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
	/// 
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
	/// @param depth Automatically clears depth between groups if true and autoClear is true.
	/// @param stencil Automatically clears stencil between groups if true and autoClear is true.
	external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil, [bool? depth, bool? stencil]);
	
	/// Gets the current auto clear configuration for one rendering group of the rendering
	/// manager.
	/// @param index the rendering group index to get the information for
	/// @returns The auto clear setup for the requested rendering group
	external IRenderingManagerAutoClearSetup getAutoClearDepthStencilSetup(num index);
}

/// Defines the options associated with the creation of a custom shader for a shadow generator.
@JS()
@anonymous
class ICustomShaderOptions {
	
	external factory ICustomShaderOptions({String shaderName, List<String> attributes, List<String> uniforms, List<String> samplers, List<String> defines});
	
	/// Gets or sets the custom shader name to use
	external String get shaderName;
	external set shaderName( String value );
	
	/// The list of attribute names used in the shader
	external List<String> get attributes;
	external set attributes( List<String> value );
	
	/// The list of unifrom names used in the shader
	external List<String> get uniforms;
	external set uniforms( List<String> value );
	
	/// The list of sampler names used in the shader
	external List<String> get samplers;
	external set samplers( List<String> value );
	
	/// The list of defines used in the shader
	external List<String> get defines;
	external set defines( List<String> value );
}

/// Interface to implement to create a shadow generator compatible with BJS.
@JS()
abstract class IShadowGenerator {
	
	/// Gets or set the id of the shadow generator. It will be the one from the light if not defined
	external String get id;
	external set id(String value);
	
	/// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
	/// @returns The render target texture if present otherwise, null
	external RenderTargetTexture? getShadowMap();
	
	/// Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
	/// @param subMesh The submesh we want to render in the shadow map
	/// @param useInstances Defines wether will draw in the map using instances
	/// @param isTransparent Indicates that isReady is called for a transparent subMesh
	/// @returns true if ready otherwise, false
	external bool isReady(SubMesh subMesh, bool useInstances, bool isTransparent);
	
	/// Prepare all the defines in a material relying on a shadow map at the specified light index.
	/// @param defines Defines of the material we want to update
	/// @param lightIndex Index of the light in the enabled light list of the material
	external void prepareDefines(MaterialDefines defines, num lightIndex);
	
	/// Binds the shadow related information inside of an effect (information like near, far, darkness...
	/// defined in the generator but impacting the effect).
	/// It implies the unifroms available on the materials are the standard BJS ones.
	/// @param lightIndex Index of the light in the enabled light list of the material owning the effect
	/// @param effect The effect we are binfing the information for
	external void bindShadowLight(String lightIndex, Effect effect);
	
	/// Gets the transformation matrix used to project the meshes into the map from the light point of view.
	/// (eq to shadow prjection matrix * light transform matrix)
	/// @returns The transform matrix used to create the shadow map
	external Matrix getTransformMatrix();
	
	/// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
	/// Cube and 2D textures for instance.
	external void recreateShadowMap();
	
	/// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
	/// @param onCompiled Callback triggered at the and of the effects compilation
	/// @param options Sets of optional options forcing the compilation with different modes
	external void forceCompilation([void Function(IShadowGenerator generator)? onCompiled, IShadowGeneratorForceCompilationOptions? options]);
	
	/// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
	/// @param options Sets of optional options forcing the compilation with different modes
	/// @returns A promise that resolves when the compilation completes
	external Promise<void> forceCompilationAsync([IShadowGeneratorForceCompilationAsyncOptions? options]);
	
	/// Serializes the shadow generator setup to a json object.
	/// @returns The serialized JSON object
	external dynamic serialize();
	
	/// Disposes the Shadow map and related Textures and effects.
	external void dispose();
}

/// Default implementation IShadowGenerator.
/// This is the main object responsible of generating shadows in the framework.
/// Documentation: https://doc.babylonjs.com/babylon101/shadows
@JS()
class ShadowGenerator implements IShadowGenerator {
	
	/// Creates a ShadowGenerator object.
	/// A ShadowGenerator is the required tool to use the shadows.
	/// Each light casting shadows needs to use its own ShadowGenerator.
	/// Documentation : https://doc.babylonjs.com/babylon101/shadows
	/// @param mapSize The size of the texture what stores the shadows. Example : 1024.
	/// @param light The light object generating the shadows.
	/// @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
	external factory ShadowGenerator(num mapSize, IShadowLight light, [bool? usefulFloatFirst]);
	
	/// Name of the shadow generator class
	external static String get CLASSNAME;
	external static set CLASSNAME(String value);
	
	/// Shadow generator mode None: no filtering applied.
	external static num get FILTER_NONE;
	
	/// Shadow generator mode ESM: Exponential Shadow Mapping.
	/// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
	external static num get FILTER_EXPONENTIALSHADOWMAP;
	
	/// Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
	/// (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
	external static num get FILTER_POISSONSAMPLING;
	
	/// Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
	/// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
	external static num get FILTER_BLUREXPONENTIALSHADOWMAP;
	
	/// Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
	/// edge artifacts on steep falloff.
	/// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
	external static num get FILTER_CLOSEEXPONENTIALSHADOWMAP;
	
	/// Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
	/// edge artifacts on steep falloff.
	/// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
	external static num get FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
	
	/// Shadow generator mode PCF: Percentage Closer Filtering
	/// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
	/// (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
	external static num get FILTER_PCF;
	
	/// Shadow generator mode PCSS: Percentage Closering Soft Shadow.
	/// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
	/// Contact Hardening
	external static num get FILTER_PCSS;
	
	/// Reserved for PCF and PCSS
	/// Highest Quality.
	/// 
	/// Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
	/// 
	/// Execute PCSS with 32 taps blocker search and 64 taps PCF.
	external static num get QUALITY_HIGH;
	
	/// Reserved for PCF and PCSS
	/// Good tradeoff for quality/perf cross devices
	/// 
	/// Execute PCF on a 3*3 kernel.
	/// 
	/// Execute PCSS with 16 taps blocker search and 32 taps PCF.
	external static num get QUALITY_MEDIUM;
	
	/// Reserved for PCF and PCSS
	/// The lowest quality but the fastest.
	/// 
	/// Execute PCF on a 1*1 kernel.
	/// 
	/// Execute PCSS with 16 taps blocker search and 16 taps PCF.
	external static num get QUALITY_LOW;
	
	/// Gets or set the id of the shadow generator. It will be the one from the light if not defined
	@override
	external String get id;
	@override
	external set id(String value);
	
	/// Gets or sets the custom shader name to use
	external ICustomShaderOptions get customShaderOptions;
	external set customShaderOptions(ICustomShaderOptions value);
	
	/// Gets or sets a custom function to allow/disallow rendering a sub mesh in the shadow map
	external bool Function(SubMesh subMesh) get customAllowRendering;
	external set customAllowRendering(bool Function(SubMesh subMesh) value);
	
	/// Observable triggered before the shadow is rendered. Can be used to update internal effect state
	external Observable<Effect> get onBeforeShadowMapRenderObservable;
	external set onBeforeShadowMapRenderObservable(Observable<Effect> value);
	
	/// Observable triggered after the shadow is rendered. Can be used to restore internal effect state
	external Observable<Effect> get onAfterShadowMapRenderObservable;
	external set onAfterShadowMapRenderObservable(Observable<Effect> value);
	
	/// Observable triggered before a mesh is rendered in the shadow map.
	/// Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)
	external Observable<Mesh> get onBeforeShadowMapRenderMeshObservable;
	external set onBeforeShadowMapRenderMeshObservable(Observable<Mesh> value);
	
	/// Observable triggered after a mesh is rendered in the shadow map.
	/// Can be used to update internal effect state (that you can get from the onAfterShadowMapRenderObservable)
	external Observable<Mesh> get onAfterShadowMapRenderMeshObservable;
	external set onAfterShadowMapRenderMeshObservable(Observable<Mesh> value);
	
	/// Gets the bias: offset applied on the depth preventing acnea (in light direction).
	external num get bias;
	
	/// Sets the bias: offset applied on the depth preventing acnea (in light direction).
	external set bias(num value);
	
	/// Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
	external num get normalBias;
	
	/// Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
	external set normalBias(num value);
	
	/// Gets the blur box offset: offset applied during the blur pass.
	/// Only useful if useKernelBlur = false
	external num get blurBoxOffset;
	
	/// Sets the blur box offset: offset applied during the blur pass.
	/// Only useful if useKernelBlur = false
	external set blurBoxOffset(num value);
	
	/// Gets the blur scale: scale of the blurred texture compared to the main shadow map.
	/// 2 means half of the size.
	external num get blurScale;
	
	/// Sets the blur scale: scale of the blurred texture compared to the main shadow map.
	/// 2 means half of the size.
	external set blurScale(num value);
	
	/// Gets the blur kernel: kernel size of the blur pass.
	/// Only useful if useKernelBlur = true
	external num get blurKernel;
	
	/// Sets the blur kernel: kernel size of the blur pass.
	/// Only useful if useKernelBlur = true
	external set blurKernel(num value);
	
	/// Gets whether the blur pass is a kernel blur (if true) or box blur.
	/// Only useful in filtered mode (useBlurExponentialShadowMap...)
	external bool get useKernelBlur;
	
	/// Sets whether the blur pass is a kernel blur (if true) or box blur.
	/// Only useful in filtered mode (useBlurExponentialShadowMap...)
	external set useKernelBlur(bool value);
	
	/// Gets the depth scale used in ESM mode.
	external num get depthScale;
	
	/// Sets the depth scale used in ESM mode.
	/// This can override the scale stored on the light.
	external set depthScale(num value);
	
	/// Gets the current mode of the shadow generator (normal, PCF, ESM...).
	/// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
	external num get filter;
	
	/// Sets the current mode of the shadow generator (normal, PCF, ESM...).
	/// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
	external set filter(num value);
	
	/// Gets if the current filter is set to Poisson Sampling.
	external bool get usePoissonSampling;
	
	/// Sets the current filter to Poisson Sampling.
	external set usePoissonSampling(bool value);
	
	/// Gets if the current filter is set to ESM.
	external bool get useExponentialShadowMap;
	
	/// Sets the current filter is to ESM.
	external set useExponentialShadowMap(bool value);
	
	/// Gets if the current filter is set to filtered ESM.
	external bool get useBlurExponentialShadowMap;
	
	/// Gets if the current filter is set to filtered  ESM.
	external set useBlurExponentialShadowMap(bool value);
	
	/// Gets if the current filter is set to "close ESM" (using the inverse of the
	/// exponential to prevent steep falloff artifacts).
	external bool get useCloseExponentialShadowMap;
	
	/// Sets the current filter to "close ESM" (using the inverse of the
	/// exponential to prevent steep falloff artifacts).
	external set useCloseExponentialShadowMap(bool value);
	
	/// Gets if the current filter is set to filtered "close ESM" (using the inverse of the
	/// exponential to prevent steep falloff artifacts).
	external bool get useBlurCloseExponentialShadowMap;
	
	/// Sets the current filter to filtered "close ESM" (using the inverse of the
	/// exponential to prevent steep falloff artifacts).
	external set useBlurCloseExponentialShadowMap(bool value);
	
	/// Gets if the current filter is set to "PCF" (percentage closer filtering).
	external bool get usePercentageCloserFiltering;
	
	/// Sets the current filter to "PCF" (percentage closer filtering).
	external set usePercentageCloserFiltering(bool value);
	
	/// Gets the PCF or PCSS Quality.
	/// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
	external num get filteringQuality;
	
	/// Sets the PCF or PCSS Quality.
	/// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
	external set filteringQuality(num value);
	
	/// Gets if the current filter is set to "PCSS" (contact hardening).
	external bool get useContactHardeningShadow;
	
	/// Sets the current filter to "PCSS" (contact hardening).
	external set useContactHardeningShadow(bool value);
	
	/// Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
	/// Using a ratio helps keeping shape stability independently of the map size.
	/// 
	/// It does not account for the light projection as it was having too much
	/// instability during the light setup or during light position changes.
	/// 
	/// Only valid if useContactHardeningShadow is true.
	external num get contactHardeningLightSizeUVRatio;
	
	/// Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
	/// Using a ratio helps keeping shape stability independently of the map size.
	/// 
	/// It does not account for the light projection as it was having too much
	/// instability during the light setup or during light position changes.
	/// 
	/// Only valid if useContactHardeningShadow is true.
	external set contactHardeningLightSizeUVRatio(num value);
	
	/// Gets or sets the actual darkness of a shadow
	external num get darkness;
	
	external set darkness(num value);
	
	/// Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
	/// 0 means strongest and 1 would means no shadow.
	/// @returns the darkness.
	external num getDarkness();
	
	/// Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
	/// @param darkness The darkness value 0 means strongest and 1 would means no shadow.
	/// @returns the shadow generator allowing fluent coding.
	external ShadowGenerator setDarkness(num darkness);
	
	/// Gets or sets the ability to have transparent shadow
	external bool get transparencyShadow;
	
	external set transparencyShadow(bool value);
	
	/// Sets the ability to have transparent shadow (boolean).
	/// @param transparent True if transparent else False
	/// @returns the shadow generator allowing fluent coding
	external ShadowGenerator setTransparencyShadow(bool transparent);
	
	/// Enables or disables shadows with varying strength based on the transparency
	/// When it is enabled, the strength of the shadow is taken equal to mesh.visibility
	/// If you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:
	/// mesh.visibility * alphaTexture.a
	/// Note that by definition transparencyShadow must be set to true for enableSoftTransparentShadow to work!
	external bool get enableSoftTransparentShadow;
	external set enableSoftTransparentShadow(bool value);
	
	/// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
	/// @returns The render target texture if present otherwise, null
	@override
	external RenderTargetTexture? getShadowMap();
	
	/// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
	/// @returns The render target texture if the shadow map is present otherwise, null
	external RenderTargetTexture? getShadowMapForRendering();
	
	/// Gets the class name of that object
	/// @returns "ShadowGenerator"
	external String getClassName();
	
	/// Helper function to add a mesh and its descendants to the list of shadow casters.
	/// @param mesh Mesh to add
	/// @param includeDescendants boolean indicating if the descendants should be added. Default to true
	/// @returns the Shadow Generator itself
	external ShadowGenerator addShadowCaster(AbstractMesh mesh, [bool? includeDescendants]);
	
	/// Helper function to remove a mesh and its descendants from the list of shadow casters
	/// @param mesh Mesh to remove
	/// @param includeDescendants boolean indicating if the descendants should be removed. Default to true
	/// @returns the Shadow Generator itself
	external ShadowGenerator removeShadowCaster(AbstractMesh mesh, [bool? includeDescendants]);
	
	/// Controls the extent to which the shadows fade out at the edge of the frustum
	external num get frustumEdgeFalloff;
	external set frustumEdgeFalloff(num value);
	
	/// Returns the associated light object.
	/// @returns the light generating the shadow
	external IShadowLight getLight();
	
	/// If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
	/// This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
	/// It might on the other hand introduce peter panning.
	external bool get forceBackFacesOnly;
	external set forceBackFacesOnly(bool value);
	
	/// Gets or sets the size of the texture what stores the shadows
	external num get mapSize;
	
	external set mapSize(num value);
	
	/// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
	/// @param onCompiled Callback triggered at the and of the effects compilation
	/// @param options Sets of optional options forcing the compilation with different modes
	@override
	/* Manual Fix 26 */
	external void forceCompilation([void Function(IShadowGenerator generator)? onCompiled, IShadowGeneratorForceCompilationOptions? options]);
	
	/// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
	/// @param options Sets of optional options forcing the compilation with different modes
	/// @returns A promise that resolves when the compilation completes
	@override
	/* Manual Fix 27 */
	external Promise<void> forceCompilationAsync([IShadowGeneratorForceCompilationAsyncOptions? options]);
	
	/// Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
	/// @param subMesh The submesh we want to render in the shadow map
	/// @param useInstances Defines wether will draw in the map using instances
	/// @param isTransparent Indicates that isReady is called for a transparent subMesh
	/// @returns true if ready otherwise, false
	@override
	external bool isReady(SubMesh subMesh, bool useInstances, bool isTransparent);
	
	/// Prepare all the defines in a material relying on a shadow map at the specified light index.
	/// @param defines Defines of the material we want to update
	/// @param lightIndex Index of the light in the enabled light list of the material
	@override
	external void prepareDefines(dynamic defines, num lightIndex);
	
	/// Binds the shadow related information inside of an effect (information like near, far, darkness...
	/// defined in the generator but impacting the effect).
	/// @param lightIndex Index of the light in the enabled light list of the material owning the effect
	/// @param effect The effect we are binfing the information for
	@override
	external void bindShadowLight(String lightIndex, Effect effect);
	
	/// Gets the transformation matrix used to project the meshes into the map from the light point of view.
	/// (eq to shadow prjection matrix * light transform matrix)
	/// @returns The transform matrix used to create the shadow map
	@override
	external Matrix getTransformMatrix();
	
	/// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
	/// Cube and 2D textures for instance.
	@override
	external void recreateShadowMap();
	
	/// Disposes the ShadowGenerator.
	/// Returns nothing.
	@override
	external void dispose();
	
	/// Serializes the shadow generator setup to a json object.
	/// @returns The serialized JSON object
	@override
	external dynamic serialize();
	
	/// Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
	/// @param parsedShadowGenerator The JSON object to parse
	/// @param scene The scene to create the shadow map for
	/// @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
	/// @returns The parsed shadow generator
	external static ShadowGenerator Parse(dynamic parsedShadowGenerator, Scene scene, [ShadowGenerator Function(num mapSize, IShadowLight light)? constr]);
}

/// Options to be used when creating a shadow depth material
@JS()
@anonymous
class IIOptionShadowDepthMaterial {
	
	external factory IIOptionShadowDepthMaterial({List<String> remappedVariables, bool standalone});
	
	/// Variables in the vertex shader code that need to have their names remapped.
	/// The format is: ["var_name", "var_remapped_name", "var_name", "var_remapped_name", ...]
	/// "var_name" should be either: worldPos or vNormalW
	/// So, if the variable holding the world position in your vertex shader is not named worldPos, you must tell the system
	/// the name to use instead by using: ["worldPos", "myWorldPosVar"] assuming the variable is named myWorldPosVar in your code.
	/// If the normal must also be remapped: ["worldPos", "myWorldPosVar", "vNormalW", "myWorldNormal"]
	external List<String> get remappedVariables;
	external set remappedVariables( List<String> value );
	
	/// Set standalone to true if the base material wrapped by ShadowDepthMaterial is not used for a regular object but for depth shadow generation only
	external bool get standalone;
	external set standalone( bool value );
}

/// Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material
@JS()
class ShadowDepthWrapper {
	
	/// Instantiate a new shadow depth wrapper.
	/// It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to
	/// generate the shadow depth map. For more information, please refer to the documentation:
	/// https://doc.babylonjs.com/babylon101/shadows
	/// @param baseMaterial Material to wrap
	/// @param scene Define the scene the material belongs to
	/// @param options Options used to create the wrapper
	external factory ShadowDepthWrapper(Material baseMaterial, Scene scene, [IIOptionShadowDepthMaterial? options]);
	
	/// Gets the standalone status of the wrapper
	external bool get standalone;
	
	/// Gets the base material the wrapper is built upon
	external Material get baseMaterial;
	
	/// Gets the effect to use to generate the depth map
	/// @param subMesh subMesh to get the effect for
	/// @param shadowGenerator shadow generator to get the effect for
	/// @returns the effect to use to generate the depth map for the subMesh + shadow generator specified
	external Effect? getEffect(SubMesh? subMesh, ShadowGenerator shadowGenerator);
	
	/// Specifies that the submesh is ready to be used for depth rendering
	/// @param subMesh submesh to check
	/// @param defines the list of defines to take into account when checking the effect
	/// @param shadowGenerator combined with subMesh, it defines the effect to check
	/// @param useInstances specifies that instances should be used
	/// @returns a boolean indicating that the submesh is ready or not
	external bool isReadyForSubMesh(SubMesh subMesh, List<String> defines, ShadowGenerator shadowGenerator, bool useInstances);
	
	/// Disposes the resources
	external void dispose();
}

/// Options for compiling materials.
@JS()
@anonymous
class IMaterialCompilationOptions {
	
	external factory IMaterialCompilationOptions({bool clipPlane, bool useInstances});
	
	/// Defines whether clip planes are enabled.
	external bool get clipPlane;
	external set clipPlane( bool value );
	
	/// Defines whether instances are enabled.
	external bool get useInstances;
	external set useInstances( bool value );
}

/// Options passed when calling customShaderNameResolve
@JS()
@anonymous
class ICustomShaderNameResolveOptions {
	
	external factory ICustomShaderNameResolveOptions({String Function(String shaderType, String code)? processFinalCode});
	
	/// If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU
	external String Function(String shaderType, String code)? get processFinalCode;
	external set processFinalCode( String Function(String shaderType, String code)? value );
}

/// Base class for the main features of a material in Babylon.js
@JS()
class Material implements IAnimatable {
	
	/// Creates a material instance
	/// @param name defines the name of the material
	/// @param scene defines the scene to reference
	/// @param doNotAdd specifies if the material should be added to the scene
	external factory Material(String name, Scene scene, [bool? doNotAdd]);
	
	/// Returns the triangle fill mode
	external static num get TriangleFillMode;
	
	/// Returns the wireframe mode
	external static num get WireFrameFillMode;
	
	/// Returns the point fill mode
	external static num get PointFillMode;
	
	/// Returns the point list draw mode
	external static num get PointListDrawMode;
	
	/// Returns the line list draw mode
	external static num get LineListDrawMode;
	
	/// Returns the line loop draw mode
	external static num get LineLoopDrawMode;
	
	/// Returns the line strip draw mode
	external static num get LineStripDrawMode;
	
	/// Returns the triangle strip draw mode
	external static num get TriangleStripDrawMode;
	
	/// Returns the triangle fan draw mode
	external static num get TriangleFanDrawMode;
	
	/// Stores the clock-wise side orientation
	external static num get ClockWiseSideOrientation;
	
	/// Stores the counter clock-wise side orientation
	external static num get CounterClockWiseSideOrientation;
	
	/// The dirty texture flag value
	external static num get TextureDirtyFlag;
	
	/// The dirty light flag value
	external static num get LightDirtyFlag;
	
	/// The dirty fresnel flag value
	external static num get FresnelDirtyFlag;
	
	/// The dirty attribute flag value
	external static num get AttributesDirtyFlag;
	
	/// The dirty misc flag value
	external static num get MiscDirtyFlag;
	
	/// The dirty prepass flag value
	external static num get PrePassDirtyFlag;
	
	/// The all dirty flag value
	external static num get AllDirtyFlag;
	
	/// MaterialTransparencyMode: No transparency mode, Alpha channel is not use.
	external static num get MATERIAL_OPAQUE;
	
	/// MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
	external static num get MATERIAL_ALPHATEST;
	
	/// MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
	external static num get MATERIAL_ALPHABLEND;
	
	/// MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
	/// They are also discarded below the alpha cutoff threshold to improve performances.
	external static num get MATERIAL_ALPHATESTANDBLEND;
	
	/// The Whiteout method is used to blend normals.
	/// Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/
	external static num get MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
	
	/// The Reoriented Normal Mapping method is used to blend normals.
	/// Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/
	external static num get MATERIAL_NORMALBLENDMETHOD_RNM;
	
	/// Custom callback helping to override the default shader used in the material.
	external String Function(String shaderName, List<String> uniforms, List<String> uniformBuffers, List<String> samplers, dynamic defines, [List<String>? attributes, ICustomShaderNameResolveOptions? options]) get customShaderNameResolve;
	external set customShaderNameResolve(String Function(String shaderName, List<String> uniforms, List<String> uniformBuffers, List<String> samplers, dynamic defines, [List<String>? attributes, ICustomShaderNameResolveOptions? options]) value);
	
	/// Custom shadow depth material to use for shadow rendering instead of the in-built one
	external ShadowDepthWrapper? get shadowDepthWrapper;
	external set shadowDepthWrapper(ShadowDepthWrapper? value);
	
	/// Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.
	/// This means that the material can keep using a previous shader while a new one is being compiled.
	/// This is mostly used when shader parallel compilation is supported (true by default)
	external bool get allowShaderHotSwapping;
	external set allowShaderHotSwapping(bool value);
	
	/// The ID of the material
	external String get id;
	external set id(String value);
	
	/// Gets or sets the unique id of the material
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// The name of the material
	external String get name;
	external set name(String value);
	
	/// Gets or sets user defined metadata
	external dynamic get metadata;
	external set metadata(dynamic value);
	
	/// For internal use only. Please do not use.
	external dynamic get reservedDataStore;
	external set reservedDataStore(dynamic value);
	
	/// Specifies if the ready state should be checked on each call
	external bool get checkReadyOnEveryCall;
	external set checkReadyOnEveryCall(bool value);
	
	/// Specifies if the ready state should be checked once
	external bool get checkReadyOnlyOnce;
	external set checkReadyOnlyOnce(bool value);
	
	/// The state of the material
	external String get state;
	external set state(String value);
	
	/// If the material can be rendered to several textures with MRT extension
	external bool get canRenderToMRT;
	
	/// List of inspectable custom properties (used by the Inspector)
	/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
	external List<IInspectable> get inspectableCustomProperties;
	external set inspectableCustomProperties(List<IInspectable> value);
	
	/// Sets the alpha value of the material
	external set alpha(num value);
	
	/// Gets the alpha value of the material
	external num get alpha;
	
	/// Sets the back-face culling state
	external set backFaceCulling(bool value);
	
	/// Gets the back-face culling state
	external bool get backFaceCulling;
	
	/// Stores the value for side orientation
	external num get sideOrientation;
	external set sideOrientation(num value);
	
	/// Callback triggered when the material is compiled
	external void Function(Effect effect)? get onCompiled;
	external set onCompiled(void Function(Effect effect)? value);
	
	/// Callback triggered when an error occurs
	external void Function(Effect effect, String errors)? get onError;
	external set onError(void Function(Effect effect, String errors)? value);
	
	/// Callback triggered to get the render target textures
	external SmartArray<RenderTargetTexture> Function()? get getRenderTargetTextures;
	external set getRenderTargetTextures(SmartArray<RenderTargetTexture> Function()? value);
	
	/// Gets a boolean indicating that current material needs to register RTT
	external bool get hasRenderTargetTextures;
	
	/// Specifies if the material should be serialized
	external bool get doNotSerialize;
	external set doNotSerialize(bool value);
	
	/// Stores the animations for the material
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// An event triggered when the material is disposed
	external Observable<Material> get onDisposeObservable;
	external set onDisposeObservable(Observable<Material> value);
	
	/// Called during a dispose event
	external set onDispose(void Function() value);
	
	/// An event triggered when the material is bound
	external Observable<AbstractMesh> get onBindObservable;
	
	/// Called during a bind event
	external set onBind(void Function(AbstractMesh Mesh) value);
	
	/// An event triggered when the material is unbound
	external Observable<Material> get onUnBindObservable;
	
	/// An event triggered when the effect is (re)created
	external Observable<MaterialOnEffectCreatedObservable> get onEffectCreatedObservable;
	
	/// Sets the value of the alpha mode.
	/// 
	/// | Value | Type | Description |
	/// | --- | --- | --- |
	/// | 0 | ALPHA_DISABLE |   |
	/// | 1 | ALPHA_ADD |   |
	/// | 2 | ALPHA_COMBINE |   |
	/// | 3 | ALPHA_SUBTRACT |   |
	/// | 4 | ALPHA_MULTIPLY |   |
	/// | 5 | ALPHA_MAXIMIZED |   |
	/// | 6 | ALPHA_ONEONE |   |
	/// | 7 | ALPHA_PREMULTIPLIED |   |
	/// | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
	/// | 9 | ALPHA_INTERPOLATE |   |
	/// | 10 | ALPHA_SCREENMODE |   |
	/// 
	external set alphaMode(num value);
	
	/// Gets the value of the alpha mode
	external num get alphaMode;
	
	/// Sets the need depth pre-pass value
	external set needDepthPrePass(bool value);
	
	/// Gets the depth pre-pass value
	external bool get needDepthPrePass;
	
	/// Specifies if depth writing should be disabled
	external bool get disableDepthWrite;
	external set disableDepthWrite(bool value);
	
	/// Specifies if color writing should be disabled
	external bool get disableColorWrite;
	external set disableColorWrite(bool value);
	
	/// Specifies if depth writing should be forced
	external bool get forceDepthWrite;
	external set forceDepthWrite(bool value);
	
	/// Specifies the depth function that should be used. 0 means the default engine function
	external num get depthFunction;
	external set depthFunction(num value);
	
	/// Specifies if there should be a separate pass for culling
	external bool get separateCullingPass;
	external set separateCullingPass(bool value);
	
	/// Sets the state for enabling fog
	external set fogEnabled(bool value);
	
	/// Gets the value of the fog enabled state
	external bool get fogEnabled;
	
	/// Stores the size of points
	external num get pointSize;
	external set pointSize(num value);
	
	/// Stores the z offset value
	external num get zOffset;
	external set zOffset(num value);
	
	external bool get wireframe;
	
	/// Sets the state of wireframe mode
	external set wireframe(bool value);
	
	/// Gets the value specifying if point clouds are enabled
	external bool get pointsCloud;
	
	/// Sets the state of point cloud mode
	external set pointsCloud(bool value);
	
	/// Gets the material fill mode
	external num get fillMode;
	
	/// Sets the material fill mode
	external set fillMode(num value);
	
	/// @hidden
	external dynamic /* object */? get meshMap;
	external set meshMap(dynamic /* object */? value);
	
	/// Returns a string representation of the current material
	/// @param fullDetails defines a boolean indicating which levels of logging is desired
	/// @returns a string with material information
	external String toString([bool? fullDetails]);
	
	/// Gets the class name of the material
	/// @returns a string with the class name of the material
	external String getClassName();
	
	/// Specifies if updates for the material been locked
	external bool get isFrozen;
	
	/// Locks updates for the material
	external void freeze();
	
	/// Unlocks updates for the material
	external void unfreeze();
	
	/// Specifies if the material is ready to be used
	/// @param mesh defines the mesh to check
	/// @param useInstances specifies if instances should be used
	/// @returns a boolean indicating if the material is ready to be used
	external bool isReady([AbstractMesh? mesh, bool? useInstances]);
	
	/// Specifies that the submesh is ready to be used
	/// @param mesh defines the mesh to check
	/// @param subMesh defines which submesh to check
	/// @param useInstances specifies that instances should be used
	/// @returns a boolean indicating that the submesh is ready or not
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Returns the material effect
	/// @returns the effect associated with the material
	external Effect? getEffect();
	
	/// Returns the current scene
	/// @returns a Scene
	external Scene getScene();
	
	/// Gets the current transparency mode.
	external num? get transparencyMode;
	
	/// Sets the transparency mode of the material.
	/// 
	/// | Value | Type                                | Description |
	/// | ----- | ----------------------------------- | ----------- |
	/// | 0     | OPAQUE                              |             |
	/// | 1     | ALPHATEST                           |             |
	/// | 2     | ALPHABLEND                          |             |
	/// | 3     | ALPHATESTANDBLEND                   |             |
	/// 
	external set transparencyMode(num? value);
	
	/// Specifies whether or not this material should be rendered in alpha blend mode.
	/// @returns a boolean specifying if alpha blending is needed
	external bool needAlphaBlending();
	
	/// Specifies if the mesh will require alpha blending
	/// @param mesh defines the mesh to check
	/// @returns a boolean specifying if alpha blending is needed for the mesh
	external bool needAlphaBlendingForMesh(AbstractMesh mesh);
	
	/// Specifies whether or not this material should be rendered in alpha test mode.
	/// @returns a boolean specifying if an alpha test is needed.
	external bool needAlphaTesting();
	
	/// Gets the texture used for the alpha test
	/// @returns the texture to use for alpha testing
	external BaseTexture? getAlphaTestTexture();
	
	/// Marks the material to indicate that it needs to be re-calculated
	external void markDirty();
	
	/// Binds the material to the mesh
	/// @param world defines the world transformation matrix
	/// @param mesh defines the mesh to bind the material to
	external void bind(Matrix world, [Mesh? mesh]);
	
	/// Binds the submesh to the material
	/// @param world defines the world transformation matrix
	/// @param mesh defines the mesh containing the submesh
	/// @param subMesh defines the submesh to bind the material to
	external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
	
	/// Binds the world matrix to the material
	/// @param world defines the world transformation matrix
	external void bindOnlyWorldMatrix(Matrix world);
	
	/// Binds the scene's uniform buffer to the effect.
	/// @param effect defines the effect to bind to the scene uniform buffer
	/// @param sceneUbo defines the uniform buffer storing scene data
	external void bindSceneUniformBuffer(Effect effect, UniformBuffer sceneUbo);
	
	/// Binds the view matrix to the effect
	/// @param effect defines the effect to bind the view matrix to
	external void bindView(Effect effect);
	
	/// Binds the view projection matrix to the effect
	/// @param effect defines the effect to bind the view projection matrix to
	external void bindViewProjection(Effect effect);
	
	/// Unbinds the material from the mesh
	external void unbind();
	
	/// Gets the active textures from the material
	/// @returns an array of textures
	external List<BaseTexture> getActiveTextures();
	
	/// Specifies if the material uses a texture
	/// @param texture defines the texture to check against the material
	/// @returns a boolean specifying if the material uses the texture
	external bool hasTexture(BaseTexture texture);
	
	/// Makes a duplicate of the material, and gives it a new name
	/// @param name defines the new name for the duplicated material
	/// @returns the cloned material
	external Material? clone(String name);
	
	/// Gets the meshes bound to the material
	/// @returns an array of meshes bound to the material
	external List<AbstractMesh> getBindedMeshes();
	
	/// Force shader compilation
	/// @param mesh defines the mesh associated with this material
	/// @param onCompiled defines a function to execute once the material is compiled
	/// @param options defines the options to configure the compilation
	/// @param onError defines a function to execute if the material fails compiling
	external void forceCompilation(AbstractMesh mesh, [void Function(Material material)? onCompiled, IMaterialCompilationOptions? options, void Function(String reason)? onError]);
	
	/// Force shader compilation
	/// @param mesh defines the mesh that will use this material
	/// @param options defines additional options for compiling the shaders
	/// @returns a promise that resolves when the compilation completes
	external Promise<void> forceCompilationAsync(AbstractMesh mesh, [IMaterialCompilationOptions? options]);
	
	/// Marks a define in the material to indicate that it needs to be re-computed
	/// @param flag defines a flag used to determine which parts of the material have to be marked as dirty
	external void markAsDirty(num flag);
	
	/// Sets the required values to the prepass renderer.
	/// @param prePassRenderer defines the prepass renderer to setup.
	/// @returns true if the pre pass is needed.
	external bool setPrePassRenderer(PrePassRenderer prePassRenderer);
	
	/// Disposes the material
	/// @param forceDisposeEffect specifies if effects should be forcefully disposed
	/// @param forceDisposeTextures specifies if textures should be forcefully disposed
	/// @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? notBoundToMesh]);
	
	/// Serializes this material
	/// @returns the serialized material object
	external dynamic serialize();
	
	/// Creates a material from parsed material data
	/// @param parsedMaterial defines parsed material data
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root URL to use to load textures
	/// @returns a new material
	external static Material? Parse(dynamic parsedMaterial, Scene scene, String rootUrl);
}

/// A multi-material is used to apply different materials to different parts of the same object without the need of
/// separate meshes. This can be use to improve performances.
/// @see https://doc.babylonjs.com/how_to/multi_materials
@JS()
class MultiMaterial extends Material {
	
	/// Instantiates a new Multi Material
	/// A multi-material is used to apply different materials to different parts of the same object without the need of
	/// separate meshes. This can be use to improve performances.
	/// @see https://doc.babylonjs.com/how_to/multi_materials
	/// @param name Define the name in the scene
	/// @param scene Define the scene the material belongs to
	external factory MultiMaterial(String name, Scene scene);
	
	/// Gets or Sets the list of Materials used within the multi material.
	/// They need to be ordered according to the submeshes order in the associated mesh
	external List<Material>? get subMaterials;
	
	external set subMaterials(List<Material>? value);
	
	/// Function used to align with Node.getChildren()
	/// @returns the list of Materials used within the multi material
	external List<Material>? getChildren();
	
	/// Get one of the submaterial by its index in the submaterials array
	/// @param index The index to look the sub material at
	/// @returns The Material if the index has been defined
	external Material? getSubMaterial(num index);
	
	/// Get the list of active textures for the whole sub materials list.
	/// @returns All the textures that will be used during the rendering
	@override
	external List<BaseTexture> getActiveTextures();
	
	/// Specifies if any sub-materials of this multi-material use a given texture.
	/// @param texture Defines the texture to check against this multi-material's sub-materials.
	/// @returns A boolean specifying if any sub-material of this multi-material uses the texture.
	@override
	external bool hasTexture(BaseTexture texture);
	
	/// Gets the current class name of the material e.g. "MultiMaterial"
	/// Mainly use in serialization.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Checks if the material is ready to render the requested sub mesh
	/// @param mesh Define the mesh the submesh belongs to
	/// @param subMesh Define the sub mesh to look readyness for
	/// @param useInstances Define whether or not the material is used with instances
	/// @returns true if ready, otherwise false
	@override
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Clones the current material and its related sub materials
	/// @param name Define the name of the newly cloned material
	/// @param cloneChildren Define if submaterial will be cloned or shared with the parent instance
	/// @returns the cloned material
	@override
	external MultiMaterial? clone(String name, [bool? cloneChildren]);
	
	/// Serializes the materials into a JSON representation.
	/// @returns the JSON representation
	@override
	external dynamic serialize();
	
	/// Dispose the material and release its associated resources
	/// @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)
	/// @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)
	/// @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)
	@override
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? forceDisposeChildren]);
	
	/// Creates a MultiMaterial from parsed MultiMaterial data.
	/// @param parsedMultiMaterial defines parsed MultiMaterial data.
	/// @param scene defines the hosting scene
	/// @returns a new MultiMaterial
	external static MultiMaterial ParseMultiMaterial(dynamic parsedMultiMaterial, Scene scene);
}

/// Defines a subdivision inside a mesh
@JS()
class SubMesh implements ICullable {
	
	/// Creates a new submesh
	/// @param materialIndex defines the material index to use
	/// @param verticesStart defines vertex index start
	/// @param verticesCount defines vertices count
	/// @param indexStart defines index start
	/// @param indexCount defines indices count
	/// @param mesh defines the parent mesh
	/// @param renderingMesh defines an optional rendering mesh
	/// @param createBoundingBox defines if bounding box should be created for this submesh
	/// @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)
	external factory SubMesh(num materialIndex, num verticesStart, num verticesCount, num indexStart, num indexCount, AbstractMesh mesh, [Mesh? renderingMesh, bool? createBoundingBox, bool? addToMesh]);
	
	/// the material index to use
	external num get materialIndex;
	external set materialIndex(num value);
	
	/// vertex index start
	external num get verticesStart;
	external set verticesStart(num value);
	
	/// vertices count
	external num get verticesCount;
	external set verticesCount(num value);
	
	/// index start
	external num get indexStart;
	external set indexStart(num value);
	
	/// indices count
	external num get indexCount;
	external set indexCount(num value);
	
	/// Gets material defines used by the effect associated to the sub mesh
	external MaterialDefines? get materialDefines;
	
	/// Sets material defines used by the effect associated to the sub mesh
	external set materialDefines(MaterialDefines? value);
	
	/// Gets associated effect
	external Effect? get effect;
	
	/// Sets associated effect (effect used to render this submesh)
	/// @param effect defines the effect to associate with
	/// @param defines defines the set of defines used to compile this effect
	external void setEffect(Effect? effect, [MaterialDefines? defines]);
	
	/// Add a new submesh to a mesh
	/// @param materialIndex defines the material index to use
	/// @param verticesStart defines vertex index start
	/// @param verticesCount defines vertices count
	/// @param indexStart defines index start
	/// @param indexCount defines indices count
	/// @param mesh defines the parent mesh
	/// @param renderingMesh defines an optional rendering mesh
	/// @param createBoundingBox defines if bounding box should be created for this submesh
	/// @returns the new submesh
	external static SubMesh AddToMesh(num materialIndex, num verticesStart, num verticesCount, num indexStart, num indexCount, AbstractMesh mesh, [Mesh? renderingMesh, bool? createBoundingBox]);
	
	/// Returns true if this submesh covers the entire parent mesh
	/// @ignorenaming
	external bool get IsGlobal;
	
	/// Returns the submesh BoudingInfo object
	/// @returns current bounding info (or mesh's one if the submesh is global)
	external BoundingInfo getBoundingInfo();
	
	/// Sets the submesh BoundingInfo
	/// @param boundingInfo defines the new bounding info to use
	/// @returns the SubMesh
	external SubMesh setBoundingInfo(BoundingInfo boundingInfo);
	
	/// Returns the mesh of the current submesh
	/// @return the parent mesh
	external AbstractMesh getMesh();
	
	/// Returns the rendering mesh of the submesh
	/// @returns the rendering mesh (could be different from parent mesh)
	external Mesh getRenderingMesh();
	
	/// Returns the replacement mesh of the submesh
	/// @returns the replacement mesh (could be different from parent mesh)
	external AbstractMesh? getReplacementMesh();
	
	/// Returns the effective mesh of the submesh
	/// @returns the effective mesh (could be different from parent mesh)
	external AbstractMesh getEffectiveMesh();
	
	/// Returns the submesh material
	/// @returns null or the current material
	external Material? getMaterial();
	
	/// Sets a new updated BoundingInfo object to the submesh
	/// @param data defines an optional position array to use to determine the bounding info
	/// @returns the SubMesh
	external SubMesh refreshBoundingInfo([dynamic? data]);
	
	/// Updates the submesh BoundingInfo
	/// @param world defines the world matrix to use to update the bounding info
	/// @returns the submesh
	external SubMesh updateBoundingInfo(Matrix world);
	
	/// True is the submesh bounding box intersects the frustum defined by the passed array of planes.
	/// @param frustumPlanes defines the frustum planes
	/// @returns true if the submesh is intersecting with the frustum
	@override
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// True is the submesh bounding box is completely inside the frustum defined by the passed array of planes
	/// @param frustumPlanes defines the frustum planes
	/// @returns true if the submesh is inside the frustum
	@override
	external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
	
	/// Renders the submesh
	/// @param enableAlphaMode defines if alpha needs to be used
	/// @returns the submesh
	external SubMesh render(bool enableAlphaMode);
	
	/// Checks if the submesh intersects with a ray
	/// @param ray defines the ray to test
	/// @returns true is the passed ray intersects the submesh bounding box
	external bool canIntersects(Ray ray);
	
	/// Intersects current submesh with a ray
	/// @param ray defines the ray to test
	/// @param positions defines mesh's positions array
	/// @param indices defines mesh's indices array
	/// @param fastCheck defines if the first intersection will be used (and not the closest)
	/// @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
	/// @returns intersection info or null if no intersection
	external IntersectionInfo? intersects(Ray ray, List<Vector3> positions, dynamic indices, [bool? fastCheck, dynamic? trianglePredicate]);
	
	/// Creates a new submesh from the passed mesh
	/// @param newMesh defines the new hosting mesh
	/// @param newRenderingMesh defines an optional rendering mesh
	/// @returns the new submesh
	external SubMesh clone(AbstractMesh newMesh, [Mesh? newRenderingMesh]);
	
	/// Release associated resources
	external void dispose();
	
	/// Gets the class name
	/// @returns the string "SubMesh".
	external String getClassName();
	
	/// Creates a new submesh from indices data
	/// @param materialIndex the index of the main mesh material
	/// @param startIndex the index where to start the copy in the mesh indices array
	/// @param indexCount the number of indices to copy then from the startIndex
	/// @param mesh the main mesh to create the submesh from
	/// @param renderingMesh the optional rendering mesh
	/// @returns a new submesh
	external static SubMesh CreateFromIndices(num materialIndex, num startIndex, num indexCount, AbstractMesh mesh, [Mesh? renderingMesh]);
}

/// Class used to represent data loading progression
@JS()
class SceneLoaderFlags {
	external factory SceneLoaderFlags();
	
	/// Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
	external static bool get ForceFullSceneLoadingForIncremental;
	
	external static set ForceFullSceneLoadingForIncremental(bool value);
	
	/// Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
	external static bool get ShowLoadingScreen;
	
	external static set ShowLoadingScreen(bool value);
	
	/// Defines the current logging level (while loading the scene)
	/// @ignorenaming
	external static num get loggingLevel;
	
	external static set loggingLevel(num value);
	
	/// Gets or set a boolean indicating if matrix weights must be cleaned upon loading
	external static bool get CleanBoneMatrixWeights;
	
	external static set CleanBoneMatrixWeights(bool value);
}

/// Class used to store geometry data (vertex buffers + index buffer)
@JS()
class Geometry implements IGetSetVerticesData {
	
	/// Creates a new geometry
	/// @param id defines the unique ID
	/// @param scene defines the hosting scene
	/// @param vertexData defines the VertexData used to get geometry data
	/// @param updatable defines if geometry must be updatable (false by default)
	/// @param mesh defines the mesh that will be associated with the geometry
	external factory Geometry(String id, Scene scene, [VertexData? vertexData, bool? updatable, Mesh? mesh]);
	
	/// Gets or sets the ID of the geometry
	external String get id;
	external set id(String value);
	
	/// Gets or sets the unique ID of the geometry
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Gets the delay loading state of the geometry (none by default which means not delayed)
	external num get delayLoadState;
	external set delayLoadState(num value);
	
	/// Gets the file containing the data to load when running in delay load state
	external String? get delayLoadingFile;
	external set delayLoadingFile(String? value);
	
	/// Callback called when the geometry is updated
	external void Function(Geometry geometry, [String? kind]) get onGeometryUpdated;
	external set onGeometryUpdated(void Function(Geometry geometry, [String? kind]) value);
	
	/// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
	external Vector2 get boundingBias;
	
	/// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
	external set boundingBias(Vector2 value);
	
	/// Static function used to attach a new empty geometry to a mesh
	/// @param mesh defines the mesh to attach the geometry to
	/// @returns the new Geometry
	external static Geometry CreateGeometryForMesh(Mesh mesh);
	
	/// Get the list of meshes using this geometry
	external List<Mesh> get meshes;
	
	/// If set to true (false by defaut), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level
	/// and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)
	external bool get useBoundingInfoFromGeometry;
	external set useBoundingInfoFromGeometry(bool value);
	
	/// Gets the current extend of the geometry
	external GeometryExtend get extend;
	
	/// Gets the hosting scene
	/// @returns the hosting Scene
	external Scene getScene();
	
	/// Gets the hosting engine
	/// @returns the hosting Engine
	external Engine getEngine();
	
	/// Defines if the geometry is ready to use
	/// @returns true if the geometry is ready to be used
	external bool isReady();
	
	/// Gets a value indicating that the geometry should not be serialized
	external bool get doNotSerialize;
	
	/// Affects all geometry data in one call
	/// @param vertexData defines the geometry data
	/// @param updatable defines if the geometry must be flagged as updatable (false as default)
	external void setAllVerticesData(VertexData vertexData, [bool? updatable]);
	
	/// Set specific vertex data
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @param data defines the vertex data to use
	/// @param updatable defines if the vertex must be flagged as updatable (false as default)
	/// @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
	@override
	external void setVerticesData(String kind, dynamic data, [bool? updatable, num? stride]);
	
	/// Removes a specific vertex data
	/// @param kind defines the data kind (Position, normal, etc...)
	external void removeVerticesData(String kind);
	
	/// Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data
	/// @param buffer defines the vertex buffer to use
	/// @param totalVertices defines the total number of vertices for position kind (could be null)
	external void setVerticesBuffer(VertexBuffer buffer, [num? totalVertices]);
	
	/// Update a specific vertex buffer
	/// This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array
	/// It will do nothing if the buffer is not updatable
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @param data defines the data to use
	/// @param offset defines the offset in the target buffer where to store the data
	/// @param useBytes set to true if the offset is in bytes
	external void updateVerticesDataDirectly(String kind, dynamic data, num offset, [bool? useBytes]);
	
	/// Update a specific vertex buffer
	/// This function will create a new buffer if the current one is not updatable
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @param data defines the data to use
	/// @param updateExtends defines if the geometry extends must be recomputed (false by default)
	@override
	external void updateVerticesData(String kind, dynamic data, [bool? updateExtends, bool? makeItUnique]);
	
	/// Gets total number of vertices
	/// @returns the total number of vertices
	external num getTotalVertices();
	
	/// Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
	/// @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
	/// @returns a float array containing vertex data
	@override
	external dynamic? getVerticesData(String kind, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Returns a boolean defining if the vertex data for the requested `kind` is updatable
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @returns true if the vertex buffer with the specified kind is updatable
	external bool isVertexBufferUpdatable(String kind);
	
	/// Gets a specific vertex buffer
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @returns a VertexBuffer
	external VertexBuffer? getVertexBuffer(String kind);
	
	/// Returns all vertex buffers
	/// @return an object holding all vertex buffers indexed by kind
	external dynamic /* object */? getVertexBuffers();
	
	/// Gets a boolean indicating if specific vertex buffer is present
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @returns true if data is present
	@override
	external bool isVerticesDataPresent(String kind);
	
	/// Gets a list of all attached data kinds (Position, normal, etc...)
	/// @returns a list of string containing all kinds
	external List<String> getVerticesDataKinds();
	
	/// Update index buffer
	/// @param indices defines the indices to store in the index buffer
	/// @param offset defines the offset in the target buffer where to store the data
	/// @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
	external void updateIndices(dynamic indices, [num? offset, bool? gpuMemoryOnly]);
	
	/// Creates a new index buffer
	/// @param indices defines the indices to store in the index buffer
	/// @param totalVertices defines the total number of vertices (could be null)
	/// @param updatable defines if the index buffer must be flagged as updatable (false by default)
	@override
	external void setIndices(dynamic indices, [num? totalVertices, bool? updatable]);
	
	/// Return the total number of indices
	/// @returns the total number of indices
	external num getTotalIndices();
	
	/// Gets the index buffer array
	/// @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
	/// @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
	/// @returns the index buffer array
	@override
	external dynamic? getIndices([bool? copyWhenShared, bool? forceCopy]);
	
	/// Gets the index buffer
	/// @return the index buffer
	external DataBuffer? getIndexBuffer();
	
	/// Release the associated resources for a specific mesh
	/// @param mesh defines the source mesh
	/// @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it
	external void releaseForMesh(Mesh mesh, [bool? shouldDispose]);
	
	/// Apply current geometry to a given mesh
	/// @param mesh defines the mesh to apply geometry to
	external void applyToMesh(Mesh mesh);
	
	/// Load the geometry if it was flagged as delay loaded
	/// @param scene defines the hosting scene
	/// @param onLoaded defines a callback called when the geometry is loaded
	external void load(Scene scene, [void Function()? onLoaded]);
	
	/// Invert the geometry to move from a right handed system to a left handed one.
	external void toLeftHanded();
	
	/// Gets a value indicating if the geometry is disposed
	/// @returns true if the geometry was disposed
	external bool isDisposed();
	
	/// Free all associated resources
	external void dispose();
	
	/// Clone the current geometry into a new geometry
	/// @param id defines the unique ID of the new geometry
	/// @returns a new geometry object
	external Geometry copy(String id);
	
	/// Serialize the current geometry info (and not the vertices data) into a JSON object
	/// @return a JSON representation of the current geometry data (without the vertices data)
	external dynamic serialize();
	
	/// Serialize all vertices data into a JSON oject
	/// @returns a JSON representation of the current geometry data
	external dynamic serializeVerticeData();
	
	/// Extracts a clone of a mesh geometry
	/// @param mesh defines the source mesh
	/// @param id defines the unique ID of the new geometry object
	/// @returns the new geometry object
	external static Geometry? ExtractFromMesh(Mesh mesh, String id);
	
	/// You should now use Tools.RandomId(), this method is still here for legacy reasons.
	/// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
	/// Be aware Math.random() could cause collisions, but:
	/// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
	/// @returns a string containing a new GUID
	external static String RandomId();
	
	/// Create a new geometry from persisted data (Using .babylon file format)
	/// @param parsedVertexData defines the persisted data
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root url to use to load assets (like delayed data)
	/// @returns the new geometry object
	external static Geometry? Parse(dynamic parsedVertexData, Scene scene, String rootUrl);
}

/// Defines a target to use with MorphTargetManager
/// @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets
@JS()
class MorphTarget implements IAnimatable {
	
	/// Creates a new MorphTarget
	/// @param name defines the name of the target
	/// @param influence defines the influence to use
	/// @param scene defines the scene the morphtarget belongs to
	external factory MorphTarget(String name, [num? influence, Scene? scene]);
	
	/// defines the name of the target
	external String get name;
	external set name(String value);
	
	/// Gets or sets the list of animations
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// Observable raised when the influence changes
	external Observable<bool> get onInfluenceChanged;
	external set onInfluenceChanged(Observable<bool> value);
	
	/// Gets or sets the influence of this target (ie. its weight in the overall morphing)
	external num get influence;
	
	external set influence(num value);
	
	/// Gets or sets the id of the morph Target
	external String get id;
	external set id(String value);
	
	/// Gets or sets the animation properties override
	external AnimationPropertiesOverride? get animationPropertiesOverride;
	
	external set animationPropertiesOverride(AnimationPropertiesOverride? value);
	
	/// Gets the unique ID of this manager
	external num get uniqueId;
	
	/// Gets a boolean defining if the target contains position data
	external bool get hasPositions;
	
	/// Gets a boolean defining if the target contains normal data
	external bool get hasNormals;
	
	/// Gets a boolean defining if the target contains tangent data
	external bool get hasTangents;
	
	/// Gets a boolean defining if the target contains texture coordinates data
	external bool get hasUVs;
	
	/// Affects position data to this target
	/// @param data defines the position data to use
	external void setPositions(dynamic? data);
	
	/// Gets the position data stored in this target
	/// @returns a FloatArray containing the position data (or null if not present)
	external dynamic? getPositions();
	
	/// Affects normal data to this target
	/// @param data defines the normal data to use
	external void setNormals(dynamic? data);
	
	/// Gets the normal data stored in this target
	/// @returns a FloatArray containing the normal data (or null if not present)
	external dynamic? getNormals();
	
	/// Affects tangent data to this target
	/// @param data defines the tangent data to use
	external void setTangents(dynamic? data);
	
	/// Gets the tangent data stored in this target
	/// @returns a FloatArray containing the tangent data (or null if not present)
	external dynamic? getTangents();
	
	/// Affects texture coordinates data to this target
	/// @param data defines the texture coordinates data to use
	external void setUVs(dynamic? data);
	
	/// Gets the texture coordinates data stored in this target
	/// @returns a FloatArray containing the texture coordinates data (or null if not present)
	external dynamic? getUVs();
	
	/// Clone the current target
	/// @returns a new MorphTarget
	external MorphTarget clone();
	
	/// Serializes the current target into a Serialization object
	/// @returns the serialized object
	external dynamic serialize();
	
	/// Returns the string "MorphTarget"
	/// @returns "MorphTarget"
	external String getClassName();
	
	/// Creates a new target from serialized data
	/// @param serializationObject defines the serialized data to use
	/// @returns a new MorphTarget
	external static MorphTarget Parse(dynamic serializationObject);
	
	/// Creates a MorphTarget from mesh data
	/// @param mesh defines the source mesh
	/// @param name defines the name to use for the new target
	/// @param influence defines the influence to attach to the target
	/// @returns a new MorphTarget
	external static MorphTarget FromMesh(AbstractMesh mesh, [String? name, num? influence]);
}

/// This class is used to deform meshes using morphing between different targets
/// @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets
@JS()
class MorphTargetManager {
	
	/// Creates a new MorphTargetManager
	/// @param scene defines the current scene
	external factory MorphTargetManager([Scene? scene]);
	
	/// Gets or sets a boolean indicating if normals must be morphed
	external bool get enableNormalMorphing;
	external set enableNormalMorphing(bool value);
	
	/// Gets or sets a boolean indicating if tangents must be morphed
	external bool get enableTangentMorphing;
	external set enableTangentMorphing(bool value);
	
	/// Gets or sets a boolean indicating if UV must be morphed
	external bool get enableUVMorphing;
	external set enableUVMorphing(bool value);
	
	/// Gets the unique ID of this manager
	external num get uniqueId;
	
	/// Gets the number of vertices handled by this manager
	external num get vertexCount;
	
	/// Gets a boolean indicating if this manager supports morphing of normals
	external bool get supportsNormals;
	
	/// Gets a boolean indicating if this manager supports morphing of tangents
	external bool get supportsTangents;
	
	/// Gets a boolean indicating if this manager supports morphing of texture coordinates
	external bool get supportsUVs;
	
	/// Gets the number of targets stored in this manager
	external num get numTargets;
	
	/// Gets the number of influencers (ie. the number of targets with influences > 0)
	external num get numInfluencers;
	
	/// Gets the list of influences (one per target)
	external Float32List get influences;
	
	/// Gets the active target at specified index. An active target is a target with an influence > 0
	/// @param index defines the index to check
	/// @returns the requested target
	external MorphTarget getActiveTarget(num index);
	
	/// Gets the target at specified index
	/// @param index defines the index to check
	/// @returns the requested target
	external MorphTarget getTarget(num index);
	
	/// Add a new target to this manager
	/// @param target defines the target to add
	external void addTarget(MorphTarget target);
	
	/// Removes a target from the manager
	/// @param target defines the target to remove
	external void removeTarget(MorphTarget target);
	
	/// Clone the current manager
	/// @returns a new MorphTargetManager
	external MorphTargetManager clone();
	
	/// Serializes the current manager into a Serialization object
	/// @returns the serialized object
	external dynamic serialize();
	
	/// Syncrhonize the targets with all the meshes using this morph target manager
	external void synchronize();
	
	/// Creates a new MorphTargetManager from serialized data
	/// @param serializationObject defines the serialized data
	/// @param scene defines the hosting scene
	/// @returns the new MorphTargetManager
	external static MorphTargetManager Parse(dynamic serializationObject, Scene scene);
}

/// Class used to represent a specific level of detail of a mesh
/// @see https://doc.babylonjs.com/how_to/how_to_use_lod
@JS()
class MeshLODLevel {
	
	/// Creates a new LOD level
	/// @param distance defines the distance where this level should star being displayed
	/// @param mesh defines the mesh to use to render this level
	external factory MeshLODLevel(num distance, Mesh? mesh);
	
	/// Defines the distance where this level should start being displayed
	external num get distance;
	external set distance(num value);
	
	/// Defines the mesh to use to render this level
	external Mesh? get mesh;
	external set mesh(Mesh? value);
}

/// Helper class used to generate a canvas to manipulate images
@JS()
class CanvasGenerator {
	external factory CanvasGenerator();
	
	/// Create a new canvas (or offscreen canvas depending on the context)
	/// @param width defines the expected width
	/// @param height defines the expected height
	/// @return a new canvas or offscreen canvas
	external static dynamic CreateCanvas(num width, num height);
}

/// Mesh representing the gorund
@JS()
class GroundMesh extends Mesh {
	
	external factory GroundMesh(String name, Scene scene);
	
	/// If octree should be generated
	external bool get generateOctree;
	external set generateOctree(bool value);
	
	/// "GroundMesh"
	/// @returns "GroundMesh"
	@override
	external String getClassName();
	
	/// The minimum of x and y subdivisions
	external num get subdivisions;
	
	/// X subdivisions
	external num get subdivisionsX;
	
	/// Y subdivisions
	external num get subdivisionsY;
	
	/// This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.
	/// Please note that you must have a decent number of submeshes to get performance improvements when using an octree
	/// @param chunksCount the number of subdivisions for x and y
	/// @param octreeBlocksSize (Default: 32)
	external void optimize(num chunksCount, [num? octreeBlocksSize]);
	
	/// Returns a height (y) value in the Worl system :
	/// the ground altitude at the coordinates (x, z) expressed in the World system.
	/// @param x x coordinate
	/// @param z z coordinate
	/// @returns the ground y position if (x, z) are outside the ground surface.
	external num getHeightAtCoordinates(num x, num z);
	
	/// Returns a normalized vector (Vector3) orthogonal to the ground
	/// at the ground coordinates (x, z) expressed in the World system.
	/// @param x x coordinate
	/// @param z z coordinate
	/// @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
	external Vector3 getNormalAtCoordinates(num x, num z);
	
	/// Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
	/// at the ground coordinates (x, z) expressed in the World system.
	/// Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.
	/// @param x x coordinate
	/// @param z z coordinate
	/// @param ref vector to store the result
	/// @returns the GroundMesh.
	external GroundMesh getNormalAtCoordinatesToRef(num x, num z, Vector3 ref);
	
	/// Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
	/// if the ground has been updated.
	/// This can be used in the render loop.
	/// @returns the GroundMesh.
	external GroundMesh updateCoordinateHeights();
	
	/// Serializes this ground mesh
	/// @param serializationObject object to write serialization to
	@override
	external void serialize([dynamic? serializationObject]);
	
	/// Parses a serialized ground mesh
	/// @param parsedMesh the serialized mesh
	/// @param scene the scene to create the ground mesh in
	/// @returns the created ground mesh
	@override
	external static GroundMesh Parse(dynamic parsedMesh, Scene scene, [String? rootUrl]);
}

/// Interface for Physics-Joint data
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
abstract class PhysicsJointData {
	
	/// The main pivot of the joint
	external Vector3 get mainPivot;
	external set mainPivot(Vector3 value);
	
	/// The connected pivot of the joint
	external Vector3 get connectedPivot;
	external set connectedPivot(Vector3 value);
	
	/// The main axis of the joint
	external Vector3 get mainAxis;
	external set mainAxis(Vector3 value);
	
	/// The connected axis of the joint
	external Vector3 get connectedAxis;
	external set connectedAxis(Vector3 value);
	
	/// The collision of the joint
	external bool get collision;
	external set collision(bool value);
	
	/// Native Oimo/Cannon/Energy data
	external dynamic get nativeParams;
	external set nativeParams(dynamic value);
}

/// This is a holder class for the physics joint created by the physics plugin
/// It holds a set of functions to control the underlying joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class PhysicsJoint {
	
	/// Initializes the physics joint
	/// @param type The type of the physics joint
	/// @param jointData The data for the physics joint
	external factory PhysicsJoint(num type, PhysicsJointData jointData);
	
	/// The type of the physics joint
	external num get type;
	external set type(num value);
	
	/// The data for the physics joint
	external PhysicsJointData get jointData;
	external set jointData(PhysicsJointData value);
	
	/// Gets the physics joint
	external dynamic get physicsJoint;
	
	/// Sets the physics joint
	external set physicsJoint(dynamic value);
	
	/// Sets the physics plugin
	external set physicsPlugin(IPhysicsEnginePlugin value);
	
	/// Execute a function that is physics-plugin specific.
	/// @param {Function} func the function that will be executed.
	/// It accepts two parameters: the physics world and the physics joint
	external void executeNativeFunction(void Function(dynamic world, dynamic physicsJoint) func);
	
	/// Distance-Joint type
	@JS("DistanceJoint")
	external static num get DistanceJoint_js;
	@JS("DistanceJoint")
	external static set DistanceJoint_js(num value);
	
	/// Hinge-Joint type
	@JS("HingeJoint")
	external static num get HingeJoint_js;
	@JS("HingeJoint")
	external static set HingeJoint_js(num value);
	
	/// Ball-and-Socket joint type
	external static num get BallAndSocketJoint;
	external static set BallAndSocketJoint(num value);
	
	/// Wheel-Joint type
	external static num get WheelJoint;
	external static set WheelJoint(num value);
	
	/// Slider-Joint type
	external static num get SliderJoint;
	external static set SliderJoint(num value);
	
	/// Prismatic-Joint type
	external static num get PrismaticJoint;
	external static set PrismaticJoint(num value);
	
	/// Universal-Joint type
	/// ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)
	external static num get UniversalJoint;
	external static set UniversalJoint(num value);
	
	/// Hinge-Joint 2 type
	@JS("Hinge2Joint")
	external static num get Hinge2Joint_js;
	@JS("Hinge2Joint")
	external static set Hinge2Joint_js(num value);
	
	/// Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters
	external static num get PointToPointJoint;
	external static set PointToPointJoint(num value);
	
	/// Spring-Joint type
	external static num get SpringJoint;
	external static set SpringJoint(num value);
	
	/// Lock-Joint type
	external static num get LockJoint;
	external static set LockJoint(num value);
}

/// A class representing a physics distance joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class DistanceJoint extends PhysicsJoint {
	
	/// 
	/// @param jointData The data for the Distance-Joint
	external factory DistanceJoint(DistanceJointData jointData);
	
	/// Update the predefined distance.
	/// @param maxDistance The maximum preferred distance
	/// @param minDistance The minimum preferred distance
	external void updateDistance(num maxDistance, [num? minDistance]);
}

/// Represents a Motor-Enabled Joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {
	
	/// Initializes the Motor-Enabled Joint
	/// @param type The type of the joint
	/// @param jointData The physica joint data for the joint
	external factory MotorEnabledJoint(num type, PhysicsJointData jointData);
	
	/// Set the motor values.
	/// Attention, this function is plugin specific. Engines won't react 100% the same.
	/// @param force the force to apply
	/// @param maxForce max force for this motor.
	@override
	external void setMotor([num? force, num? maxForce, num? motorIndex]);
	
	/// Set the motor's limits.
	/// Attention, this function is plugin specific. Engines won't react 100% the same.
	/// @param upperLimit The upper limit of the motor
	/// @param lowerLimit The lower limit of the motor
	@override
	external void setLimit(num upperLimit, [num? lowerLimit, num? motorIndex]);
	
	/// Physics joint
	external dynamic get physicsJoint;
	external set physicsJoint(dynamic value);
}

/// This class represents a single physics Hinge-Joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class HingeJoint extends MotorEnabledJoint {
	
	/// Initializes the Hinge-Joint
	/// @param jointData The joint data for the Hinge-Joint
	external factory HingeJoint(PhysicsJointData jointData);
	
	/// Set the motor values.
	/// Attention, this function is plugin specific. Engines won't react 100% the same.
	/// @param {number} force the force to apply
	/// @param {number} maxForce max force for this motor.
	@override
	external void setMotor([num? force, num? maxForce, num? motorIndex]);
	
	/// Set the motor's limits.
	/// Attention, this function is plugin specific. Engines won't react 100% the same.
	/// @param upperLimit The upper limit of the motor
	/// @param lowerLimit The lower limit of the motor
	@override
	external void setLimit(num upperLimit, [num? lowerLimit, num? motorIndex]);
}

/// This class represents a dual hinge physics joint (same as wheel joint)
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class Hinge2Joint extends MotorEnabledJoint {
	
	/// Initializes the Hinge2-Joint
	/// @param jointData The joint data for the Hinge2-Joint
	external factory Hinge2Joint(PhysicsJointData jointData);
	
	/// Set the motor values.
	/// Attention, this function is plugin specific. Engines won't react 100% the same.
	/// @param {number} targetSpeed the speed the motor is to reach
	/// @param {number} maxForce max force for this motor.
	/// @param {motorIndex} the motor's index, 0 or 1.
	@override
	external void setMotor([num? targetSpeed, num? maxForce, num? motorIndex]);
	
	/// Set the motor limits.
	/// Attention, this function is plugin specific. Engines won't react 100% the same.
	/// @param {number} upperLimit the upper limit
	/// @param {number} lowerLimit lower limit
	/// @param {motorIndex} the motor's index, 0 or 1.
	@override
	external void setLimit(num upperLimit, [num? lowerLimit, num? motorIndex]);
}

/// Interface for a motor enabled joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
abstract class IMotorEnabledJoint {
	
	/// Physics joint
	external dynamic get physicsJoint;
	external set physicsJoint(dynamic value);
	
	/// Sets the motor of the motor-enabled joint
	/// @param force The force of the motor
	/// @param maxForce The maximum force of the motor
	/// @param motorIndex The index of the motor
	external void setMotor([num? force, num? maxForce, num? motorIndex]);
	
	/// Sets the limit of the motor
	/// @param upperLimit The upper limit of the motor
	/// @param lowerLimit The lower limit of the motor
	/// @param motorIndex The index of the motor
	external void setLimit(num upperLimit, [num? lowerLimit, num? motorIndex]);
}

/// Joint data for a Distance-Joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
@anonymous
class DistanceJointData {
	
	external factory DistanceJointData({num maxDistance});
	
	/// Max distance the 2 joint objects can be apart
	external num get maxDistance;
	external set maxDistance( num value );
}

/// Joint data from a spring joint
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
@anonymous
class SpringJointData {
	
	external factory SpringJointData({num length, num stiffness, num damping, void Function() forceApplicationCallback});
	
	/// Length of the spring
	external num get length;
	external set length( num value );
	
	/// Stiffness of the spring
	external num get stiffness;
	external set stiffness( num value );
	
	/// Damping of the spring
	external num get damping;
	external set damping( num value );
	
	/// this callback will be called when applying the force to the impostors.
	external void Function() get forceApplicationCallback;
	external set forceApplicationCallback( void Function() value );
}

/// Holds the data for the raycast result
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class PhysicsRaycastResult {
	external factory PhysicsRaycastResult();
	
	/// Gets if there was a hit
	external bool get hasHit;
	
	/// Gets the distance from the hit
	external num get hitDistance;
	
	/// Gets the hit normal/direction in the world
	external Vector3 get hitNormalWorld;
	
	/// Gets the hit point in the world
	external Vector3 get hitPointWorld;
	
	/// Gets the ray "start point" of the ray in the world
	external Vector3 get rayFromWorld;
	
	/// Gets the ray "end point" of the ray in the world
	external Vector3 get rayToWorld;
	
	/// Sets the hit data (normal & point in world space)
	/// @param hitNormalWorld defines the normal in world space
	/// @param hitPointWorld defines the point in world space
	external void setHitData(IXYZ hitNormalWorld, IXYZ hitPointWorld);
	
	/// Sets the distance from the start point to the hit point
	/// @param distance
	external void setHitDistance(num distance);
	
	/// Calculates the distance manually
	external void calculateHitDistance();
	
	/// Resets all the values to default
	/// @param from The from point on world space
	/// @param to The to point on world space
	external void reset([Vector3? from, Vector3? to]);
}

/// Interface for the size containing width and height
@JS()
@anonymous
class IXYZ {
	
	external factory IXYZ({num x, num y, num z});
	
	/// X
	external num get x;
	external set x( num value );
	
	/// Y
	external num get y;
	external set y( num value );
	
	/// Z
	external num get z;
	external set z( num value );
}

/// Interface used to describe a physics joint
@JS()
@anonymous
class PhysicsImpostorJoint {
	
	external factory PhysicsImpostorJoint({PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint});
	
	/// Defines the main impostor to which the joint is linked
	external PhysicsImpostor get mainImpostor;
	external set mainImpostor( PhysicsImpostor value );
	
	/// Defines the impostor that is connected to the main impostor using this joint
	external PhysicsImpostor get connectedImpostor;
	external set connectedImpostor( PhysicsImpostor value );
	
	/// Defines the joint itself
	external PhysicsJoint get joint;
	external set joint( PhysicsJoint value );
}

/// @hidden
@JS()
abstract class IPhysicsEnginePlugin {
	
	external dynamic get world;
	external set world(dynamic value);
	
	external String get name;
	external set name(String value);
	
	external void setGravity(Vector3 gravity);
	
	external void setTimeStep(num timeStep);
	
	external num getTimeStep();
	
	external void executeStep(num delta, List<PhysicsImpostor> impostors);
	
	external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	external void generatePhysicsBody(PhysicsImpostor impostor);
	
	external void removePhysicsBody(PhysicsImpostor impostor);
	
	external void generateJoint(PhysicsImpostorJoint joint);
	
	external void removeJoint(PhysicsImpostorJoint joint);
	
	external bool isSupported();
	
	external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);
	
	external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);
	
	external void setLinearVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	external void setAngularVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	external Vector3? getLinearVelocity(PhysicsImpostor impostor);
	
	external Vector3? getAngularVelocity(PhysicsImpostor impostor);
	
	external void setBodyMass(PhysicsImpostor impostor, num mass);
	
	external num getBodyMass(PhysicsImpostor impostor);
	
	external num getBodyFriction(PhysicsImpostor impostor);
	
	external void setBodyFriction(PhysicsImpostor impostor, num friction);
	
	external num getBodyRestitution(PhysicsImpostor impostor);
	
	external void setBodyRestitution(PhysicsImpostor impostor, num restitution);
	
	external num getBodyPressure(PhysicsImpostor impostor);
	
	external void setBodyPressure(PhysicsImpostor impostor, num pressure);
	
	external num getBodyStiffness(PhysicsImpostor impostor);
	
	external void setBodyStiffness(PhysicsImpostor impostor, num stiffness);
	
	external num getBodyVelocityIterations(PhysicsImpostor impostor);
	
	external void setBodyVelocityIterations(PhysicsImpostor impostor, num velocityIterations);
	
	external num getBodyPositionIterations(PhysicsImpostor impostor);
	
	external void setBodyPositionIterations(PhysicsImpostor impostor, num positionIterations);
	
	external void appendAnchor(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num width, num height, num influence, bool noCollisionBetweenLinkedBodies);
	
	external void appendHook(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num length, num influence, bool noCollisionBetweenLinkedBodies);
	
	external void sleepBody(PhysicsImpostor impostor);
	
	external void wakeUpBody(PhysicsImpostor impostor);
	
	external PhysicsRaycastResult raycast(Vector3 from, Vector3 to);
	
	external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num? minDistance]);
	
	external void setMotor(IMotorEnabledJoint joint, num speed, [num? maxForce, num? motorIndex]);
	
	external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num? lowerLimit, num? motorIndex]);
	
	external num getRadius(PhysicsImpostor impostor);
	
	external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);
	
	external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);
	
	external void dispose();
}

/// Interface used to define a physics engine
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
abstract class IPhysicsEngine {
	
	/// Gets the gravity vector used by the simulation
	external Vector3 get gravity;
	external set gravity(Vector3 value);
	
	/// Sets the gravity vector used by the simulation
	/// @param gravity defines the gravity vector to use
	external void setGravity(Vector3 gravity);
	
	/// Set the time step of the physics engine.
	/// Default is 1/60.
	/// To slow it down, enter 1/600 for example.
	/// To speed it up, 1/30
	/// @param newTimeStep the new timestep to apply to this world.
	external void setTimeStep(num newTimeStep);
	
	/// Get the time step of the physics engine.
	/// @returns the current time step
	external num getTimeStep();
	
	/// Set the sub time step of the physics engine.
	/// Default is 0 meaning there is no sub steps
	/// To increase physics resolution precision, set a small value (like 1 ms)
	/// @param subTimeStep defines the new sub timestep used for physics resolution.
	external void setSubTimeStep(num subTimeStep);
	
	/// Get the sub time step of the physics engine.
	/// @returns the current sub time step
	external num getSubTimeStep();
	
	/// Release all resources
	external void dispose();
	
	/// Gets the name of the current physics plugin
	/// @returns the name of the plugin
	external String getPhysicsPluginName();
	
	/// Adding a new impostor for the impostor tracking.
	/// This will be done by the impostor itself.
	/// @param impostor the impostor to add
	external void addImpostor(PhysicsImpostor impostor);
	
	/// Remove an impostor from the engine.
	/// This impostor and its mesh will not longer be updated by the physics engine.
	/// @param impostor the impostor to remove
	external void removeImpostor(PhysicsImpostor impostor);
	
	/// Add a joint to the physics engine
	/// @param mainImpostor defines the main impostor to which the joint is added.
	/// @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
	/// @param joint defines the joint that will connect both impostors.
	external void addJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);
	
	/// Removes a joint from the simulation
	/// @param mainImpostor defines the impostor used with the joint
	/// @param connectedImpostor defines the other impostor connected to the main one by the joint
	/// @param joint defines the joint to remove
	external void removeJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);
	
	/// Gets the current plugin used to run the simulation
	/// @returns current plugin
	external IPhysicsEnginePlugin getPhysicsPlugin();
	
	/// Gets the list of physic impostors
	/// @returns an array of PhysicsImpostor
	external List<PhysicsImpostor> getImpostors();
	
	/// Gets the impostor for a physics enabled object
	/// @param object defines the object impersonated by the impostor
	/// @returns the PhysicsImpostor or null if not found
	external PhysicsImpostor? getImpostorForPhysicsObject(IPhysicsEnabledObject object);
	
	/// Gets the impostor for a physics body object
	/// @param body defines physics body used by the impostor
	/// @returns the PhysicsImpostor or null if not found
	external PhysicsImpostor? getImpostorWithPhysicsBody(dynamic body);
	
	/// Does a raycast in the physics world
	/// @param from when should the ray start?
	/// @param to when should the ray end?
	/// @returns PhysicsRaycastResult
	external PhysicsRaycastResult raycast(Vector3 from, Vector3 to);
}

/// The interface for the physics imposter parameters
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
@anonymous
class PhysicsImpostorParameters {
	
	external factory PhysicsImpostorParameters({num mass, num friction, num restitution, dynamic nativeOptions, bool ignoreParent, bool disableBidirectionalTransformation, num pressure, num stiffness, num velocityIterations, num positionIterations, num fixedPoints, num margin, num damping, dynamic path, dynamic shape});
	
	/// The mass of the physics imposter
	external num get mass;
	external set mass( num value );
	
	/// The friction of the physics imposter
	external num get friction;
	external set friction( num value );
	
	/// The coefficient of restitution of the physics imposter
	external num get restitution;
	external set restitution( num value );
	
	/// The native options of the physics imposter
	external dynamic get nativeOptions;
	external set nativeOptions( dynamic value );
	
	/// Specifies if the parent should be ignored
	external bool get ignoreParent;
	external set ignoreParent( bool value );
	
	/// Specifies if bi-directional transformations should be disabled
	external bool get disableBidirectionalTransformation;
	external set disableBidirectionalTransformation( bool value );
	
	/// The pressure inside the physics imposter, soft object only
	external num get pressure;
	external set pressure( num value );
	
	/// The stiffness the physics imposter, soft object only
	external num get stiffness;
	external set stiffness( num value );
	
	/// The number of iterations used in maintaining consistent vertex velocities, soft object only
	external num get velocityIterations;
	external set velocityIterations( num value );
	
	/// The number of iterations used in maintaining consistent vertex positions, soft object only
	external num get positionIterations;
	external set positionIterations( num value );
	
	/// The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only
	/// 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right
	/// Add to fix multiple points
	external num get fixedPoints;
	external set fixedPoints( num value );
	
	/// The collision margin around a soft object
	external num get margin;
	external set margin( num value );
	
	/// The collision margin around a soft object
	external num get damping;
	external set damping( num value );
	
	/// The path for a rope based on an extrusion
	external dynamic get path;
	external set path( dynamic value );
	
	/// The shape of an extrusion used for a rope based on an extrusion
	external dynamic get shape;
	external set shape( dynamic value );
}

/// Interface for a physics-enabled object
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
abstract class IPhysicsEnabledObject {
	
	/// The position of the physics-enabled object
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// The rotation of the physics-enabled object
	external Quaternion? get rotationQuaternion;
	external set rotationQuaternion(Quaternion? value);
	
	/// The scale of the physics-enabled object
	external Vector3 get scaling;
	external set scaling(Vector3 value);
	
	/// The rotation of the physics-enabled object
	external Vector3 get rotation;
	external set rotation(Vector3 value);
	
	/// The parent of the physics-enabled object
	external dynamic get parent;
	external set parent(dynamic value);
	
	/// The bounding info of the physics-enabled object
	/// @returns The bounding info of the physics-enabled object
	external BoundingInfo getBoundingInfo();
	
	/// Computes the world matrix
	/// @param force Specifies if the world matrix should be computed by force
	/// @returns A world matrix
	external Matrix computeWorldMatrix(bool force);
	
	/// Gets the world matrix
	/// @returns A world matrix
	external Matrix getWorldMatrix();
	
	/// Gets the child meshes
	/// @param directDescendantsOnly Specifies if only direct-descendants should be obtained
	/// @returns An array of abstract meshes
	external List<AbstractMesh> getChildMeshes([bool? directDescendantsOnly]);
	
	/// Gets the vertex data
	/// @param kind The type of vertex data
	/// @returns A nullable array of numbers, or a float32 array
	external dynamic? getVerticesData(String kind);
	
	/// Gets the indices from the mesh
	/// @returns A nullable array of index arrays
	external dynamic? getIndices();
	
	/// Gets the scene from the mesh
	/// @returns the indices array or null
	external Scene getScene();
	
	/// Gets the absolute position from the mesh
	/// @returns the absolute position
	external Vector3 getAbsolutePosition();
	
	/// Gets the absolute pivot point from the mesh
	/// @returns the absolute pivot point
	external Vector3 getAbsolutePivotPoint();
	
	/// Rotates the mesh
	/// @param axis The axis of rotation
	/// @param amount The amount of rotation
	/// @param space The space of the rotation
	/// @returns The rotation transform node
	external TransformNode rotate(Vector3 axis, num amount, [int? space]);
	
	/// Translates the mesh
	/// @param axis The axis of translation
	/// @param distance The distance of translation
	/// @param space The space of the translation
	/// @returns The transform node
	external TransformNode translate(Vector3 axis, num distance, [int? space]);
	
	/// Sets the absolute position of the mesh
	/// @param absolutePosition The absolute position of the mesh
	/// @returns The transform node
	external TransformNode setAbsolutePosition(Vector3 absolutePosition);
	
	/// Gets the class name of the mesh
	/// @returns The class name
	external String getClassName();
}

/// Represents a physics imposter
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class PhysicsImpostor {
	
	/// Initializes the physics imposter
	/// @param object The physics-enabled object used as the physics imposter
	/// @param type The type of the physics imposter
	/// @param _options The options for the physics imposter
	/// @param _scene The Babylon scene
	external factory PhysicsImpostor(IPhysicsEnabledObject object, num type, [PhysicsImpostorParameters? _options, Scene? _scene]);
	
	/// The physics-enabled object used as the physics imposter
	external IPhysicsEnabledObject get object;
	external set object(IPhysicsEnabledObject value);
	
	/// The type of the physics imposter
	external num get type;
	external set type(num value);
	
	/// The default object size of the imposter
	external static Vector3 get DEFAULT_OBJECT_SIZE;
	external static set DEFAULT_OBJECT_SIZE(Vector3 value);
	
	/// The identity quaternion of the imposter
	external static Quaternion get IDENTITY_QUATERNION;
	external static set IDENTITY_QUATERNION(Quaternion value);
	
	/// Specifies if the physics imposter is disposed
	external bool get isDisposed;
	
	/// Gets the mass of the physics imposter
	external num get mass;
	
	external set mass(num value);
	
	/// Gets the coefficient of friction
	external num get friction;
	
	/// Sets the coefficient of friction
	external set friction(num value);
	
	/// Gets the coefficient of restitution
	external num get restitution;
	
	/// Sets the coefficient of restitution
	external set restitution(num value);
	
	/// Gets the pressure of a soft body; only supported by the AmmoJSPlugin
	external num get pressure;
	
	/// Sets the pressure of a soft body; only supported by the AmmoJSPlugin
	external set pressure(num value);
	
	/// Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
	external num get stiffness;
	
	/// Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
	external set stiffness(num value);
	
	/// Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
	external num get velocityIterations;
	
	/// Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
	external set velocityIterations(num value);
	
	/// Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
	external num get positionIterations;
	
	/// Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
	external set positionIterations(num value);
	
	/// The unique id of the physics imposter
	/// set by the physics engine when adding this impostor to the array
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// @hidden
	external bool get soft;
	external set soft(bool value);
	
	/// @hidden
	external num get segments;
	external set segments(num value);
	
	/// Should a new body be generated.
	/// @returns boolean specifying if body initialization is required
	external bool isBodyInitRequired();
	
	/// Sets the updated scaling
	/// @param updated Specifies if the scaling is updated
	external void setScalingUpdated();
	
	/// Force a regeneration of this or the parent's impostor's body.
	/// Use under cautious - This will remove all joints already implemented.
	external void forceUpdate();
	
	/// Gets the body that holds this impostor. Either its own, or its parent.
	external dynamic get physicsBody;
	
	/// Get the parent of the physics imposter
	/// @returns Physics imposter or null
	external PhysicsImpostor? get parent;
	
	/// Sets the parent of the physics imposter
	external set parent(PhysicsImpostor? value);
	
	/// Set the physics body. Used mainly by the physics engine/plugin
	external set physicsBody(dynamic value);
	
	/// Resets the update flags
	external void resetUpdateFlags();
	
	/// Gets the object extend size
	/// @returns the object extend size
	external Vector3 getObjectExtendSize();
	
	/// Gets the object center
	/// @returns The object center
	external Vector3 getObjectCenter();
	
	/// Get a specific parameter from the options parameters
	/// @param paramName The object parameter name
	/// @returns The object parameter
	external dynamic getParam(String paramName);
	
	/// Sets a specific parameter in the options given to the physics plugin
	/// @param paramName The parameter name
	/// @param value The value of the parameter
	external void setParam(String paramName, num value);
	
	/// Specifically change the body's mass option. Won't recreate the physics body object
	/// @param mass The mass of the physics imposter
	external void setMass(num mass);
	
	/// Gets the linear velocity
	/// @returns  linear velocity or null
	external Vector3? getLinearVelocity();
	
	/// Sets the linear velocity
	/// @param velocity  linear velocity or null
	external void setLinearVelocity(Vector3? velocity);
	
	/// Gets the angular velocity
	/// @returns angular velocity or null
	external Vector3? getAngularVelocity();
	
	/// Sets the angular velocity
	/// @param velocity The velocity or null
	external void setAngularVelocity(Vector3? velocity);
	
	/// Execute a function with the physics plugin native code
	/// Provide a function the will have two variables - the world object and the physics body object
	/// @param func The function to execute with the physics plugin native code
	external void executeNativeFunction(void Function(dynamic world, dynamic physicsBody) func);
	
	/// Register a function that will be executed before the physics world is stepping forward
	/// @param func The function to execute before the physics world is stepped forward
	external void registerBeforePhysicsStep(void Function(PhysicsImpostor impostor) func);
	
	/// Unregister a function that will be executed before the physics world is stepping forward
	/// @param func The function to execute before the physics world is stepped forward
	external void unregisterBeforePhysicsStep(void Function(PhysicsImpostor impostor) func);
	
	/// Register a function that will be executed after the physics step
	/// @param func The function to execute after physics step
	external void registerAfterPhysicsStep(void Function(PhysicsImpostor impostor) func);
	
	/// Unregisters a function that will be executed after the physics step
	/// @param func The function to execute after physics step
	external void unregisterAfterPhysicsStep(void Function(PhysicsImpostor impostor) func);
	
	/// register a function that will be executed when this impostor collides against a different body
	/// @param collideAgainst Physics imposter, or array of physics imposters to collide against
	/// @param func Callback that is executed on collision
	external void registerOnPhysicsCollide(dynamic collideAgainst, void Function(PhysicsImpostor collider, PhysicsImpostor collidedAgainst) func);
	
	/// Unregisters the physics imposter on contact
	/// @param collideAgainst The physics object to collide against
	/// @param func Callback to execute on collision
	external void unregisterOnPhysicsCollide(dynamic collideAgainst, void Function(PhysicsImpostor collider, dynamic collidedAgainst) func);
	
	/// Get the parent rotation
	/// @returns The parent rotation
	external Quaternion getParentsRotation();
	
	/// this function is executed by the physics engine.
	external void Function() get beforeStep;
	external set beforeStep(void Function() value);
	
	/// this function is executed by the physics engine
	external void Function() get afterStep;
	external set afterStep(void Function() value);
	
	/// Legacy collision detection event support
	external void Function(PhysicsImpostor collider, PhysicsImpostor collidedWith)? get onCollideEvent;
	external set onCollideEvent(void Function(PhysicsImpostor collider, PhysicsImpostor collidedWith)? value);
	
	/// event and body object due to cannon's event-based architecture.
	external void Function(PhysicsImpostorOnCollideE e) get onCollide;
	external set onCollide(void Function(PhysicsImpostorOnCollideE e) value);
	
	/// Apply a force
	/// @param force The force to apply
	/// @param contactPoint The contact point for the force
	/// @returns The physics imposter
	external PhysicsImpostor applyForce(Vector3 force, Vector3 contactPoint);
	
	/// Apply an impulse
	/// @param force The impulse force
	/// @param contactPoint The contact point for the impulse force
	/// @returns The physics imposter
	external PhysicsImpostor applyImpulse(Vector3 force, Vector3 contactPoint);
	
	/// A help function to create a joint
	/// @param otherImpostor A physics imposter used to create a joint
	/// @param jointType The type of joint
	/// @param jointData The data for the joint
	/// @returns The physics imposter
	external PhysicsImpostor createJoint(PhysicsImpostor otherImpostor, num jointType, PhysicsJointData jointData);
	
	/// Add a joint to this impostor with a different impostor
	/// @param otherImpostor A physics imposter used to add a joint
	/// @param joint The joint to add
	/// @returns The physics imposter
	external PhysicsImpostor addJoint(PhysicsImpostor otherImpostor, PhysicsJoint joint);
	
	/// Add an anchor to a cloth impostor
	/// @param otherImpostor rigid impostor to anchor to
	/// @param width ratio across width from 0 to 1
	/// @param height ratio up height from 0 to 1
	/// @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech
	/// @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
	/// @returns impostor the soft imposter
	external PhysicsImpostor addAnchor(PhysicsImpostor otherImpostor, num width, num height, num influence, bool noCollisionBetweenLinkedBodies);
	
	/// Add a hook to a rope impostor
	/// @param otherImpostor rigid impostor to anchor to
	/// @param length ratio across rope from 0 to 1
	/// @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little strech
	/// @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
	/// @returns impostor the rope imposter
	external PhysicsImpostor addHook(PhysicsImpostor otherImpostor, num length, num influence, bool noCollisionBetweenLinkedBodies);
	
	/// Will keep this body still, in a sleep mode.
	/// @returns the physics imposter
	external PhysicsImpostor sleep();
	
	/// Wake the body up.
	/// @returns The physics imposter
	external PhysicsImpostor wakeUp();
	
	/// Clones the physics imposter
	/// @param newObject The physics imposter clones to this physics-enabled object
	/// @returns A nullable physics imposter
	external PhysicsImpostor? clone(IPhysicsEnabledObject newObject);
	
	/// Disposes the physics imposter
	external void dispose();
	
	/// Sets the delta position
	/// @param position The delta position amount
	external void setDeltaPosition(Vector3 position);
	
	/// Sets the delta rotation
	/// @param rotation The delta rotation amount
	external void setDeltaRotation(Quaternion rotation);
	
	/// Gets the box size of the physics imposter and stores the result in the input parameter
	/// @param result Stores the box size
	/// @returns The physics imposter
	external PhysicsImpostor getBoxSizeToRef(Vector3 result);
	
	/// Gets the radius of the physics imposter
	/// @returns Radius of the physics imposter
	external num getRadius();
	
	/// Sync a bone with this impostor
	/// @param bone The bone to sync to the impostor.
	/// @param boneMesh The mesh that the bone is influencing.
	/// @param jointPivot The pivot of the joint / bone in local space.
	/// @param distToJoint Optional distance from the impostor to the joint.
	/// @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
	external void syncBoneWithImpostor(Bone bone, AbstractMesh boneMesh, Vector3 jointPivot, [num? distToJoint, Quaternion? adjustRotation]);
	
	/// Sync impostor to a bone
	/// @param bone The bone that the impostor will be synced to.
	/// @param boneMesh The mesh that the bone is influencing.
	/// @param jointPivot The pivot of the joint / bone in local space.
	/// @param distToJoint Optional distance from the impostor to the joint.
	/// @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
	/// @param boneAxis Optional vector3 axis the bone is aligned with
	external void syncImpostorWithBone(Bone bone, AbstractMesh boneMesh, Vector3 jointPivot, [num? distToJoint, Quaternion? adjustRotation, Vector3? boneAxis]);
	
	/// No-Imposter type
	external static num get NoImpostor;
	external static set NoImpostor(num value);
	
	/// Sphere-Imposter type
	external static num get SphereImpostor;
	external static set SphereImpostor(num value);
	
	/// Box-Imposter type
	external static num get BoxImpostor;
	external static set BoxImpostor(num value);
	
	/// Plane-Imposter type
	external static num get PlaneImpostor;
	external static set PlaneImpostor(num value);
	
	/// Mesh-imposter type
	external static num get MeshImpostor;
	external static set MeshImpostor(num value);
	
	/// Capsule-Impostor type (Ammo.js plugin only)
	external static num get CapsuleImpostor;
	external static set CapsuleImpostor(num value);
	
	/// Cylinder-Imposter type
	external static num get CylinderImpostor;
	external static set CylinderImpostor(num value);
	
	/// Particle-Imposter type
	external static num get ParticleImpostor;
	external static set ParticleImpostor(num value);
	
	/// Heightmap-Imposter type
	external static num get HeightmapImpostor;
	external static set HeightmapImpostor(num value);
	
	/// ConvexHull-Impostor type (Ammo.js plugin only)
	external static num get ConvexHullImpostor;
	external static set ConvexHullImpostor(num value);
	
	/// Custom-Imposter type (Ammo.js plugin only)
	external static num get CustomImpostor;
	external static set CustomImpostor(num value);
	
	/// Rope-Imposter type
	external static num get RopeImpostor;
	external static set RopeImpostor(num value);
	
	/// Cloth-Imposter type
	external static num get ClothImpostor;
	external static set ClothImpostor(num value);
	
	/// Softbody-Imposter type
	external static num get SoftbodyImpostor;
	external static set SoftbodyImpostor(num value);
}

/// The options Interface for creating a Capsule Mesh
@JS()
@anonymous
class ICreateCapsuleOptions {
	
	external factory ICreateCapsuleOptions({Vector3 orientation, num subdivisions, num tessellation, num height, num radius, num capSubdivisions, num radiusTop, num radiusBottom, num topCapSubdivisions, num bottomCapSubdivisions});
	
	/// The Orientation of the capsule.  Default : Vector3.Up()
	external Vector3 get orientation;
	external set orientation( Vector3 value );
	
	/// Number of sub segments on the tube section of the capsule running parallel to orientation.
	external num get subdivisions;
	external set subdivisions( num value );
	
	/// Number of cylindrical segments on the capsule.
	external num get tessellation;
	external set tessellation( num value );
	
	/// Height or Length of the capsule.
	external num get height;
	external set height( num value );
	
	/// Radius of the capsule.
	external num get radius;
	external set radius( num value );
	
	/// Number of sub segments on the cap sections of the capsule running parallel to orientation.
	external num get capSubdivisions;
	external set capSubdivisions( num value );
	
	/// Overwrite for the top radius.
	external num get radiusTop;
	external set radiusTop( num value );
	
	/// Overwrite for the bottom radius.
	external num get radiusBottom;
	external set radiusBottom( num value );
	
	/// Overwrite for the top capSubdivisions.
	external num get topCapSubdivisions;
	external set topCapSubdivisions( num value );
	
	/// Overwrite for the bottom capSubdivisions.
	external num get bottomCapSubdivisions;
	external set bottomCapSubdivisions( num value );
}

/// Class containing static functions to help procedurally build meshes
@JS()
class CapsuleBuilder {
	external factory CapsuleBuilder();
	
	/// Creates a capsule or a pill mesh
	/// @param name defines the name of the mesh
	/// @param options The constructors options.
	/// @param scene The scene the mesh is scoped to.
	/// @returns Capsule Mesh
	external static Mesh CreateCapsule(String name, ICreateCapsuleOptions? options, dynamic scene);
}

/// Define an interface for all classes that will get and set the data on vertices
@JS()
abstract class IGetSetVerticesData {
	
	/// Gets a boolean indicating if specific vertex data is present
	/// @param kind defines the vertex data kind to use
	/// @returns true is data kind is present
	external bool isVerticesDataPresent(String kind);
	
	/// Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
	/// @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
	/// @returns a float array containing vertex data
	external dynamic? getVerticesData(String kind, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
	/// @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
	/// @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
	/// @returns the indices array or an empty array if the mesh has no geometry
	external dynamic? getIndices([bool? copyWhenShared, bool? forceCopy]);
	
	/// Set specific vertex data
	/// @param kind defines the data kind (Position, normal, etc...)
	/// @param data defines the vertex data to use
	/// @param updatable defines if the vertex must be flagged as updatable (false as default)
	/// @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
	external void setVerticesData(String kind, dynamic data, bool updatable);
	
	/// Update a specific associated vertex buffer
	/// @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
	/// - VertexBuffer.PositionKind
	/// - VertexBuffer.UVKind
	/// - VertexBuffer.UV2Kind
	/// - VertexBuffer.UV3Kind
	/// - VertexBuffer.UV4Kind
	/// - VertexBuffer.UV5Kind
	/// - VertexBuffer.UV6Kind
	/// - VertexBuffer.ColorKind
	/// - VertexBuffer.MatricesIndicesKind
	/// - VertexBuffer.MatricesIndicesExtraKind
	/// - VertexBuffer.MatricesWeightsKind
	/// - VertexBuffer.MatricesWeightsExtraKind
	/// @param data defines the data source
	/// @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
	/// @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)
	external void updateVerticesData(String kind, dynamic data, [bool? updateExtends, bool? makeItUnique]);
	
	/// Creates a new index buffer
	/// @param indices defines the indices to store in the index buffer
	/// @param totalVertices defines the total number of vertices (could be null)
	/// @param updatable defines if the index buffer must be flagged as updatable (false by default)
	external void setIndices(dynamic indices, num? totalVertices, [bool? updatable]);
}

/// This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
@JS()
class VertexData {
	external factory VertexData();
	
	/// Mesh side orientation : usually the external or front surface
	external static num get FRONTSIDE;
	
	/// Mesh side orientation : usually the internal or back surface
	external static num get BACKSIDE;
	
	/// Mesh side orientation : both internal and external or front and back surfaces
	external static num get DOUBLESIDE;
	
	/// Mesh side orientation : by default, `FRONTSIDE`
	external static num get DEFAULTSIDE;
	
	/// An array of the x, y, z position of each vertex  [...., x, y, z, .....]
	external dynamic? get positions;
	external set positions(dynamic? value);
	
	/// An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]
	external dynamic? get normals;
	external set normals(dynamic? value);
	
	/// An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]
	external dynamic? get tangents;
	external set tangents(dynamic? value);
	
	/// An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
	external dynamic? get uvs;
	external set uvs(dynamic? value);
	
	/// A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
	external dynamic? get uvs2;
	external set uvs2(dynamic? value);
	
	/// A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
	external dynamic? get uvs3;
	external set uvs3(dynamic? value);
	
	/// A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
	external dynamic? get uvs4;
	external set uvs4(dynamic? value);
	
	/// A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
	external dynamic? get uvs5;
	external set uvs5(dynamic? value);
	
	/// A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
	external dynamic? get uvs6;
	external set uvs6(dynamic? value);
	
	/// An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]
	external dynamic? get colors;
	external set colors(dynamic? value);
	
	/// An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).
	external dynamic? get matricesIndices;
	external set matricesIndices(dynamic? value);
	
	/// An array containing the list of weights defining the weight of each indexed matrix in the final computation
	external dynamic? get matricesWeights;
	external set matricesWeights(dynamic? value);
	
	/// An array extending the number of possible indices
	external dynamic? get matricesIndicesExtra;
	external set matricesIndicesExtra(dynamic? value);
	
	/// An array extending the number of possible weights when the number of indices is extended
	external dynamic? get matricesWeightsExtra;
	external set matricesWeightsExtra(dynamic? value);
	
	/// An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]
	external dynamic? get indices;
	external set indices(dynamic? value);
	
	/// Uses the passed data array to set the set the values for the specified kind of data
	/// @param data a linear array of floating numbers
	/// @param kind the type of data that is being set, eg positions, colors etc
	external void set(dynamic data, String kind);
	
	/// Associates the vertexData to the passed Mesh.
	/// Sets it as updatable or not (default `false`)
	/// @param mesh the mesh the vertexData is applied to
	/// @param updatable when used and having the value true allows new data to update the vertexData
	/// @returns the VertexData
	external VertexData applyToMesh(Mesh mesh, [bool? updatable]);
	
	/// Associates the vertexData to the passed Geometry.
	/// Sets it as updatable or not (default `false`)
	/// @param geometry the geometry the vertexData is applied to
	/// @param updatable when used and having the value true allows new data to update the vertexData
	/// @returns VertexData
	external VertexData applyToGeometry(Geometry geometry, [bool? updatable]);
	
	/// Updates the associated mesh
	/// @param mesh the mesh to be updated
	/// @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false
	/// @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false
	/// @returns VertexData
	external VertexData updateMesh(Mesh mesh);
	
	/// Updates the associated geometry
	/// @param geometry the geometry to be updated
	/// @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false
	/// @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false
	/// @returns VertexData.
	external VertexData updateGeometry(Geometry geometry);
	
	/// Transforms each position and each normal of the vertexData according to the passed Matrix
	/// @param matrix the transforming matrix
	/// @returns the VertexData
	external VertexData transform(Matrix matrix);
	
	/// Merges the passed VertexData into the current one
	/// @param other the VertexData to be merged into the current one
	/// @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array
	/// @returns the modified VertexData
	external VertexData merge(VertexData other, [bool? use32BitsIndices]);
	
	/// Serializes the VertexData
	/// @returns a serialized object
	external dynamic serialize();
	
	/// Extracts the vertexData from a mesh
	/// @param mesh the mesh from which to extract the VertexData
	/// @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false
	/// @param forceCopy indicating that the VertexData must be cloned, optional, default false
	/// @returns the object VertexData associated to the passed mesh
	external static VertexData ExtractFromMesh(Mesh mesh, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Extracts the vertexData from the geometry
	/// @param geometry the geometry from which to extract the VertexData
	/// @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false
	/// @param forceCopy indicating that the VertexData must be cloned, optional, default false
	/// @returns the object VertexData associated to the passed mesh
	external static VertexData ExtractFromGeometry(Geometry geometry, [bool? copyWhenShared, bool? forceCopy]);
	
	/// Creates the VertexData for a Ribbon
	/// @param options an object used to set the following optional parameters for the ribbon, required but can be empty
	/// * pathArray array of paths, each of which an array of successive Vector3
	/// * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
	/// * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
	/// * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
	/// * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
	/// * colors a linear array, of length 4 * number of vertices, of custom color values, optional
	/// @returns the VertexData of the ribbon
	external static VertexData CreateRibbon(VertexDataCreateRibbonOptions options);
	
	/// Creates the VertexData for a box
	/// @param options an object used to set the following optional parameters for the box, required but can be empty
	/// * size sets the width, height and depth of the box to the value of size, optional default 1
	/// * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
	/// * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
	/// * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
	/// * faceUV an array of 6 Vector4 elements used to set different images to each box side
	/// * faceColors an array of 6 Color3 elements used to set different colors to each box side
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the box
	external static VertexData CreateBox(VertexDataCreateBoxOptions options);
	
	/// Creates the VertexData for a tiled box
	/// @param options an object used to set the following optional parameters for the box, required but can be empty
	/// * faceTiles sets the pattern, tile size and number of tiles for a face
	/// * faceUV an array of 6 Vector4 elements used to set different images to each box side
	/// * faceColors an array of 6 Color3 elements used to set different colors to each box side
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// @returns the VertexData of the box
	external static VertexData CreateTiledBox(VertexDataCreateTiledBoxOptions options);
	
	/// Creates the VertexData for a tiled plane
	/// @param options an object used to set the following optional parameters for the box, required but can be empty
	/// * pattern a limited pattern arrangement depending on the number
	/// * tileSize sets the width, height and depth of the tile to the value of size, optional default 1
	/// * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size
	/// * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the tiled plane
	external static VertexData CreateTiledPlane(VertexDataCreateTiledPlaneOptions options);
	
	/// Creates the VertexData for an ellipsoid, defaults to a sphere
	/// @param options an object used to set the following optional parameters for the box, required but can be empty
	/// * segments sets the number of horizontal strips optional, default 32
	/// * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
	/// * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
	/// * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
	/// * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
	/// * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
	/// * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the ellipsoid
	external static VertexData CreateSphere(VertexDataCreateSphereOptions options);
	
	/// Creates the VertexData for a cylinder, cone or prism
	/// @param options an object used to set the following optional parameters for the box, required but can be empty
	/// * height sets the height (y direction) of the cylinder, optional, default 2
	/// * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
	/// * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
	/// * diameter sets the diameter of the top and bottom of the cone, optional default 1
	/// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
	/// * subdivisions` the number of rings along the cylinder height, optional, default 1
	/// * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
	/// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
	/// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
	/// * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false
	/// * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the cylinder, cone or prism
	external static VertexData CreateCylinder(VertexDataCreateCylinderOptions options);
	
	/// Creates the VertexData for a torus
	/// @param options an object used to set the following optional parameters for the box, required but can be empty
	/// * diameter the diameter of the torus, optional default 1
	/// * thickness the diameter of the tube forming the torus, optional default 0.5
	/// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the torus
	external static VertexData CreateTorus(VertexDataCreateTorusOptions options);
	
	/// Creates the VertexData of the LineSystem
	/// @param options an object used to set the following optional parameters for the LineSystem, required but can be empty
	/// - lines an array of lines, each line being an array of successive Vector3
	/// - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point
	/// @returns the VertexData of the LineSystem
	external static VertexData CreateLineSystem(VertexDataCreateLineSystemOptions options);
	
	/// Create the VertexData for a DashedLines
	/// @param options an object used to set the following optional parameters for the DashedLines, required but can be empty
	/// - points an array successive Vector3
	/// - dashSize the size of the dashes relative to the dash number, optional, default 3
	/// - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
	/// - dashNb the intended total number of dashes, optional, default 200
	/// @returns the VertexData for the DashedLines
	external static VertexData CreateDashedLines(VertexDataCreateDashedLinesOptions options);
	
	/// Creates the VertexData for a Ground
	/// @param options an object used to set the following optional parameters for the Ground, required but can be empty
	/// - width the width (x direction) of the ground, optional, default 1
	/// - height the height (z direction) of the ground, optional, default 1
	/// - subdivisions the number of subdivisions per side, optional, default 1
	/// @returns the VertexData of the Ground
	external static VertexData CreateGround(VertexDataCreateGroundOptions options);
	
	/// Creates the VertexData for a TiledGround by subdividing the ground into tiles
	/// @param options an object used to set the following optional parameters for the Ground, required but can be empty
	/// * xmin the ground minimum X coordinate, optional, default -1
	/// * zmin the ground minimum Z coordinate, optional, default -1
	/// * xmax the ground maximum X coordinate, optional, default 1
	/// * zmax the ground maximum Z coordinate, optional, default 1
	/// * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
	/// * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}
	/// @returns the VertexData of the TiledGround
	external static VertexData CreateTiledGround(VertexDataCreateTiledGroundOptions options);
	
	/// Creates the VertexData of the Ground designed from a heightmap
	/// @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap
	/// * width the width (x direction) of the ground
	/// * height the height (z direction) of the ground
	/// * subdivisions the number of subdivisions per side
	/// * minHeight the minimum altitude on the ground, optional, default 0
	/// * maxHeight the maximum altitude on the ground, optional default 1
	/// * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
	/// * buffer the array holding the image color data
	/// * bufferWidth the width of image
	/// * bufferHeight the height of image
	/// * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)
	/// @returns the VertexData of the Ground designed from a heightmap
	external static VertexData CreateGroundFromHeightMap(VertexDataCreateGroundFromHeightMapOptions options);
	
	/// Creates the VertexData for a Plane
	/// @param options an object used to set the following optional parameters for the plane, required but can be empty
	/// * size sets the width and height of the plane to the value of size, optional default 1
	/// * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
	/// * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the box
	external static VertexData CreatePlane(VertexDataCreatePlaneOptions options);
	
	/// Creates the VertexData of the Disc or regular Polygon
	/// @param options an object used to set the following optional parameters for the disc, required but can be empty
	/// * radius the radius of the disc, optional default 0.5
	/// * tessellation the number of polygon sides, optional, default 64
	/// * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the box
	external static VertexData CreateDisc(VertexDataCreateDiscOptions options);
	
	/// Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
	/// All parameters are provided by MeshBuilder.CreatePolygon as needed
	/// @param polygon a mesh built from polygonTriangulation.build()
	/// @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
	/// @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
	/// @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side
	/// @returns the VertexData of the Polygon
	external static VertexData CreatePolygon(Mesh polygon, num sideOrientation, [List<Vector4>? fUV, List<Color4>? fColors, Vector4? frontUVs, Vector4? backUVs, bool? wrap]);
	
	/// Creates the VertexData of the IcoSphere
	/// @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty
	/// * radius the radius of the IcoSphere, optional default 1
	/// * radiusX allows stretching in the x direction, optional, default radius
	/// * radiusY allows stretching in the y direction, optional, default radius
	/// * radiusZ allows stretching in the z direction, optional, default radius
	/// * flat when true creates a flat shaded mesh, optional, default true
	/// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the IcoSphere
	external static VertexData CreateIcoSphere(VertexDataCreateIcoSphereOptions options);
	
	/// Creates the VertexData for a Polyhedron
	/// @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
	/// * type provided types are:
	/// * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
	/// * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
	/// * size the size of the IcoSphere, optional default 1
	/// * sizeX allows stretching in the x direction, optional, default size
	/// * sizeY allows stretching in the y direction, optional, default size
	/// * sizeZ allows stretching in the z direction, optional, default size
	/// * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
	/// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
	/// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
	/// * flat when true creates a flat shaded mesh, optional, default true
	/// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the Polyhedron
	external static VertexData CreatePolyhedron(VertexDataCreatePolyhedronOptions options);
	
	/// Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js
	/// @param options an object used to set the following optional parameters for the capsule, required but can be empty
	/// @returns the VertexData of the Capsule
	external static VertexData CreateCapsule([ICreateCapsuleOptions? options]);
	
	/// Creates the VertexData for a TorusKnot
	/// @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty
	/// * radius the radius of the torus knot, optional, default 2
	/// * tube the thickness of the tube, optional, default 0.5
	/// * radialSegments the number of sides on each tube segments, optional, default 32
	/// * tubularSegments the number of tubes to decompose the knot into, optional, default 32
	/// * p the number of windings around the z axis, optional,  default 2
	/// * q the number of windings around the x axis, optional,  default 3
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @returns the VertexData of the Torus Knot
	external static VertexData CreateTorusKnot(VertexDataCreateTorusKnotOptions options);
	
	/// Compute normals for given positions and indices
	/// @param positions an array of vertex positions, [...., x, y, z, ......]
	/// @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]
	/// @param normals an array of vertex normals, [...., x, y, z, ......]
	/// @param options an object used to set the following optional parameters for the TorusKnot, optional
	/// * facetNormals : optional array of facet normals (vector3)
	/// * facetPositions : optional array of facet positions (vector3)
	/// * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
	/// * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
	/// * bInfo : optional bounding info, required for facetPartitioning computation
	/// * bbSize : optional bounding box size data, required for facetPartitioning computation
	/// * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation
	/// * useRightHandedSystem: optional boolean to for right handed system computation
	/// * depthSort : optional boolean to enable the facet depth sort computation
	/// * distanceTo : optional Vector3 to compute the facet depth from this location
	/// * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location
	external static void ComputeNormals(dynamic positions, dynamic indices, dynamic normals, [VertexDataComputeNormalsOptions? options]);
	
	/// Applies VertexData created from the imported parameters to the geometry
	/// @param parsedVertexData the parsed data from an imported file
	/// @param geometry the geometry to apply the VertexData to
	external static void ImportVertexData(dynamic parsedVertexData, Geometry geometry);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class DiscBuilder {
	external factory DiscBuilder();
	
	/// Creates a plane polygonal mesh.  By default, this is a disc
	/// * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
	/// * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
	/// * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the plane polygonal mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
	external static Mesh CreateDisc(String name, DiscBuilderCreateDiscOptions options, [Scene? scene]);
}

/// The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
/// As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
/// The SPS is also a particle system. It provides some methods to manage the particles.
/// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
/// 
/// Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System
@JS()
class SolidParticleSystem implements IDisposable {
	
	/// Creates a SPS (Solid Particle System) object.
	/// @param name (String) is the SPS name, this will be the underlying mesh name.
	/// @param scene (Scene) is the scene in which the SPS is added.
	/// @param options defines the options of the sps e.g.
	/// * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.
	/// * isPickable (optional boolean, default false) : if the solid particles must be pickable.
	/// * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.
	/// * useModelMaterial (optional boolean, defaut false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.
	/// * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.
	/// * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.
	/// * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.
	/// * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).
	/// * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.
	/// @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.
	external factory SolidParticleSystem(String name, Scene scene, [SolidParticleSystemConstructorOptions? options]);
	
	/// The SPS array of Solid Particle objects. Just access each particle as with any classic array.
	/// Example : var p = SPS.particles[i];
	external List<SolidParticle> get particles;
	external set particles(List<SolidParticle> value);
	
	/// The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
	external num get nbParticles;
	external set nbParticles(num value);
	
	/// If the particles must ever face the camera (default false). Useful for planar particles.
	external bool get billboard;
	external set billboard(bool value);
	
	/// Recompute normals when adding a shape
	external bool get recomputeNormals;
	external set recomputeNormals(bool value);
	
	/// This a counter ofr your own usage. It's not set by any SPS functions.
	external num get counter;
	external set counter(num value);
	
	/// The SPS name. This name is also given to the underlying mesh.
	external String get name;
	external set name(String value);
	
	/// The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
	external Mesh get mesh;
	external set mesh(Mesh value);
	
	/// This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
	/// Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns
	external dynamic get vars;
	external set vars(dynamic value);
	
	/// This array is populated when the SPS is set as 'pickable'.
	/// Each key of this array is a `faceId` value that you can get from a pickResult object.
	/// Each element of this array is an object `{idx: int, faceId: int}`.
	/// `idx` is the picked particle index in the `SPS.particles` array
	/// `faceId` is the picked face index counted within this particle.
	/// This array is the first element of the pickedBySubMesh array : sps.pickBySubMesh[0].
	/// It's not pertinent to use it when using a SPS with the support for MultiMaterial enabled.
	/// Use the method SPS.pickedParticle(pickingInfo) instead.
	/// Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles
	external List<SolidParticleSystemPickedParticles> get pickedParticles;
	external set pickedParticles(List<SolidParticleSystemPickedParticles> value);
	
	/// This array is populated when the SPS is set as 'pickable'
	/// Each key of this array is a submesh index.
	/// Each element of this array is a second array defined like this :
	/// Each key of this second array is a `faceId` value that you can get from a pickResult object.
	/// Each element of this second array is an object `{idx: int, faceId: int}`.
	/// `idx` is the picked particle index in the `SPS.particles` array
	/// `faceId` is the picked face index counted within this particle.
	/// It's better to use the method SPS.pickedParticle(pickingInfo) rather than using directly this array.
	/// Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles
	external List<List<SolidParticleSystemPickedBySubMesh>> get pickedBySubMesh;
	external set pickedBySubMesh(List<List<SolidParticleSystemPickedBySubMesh>> value);
	
	/// This array is populated when `enableDepthSort` is set to true.
	/// Each element of this array is an instance of the class DepthSortedParticle.
	external List<DepthSortedParticle> get depthSortedParticles;
	external set depthSortedParticles(List<DepthSortedParticle> value);
	
	/// Builds the SPS underlying mesh. Returns a standard Mesh.
	/// If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
	/// @returns the created mesh
	external Mesh buildMesh();
	
	/// Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
	/// These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
	/// Thus the particles generated from `digest()` have their property `position` set yet.
	/// @param mesh ( Mesh ) is the mesh to be digested
	/// @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
	/// {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
	/// {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets
	/// {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.
	/// @returns the current SPS
	external SolidParticleSystem digest(Mesh mesh, [SolidParticleSystemDigestOptions? options]);
	
	/// Adds some particles to the SPS from the model shape. Returns the shape id.
	/// Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps
	/// @param mesh is any Mesh object that will be used as a model for the solid particles.
	/// @param nb (positive integer) the number of particles to be created from this model
	/// @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.
	/// {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation
	/// {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.
	/// @returns the number of shapes in the system
	external num addShape(Mesh mesh, num nb, [SolidParticleSystemAddShapeOptions? options]);
	
	/// Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
	/// @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.
	/// @returns the SPS.
	external SolidParticleSystem rebuildMesh([bool? reset]);
	
	/// Removes the particles from the start-th to the end-th included from an expandable SPS (required).
	/// Returns an array with the removed particles.
	/// If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.
	/// The SPS can't be empty so at least one particle needs to remain in place.
	/// Under the hood, the VertexData array, so the VBO buffer, is recreated each call.
	/// @param start index of the first particle to remove
	/// @param end index of the last particle to remove (included)
	/// @returns an array populated with the removed particles
	external List<SolidParticle> removeParticles(num start, num end);
	
	/// Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().
	/// @param solidParticleArray an array populated with Solid Particles objects
	/// @returns the SPS
	external SolidParticleSystem insertParticlesFromArray(List<SolidParticle> solidParticleArray);
	
	/// Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
	/// This method calls `updateParticle()` for each particle of the SPS.
	/// For an animated SPS, it is usually called within the render loop.
	/// This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.
	/// @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
	/// @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
	/// @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
	/// @returns the SPS.
	external SolidParticleSystem setParticles([num? start, num? end, bool? update]);
	
	/// Disposes the SPS.
	@override
	external void dispose();
	
	/// Returns an object {idx: numbern faceId: number} for the picked particle from the passed pickingInfo object.
	/// idx is the particle index in the SPS
	/// faceId is the picked face index counted within this particle.
	/// Returns null if the pickInfo can't identify a picked particle.
	/// @param pickingInfo (PickingInfo object)
	/// @returns {idx: number, faceId: number} or null
	external SolidParticleSystemPickedParticle? pickedParticle(PickingInfo pickingInfo);
	
	/// Returns a SolidParticle object from its identifier : particle.id
	/// @param id (integer) the particle Id
	/// @returns the searched particle or null if not found in the SPS.
	external SolidParticle? getParticleById(num id);
	
	/// Returns a new array populated with the particles having the passed shapeId.
	/// @param shapeId (integer) the shape identifier
	/// @returns a new solid particle array
	external List<SolidParticle> getParticlesByShapeId(num shapeId);
	
	/// Populates the passed array "ref" with the particles having the passed shapeId.
	/// @param shapeId the shape identifier
	/// @returns the SPS
	/// @param ref
	external SolidParticleSystem getParticlesByShapeIdToRef(num shapeId, List<SolidParticle> ref);
	
	/// Computes the required SubMeshes according the materials assigned to the particles.
	/// @returns the solid particle system.
	/// Does nothing if called before the SPS mesh is built.
	external SolidParticleSystem computeSubMeshes();
	
	/// Visibilty helper : Recomputes the visible size according to the mesh bounding box
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
	/// @returns the SPS.
	external SolidParticleSystem refreshVisibleSize();
	
	/// Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
	/// @param size the size (float) of the visibility box
	/// note : this doesn't lock the SPS mesh bounding box.
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
	external void setVisibilityBox(num size);
	
	/// Gets whether the SPS as always visible or not
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
	external bool get isAlwaysVisible;
	
	/// Sets the SPS as always visible or not
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
	external set isAlwaysVisible(bool value);
	
	/// Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
	external set isVisibilityBoxLocked(bool value);
	
	/// Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
	external bool get isVisibilityBoxLocked;
	
	/// Tells to `setParticles()` to compute the particle rotations or not.
	/// Default value : true. The SPS is faster when it's set to false.
	/// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
	external set computeParticleRotation(bool value);
	
	/// Tells to `setParticles()` to compute the particle colors or not.
	/// Default value : true. The SPS is faster when it's set to false.
	/// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
	external set computeParticleColor(bool value);
	
	external set computeParticleTexture(bool value);
	
	/// Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
	/// Default value : false. The SPS is faster when it's set to false.
	/// Note : the particle custom vertex positions aren't stored values.
	external set computeParticleVertex(bool value);
	
	/// Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
	external set computeBoundingBox(bool value);
	
	/// Tells to `setParticles()` to sort or not the distance between each particle and the camera.
	/// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
	/// Default : `true`
	external set depthSortParticles(bool value);
	
	/// Gets if `setParticles()` computes the particle rotations or not.
	/// Default value : true. The SPS is faster when it's set to false.
	/// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
	external bool get computeParticleRotation;
	
	/// Gets if `setParticles()` computes the particle colors or not.
	/// Default value : true. The SPS is faster when it's set to false.
	/// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
	external bool get computeParticleColor;
	
	/// Gets if `setParticles()` computes the particle textures or not.
	/// Default value : true. The SPS is faster when it's set to false.
	/// Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
	external bool get computeParticleTexture;
	
	/// Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
	/// Default value : false. The SPS is faster when it's set to false.
	/// Note : the particle custom vertex positions aren't stored values.
	external bool get computeParticleVertex;
	
	/// Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
	external bool get computeBoundingBox;
	
	/// Gets if `setParticles()` sorts or not the distance between each particle and the camera.
	/// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
	/// Default : `true`
	external bool get depthSortParticles;
	
	/// Gets if the SPS is created as expandable at construction time.
	/// Default : `false`
	external bool get expandable;
	
	/// Gets if the SPS supports the Multi Materials
	external bool get multimaterialEnabled;
	
	/// Gets if the SPS uses the model materials for its own multimaterial.
	external bool get useModelMaterial;
	
	/// The SPS used material array.
	external List<Material> get materials;
	
	/// Sets the SPS MultiMaterial from the passed materials.
	/// Note : the passed array is internally copied and not used then by reference.
	/// @param materials an array of material objects. This array indexes are the materialIndex values of the particles.
	external void setMultiMaterial(List<Material> materials);
	
	/// The SPS computed multimaterial object
	external MultiMaterial get multimaterial;
	
	external set multimaterial(MultiMaterial value);
	
	/// If the subMeshes must be updated on the next call to setParticles()
	external bool get autoUpdateSubMeshes;
	
	external set autoUpdateSubMeshes(bool value);
	
	/// This function does nothing. It may be overwritten to set all the particle first values.
	/// The SPS doesn't call this function, you may have to call it by your own.
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management
	external void initParticles();
	
	/// This function does nothing. It may be overwritten to recycle a particle.
	/// The SPS doesn't call this function, you may have to call it by your own.
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management
	/// @param particle The particle to recycle
	/// @returns the recycled particle
	external SolidParticle recycleParticle(SolidParticle particle);
	
	/// Updates a particle : this function should  be overwritten by the user.
	/// It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management
	/// @example : just set a particle position or velocity and recycle conditions
	/// @param particle The particle to update
	/// @returns the updated particle
	external SolidParticle updateParticle(SolidParticle particle);
	
	/// Updates a vertex of a particle : it can be overwritten by the user.
	/// This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.
	/// @param particle the current particle
	/// @param vertex the current vertex of the current particle : a SolidParticleVertex object
	/// @param pt the index of the current vertex in the particle shape
	/// doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape
	/// @example : just set a vertex particle position or color
	/// @returns the sps
	external SolidParticleSystem updateParticleVertex(SolidParticle particle, SolidParticleVertex vertex, num pt);
	
	/// This will be called before any other treatment by `setParticles()` and will be passed three parameters.
	/// This does nothing and may be overwritten by the user.
	/// @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
	/// @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
	/// @param update the boolean update value actually passed to setParticles()
	external void beforeUpdateParticles([num? start, num? stop, bool? update]);
	
	/// This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
	/// This will be passed three parameters.
	/// This does nothing and may be overwritten by the user.
	/// @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
	/// @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
	/// @param update the boolean update value actually passed to setParticles()
	external void afterUpdateParticles([num? start, num? stop, bool? update]);
}

/// Represents one particle of a solid particle system.
@JS()
class SolidParticle {
	
	/// Creates a Solid Particle object.
	/// Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()
	/// @param particleIndex (integer) is the particle index in the Solid Particle System pool.
	/// @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.
	/// @param positionIndex (integer) is the starting index of the particle vertices in the SPS "positions" array.
	/// @param indiceIndex (integer) is the starting index of the particle indices in the SPS "indices" array.
	/// @param model (ModelShape) is a reference to the model shape on what the particle is designed.
	/// @param shapeId (integer) is the model shape identifier in the SPS.
	/// @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))
	/// @param sps defines the sps it is associated to
	/// @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.
	/// @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.
	external factory SolidParticle(num particleIndex, num particleId, num positionIndex, num indiceIndex, ModelShape? model, num shapeId, num idxInShape, SolidParticleSystem sps, [BoundingInfo? modelBoundingInfo, num? materialIndex]);
	
	/// particle global index
	external num get idx;
	external set idx(num value);
	
	/// particle identifier
	external num get id;
	external set id(num value);
	
	/// The color of the particle
	external Color4? get color;
	external set color(Color4? value);
	
	/// The world space position of the particle.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// The world space rotation of the particle. (Not use if rotationQuaternion is set)
	external Vector3 get rotation;
	external set rotation(Vector3 value);
	
	/// The world space rotation quaternion of the particle.
	external Quaternion? get rotationQuaternion;
	external set rotationQuaternion(Quaternion? value);
	
	/// The scaling of the particle.
	external Vector3 get scaling;
	external set scaling(Vector3 value);
	
	/// The uvs of the particle.
	external Vector4 get uvs;
	external set uvs(Vector4 value);
	
	/// The current speed of the particle.
	external Vector3 get velocity;
	external set velocity(Vector3 value);
	
	/// The pivot point in the particle local space.
	external Vector3 get pivot;
	external set pivot(Vector3 value);
	
	/// Must the particle be translated from its pivot point in its local space ?
	/// In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
	/// Default : false
	external bool get translateFromPivot;
	external set translateFromPivot(bool value);
	
	/// Is the particle active or not ?
	external bool get alive;
	external set alive(bool value);
	
	/// Is the particle visible or not ?
	external bool get isVisible;
	external set isVisible(bool value);
	
	/// ModelShape id of this particle
	external num get shapeId;
	external set shapeId(num value);
	
	/// Index of the particle in its shape id
	external num get idxInShape;
	external set idxInShape(num value);
	
	/// Parent particle Id, if any.
	/// Default null.
	external num? get parentId;
	external set parentId(num? value);
	
	/// The particle material identifier (integer) when MultiMaterials are enabled in the SPS.
	external num? get materialIndex;
	external set materialIndex(num? value);
	
	/// Custom object or properties.
	external dynamic? get props;
	external set props(dynamic? value);
	
	/// The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().
	/// The possible values are :
	/// - AbstractMesh.CULLINGSTRATEGY_STANDARD
	/// - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
	/// - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
	/// - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
	/// The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
	/// Please read each static variable documentation in the class AbstractMesh to get details about the culling process.
	/// 
	external num get cullingStrategy;
	external set cullingStrategy(num value);
	
	/// Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive
	/// @param target the particle target
	/// @returns the current particle
	external SolidParticle copyToRef(SolidParticle target);
	
	/// Legacy support, changed scale to scaling
	external Vector3 get scale;
	
	/// Legacy support, changed scale to scaling
	external set scale(Vector3 value);
	
	/// Legacy support, changed quaternion to rotationQuaternion
	external Quaternion? get quaternion;
	
	/// Legacy support, changed quaternion to rotationQuaternion
	external set quaternion(Quaternion? value);
	
	/// Returns a boolean. True if the particle intersects another particle or another mesh, else false.
	/// The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)
	/// @param target is the object (solid particle or mesh) what the intersection is computed against.
	/// @returns true if it intersects
	external bool intersectsMesh(dynamic target);
	
	/// Returns `true` if the solid particle is within the frustum defined by the passed array of planes.
	/// A particle is in the frustum if its bounding box intersects the frustum
	/// @param frustumPlanes defines the frustum to test
	/// @returns true if the particle is in the frustum planes
	external bool isInFrustum(List<Plane> frustumPlanes);
	
	/// get the rotation matrix of the particle
	/// @hidden
	external void getRotationMatrix(Matrix m);
}

/// Represents the shape of the model used by one particle of a solid particle system.
/// SPS internal tool, don't use it manually.
@JS()
class ModelShape {
	
	/// Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
	/// SPS internal tool, don't use it manually.
	/// @hidden
	external factory ModelShape(num id, List<Vector3> shape, List<num> indices, List<num> normals, List<num> colors, List<num> shapeUV, void Function(SolidParticle particle, num i, num s)? posFunction, void Function(SolidParticle particle, Vector3 vertex, num i)? vtxFunction, Material? material);
	
	/// The shape id
	/// @hidden
	external num get shapeID;
	external set shapeID(num value);
}

/// Represents a Depth Sorted Particle in the solid particle system.
/// @hidden
@JS()
class DepthSortedParticle {
	
	/// Creates a new sorted particle
	/// @param materialIndex
	external factory DepthSortedParticle(num idx, num ind, num indLength, num materialIndex);
	
	/// Particle index
	external num get idx;
	external set idx(num value);
	
	/// Index of the particle in the "indices" array
	external num get ind;
	external set ind(num value);
	
	/// Length of the particle shape in the "indices" array
	external num get indicesLength;
	external set indicesLength(num value);
	
	/// Squared distance from the particle to the camera
	external num get sqDistance;
	external set sqDistance(num value);
	
	/// Material index when used with MultiMaterials
	external num get materialIndex;
	external set materialIndex(num value);
}

/// Represents a solid particle vertex
@JS()
class SolidParticleVertex {
	
	/// Creates a new solid particle vertex
	external factory SolidParticleVertex();
	
	/// Vertex position
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// Vertex color
	external Color4 get color;
	external set color(Color4 value);
	
	/// Vertex UV
	external Vector2 get uv;
	external set uv(Vector2 value);
	
	/// Vertex x coordinate
	external num get x;
	
	external set x(num value);
	
	/// Vertex y coordinate
	external num get y;
	
	external set y(num value);
	
	/// Vertex z coordinate
	external num get z;
	
	external set z(num value);
}

/// Interface used to define ActionEvent
@JS()
abstract class IActionEvent {
	
	/// The mesh or sprite that triggered the action
	external dynamic get source;
	external set source(dynamic value);
	
	/// The X mouse cursor position at the time of the event
	external num get pointerX;
	external set pointerX(num value);
	
	/// The Y mouse cursor position at the time of the event
	external num get pointerY;
	external set pointerY(num value);
	
	/// The mesh that is currently pointed at (can be null)
	external AbstractMesh? get meshUnderPointer;
	external set meshUnderPointer(AbstractMesh? value);
	
	/// the original (browser) event that triggered the ActionEvent
	external dynamic get sourceEvent;
	external set sourceEvent(dynamic value);
	
	/// additional data for the event
	external dynamic get additionalData;
	external set additionalData(dynamic value);
}

/// ActionEvent is the event being sent when an action is triggered.
@JS()
class ActionEvent implements IActionEvent {
	
	/// Creates a new ActionEvent
	/// @param source The mesh or sprite that triggered the action
	/// @param pointerX The X mouse cursor position at the time of the event
	/// @param pointerY The Y mouse cursor position at the time of the event
	/// @param meshUnderPointer The mesh that is currently pointed at (can be null)
	/// @param sourceEvent the original (browser) event that triggered the ActionEvent
	/// @param additionalData additional data for the event
	external factory ActionEvent(dynamic source, num pointerX, num pointerY, AbstractMesh? meshUnderPointer, [dynamic? sourceEvent, dynamic? additionalData]);
	
	/// The mesh or sprite that triggered the action
	@override
	external dynamic get source;
	@override
	external set source(dynamic value);
	
	/// The X mouse cursor position at the time of the event
	@override
	external num get pointerX;
	@override
	external set pointerX(num value);
	
	/// The Y mouse cursor position at the time of the event
	@override
	external num get pointerY;
	@override
	external set pointerY(num value);
	
	/// The mesh that is currently pointed at (can be null)
	@override
	external AbstractMesh? get meshUnderPointer;
	@override
	external set meshUnderPointer(AbstractMesh? value);
	
	/// the original (browser) event that triggered the ActionEvent
	@override
	external dynamic get sourceEvent;
	@override
	external set sourceEvent(dynamic value);
	
	/// additional data for the event
	@override
	external dynamic get additionalData;
	@override
	external set additionalData(dynamic value);
	
	/// Helper function to auto-create an ActionEvent from a source mesh.
	/// @param source The source mesh that triggered the event
	/// @param evt The original (browser) event
	/// @param additionalData additional data for the event
	/// @returns the new ActionEvent
	external static ActionEvent CreateNew(AbstractMesh source, [HTML.Event? evt, dynamic? additionalData]);
	
	/// Helper function to auto-create an ActionEvent from a source sprite
	/// @param source The source sprite that triggered the event
	/// @param scene Scene associated with the sprite
	/// @param evt The original (browser) event
	/// @param additionalData additional data for the event
	/// @returns the new ActionEvent
	external static ActionEvent CreateNewFromSprite(Sprite source, Scene scene, [HTML.Event? evt, dynamic? additionalData]);
	
	/// Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
	/// @param scene the scene where the event occurred
	/// @param evt The original (browser) event
	/// @returns the new ActionEvent
	external static ActionEvent CreateNewFromScene(Scene scene, HTML.Event evt);
	
	/// Helper function to auto-create an ActionEvent from a primitive
	/// @param prim defines the target primitive
	/// @param pointerPos defines the pointer position
	/// @param evt The original (browser) event
	/// @param additionalData additional data for the event
	/// @returns the new ActionEvent
	external static ActionEvent CreateNewFromPrimitive(dynamic prim, Vector2 pointerPos, [HTML.Event? evt, dynamic? additionalData]);
}

/// Abstract class used to decouple action Manager from scene and meshes.
/// Do not instantiate.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
abstract class AbstractActionManager implements IDisposable {
	external factory AbstractActionManager();
	
	/// Gets the list of active triggers
	external static dynamic /* object */ get Triggers;
	external static set Triggers(dynamic /* object */ value);
	
	/// Gets the cursor to use when hovering items
	external String get hoverCursor;
	external set hoverCursor(String value);
	
	/// Gets the list of actions
	external List<IAction> get actions;
	external set actions(List<IAction> value);
	
	/// Gets or sets a boolean indicating that the manager is recursive meaning that it can trigger action from children
	external bool get isRecursive;
	external set isRecursive(bool value);
	
	/// Releases all associated resources
	@override
	external void dispose();
	
	/// Does this action manager has pointer triggers
	external bool get hasPointerTriggers;
	
	/// Does this action manager has pick triggers
	external bool get hasPickTriggers;
	
	/// Process a specific trigger
	/// @param trigger defines the trigger to process
	/// @param evt defines the event details to be processed
	external void processTrigger(num trigger, [IActionEvent? evt]);
	
	/// Does this action manager handles actions of any of the given triggers
	/// @param triggers defines the triggers to be tested
	/// @return a boolean indicating whether one (or more) of the triggers is handled
	external bool hasSpecificTriggers(List<num> triggers);
	
	/// Does this action manager handles actions of any of the given triggers. This function takes two arguments for
	/// speed.
	/// @param triggerA defines the trigger to be tested
	/// @param triggerB defines the trigger to be tested
	/// @return a boolean indicating whether one (or more) of the triggers is handled
	external bool hasSpecificTriggers2(num triggerA, num triggerB);
	
	/// Does this action manager handles actions of a given trigger
	/// @param trigger defines the trigger to be tested
	/// @param parameterPredicate defines an optional predicate to filter triggers by parameter
	/// @return whether the trigger is handled
	external bool hasSpecificTrigger(num trigger, [bool Function(dynamic parameter)? parameterPredicate]);
	
	/// Serialize this manager to a JSON object
	/// @param name defines the property name to store this manager
	/// @returns a JSON representation of this manager
	external dynamic serialize(String name);
	
	/// Registers an action to this action manager
	/// @param action defines the action to be registered
	/// @return the action amended (prepared) after registration
	external IAction? registerAction(IAction action);
	
	/// Unregisters an action to this action manager
	/// @param action defines the action to be unregistered
	/// @return a boolean indicating whether the action has been unregistered
	external bool unregisterAction(IAction action);
	
	/// Does exist one action manager with at least one trigger
	/// 
	external static bool get HasTriggers;
	
	/// Does exist one action manager with at least one pick trigger
	/// 
	external static bool get HasPickTriggers;
	
	/// Does exist one action manager that handles actions of a given trigger
	/// @param trigger defines the trigger to be tested
	/// @return a boolean indicating whether the trigger is handeled by at least one action manager
	/// 
	external static bool HasSpecificTrigger(num trigger);
}

/// Node is the basic class for all scene objects (Mesh, Light, Camera.)
@JS()
class Node implements IBehaviorAware<Node> {
	
	/// Creates a new Node
	/// @param name the name and id to be given to this node
	/// @param scene the scene this node will be added to
	external factory Node(String name, [Scene? scene]);
	
	/// Add a new node constructor
	/// @param type defines the type name of the node to construct
	/// @param constructorFunc defines the constructor function
	external static void AddNodeConstructor(String type, dynamic constructorFunc);
	
	/// Returns a node constructor based on type name
	/// @param type defines the type name
	/// @param name defines the new node name
	/// @param scene defines the hosting scene
	/// @param options defines optional options to transmit to constructors
	/// @returns the new constructor or null
	external static Node Function()? Construct(String type, String name, Scene scene, [dynamic? options]);
	
	/// Gets or sets the name of the node
	external String get name;
	external set name(String value);
	
	/// Gets or sets the id of the node
	external String get id;
	external set id(String value);
	
	/// Gets or sets the unique id of the node
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Gets or sets a string used to store user defined state for the node
	external String get state;
	external set state(String value);
	
	/// Gets or sets an object used to store user defined information for the node
	external dynamic get metadata;
	external set metadata(dynamic value);
	
	/// For internal use only. Please do not use.
	external dynamic get reservedDataStore;
	external set reservedDataStore(dynamic value);
	
	/// List of inspectable custom properties (used by the Inspector)
	/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
	external List<IInspectable> get inspectableCustomProperties;
	external set inspectableCustomProperties(List<IInspectable> value);
	
	/// Gets or sets a boolean used to define if the node must be serialized
	external bool get doNotSerialize;
	
	external set doNotSerialize(bool value);
	
	/// Gets a list of Animations associated with the node
	external List<Animation> get animations;
	external set animations(List<Animation> value);
	
	/// Callback raised when the node is ready to be used
	external void Function(Node node)? get onReady;
	external set onReady(void Function(Node node)? value);
	
	/// Gets a boolean indicating if the node has been disposed
	/// @returns true if the node was disposed
	external bool isDisposed();
	
	/// Gets or sets the parent of the node (without keeping the current position in the scene)
	/// @see https://doc.babylonjs.com/how_to/parenting
	external set parent(Node? value);
	
	external Node? get parent;
	
	/// Gets or sets the animation properties override
	external AnimationPropertiesOverride? get animationPropertiesOverride;
	
	external set animationPropertiesOverride(AnimationPropertiesOverride? value);
	
	/// Gets a string identifying the name of the class
	/// @returns "Node" string
	external String getClassName();
	
	/// An event triggered when the mesh is disposed
	external Observable<Node> get onDisposeObservable;
	external set onDisposeObservable(Observable<Node> value);
	
	/// Sets a callback that will be raised when the node will be disposed
	external set onDispose(void Function() value);
	
	/// Gets the scene of the node
	/// @returns a scene
	external Scene getScene();
	
	/// Gets the engine of the node
	/// @returns a Engine
	external Engine getEngine();
	
	/// Attach a behavior to the node
	/// @see https://doc.babylonjs.com/features/behaviour
	/// @param behavior defines the behavior to attach
	/// @param attachImmediately defines that the behavior must be attached even if the scene is still loading
	/// @returns the current Node
	@override
	external Node addBehavior(Behavior<Node> behavior, [bool? attachImmediately]);
	
	/// Remove an attached behavior
	/// @see https://doc.babylonjs.com/features/behaviour
	/// @param behavior defines the behavior to attach
	/// @returns the current Node
	@override
	external Node removeBehavior(Behavior<Node> behavior);
	
	/// Gets the list of attached behaviors
	/// @see https://doc.babylonjs.com/features/behaviour
	external List<Behavior<Node>> get behaviors;
	
	/// Gets an attached behavior by name
	/// @param name defines the name of the behavior to look for
	/// @see https://doc.babylonjs.com/features/behaviour
	/// @returns null if behavior was not found else the requested behavior
	@override
	external Behavior<Node>? getBehaviorByName(String name);
	
	/// Returns the latest update of the World matrix
	/// @returns a Matrix
	external Matrix getWorldMatrix();
	
	/// Returns directly the latest state of the mesh World matrix.
	/// A Matrix is returned.
	external Matrix get worldMatrixFromCache;
	
	/// @hidden
	external void updateCache([bool? force]);
	
	/// @hidden
	external bool isSynchronizedWithParent();
	
	/// @hidden
	external bool isSynchronized();
	
	/// Is this node ready to be used/rendered
	/// @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
	/// @return true if the node is ready
	external bool isReady([bool? completeCheck]);
	
	/// Is this node enabled?
	/// If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true
	/// @param checkAncestors indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors
	/// @return whether this node (and its parent) is enabled
	external bool isEnabled([bool? checkAncestors]);
	
	/// Set the enabled state of this node
	/// @param value defines the new enabled state
	external void setEnabled(bool value);
	
	/// Is this node a descendant of the given node?
	/// The function will iterate up the hierarchy until the ancestor was found or no more parents defined
	/// @param ancestor defines the parent node to inspect
	/// @returns a boolean indicating if this node is a descendant of the given node
	external bool isDescendantOf(Node ancestor);
	
	/// Will return all nodes that have this node as ascendant
	/// @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
	/// @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
	/// @return all children nodes of all types
	external List<Node> getDescendants([bool? directDescendantsOnly, bool Function(Node node)? predicate]);
	
	/// Get all child-meshes of this node
	/// @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)
	/// @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
	/// @returns an array of AbstractMesh
	external List<AbstractMesh> getChildMeshes([bool? directDescendantsOnly, bool Function(Node node)? predicate]);
	
	/// Get all direct children of this node
	/// @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
	/// @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)
	/// @returns an array of Node
	external List<Node> getChildren([bool Function(Node node)? predicate, bool? directDescendantsOnly]);
	
	/// Get an animation by name
	/// @param name defines the name of the animation to look for
	/// @returns null if not found else the requested animation
	external Animation? getAnimationByName(String name);
	
	/// Creates an animation range for this node
	/// @param name defines the name of the range
	/// @param from defines the starting key
	/// @param to defines the end key
	external void createAnimationRange(String name, num from, num to);
	
	/// Delete a specific animation range
	/// @param name defines the name of the range to delete
	/// @param deleteFrames defines if animation frames from the range must be deleted as well
	external void deleteAnimationRange(String name, [bool? deleteFrames]);
	
	/// Get an animation range by name
	/// @param name defines the name of the animation range to look for
	/// @returns null if not found else the requested animation range
	external AnimationRange? getAnimationRange(String name);
	
	/// Gets the list of all animation ranges defined on this node
	/// @returns an array
	external List<AnimationRange>? getAnimationRanges();
	
	/// Will start the animation sequence
	/// @param name defines the range frames for animation sequence
	/// @param loop defines if the animation should loop (false by default)
	/// @param speedRatio defines the speed factor in which to run the animation (1 by default)
	/// @param onAnimationEnd defines a function to be executed when the animation ended (undefined by default)
	/// @returns the object created for this animation. If range does not exist, it will return null
	external Animatable? beginAnimation(String name, [bool? loop, num? speedRatio, void Function()? onAnimationEnd]);
	
	/// Serialize animation ranges into a JSON compatible object
	/// @returns serialization object
	external dynamic serializeAnimationRanges();
	
	/// Computes the world matrix of the node
	/// @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
	/// @returns the world matrix
	external Matrix computeWorldMatrix([bool? force]);
	
	/// Releases resources associated with this node.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Parse animation range data from a serialization object and store them into a given node
	/// @param node defines where to store the animation ranges
	/// @param parsedNode defines the serialization object to read data from
	/// @param scene defines the hosting scene
	external static void ParseAnimationRanges(Node node, dynamic parsedNode, Scene scene);
	
	/// Return the minimum and maximum world vectors of the entire hierarchy under current node
	/// @param includeDescendants Include bounding info from descendants as well (true by default)
	/// @param predicate defines a callback function that can be customize to filter what meshes should be included in the list used to compute the bounding vectors
	/// @returns the new bounding vectors
	external NodeGetHierarchyBoundingVectors getHierarchyBoundingVectors([bool? includeDescendants, bool Function(AbstractMesh abstractMesh)? predicate]);
}

/// Class used to store any kind of animation
@JS()
class Animation {
	
	/// Initializes the animation
	/// @param name Name of the animation
	/// @param targetProperty Property to animate
	/// @param framePerSecond The frames per second of the animation
	/// @param dataType The data type of the animation
	/// @param loopMode The loop mode of the animation
	/// @param enableBlending Specifies if blending should be enabled
	external factory Animation(String name, String targetProperty, num framePerSecond, num dataType, [num? loopMode, bool? enableBlending]);
	
	/// Name of the animation
	external String get name;
	external set name(String value);
	
	/// Property to animate
	external String get targetProperty;
	external set targetProperty(String value);
	
	/// The frames per second of the animation
	external num get framePerSecond;
	external set framePerSecond(num value);
	
	/// The data type of the animation
	external num get dataType;
	external set dataType(num value);
	
	/// The loop mode of the animation
	external num? get loopMode;
	external set loopMode(num? value);
	
	/// Specifies if blending should be enabled
	external bool? get enableBlending;
	external set enableBlending(bool? value);
	
	/// Use matrix interpolation instead of using direct key value when animating matrices
	external static bool get AllowMatricesInterpolation;
	external static set AllowMatricesInterpolation(bool value);
	
	/// When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower
	external static bool get AllowMatrixDecomposeForInterpolation;
	external static set AllowMatrixDecomposeForInterpolation(bool value);
	
	/// Define the Url to load snippets
	external static String get SnippetUrl;
	external static set SnippetUrl(String value);
	
	/// Snippet ID if the animation was created from the snippet server
	external String get snippetId;
	external set snippetId(String value);
	
	/// Stores an array of target property paths
	external List<String> get targetPropertyPath;
	external set targetPropertyPath(List<String> value);
	
	/// Stores the blending speed of the animation
	external num get blendingSpeed;
	external set blendingSpeed(num value);
	
	/// Sets up an animation
	/// @param property The property to animate
	/// @param animationType The animation type to apply
	/// @param framePerSecond The frames per second of the animation
	/// @param easingFunction The easing function used in the animation
	/// @returns The created animation
	external static Animation CreateAnimation(String property, num animationType, num framePerSecond, EasingFunction easingFunction);
	
	/// Create and start an animation on a node
	/// @param name defines the name of the global animation that will be run on all nodes
	/// @param node defines the root node where the animation will take place
	/// @param targetProperty defines property to animate
	/// @param framePerSecond defines the number of frame per second yo use
	/// @param totalFrame defines the number of frames in total
	/// @param from defines the initial value
	/// @param to defines the final value
	/// @param loopMode defines which loop mode you want to use (off by default)
	/// @param easingFunction defines the easing function to use (linear by default)
	/// @param onAnimationEnd defines the callback to call when animation end
	/// @returns the animatable created for this animation
	external static Animatable? CreateAndStartAnimation(String name, Node node, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num? loopMode, EasingFunction? easingFunction, void Function()? onAnimationEnd]);
	
	/// Create and start an animation on a node and its descendants
	/// @param name defines the name of the global animation that will be run on all nodes
	/// @param node defines the root node where the animation will take place
	/// @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used
	/// @param targetProperty defines property to animate
	/// @param framePerSecond defines the number of frame per second to use
	/// @param totalFrame defines the number of frames in total
	/// @param from defines the initial value
	/// @param to defines the final value
	/// @param loopMode defines which loop mode you want to use (off by default)
	/// @param easingFunction defines the easing function to use (linear by default)
	/// @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
	/// @returns the list of animatables created for all nodes
	/// @example https://www.babylonjs-playground.com/#MH0VLI
	external static List<Animatable>? CreateAndStartHierarchyAnimation(String name, Node node, bool directDescendantsOnly, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num? loopMode, EasingFunction? easingFunction, void Function()? onAnimationEnd]);
	
	/// Creates a new animation, merges it with the existing animations and starts it
	/// @param name Name of the animation
	/// @param node Node which contains the scene that begins the animations
	/// @param targetProperty Specifies which property to animate
	/// @param framePerSecond The frames per second of the animation
	/// @param totalFrame The total number of frames
	/// @param from The frame at the beginning of the animation
	/// @param to The frame at the end of the animation
	/// @param loopMode Specifies the loop mode of the animation
	/// @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations
	/// @param onAnimationEnd Callback to run once the animation is complete
	/// @returns Nullable animation
	external static Animatable? CreateMergeAndStartAnimation(String name, Node node, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num? loopMode, EasingFunction? easingFunction, void Function()? onAnimationEnd]);
	
	/// Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.
	/// @param sourceAnimation defines the Animation containing keyframes to convert
	/// @param referenceFrame defines the frame that keyframes in the range will be relative to
	/// @param range defines the name of the AnimationRange belonging to the Animation to convert
	/// @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)
	/// @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true
	/// @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false
	external static Animation MakeAnimationAdditive(Animation sourceAnimation, [num? referenceFrame, String? range, bool? cloneOriginal, String? clonedName]);
	
	/// Transition property of an host to the target Value
	/// @param property The property to transition
	/// @param targetValue The target Value of the property
	/// @param host The object where the property to animate belongs
	/// @param scene Scene used to run the animation
	/// @param frameRate Framerate (in frame/s) to use
	/// @param transition The transition type we want to use
	/// @param duration The duration of the animation, in milliseconds
	/// @param onAnimationEnd Callback trigger at the end of the animation
	/// @returns Nullable animation
	external static Animatable? TransitionTo(String property, dynamic targetValue, dynamic host, Scene scene, num frameRate, Animation transition, num duration, [void Function()? onAnimationEnd]);
	
	/// Return the array of runtime animations currently using this animation
	external List<RuntimeAnimation> get runtimeAnimations;
	
	/// Specifies if any of the runtime animations are currently running
	external bool get hasRunningRuntimeAnimations;
	
	/// Converts the animation to a string
	/// @param fullDetails support for multiple levels of logging within scene loading
	/// @returns String form of the animation
	external String toString([bool? fullDetails]);
	
	/// Add an event to this animation
	/// @param event Event to add
	external void addEvent(AnimationEvent event);
	
	/// Remove all events found at the given frame
	/// @param frame The frame to remove events from
	external void removeEvents(num frame);
	
	/// Retrieves all the events from the animation
	/// @returns Events from the animation
	external List<AnimationEvent> getEvents();
	
	/// Creates an animation range
	/// @param name Name of the animation range
	/// @param from Starting frame of the animation range
	/// @param to Ending frame of the animation
	external void createRange(String name, num from, num to);
	
	/// Deletes an animation range by name
	/// @param name Name of the animation range to delete
	/// @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)
	external void deleteRange(String name, [bool? deleteFrames]);
	
	/// Gets the animation range by name, or null if not defined
	/// @param name Name of the animation range
	/// @returns Nullable animation range
	external AnimationRange? getRange(String name);
	
	/// Gets the key frames from the animation
	/// @returns The key frames of the animation
	external List<IAnimationKey> getKeys();
	
	/// Gets the highest frame rate of the animation
	/// @returns Highest frame rate of the animation
	external num getHighestFrame();
	
	/// Gets the easing function of the animation
	/// @returns Easing function of the animation
	external IEasingFunction getEasingFunction();
	
	/// Sets the easing function of the animation
	/// @param easingFunction A custom mathematical formula for animation
	external void setEasingFunction(EasingFunction easingFunction);
	
	/// Interpolates a scalar linearly
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated scalar value
	external num floatInterpolateFunction(num startValue, num endValue, num gradient);
	
	/// Interpolates a scalar cubically
	/// @param startValue Start value of the animation curve
	/// @param outTangent End tangent of the animation
	/// @param endValue End value of the animation curve
	/// @param inTangent Start tangent of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated scalar value
	external num floatInterpolateFunctionWithTangents(num startValue, num outTangent, num endValue, num inTangent, num gradient);
	
	/// Interpolates a quaternion using a spherical linear interpolation
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated quaternion value
	external Quaternion quaternionInterpolateFunction(Quaternion startValue, Quaternion endValue, num gradient);
	
	/// Interpolates a quaternion cubically
	/// @param startValue Start value of the animation curve
	/// @param outTangent End tangent of the animation curve
	/// @param endValue End value of the animation curve
	/// @param inTangent Start tangent of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated quaternion value
	external Quaternion quaternionInterpolateFunctionWithTangents(Quaternion startValue, Quaternion outTangent, Quaternion endValue, Quaternion inTangent, num gradient);
	
	/// Interpolates a Vector3 linearl
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated scalar value
	external Vector3 vector3InterpolateFunction(Vector3 startValue, Vector3 endValue, num gradient);
	
	/// Interpolates a Vector3 cubically
	/// @param startValue Start value of the animation curve
	/// @param outTangent End tangent of the animation
	/// @param endValue End value of the animation curve
	/// @param inTangent Start tangent of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns InterpolatedVector3 value
	external Vector3 vector3InterpolateFunctionWithTangents(Vector3 startValue, Vector3 outTangent, Vector3 endValue, Vector3 inTangent, num gradient);
	
	/// Interpolates a Vector2 linearly
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated Vector2 value
	external Vector2 vector2InterpolateFunction(Vector2 startValue, Vector2 endValue, num gradient);
	
	/// Interpolates a Vector2 cubically
	/// @param startValue Start value of the animation curve
	/// @param outTangent End tangent of the animation
	/// @param endValue End value of the animation curve
	/// @param inTangent Start tangent of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated Vector2 value
	external Vector2 vector2InterpolateFunctionWithTangents(Vector2 startValue, Vector2 outTangent, Vector2 endValue, Vector2 inTangent, num gradient);
	
	/// Interpolates a size linearly
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated Size value
	external Size sizeInterpolateFunction(Size startValue, Size endValue, num gradient);
	
	/// Interpolates a Color3 linearly
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated Color3 value
	external Color3 color3InterpolateFunction(Color3 startValue, Color3 endValue, num gradient);
	
	/// Interpolates a Color4 linearly
	/// @param startValue Start value of the animation curve
	/// @param endValue End value of the animation curve
	/// @param gradient Scalar amount to interpolate
	/// @returns Interpolated Color3 value
	external Color4 color4InterpolateFunction(Color4 startValue, Color4 endValue, num gradient);
	
	/// Defines the function to use to interpolate matrices
	/// @param startValue defines the start matrix
	/// @param endValue defines the end matrix
	/// @param gradient defines the gradient between both matrices
	/// @param result defines an optional target matrix where to store the interpolation
	/// @returns the interpolated matrix
	external Matrix matrixInterpolateFunction(Matrix startValue, Matrix endValue, num gradient, [Matrix? result]);
	
	/// Makes a copy of the animation
	/// @returns Cloned animation
	external Animation clone();
	
	/// Sets the key frames of the animation
	/// @param values The animation key frames to set
	external void setKeys(List<IAnimationKey> values);
	
	/// Serializes the animation to an object
	/// @returns Serialized object
	external dynamic serialize();
	
	/// Float animation type
	external static num get ANIMATIONTYPE_FLOAT;
	
	/// Vector3 animation type
	external static num get ANIMATIONTYPE_VECTOR3;
	
	/// Quaternion animation type
	external static num get ANIMATIONTYPE_QUATERNION;
	
	/// Matrix animation type
	external static num get ANIMATIONTYPE_MATRIX;
	
	/// Color3 animation type
	external static num get ANIMATIONTYPE_COLOR3;
	
	/// Color3 animation type
	external static num get ANIMATIONTYPE_COLOR4;
	
	/// Vector2 animation type
	external static num get ANIMATIONTYPE_VECTOR2;
	
	/// Size animation type
	external static num get ANIMATIONTYPE_SIZE;
	
	/// Relative Loop Mode
	external static num get ANIMATIONLOOPMODE_RELATIVE;
	
	/// Cycle Loop Mode
	external static num get ANIMATIONLOOPMODE_CYCLE;
	
	/// Constant Loop Mode
	external static num get ANIMATIONLOOPMODE_CONSTANT;
	
	/// Parses an animation object and creates an animation
	/// @param parsedAnimation Parsed animation object
	/// @returns Animation object
	external static Animation Parse(dynamic parsedAnimation);
	
	/// Appends the serialized animations from the source animations
	/// @param source Source containing the animations
	/// @param destination Target to store the animations
	external static void AppendSerializedAnimations(IAnimatable source, dynamic destination);
	
	/// Creates a new animation or an array of animations from a snippet saved in a remote file
	/// @param name defines the name of the animation to create (can be null or empty to use the one from the json data)
	/// @param url defines the url to load from
	/// @returns a promise that will resolve to the new animation or an array of animations
	external static Promise<dynamic> ParseFromFileAsync(String? name, String url);
	
	/// Creates an animation or an array of animations from a snippet saved by the Inspector
	/// @param snippetId defines the snippet to load
	/// @returns a promise that will resolve to the new animation or a new array of animations
	external static Promise<dynamic> CreateFromSnippetAsync(String snippetId);
}

/// Interface containing an array of animations
@JS()
abstract class IAnimatable {
	
	/// Array of animations
	external List<Animation>? get animations;
	external set animations(List<Animation>? value);
}

/* top level function */
@JS()
external void Function(dynamic target, String propertyKey) expandToProperty(String callback, [String? targetKey]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serialize([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsTexture([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsColor3([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsFresnelParameters([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsVector2([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsVector3([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsMeshReference([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsColorCurves([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsColor4([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsImageProcessingConfiguration([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsQuaternion([String? sourceName]);

/* top level function */
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsMatrix([String? sourceName]);

/* top level function */
/// Decorator used to define property that can be serialized as reference to a camera
/// @param sourceName defines the name of the property to decorate
@JS()
external void Function(dynamic target, dynamic propertyKey) serializeAsCameraReference([String? sourceName]);

/// Class used to help serialization objects
@JS()
class SerializationHelper {
	external factory SerializationHelper();
	
	/// Appends the serialized animations from the source animations
	/// @param source Source containing the animations
	/// @param destination Target to store the animations
	external static void AppendSerializedAnimations(IAnimatable source, dynamic destination);
	
	/// Static function used to serialized a specific entity
	/// @param entity defines the entity to serialize
	/// @param serializationObject defines the optional target obecjt where serialization data will be stored
	/// @returns a JSON compatible object representing the serialization of the entity
	external static dynamic Serialize<T>(T entity, [dynamic? serializationObject]);
	
	/// Creates a new entity from a serialization data object
	/// @param creationFunction defines a function used to instanciated the new entity
	/// @param source defines the source serialization data
	/// @param scene defines the hosting scene
	/// @param rootUrl defines the root url for resources
	/// @returns a new entity
	external static T Parse<T>(T Function() creationFunction, dynamic source, Scene? scene, [String? rootUrl]);
	
	/// Clones an object
	/// @param creationFunction defines the function used to instanciate the new object
	/// @param source defines the source object
	/// @returns the cloned object
	external static T Clone<T>(T Function() creationFunction, T source);
	
	/// Instanciates a new object based on a source one (some data will be shared between both object)
	/// @param creationFunction defines the function used to instanciate the new object
	/// @param source defines the source object
	/// @returns the new object
	external static T Instanciate<T>(T Function() creationFunction, T source);
}

/// PostProcessManager is used to manage one or more post processes or post process pipelines
/// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
@JS()
class PostProcessManager {
	
	/// Creates a new instance PostProcess
	/// @param scene The scene that the post process is associated with.
	external factory PostProcessManager(Scene scene);
	
	/// Manually render a set of post processes to a texture.
	/// Please note, the frame buffer won't be unbound after the call in case you have more render to do.
	/// @param postProcesses An array of post processes to be run.
	/// @param targetTexture The target texture to render to.
	/// @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight
	/// @param faceIndex defines the face to render to if a cubemap is defined as the target
	/// @param lodLevel defines which lod of the texture to render to
	/// @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously
	external void directRender(List<PostProcess> postProcesses, [InternalTexture? targetTexture, bool? forceFullscreenViewport, num? faceIndex, num? lodLevel, bool? doNotBindFrambuffer]);
	
	/// Disposes of the post process manager.
	external void dispose();
}

/// This Helps creating a texture that will be created from a camera in your scene.
/// It is basically a dynamic texture that could be used to create special effects for instance.
/// Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
@JS()
class RenderTargetTexture extends Texture {
	
	/// Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse
	/// or used a shadow, depth texture...
	/// @param name The friendly name of the texture
	/// @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)
	/// @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.
	/// @param generateMipMaps True if mip maps need to be generated after render.
	/// @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT
	/// @param type The type of the buffer in the RTT (int, half float, float...)
	/// @param isCube True if a cube texture needs to be created
	/// @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)
	/// @param generateDepthBuffer True to generate a depth buffer
	/// @param generateStencilBuffer True to generate a stencil buffer
	/// @param isMulti True if multiple textures need to be created (Draw Buffers)
	/// @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)
	/// @param delayAllocation if the texture allocation should be delayed (default: false)
	external factory RenderTargetTexture(String name, dynamic size, Scene? scene, [bool? generateMipMaps, bool? doNotChangeAspectRatio, num? type, bool? isCube, num? samplingMode, bool? generateDepthBuffer, bool? generateStencilBuffer, bool? isMulti, num? format, bool? delayAllocation]);
	
	/// The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.
	external static num get REFRESHRATE_RENDER_ONCE;
	
	/// The texture will only be rendered rendered every frame and is recomended for dynamic contents.
	external static num get REFRESHRATE_RENDER_ONEVERYFRAME;
	
	/// The texture will be rendered every 2 frames which could be enough if your dynamic objects are not
	/// the central point of your effect and can save a lot of performances.
	external static num get REFRESHRATE_RENDER_ONEVERYTWOFRAMES;
	
	/// Use this predicate to dynamically define the list of mesh you want to render.
	/// If set, the renderList property will be overwritten.
	external bool Function(AbstractMesh AbstractMesh) get renderListPredicate;
	external set renderListPredicate(bool Function(AbstractMesh AbstractMesh) value);
	
	/// Use this list to define the list of mesh you want to render.
	external List<AbstractMesh>? get renderList;
	
	external set renderList(List<AbstractMesh>? value);
	
	/// Use this function to overload the renderList array at rendering time.
	/// Return null to render with the curent renderList, else return the list of meshes to use for rendering.
	/// For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of
	/// the cube (if the RTT is a cube, else layerOrFace=0).
	/// The renderList passed to the function is the current render list (the one that will be used if the function returns null).
	/// The length of this list is passed through renderListLength: don't use renderList.length directly because the array can
	/// hold dummy elements!
	external List<AbstractMesh>? Function(num layerOrFace, List<AbstractMesh>? renderList, num renderListLength) get getCustomRenderList;
	external set getCustomRenderList(List<AbstractMesh>? Function(num layerOrFace, List<AbstractMesh>? renderList, num renderListLength) value);
	
	/// Define if particles should be rendered in your texture.
	external bool get renderParticles;
	external set renderParticles(bool value);
	
	/// Define if sprites should be rendered in your texture.
	external bool get renderSprites;
	external set renderSprites(bool value);
	
	/// Define the camera used to render the texture.
	external Camera? get activeCamera;
	external set activeCamera(Camera? value);
	
	/// Override the mesh isReady function with your own one.
	external bool Function(AbstractMesh mesh, num refreshRate) get customIsReadyFunction;
	external set customIsReadyFunction(bool Function(AbstractMesh mesh, num refreshRate) value);
	
	/// Override the render function of the texture with your own one.
	external void Function(SmartArray<SubMesh> opaqueSubMeshes, SmartArray<SubMesh> alphaTestSubMeshes, SmartArray<SubMesh> transparentSubMeshes, SmartArray<SubMesh> depthOnlySubMeshes, [void Function()? beforeTransparents]) get customRenderFunction;
	external set customRenderFunction(void Function(SmartArray<SubMesh> opaqueSubMeshes, SmartArray<SubMesh> alphaTestSubMeshes, SmartArray<SubMesh> transparentSubMeshes, SmartArray<SubMesh> depthOnlySubMeshes, [void Function()? beforeTransparents]) value);
	
	/// Define if camera post processes should be use while rendering the texture.
	external bool get useCameraPostProcesses;
	external set useCameraPostProcesses(bool value);
	
	/// Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.
	external bool get ignoreCameraViewport;
	external set ignoreCameraViewport(bool value);
	
	/// An event triggered when the texture is unbind.
	external Observable<RenderTargetTexture> get onBeforeBindObservable;
	external set onBeforeBindObservable(Observable<RenderTargetTexture> value);
	
	/// An event triggered when the texture is unbind.
	external Observable<RenderTargetTexture> get onAfterUnbindObservable;
	external set onAfterUnbindObservable(Observable<RenderTargetTexture> value);
	
	/// Set a after unbind callback in the texture.
	/// This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.
	external set onAfterUnbind(void Function() value);
	
	/// An event triggered before rendering the texture
	external Observable<num> get onBeforeRenderObservable;
	external set onBeforeRenderObservable(Observable<num> value);
	
	/// Set a before render callback in the texture.
	/// This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.
	external set onBeforeRender(void Function(num faceIndex) value);
	
	/// An event triggered after rendering the texture
	external Observable<num> get onAfterRenderObservable;
	external set onAfterRenderObservable(Observable<num> value);
	
	/// Set a after render callback in the texture.
	/// This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.
	external set onAfterRender(void Function(num faceIndex) value);
	
	/// An event triggered after the texture clear
	external Observable<Engine> get onClearObservable;
	external set onClearObservable(Observable<Engine> value);
	
	/// Set a clear callback in the texture.
	/// This has been kept for backward compatibility and use of onClearObservable is recommended.
	external set onClear(void Function(Engine Engine) value);
	
	/// An event triggered when the texture is resized.
	external Observable<RenderTargetTexture> get onResizeObservable;
	external set onResizeObservable(Observable<RenderTargetTexture> value);
	
	/// Define the clear color of the Render Target if it should be different from the scene.
	external Color4 get clearColor;
	external set clearColor(Color4 value);
	
	/// Gets render target creation options that were used.
	external RenderTargetCreationOptions get renderTargetOptions;
	
	/// Gets or sets the center of the bounding box associated with the texture (when in cube mode)
	/// It must define where the camera used to render the texture is set
	external Vector3 get boundingBoxPosition;
	external set boundingBoxPosition(Vector3 value);
	
	/// Gets or sets the size of the bounding box associated with the texture (when in cube mode)
	/// When defined, the cubemap will switch to local mode
	/// @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
	/// @example https://www.babylonjs-playground.com/#RNASML
	external set boundingBoxSize(Vector3 value);
	
	external Vector3 get boundingBoxSize;
	
	/// In case the RTT has been created with a depth texture, get the associated
	/// depth texture.
	/// Otherwise, return null.
	external InternalTexture? get depthStencilTexture;
	
	/// Creates a depth stencil texture.
	/// This is only available in WebGL 2 or with the depth texture extension available.
	/// @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode
	/// @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture
	/// @param generateStencil Specifies whether or not a stencil should be allocated in the texture
	external void createDepthStencilTexture([num? comparisonFunction, bool? bilinearFiltering, bool? generateStencil]);
	
	/// Define the number of samples to use in case of MSAA.
	/// It defaults to one meaning no MSAA has been enabled.
	external num get samples;
	
	external set samples(num value);
	
	/// Resets the refresh counter of the texture and start bak from scratch.
	/// Could be useful to regenerate the texture if it is setup to render only once.
	external void resetRefreshCounter();
	
	/// Define the refresh rate of the texture or the rendering frequency.
	/// Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
	external num get refreshRate;
	
	external set refreshRate(num value);
	
	/// Adds a post process to the render target rendering passes.
	/// @param postProcess define the post process to add
	external void addPostProcess(PostProcess postProcess);
	
	/// Clear all the post processes attached to the render target
	/// @param dispose define if the cleared post processesshould also be disposed (false by default)
	external void clearPostProcesses([bool? dispose]);
	
	/// Remove one of the post process from the list of attached post processes to the texture
	/// @param postProcess define the post process to remove from the list
	external void removePostProcess(PostProcess postProcess);
	
	/// Gets the actual render size of the texture.
	/// @returns the width of the render size
	external num getRenderSize();
	
	/// Gets the actual render width of the texture.
	/// @returns the width of the render size
	external num getRenderWidth();
	
	/// Gets the actual render height of the texture.
	/// @returns the height of the render size
	external num getRenderHeight();
	
	/// Gets the actual number of layers of the texture.
	/// @returns the number of layers
	external num getRenderLayers();
	
	/// Get if the texture can be rescaled or not.
	@override
	external bool get canRescale;
	
	/// Resize the texture using a ratio.
	/// @param ratio the ratio to apply to the texture size in order to compute the new target size
	@override
	external void scale(num ratio);
	
	/// Get the texture reflection matrix used to rotate/transform the reflection.
	/// @returns the reflection matrix
	@override
	external Matrix getReflectionTextureMatrix();
	
	/// Resize the texture to a new desired size.
	/// Be carrefull as it will recreate all the data in the new texture.
	/// @param size Define the new size. It can be:
	/// - a number for squared texture,
	/// - an object containing { width: number, height: number }
	/// - or an object containing a ratio { ratio: number }
	external void resize(dynamic size);
	
	/// Renders all the objects from the render list into the texture.
	/// @param useCameraPostProcess Define if camera post processes should be used during the rendering
	/// @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose
	external void render([bool? useCameraPostProcess, bool? dumpForDebug]);
	
	external void unbindFrameBuffer(Engine engine, num faceIndex);
	
	/// Overrides the default sort function applied in the renderging group to prepare the meshes.
	/// This allowed control for front to back rendering or reversly depending of the special needs.
	/// 
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param opaqueSortCompareFn The opaque queue comparison function use to sort.
	/// @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
	/// @param transparentSortCompareFn The transparent queue comparison function use to sort.
	external void setRenderingOrder(num renderingGroupId, [num Function(SubMesh a, SubMesh b)? opaqueSortCompareFn, num Function(SubMesh a, SubMesh b)? alphaTestSortCompareFn, num Function(SubMesh a, SubMesh b)? transparentSortCompareFn]);
	
	/// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
	/// 
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
	external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil);
	
	/// Clones the texture.
	/// @returns the cloned texture
	@override
	external RenderTargetTexture? clone();
	
	/// Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
	/// @returns The JSON representation of the texture
	@override
	external dynamic serialize();
	
	/// This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore
	external void disposeFramebufferObjects();
	
	/// Dispose the texture and release its associated resources.
	@override
	external void dispose();
	
	/// Clear the info related to rendering groups preventing retention point in material dispose.
	external void freeRenderingGroups();
	
	/// Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
	/// @returns the view count
	external num getViewCount();
}

/// Options to be used when creating an effect.
@JS()
@anonymous
class IEffectCreationOptions {
	
	external factory IEffectCreationOptions({List<String> attributes, List<String> uniformsNames, List<String> uniformBuffersNames, List<String> samplers, dynamic defines, IEffectFallbacks? fallbacks, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, dynamic indexParameters, num maxSimultaneousLights, List<String>? transformFeedbackVaryings, String Function(String shaderType, String code)? processFinalCode, bool multiTarget});
	
	/// Atrributes that will be used in the shader.
	external List<String> get attributes;
	external set attributes( List<String> value );
	
	/// Uniform varible names that will be set in the shader.
	external List<String> get uniformsNames;
	external set uniformsNames( List<String> value );
	
	/// Uniform buffer variable names that will be set in the shader.
	external List<String> get uniformBuffersNames;
	external set uniformBuffersNames( List<String> value );
	
	/// Sampler texture variable names that will be set in the shader.
	external List<String> get samplers;
	external set samplers( List<String> value );
	
	/// Define statements that will be set in the shader.
	external dynamic get defines;
	external set defines( dynamic value );
	
	/// Possible fallbacks for this effect to improve performance when needed.
	external IEffectFallbacks? get fallbacks;
	external set fallbacks( IEffectFallbacks? value );
	
	/// Callback that will be called when the shader is compiled.
	external void Function(Effect effect)? get onCompiled;
	external set onCompiled( void Function(Effect effect)? value );
	
	/// Callback that will be called if an error occurs during shader compilation.
	external void Function(Effect effect, String errors)? get onError;
	external set onError( void Function(Effect effect, String errors)? value );
	
	/// Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
	external dynamic get indexParameters;
	external set indexParameters( dynamic value );
	
	/// Max number of lights that can be used in the shader.
	external num get maxSimultaneousLights;
	external set maxSimultaneousLights( num value );
	
	/// See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings
	external List<String>? get transformFeedbackVaryings;
	external set transformFeedbackVaryings( List<String>? value );
	
	/// If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU
	external String Function(String shaderType, String code)? get processFinalCode;
	external set processFinalCode( String Function(String shaderType, String code)? value );
	
	/// Is this effect rendering to several color attachments ?
	external bool get multiTarget;
	external set multiTarget( bool value );
}

/// Effect containing vertex and fragment shader that can be executed on an object.
@JS()
class Effect implements IDisposable {
	
	/// Instantiates an effect.
	/// An effect can be used to create/manage/execute vertex and fragment shaders.
	/// @param baseName Name of the effect.
	/// @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.
	/// @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.
	/// @param samplers List of sampler variables that will be passed to the shader.
	/// @param engine Engine to be used to render the effect
	/// @param defines Define statements to be added to the shader.
	/// @param fallbacks Possible fallbacks for this effect to improve performance when needed.
	/// @param onCompiled Callback that will be called when the shader is compiled.
	/// @param onError Callback that will be called if an error occurs during shader compilation.
	/// @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
	external factory Effect(dynamic baseName, dynamic attributesNamesOrOptions, dynamic uniformsNamesOrEngine, [List<String>? samplers, ThinEngine? engine, String? defines, IEffectFallbacks? fallbacks, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, dynamic? indexParameters]);
	
	/// Gets or sets the relative url used to load shaders if using the engine in non-minified mode
	external static String get ShadersRepository;
	external static set ShadersRepository(String value);
	
	/// Enable logging of the shader code when a compilation error occurs
	external static bool get LogShaderCodeOnCompilationError;
	external static set LogShaderCodeOnCompilationError(bool value);
	
	/// Name of the effect.
	external dynamic get name;
	external set name(dynamic value);
	
	/// String container all the define statements that should be set on the shader.
	external String get defines;
	external set defines(String value);
	
	/// Callback that will be called when the shader is compiled.
	external void Function(Effect effect)? get onCompiled;
	external set onCompiled(void Function(Effect effect)? value);
	
	/// Callback that will be called if an error occurs during shader compilation.
	external void Function(Effect effect, String errors)? get onError;
	external set onError(void Function(Effect effect, String errors)? value);
	
	/// Callback that will be called when effect is bound.
	external void Function(Effect effect)? get onBind;
	external set onBind(void Function(Effect effect)? value);
	
	/// Unique ID of the effect.
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// Observable that will be called when the shader is compiled.
	/// It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.
	external Observable<Effect> get onCompileObservable;
	external set onCompileObservable(Observable<Effect> value);
	
	/// Observable that will be called if an error occurs during shader compilation.
	external Observable<Effect> get onErrorObservable;
	external set onErrorObservable(Observable<Effect> value);
	
	/// Observable that will be called when effect is bound.
	external Observable<Effect> get onBindObservable;
	
	/// Unique key for this effect
	external String get key;
	
	/// If the effect has been compiled and prepared.
	/// @returns if the effect is compiled and prepared.
	external bool isReady();
	
	/// The engine the effect was initialized with.
	/// @returns the engine.
	external Engine getEngine();
	
	/// The pipeline context for this effect
	/// @returns the associated pipeline context
	external IPipelineContext? getPipelineContext();
	
	/// The set of names of attribute variables for the shader.
	/// @returns An array of attribute names.
	external List<String> getAttributesNames();
	
	/// Returns the attribute at the given index.
	/// @param index The index of the attribute.
	/// @returns The location of the attribute.
	external num getAttributeLocation(num index);
	
	/// Returns the attribute based on the name of the variable.
	/// @param name of the attribute to look up.
	/// @returns the attribute location.
	external num getAttributeLocationByName(String name);
	
	/// The number of attributes.
	/// @returns the numnber of attributes.
	external num getAttributesCount();
	
	/// Gets the index of a uniform variable.
	/// @param uniformName of the uniform to look up.
	/// @returns the index.
	external num getUniformIndex(String uniformName);
	
	/// Returns the attribute based on the name of the variable.
	/// @param uniformName of the uniform to look up.
	/// @returns the location of the uniform.
	external WebGL.UniformLocation? getUniform(String uniformName);
	
	/// Returns an array of sampler variable names
	/// @returns The array of sampler variable names.
	external List<String> getSamplers();
	
	/// Returns an array of uniform variable names
	/// @returns The array of uniform variable names.
	external List<String> getUniformNames();
	
	/// Returns an array of uniform buffer variable names
	/// @returns The array of uniform buffer variable names.
	external List<String> getUniformBuffersNames();
	
	/// Returns the index parameters used to create the effect
	/// @returns The index parameters object
	external dynamic getIndexParameters();
	
	/// The error from the last compilation.
	/// @returns the error string.
	external String getCompilationError();
	
	/// Gets a boolean indicating that all fallbacks were used during compilation
	/// @returns true if all fallbacks were used
	external bool allFallbacksProcessed();
	
	/// Adds a callback to the onCompiled observable and call the callback imediatly if already ready.
	/// @param func The callback to be used.
	external void executeWhenCompiled(void Function(Effect effect) func);
	
	/// Gets the vertex shader source code of this effect
	external String get vertexSourceCode;
	
	/// Gets the fragment shader source code of this effect
	external String get fragmentSourceCode;
	
	/// Gets the vertex shader source code before it has been processed by the preprocessor
	external String get rawVertexSourceCode;
	
	/// Gets the fragment shader source code before it has been processed by the preprocessor
	external String get rawFragmentSourceCode;
	
	/// Checks if the effect is supported. (Must be called after compilation)
	external bool get isSupported;
	
	/// Sets a texture on the engine to be used in the shader.
	/// @param channel Name of the sampler variable.
	/// @param texture Texture to set.
	external void setTexture(String channel, ThinTexture? texture);
	
	/// Sets a depth stencil texture from a render target on the engine to be used in the shader.
	/// @param channel Name of the sampler variable.
	/// @param texture Texture to set.
	external void setDepthStencilTexture(String channel, RenderTargetTexture? texture);
	
	/// Sets an array of textures on the engine to be used in the shader.
	/// @param channel Name of the variable.
	/// @param textures Textures to set.
	external void setTextureArray(String channel, List<ThinTexture> textures);
	
	/// Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)
	/// @param channel Name of the sampler variable.
	/// @param postProcess Post process to get the input texture from.
	external void setTextureFromPostProcess(String channel, PostProcess? postProcess);
	
	/// (Warning! setTextureFromPostProcessOutput may be desired instead)
	/// Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)
	/// @param channel Name of the sampler variable.
	/// @param postProcess Post process to get the output texture from.
	external void setTextureFromPostProcessOutput(String channel, PostProcess? postProcess);
	
	/// Binds a buffer to a uniform.
	/// @param buffer Buffer to bind.
	/// @param name Name of the uniform variable to bind to.
	external void bindUniformBuffer(DataBuffer buffer, String name);
	
	/// Binds block to a uniform.
	/// @param blockName Name of the block to bind.
	/// @param index Index to bind.
	external void bindUniformBlock(String blockName, num index);
	
	/// Sets an interger value on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param value Value to be set.
	/// @returns this effect.
	external Effect setInt(String uniformName, num value);
	
	/// Sets an int array on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setIntArray(String uniformName, Int32List array);
	
	/// Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setIntArray2(String uniformName, Int32List array);
	
	/// Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setIntArray3(String uniformName, Int32List array);
	
	/// Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setIntArray4(String uniformName, Int32List array);
	
	/// Sets an float array on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setFloatArray(String uniformName, Float32List array);
	
	/// Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setFloatArray2(String uniformName, Float32List array);
	
	/// Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setFloatArray3(String uniformName, Float32List array);
	
	/// Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setFloatArray4(String uniformName, Float32List array);
	
	/// Sets an array on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setArray(String uniformName, List<num> array);
	
	/// Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setArray2(String uniformName, List<num> array);
	
	/// Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setArray3(String uniformName, List<num> array);
	
	/// Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
	/// @param uniformName Name of the variable.
	/// @param array array to be set.
	/// @returns this effect.
	external Effect setArray4(String uniformName, List<num> array);
	
	/// Sets matrices on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param matrices matrices to be set.
	/// @returns this effect.
	external Effect setMatrices(String uniformName, dynamic matrices);
	
	/// Sets matrix on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param matrix matrix to be set.
	/// @returns this effect.
	external Effect setMatrix(String uniformName, Matrix matrix);
	
	/// Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
	/// @param uniformName Name of the variable.
	/// @param matrix matrix to be set.
	/// @returns this effect.
	external Effect setMatrix3x3(String uniformName, dynamic matrix);
	
	/// Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)
	/// @param uniformName Name of the variable.
	/// @param matrix matrix to be set.
	/// @returns this effect.
	external Effect setMatrix2x2(String uniformName, dynamic matrix);
	
	/// Sets a float on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param value value to be set.
	/// @returns this effect.
	external Effect setFloat(String uniformName, num value);
	
	/// Sets a boolean on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param bool value to be set.
	/// @returns this effect.
	external Effect setBool(String uniformName, bool bool);
	
	/// Sets a Vector2 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param vector2 vector2 to be set.
	/// @returns this effect.
	external Effect setVector2(String uniformName, Vector2 vector2);
	
	/// Sets a float2 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param x First float in float2.
	/// @param y Second float in float2.
	/// @returns this effect.
	external Effect setFloat2(String uniformName, num x, num y);
	
	/// Sets a Vector3 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param vector3 Value to be set.
	/// @returns this effect.
	external Effect setVector3(String uniformName, Vector3 vector3);
	
	/// Sets a float3 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param x First float in float3.
	/// @param y Second float in float3.
	/// @param z Third float in float3.
	/// @returns this effect.
	external Effect setFloat3(String uniformName, num x, num y, num z);
	
	/// Sets a Vector4 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param vector4 Value to be set.
	/// @returns this effect.
	external Effect setVector4(String uniformName, Vector4 vector4);
	
	/// Sets a float4 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param x First float in float4.
	/// @param y Second float in float4.
	/// @param z Third float in float4.
	/// @param w Fourth float in float4.
	/// @returns this effect.
	external Effect setFloat4(String uniformName, num x, num y, num z, num w);
	
	/// Sets a Color3 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param color3 Value to be set.
	/// @returns this effect.
	external Effect setColor3(String uniformName, Color3 color3);
	
	/// Sets a Color4 on a uniform variable.
	/// @param uniformName Name of the variable.
	/// @param color3 Value to be set.
	/// @param alpha Alpha value to be set.
	/// @returns this effect.
	external Effect setColor4(String uniformName, Color3 color3, num alpha);
	
	/// Sets a Color4 on a uniform variable
	/// @param uniformName defines the name of the variable
	/// @param color4 defines the value to be set
	/// @returns this effect.
	external Effect setDirectColor4(String uniformName, Color4 color4);
	
	/// Release all associated resources
	@override
	external void dispose();
	
	/// This function will add a new shader to the shader store
	/// @param name the name of the shader
	/// @param pixelShader optional pixel shader content
	/// @param vertexShader optional vertex shader content
	external static void RegisterShader(String name, [String? pixelShader, String? vertexShader]);
	
	/// Store of each shader (The can be looked up using effect.key)
	external static dynamic /* object */ get ShadersStore;
	external static set ShadersStore(dynamic /* object */ value);
	
	/// Store of each included file for a shader (The can be looked up using effect.key)
	external static dynamic /* object */ get IncludesShadersStore;
	external static set IncludesShadersStore(dynamic /* object */ value);
	
	/// Resets the cache of effects.
	external static void ResetCache();
}

/// Interface used to describe the capabilities of the engine relatively to the current browser
@JS()
@anonymous
class EngineCapabilities {
	
	external factory EngineCapabilities({num maxTexturesImageUnits, num maxVertexTextureImageUnits, num maxCombinedTexturesImageUnits, num maxTextureSize, num maxSamples, num maxCubemapTextureSize, num maxRenderTextureSize, num maxVertexAttribs, num maxVaryingVectors, num maxVertexUniformVectors, num maxFragmentUniformVectors, bool standardDerivatives, dynamic /* unresolved: WEBGL_compressed_texture_s3tc */ s3tc, dynamic pvrtc, dynamic etc1, dynamic etc2, dynamic astc, dynamic bptc, bool textureFloat, bool vertexArrayObject, dynamic /* unresolved: EXT_texture_filter_anisotropic */ textureAnisotropicFilterExtension, num maxAnisotropy, bool instancedArrays, bool uintIndices, bool highPrecisionShaderSupported, bool fragmentDepthSupported, bool textureFloatLinearFiltering, bool textureFloatRender, bool textureHalfFloat, bool textureHalfFloatLinearFiltering, bool textureHalfFloatRender, bool textureLOD, bool drawBuffersExtension, bool depthTextureExtension, bool colorBufferFloat, EXT_disjoint_timer_query timerQuery, bool canUseTimestampForTimerQuery, dynamic multiview, dynamic oculusMultiview, EngineCapabilitiesParallelShaderCompile parallelShaderCompile, num maxMSAASamples, bool blendMinMax});
	
	/// Maximum textures units per fragment shader
	external num get maxTexturesImageUnits;
	external set maxTexturesImageUnits( num value );
	
	/// Maximum texture units per vertex shader
	external num get maxVertexTextureImageUnits;
	external set maxVertexTextureImageUnits( num value );
	
	/// Maximum textures units in the entire pipeline
	external num get maxCombinedTexturesImageUnits;
	external set maxCombinedTexturesImageUnits( num value );
	
	/// Maximum texture size
	external num get maxTextureSize;
	external set maxTextureSize( num value );
	
	/// Maximum texture samples
	external num get maxSamples;
	external set maxSamples( num value );
	
	/// Maximum cube texture size
	external num get maxCubemapTextureSize;
	external set maxCubemapTextureSize( num value );
	
	/// Maximum render texture size
	external num get maxRenderTextureSize;
	external set maxRenderTextureSize( num value );
	
	/// Maximum number of vertex attributes
	external num get maxVertexAttribs;
	external set maxVertexAttribs( num value );
	
	/// Maximum number of varyings
	external num get maxVaryingVectors;
	external set maxVaryingVectors( num value );
	
	/// Maximum number of uniforms per vertex shader
	external num get maxVertexUniformVectors;
	external set maxVertexUniformVectors( num value );
	
	/// Maximum number of uniforms per fragment shader
	external num get maxFragmentUniformVectors;
	external set maxFragmentUniformVectors( num value );
	
	/// Defines if standard derivates (dx/dy) are supported
	external bool get standardDerivatives;
	external set standardDerivatives( bool value );
	
	/// Defines if s3tc texture compression is supported
	external dynamic /* unresolved: WEBGL_compressed_texture_s3tc */ get s3tc;
	external set s3tc( dynamic /* unresolved: WEBGL_compressed_texture_s3tc */ value );
	
	/// Defines if pvrtc texture compression is supported
	external dynamic get pvrtc;
	external set pvrtc( dynamic value );
	
	/// Defines if etc1 texture compression is supported
	external dynamic get etc1;
	external set etc1( dynamic value );
	
	/// Defines if etc2 texture compression is supported
	external dynamic get etc2;
	external set etc2( dynamic value );
	
	/// Defines if astc texture compression is supported
	external dynamic get astc;
	external set astc( dynamic value );
	
	/// Defines if bptc texture compression is supported
	external dynamic get bptc;
	external set bptc( dynamic value );
	
	/// Defines if float textures are supported
	external bool get textureFloat;
	external set textureFloat( bool value );
	
	/// Defines if vertex array objects are supported
	external bool get vertexArrayObject;
	external set vertexArrayObject( bool value );
	
	/// Gets the webgl extension for anisotropic filtering (null if not supported)
	external dynamic /* unresolved: EXT_texture_filter_anisotropic */ get textureAnisotropicFilterExtension;
	external set textureAnisotropicFilterExtension( dynamic /* unresolved: EXT_texture_filter_anisotropic */ value );
	
	/// Gets the maximum level of anisotropy supported
	external num get maxAnisotropy;
	external set maxAnisotropy( num value );
	
	/// Defines if instancing is supported
	external bool get instancedArrays;
	external set instancedArrays( bool value );
	
	/// Defines if 32 bits indices are supported
	external bool get uintIndices;
	external set uintIndices( bool value );
	
	/// Defines if high precision shaders are supported
	external bool get highPrecisionShaderSupported;
	external set highPrecisionShaderSupported( bool value );
	
	/// Defines if depth reading in the fragment shader is supported
	external bool get fragmentDepthSupported;
	external set fragmentDepthSupported( bool value );
	
	/// Defines if float texture linear filtering is supported
	external bool get textureFloatLinearFiltering;
	external set textureFloatLinearFiltering( bool value );
	
	/// Defines if rendering to float textures is supported
	external bool get textureFloatRender;
	external set textureFloatRender( bool value );
	
	/// Defines if half float textures are supported
	external bool get textureHalfFloat;
	external set textureHalfFloat( bool value );
	
	/// Defines if half float texture linear filtering is supported
	external bool get textureHalfFloatLinearFiltering;
	external set textureHalfFloatLinearFiltering( bool value );
	
	/// Defines if rendering to half float textures is supported
	external bool get textureHalfFloatRender;
	external set textureHalfFloatRender( bool value );
	
	/// Defines if textureLOD shader command is supported
	external bool get textureLOD;
	external set textureLOD( bool value );
	
	/// Defines if draw buffers extension is supported
	external bool get drawBuffersExtension;
	external set drawBuffersExtension( bool value );
	
	/// Defines if depth textures are supported
	external bool get depthTextureExtension;
	external set depthTextureExtension( bool value );
	
	/// Defines if float color buffer are supported
	external bool get colorBufferFloat;
	external set colorBufferFloat( bool value );
	
	/// Gets disjoint timer query extension (null if not supported)
	external EXT_disjoint_timer_query get timerQuery;
	external set timerQuery( EXT_disjoint_timer_query value );
	
	/// Defines if timestamp can be used with timer query
	external bool get canUseTimestampForTimerQuery;
	external set canUseTimestampForTimerQuery( bool value );
	
	/// Defines if multiview is supported (https://www.khronos.org/registry/webgl/extensions/WEBGL_multiview/)
	external dynamic get multiview;
	external set multiview( dynamic value );
	
	/// Defines if oculus multiview is supported (https://developer.oculus.com/documentation/oculus-browser/latest/concepts/browser-multiview/)
	external dynamic get oculusMultiview;
	external set oculusMultiview( dynamic value );
	
	/// Function used to let the system compiles shaders in background
	external EngineCapabilitiesParallelShaderCompile get parallelShaderCompile;
	external set parallelShaderCompile( EngineCapabilitiesParallelShaderCompile value );
	
	/// Max number of texture samples for MSAA
	external num get maxMSAASamples;
	external set maxMSAASamples( num value );
	
	/// Defines if the blend min max extension is supported
	external bool get blendMinMax;
	external set blendMinMax( bool value );
}

/// @hidden
/// 
@JS()
class DepthCullingState {
	
	/// Initializes the state.
	external factory DepthCullingState();
	
	external bool get isDirty;
	
	external num get zOffset;
	
	external set zOffset(num value);
	
	external num? get cullFace;
	
	external set cullFace(num? value);
	
	external bool? get cull;
	
	external set cull(bool? value);
	
	external num? get depthFunc;
	
	external set depthFunc(num? value);
	
	external bool get depthMask;
	
	external set depthMask(bool value);
	
	external bool get depthTest;
	
	external set depthTest(bool value);
	
	external num? get frontFace;
	
	external set frontFace(num? value);
	
	external void reset();
	
	external void apply(WebGL.RenderingContext gl);
}

/// @hidden
/// 
@JS()
class StencilState {
	
	external factory StencilState();
	
	/// Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn
	external static num get ALWAYS;
	
	/// Passed to stencilOperation to specify that stencil value must be kept
	external static num get KEEP;
	
	/// Passed to stencilOperation to specify that stencil value must be replaced
	external static num get REPLACE;
	
	external bool get isDirty;
	
	external num get stencilFunc;
	
	external set stencilFunc(num value);
	
	external num get stencilFuncRef;
	
	external set stencilFuncRef(num value);
	
	external num get stencilFuncMask;
	
	external set stencilFuncMask(num value);
	
	external num get stencilOpStencilFail;
	
	external set stencilOpStencilFail(num value);
	
	external num get stencilOpDepthFail;
	
	external set stencilOpDepthFail(num value);
	
	external num get stencilOpStencilDepthPass;
	
	external set stencilOpStencilDepthPass(num value);
	
	external num get stencilMask;
	
	external set stencilMask(num value);
	
	external bool get stencilTest;
	
	external set stencilTest(bool value);
	
	external void reset();
	
	external void apply(WebGL.RenderingContext gl);
}

/// @hidden
/// 
@JS()
class AlphaState {
	
	/// Initializes the state.
	external factory AlphaState();
	
	external bool get isDirty;
	
	external bool get alphaBlend;
	
	external set alphaBlend(bool value);
	
	external void setAlphaBlendConstants(num r, num g, num b, num a);
	
	external void setAlphaBlendFunctionParameters(num value0, num value1, num value2, num value3);
	
	external void setAlphaEquationParameters(num rgb, num alpha);
	
	external void reset();
	
	external void apply(WebGL.RenderingContext gl);
}

/// @hidden
@JS()
class WebGLShaderProcessor implements IShaderProcessor {
	external factory WebGLShaderProcessor();
	
	@override
	external String Function(String code, List<String> defines, bool isFragment, ThinEngine engine) get postProcessor;
	@override
	external set postProcessor(String Function(String code, List<String> defines, bool isFragment, ThinEngine engine) value);
	
	external String Function(String attribute) get attributeProcessor;
	external set attributeProcessor(String Function(String attribute) value);
	
	external String Function(String varying, bool isFragment) get varyingProcessor;
	external set varyingProcessor(String Function(String varying, bool isFragment) value);
	
	external String Function(String uniform, bool isFragment) get uniformProcessor;
	external set uniformProcessor(String Function(String uniform, bool isFragment) value);
	
	external String Function(String uniformBuffer, bool isFragment) get uniformBufferProcessor;
	external set uniformBufferProcessor(String Function(String uniformBuffer, bool isFragment) value);
	
	external String Function(String closingBracketLine, bool isFragment) get endOfUniformBufferProcessor;
	external set endOfUniformBufferProcessor(String Function(String closingBracketLine, bool isFragment) value);
	
	external String Function(String line, bool isFragment) get lineProcessor;
	external set lineProcessor(String Function(String line, bool isFragment) value);
	
	external String Function(String code, List<String> defines, bool isFragment) get preProcessor;
	external set preProcessor(String Function(String code, List<String> defines, bool isFragment) value);
}

/// @hidden
@JS()
class WebGL2ShaderProcessor implements IShaderProcessor {
	external factory WebGL2ShaderProcessor();
	
	@override
	external String Function(String attribute) get attributeProcessor;
	@override
	external set attributeProcessor(String Function(String attribute) value);
	
	@override
	external String Function(String varying, bool isFragment) get varyingProcessor;
	@override
	external set varyingProcessor(String Function(String varying, bool isFragment) value);
	
	@override
	external String Function(String code, List<String> defines, bool isFragment, ThinEngine engine) get postProcessor;
	@override
	external set postProcessor(String Function(String code, List<String> defines, bool isFragment, ThinEngine engine) value);
	
	external String Function(String uniform, bool isFragment) get uniformProcessor;
	external set uniformProcessor(String Function(String uniform, bool isFragment) value);
	
	external String Function(String uniformBuffer, bool isFragment) get uniformBufferProcessor;
	external set uniformBufferProcessor(String Function(String uniformBuffer, bool isFragment) value);
	
	external String Function(String closingBracketLine, bool isFragment) get endOfUniformBufferProcessor;
	external set endOfUniformBufferProcessor(String Function(String closingBracketLine, bool isFragment) value);
	
	external String Function(String line, bool isFragment) get lineProcessor;
	external set lineProcessor(String Function(String line, bool isFragment) value);
	
	external String Function(String code, List<String> defines, bool isFragment) get preProcessor;
	external set preProcessor(String Function(String code, List<String> defines, bool isFragment) value);
}

/// Interface for attribute information associated with buffer instanciation
@JS()
@anonymous
class InstancingAttributeInfo {
	
	external factory InstancingAttributeInfo({String attributeName, num index, num attributeSize, num offset, num divisor, num attributeType, bool normalized});
	
	/// Name of the GLSL attribute
	/// if attribute index is not specified, this is used to retrieve the index from the effect
	external String get attributeName;
	external set attributeName( String value );
	
	/// Index/offset of the attribute in the vertex shader
	/// if not specified, this will be computes from the name.
	external num get index;
	external set index( num value );
	
	/// size of the attribute, 1, 2, 3 or 4
	external num get attributeSize;
	external set attributeSize( num value );
	
	/// Offset of the data in the Vertex Buffer acting as the instancing buffer
	external num get offset;
	external set offset( num value );
	
	/// Modifies the rate at which generic vertex attributes advance when rendering multiple instances
	/// default to 1
	external num get divisor;
	external set divisor( num value );
	
	/// type of the attribute, gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.
	/// default is FLOAT
	external num get attributeType;
	external set attributeType( num value );
	
	/// normalization of fixed-point data. behavior unclear, use FALSE, default is FALSE
	external bool get normalized;
	external set normalized( bool value );
}

/// Settings for finer control over video usage
@JS()
@anonymous
class VideoTextureSettings {
	
	external factory VideoTextureSettings({bool autoPlay, bool muted, bool loop, bool autoUpdateTexture, String poster});
	
	/// Applies `autoplay` to video, if specified
	external bool get autoPlay;
	external set autoPlay( bool value );
	
	/// Applies `muted` to video, if specified
	external bool get muted;
	external set muted( bool value );
	
	/// Applies `loop` to video, if specified
	external bool get loop;
	external set loop( bool value );
	
	/// Automatically updates internal texture from video at every frame in the render loop
	external bool get autoUpdateTexture;
	external set autoUpdateTexture( bool value );
	
	/// Image src displayed during the video loading or until the user interacts with the video.
	external String get poster;
	external set poster( String value );
}

/// If you want to display a video in your scene, this is the special texture for that.
/// This special texture works similar to other textures, with the exception of a few parameters.
/// @see https://doc.babylonjs.com/how_to/video_texture
@JS()
class VideoTexture extends Texture {
	
	/// Creates a video texture.
	/// If you want to display a video in your scene, this is the special texture for that.
	/// This special texture works similar to other textures, with the exception of a few parameters.
	/// @see https://doc.babylonjs.com/how_to/video_texture
	/// @param name optional name, will detect from video source, if not defined
	/// @param src can be used to provide an url, array of urls or an already setup HTML video element.
	/// @param scene is obviously the current scene.
	/// @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).
	/// @param invertY is false by default but can be used to invert video on Y axis
	/// @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default
	/// @param settings allows finer control over video usage
	external factory VideoTexture(String? name, dynamic src, Scene? scene, [bool? generateMipMaps, bool? invertY, num? samplingMode, VideoTextureSettings? settings]);
	
	/// Tells whether textures will be updated automatically or user is required to call `updateTexture` manually
	external bool get autoUpdateTexture;
	
	/// The video instance used by the texture internally
	external HTML.VideoElement get video;
	
	/// Event triggerd when a dom action is required by the user to play the video.
	/// This happens due to recent changes in browser policies preventing video to auto start.
	external Observable<Texture> get onUserActionRequestedObservable;
	
	/// Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
	external void update();
	
	/// Update Texture in `manual` mode. Does not do anything if not visible or paused.
	/// @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.
	external void updateTexture(bool isVisible);
	
	/// Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.
	/// @param url New url.
	@override
	external void updateURL(String url, [dynamic? buffer, void Function()? onLoad]);
	
	/// Clones the texture.
	/// @returns the cloned texture
	@override
	external VideoTexture? clone();
	
	/// Dispose the texture and release its associated resources.
	@override
	external void dispose();
	
	/// Creates a video texture straight from a stream.
	/// @param scene Define the scene the texture should be created in
	/// @param stream Define the stream the texture should be created from
	/// @returns The created video texture as a promise
	external static Promise<VideoTexture> CreateFromStreamAsync(Scene scene, HTML.MediaStream stream);
	
	/// Creates a video texture straight from your WebCam video feed.
	/// @param scene Define the scene the texture should be created in
	/// @param constraints Define the constraints to use to create the web cam feed from WebRTC
	/// @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC
	/// @returns The created video texture as a promise
	external static Promise<VideoTexture> CreateFromWebCamAsync(Scene scene, dynamic constraints, [dynamic? audioConstaints]);
	
	/// Creates a video texture straight from your WebCam video feed.
	/// @param scene Define the scene the texture should be created in
	/// @param onReady Define a callback to triggered once the texture will be ready
	/// @param constraints Define the constraints to use to create the web cam feed from WebRTC
	/// @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC
	external static void CreateFromWebCam(Scene scene, void Function(VideoTexture videoTexture) onReady, dynamic constraints, [dynamic? audioConstaints]);
}

/// Defines the interface used by objects working like Scene
/// @hidden
@JS()
abstract class ISceneLike {
	
	external IOfflineProvider get offlineProvider;
	external set offlineProvider(IOfflineProvider value);
}

/// Information about the current host
@JS()
@anonymous
class HostInformation {
	
	external factory HostInformation({bool isMobile});
	
	/// Defines if the current host is a mobile
	external bool get isMobile;
	external set isMobile( bool value );
}

/// Interface defining initialization parameters for Engine class
@JS()
@anonymous
class EngineOptions {
	
	external factory EngineOptions({num limitDeviceRatio, bool autoEnableWebVR, bool disableWebGL2Support, bool audioEngine, bool deterministicLockstep, num lockstepMaxSteps, num timeStep, bool doNotHandleContextLost, bool doNotHandleTouchAction, bool useHighPrecisionFloats, bool xrCompatible, bool useHighPrecisionMatrix, bool failIfMajorPerformanceCaveat});
	
	/// Defines if the engine should no exceed a specified device ratio
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
	external num get limitDeviceRatio;
	external set limitDeviceRatio( num value );
	
	/// Defines if webvr should be enabled automatically
	/// @see https://doc.babylonjs.com/how_to/webvr_camera
	external bool get autoEnableWebVR;
	external set autoEnableWebVR( bool value );
	
	/// Defines if webgl2 should be turned off even if supported
	/// @see https://doc.babylonjs.com/features/webgl2
	external bool get disableWebGL2Support;
	external set disableWebGL2Support( bool value );
	
	/// Defines if webaudio should be initialized as well
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
	external bool get audioEngine;
	external set audioEngine( bool value );
	
	/// Defines if animations should run using a deterministic lock step
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	external bool get deterministicLockstep;
	external set deterministicLockstep( bool value );
	
	/// Defines the maximum steps to use with deterministic lock step mode
	external num get lockstepMaxSteps;
	external set lockstepMaxSteps( num value );
	
	/// Defines the seconds between each deterministic lock step
	external num get timeStep;
	external set timeStep( num value );
	
	/// Defines that engine should ignore context lost events
	/// If this event happens when this parameter is true, you will have to reload the page to restore rendering
	external bool get doNotHandleContextLost;
	external set doNotHandleContextLost( bool value );
	
	/// Defines that engine should ignore modifying touch action attribute and style
	/// If not handle, you might need to set it up on your side for expected touch devices behavior.
	external bool get doNotHandleTouchAction;
	external set doNotHandleTouchAction( bool value );
	
	/// Defines that engine should compile shaders with high precision floats (if supported). True by default
	external bool get useHighPrecisionFloats;
	external set useHighPrecisionFloats( bool value );
	
	/// Make the canvas XR Compatible for XR sessions
	external bool get xrCompatible;
	external set xrCompatible( bool value );
	
	/// Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default
	external bool get useHighPrecisionMatrix;
	external set useHighPrecisionMatrix( bool value );
	
	/// Will prevent the system from falling back to software implementation if a hardware device cannot be created
	external bool get failIfMajorPerformanceCaveat;
	external set failIfMajorPerformanceCaveat( bool value );
}

/* enum */
abstract class InternalTextureSource {
	
	/// The source of the texture data is unknown
	static const int Unknown = 1;
	
	/// Texture data comes from an URL
	static const int Url = 2;
	
	/// Texture data is only used for temporary storage
	static const int Temp = 3;
	
	/// Texture data comes from raw data (ArrayBuffer)
	static const int Raw = 4;
	
	/// Texture content is dynamic (video or dynamic texture)
	static const int Dynamic = 5;
	
	/// Texture content is generated by rendering to it
	static const int RenderTarget = 6;
	
	/// Texture content is part of a multi render target process
	static const int MultiRenderTarget = 7;
	
	/// Texture data comes from a cube data file
	static const int Cube = 8;
	
	/// Texture data comes from a raw cube data
	static const int CubeRaw = 9;
	
	/// Texture data come from a prefiltered cube data file
	static const int CubePrefiltered = 10;
	
	/// Texture content is raw 3D data
	static const int Raw3D = 11;
	
	/// Texture content is raw 2D array data
	static const int Raw2DArray = 12;
	
	/// Texture content is a depth texture
	static const int Depth = 13;
	
	/// Texture data comes from a raw cube data encoded with RGBD
	static const int CubeRawRGBD = 14;
}

/// Class used to store data associated with WebGL texture data for the engine
/// This class should not be used directly
@JS()
class InternalTexture {
	
	/// Creates a new InternalTexture
	/// @param engine defines the engine to use
	/// @param source defines the type of data that will be used
	/// @param delayAllocation if the texture allocation should be delayed (default: false)
	external factory InternalTexture(ThinEngine engine, int source, [bool? delayAllocation]);
	
	/// Defines if the texture is ready
	external bool get isReady;
	external set isReady(bool value);
	
	/// Defines if the texture is a cube texture
	external bool get isCube;
	external set isCube(bool value);
	
	/// Defines if the texture contains 3D data
	external bool get is3D;
	external set is3D(bool value);
	
	/// Defines if the texture contains 2D array data
	external bool get is2DArray;
	external set is2DArray(bool value);
	
	/// Defines if the texture contains multiview data
	external bool get isMultiview;
	external set isMultiview(bool value);
	
	/// Gets the URL used to load this texture
	external String get url;
	external set url(String value);
	
	/// Gets the sampling mode of the texture
	external num get samplingMode;
	external set samplingMode(num value);
	
	/// Gets a boolean indicating if the texture needs mipmaps generation
	external bool get generateMipMaps;
	external set generateMipMaps(bool value);
	
	/// Gets the number of samples used by the texture (WebGL2+ only)
	external num get samples;
	external set samples(num value);
	
	/// Gets the type of the texture (int, float...)
	external num get type;
	external set type(num value);
	
	/// Gets the format of the texture (RGB, RGBA...)
	external num get format;
	external set format(num value);
	
	/// Observable called when the texture is loaded
	external Observable<InternalTexture> get onLoadedObservable;
	external set onLoadedObservable(Observable<InternalTexture> value);
	
	/// Gets the width of the texture
	external num get width;
	external set width(num value);
	
	/// Gets the height of the texture
	external num get height;
	external set height(num value);
	
	/// Gets the depth of the texture
	external num get depth;
	external set depth(num value);
	
	/// Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
	external num get baseWidth;
	external set baseWidth(num value);
	
	/// Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
	external num get baseHeight;
	external set baseHeight(num value);
	
	/// Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
	external num get baseDepth;
	external set baseDepth(num value);
	
	/// Gets a boolean indicating if the texture is inverted on Y axis
	external bool get invertY;
	external set invertY(bool value);
	
	/// Gets the Engine the texture belongs to.
	/// @returns The babylon engine
	external ThinEngine getEngine();
	
	/// Gets the data source type of the texture
	external int get source;
	
	/// Increments the number of references (ie. the number of Texture that point to it)
	external void incrementReferences();
	
	/// Change the size of the texture (not the size of the content)
	/// @param width defines the new width
	/// @param height defines the new height
	/// @param depth defines the new depth (1 by default)
	external void updateSize(dynamic width, dynamic height, [dynamic? depth]);
	
	/// Dispose the current allocated resources
	external void dispose();
}

/// Interface used to present a loading screen while loading a scene
/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
@JS()
abstract class ILoadingScreen {
	
	/// Function called to display the loading screen
	external void Function() get displayLoadingUI;
	external set displayLoadingUI(void Function() value);
	
	/// Function called to hide the loading screen
	external void Function() get hideLoadingUI;
	external set hideLoadingUI(void Function() value);
	
	/// Gets or sets the color to use for the background
	external String get loadingUIBackgroundColor;
	external set loadingUIBackgroundColor(String value);
	
	/// Gets or sets the text to display while loading
	external String get loadingUIText;
	external set loadingUIText(String value);
}

/// Class used for the default loading screen
/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
@JS()
class DefaultLoadingScreen implements ILoadingScreen {
	
	/// Creates a new default loading screen
	/// @param _renderingCanvas defines the canvas used to render the scene
	/// @param _loadingText defines the default text to display
	/// @param _loadingDivBackgroundColor defines the default background color
	external factory DefaultLoadingScreen(HTML.CanvasElement _renderingCanvas, [String? _loadingText, String? _loadingDivBackgroundColor]);
	
	/// Gets or sets the logo url to use for the default loading screen
	external static String get DefaultLogoUrl;
	external static set DefaultLogoUrl(String value);
	
	/// Gets or sets the spinner url to use for the default loading screen
	external static String get DefaultSpinnerUrl;
	external static set DefaultSpinnerUrl(String value);
	
	@override
	external void Function() get displayLoadingUI;
	@override
	external set displayLoadingUI(void Function() value);
	
	@override
	external void Function() get hideLoadingUI;
	@override
	external set hideLoadingUI(void Function() value);
	
	/// Gets or sets the color to use for the background
	external String get loadingUIBackgroundColor;
	external set loadingUIBackgroundColor(String value);
	
	/// Gets or sets the text to display while loading
	external String get loadingUIText;
	external set loadingUIText(String value);
}

/// Interface for any object that can request an animation frame
@JS()
@anonymous
class ICustomAnimationFrameRequester {
	
	external factory ICustomAnimationFrameRequester({Function renderFunction, Function requestAnimationFrame, num requestID});
	
	/// This function will be called when the render loop is ready. If this is not populated, the engine's renderloop function will be called
	external Function get renderFunction;
	external set renderFunction( Function value );
	
	/// Called to request the next frame to render to
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
	external Function get requestAnimationFrame;
	external set requestAnimationFrame( Function value );
	
	/// You can pass this value to cancelAnimationFrame() to cancel the refresh callback request
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame#Return_value
	external num get requestID;
	external set requestID( num value );
}

/// Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
@JS()
class PerformanceMonitor {
	
	/// constructor
	/// @param frameSampleSize The number of samples required to saturate the sliding window
	external factory PerformanceMonitor([num? frameSampleSize]);
	
	/// Samples current frame
	/// @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
	external void sampleFrame([num? timeMs]);
	
	/// Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
	external num get averageFrameTime;
	
	/// Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
	external num get averageFrameTimeVariance;
	
	/// Returns the frame time of the most recent frame
	external num get instantaneousFrameTime;
	
	/// Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
	external num get averageFPS;
	
	/// Returns the average framerate in frames per second using the most recent frame time
	external num get instantaneousFPS;
	
	/// Returns true if enough samples have been taken to completely fill the sliding window
	external bool get isSaturated;
	
	/// Enables contributions to the sliding window sample set
	external void enable();
	
	/// Disables contributions to the sliding window sample set
	/// Samples will not be interpolated over the disabled period
	external void disable();
	
	/// Returns true if sampling is enabled
	external bool get isEnabled;
	
	/// Resets performance monitor
	external void reset();
}

/// RollingAverage
/// 
/// Utility to efficiently compute the rolling average and variance over a sliding window of samples
@JS()
class RollingAverage {
	
	/// constructor
	/// @param length The number of samples required to saturate the sliding window
	external factory RollingAverage(num length);
	
	/// Current average
	external num get average;
	external set average(num value);
	
	/// Current variance
	external num get variance;
	external set variance(num value);
	
	/// Adds a sample to the sample set
	/// @param v The sample value
	external void add(num v);
	
	/// Returns previously added values or null if outside of history or outside the sliding window domain
	/// @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
	/// @return Value previously recorded with add() or null if outside of range
	external num history(num i);
	
	/// Returns true if enough samples have been taken to completely fill the sliding window
	/// @return true if sample-set saturated
	external bool isSaturated();
	
	/// Resets the rolling average (equivalent to 0 samples taken so far)
	external void reset();
}

/// This class is used to track a performance counter which is number based.
/// The user has access to many properties which give statistics of different nature.
/// 
/// The implementer can track two kinds of Performance Counter: time and count.
/// For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
/// For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
@JS()
class PerfCounter {
	
	/// Creates a new counter
	external factory PerfCounter();
	
	/// Gets or sets a global boolean to turn on and off all the counters
	external static bool get Enabled;
	external static set Enabled(bool value);
	
	/// Returns the smallest value ever
	external num get min;
	
	/// Returns the biggest value ever
	external num get max;
	
	/// Returns the average value since the performance counter is running
	external num get average;
	
	/// Returns the average value of the last second the counter was monitored
	external num get lastSecAverage;
	
	/// Returns the current value
	external num get current;
	
	/// Gets the accumulated total
	external num get total;
	
	/// Gets the total value count
	external num get count;
	
	/// Call this method to start monitoring a new frame.
	/// This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
	external void fetchNewFrame();
	
	/// Call this method to monitor a count of something (e.g. mesh drawn in viewport count)
	/// @param newCount the count value to add to the monitored count
	/// @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.
	external void addCount(num newCount, bool fetchResult);
	
	/// Start monitoring this performance counter
	external void beginMonitoring();
	
	/// Compute the time lapsed since the previous beginMonitoring() call.
	/// @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter
	external void endMonitoring([bool? newFrame]);
}

/// Class used to work with sound analyzer using fast fourier transform (FFT)
/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
@JS()
class Analyser {
	
	/// Creates a new analyser
	/// @param scene defines hosting scene
	external factory Analyser(Scene scene);
	
	/// Gets or sets the smoothing
	/// @ignorenaming
	external num get SMOOTHING;
	external set SMOOTHING(num value);
	
	/// Gets or sets the FFT table size
	/// @ignorenaming
	external num get FFT_SIZE;
	external set FFT_SIZE(num value);
	
	/// Gets or sets the bar graph amplitude
	/// @ignorenaming
	external num get BARGRAPHAMPLITUDE;
	external set BARGRAPHAMPLITUDE(num value);
	
	/// Gets or sets the position of the debug canvas
	/// @ignorenaming
	external AnalyserDEBUGCANVASPOS get DEBUGCANVASPOS;
	external set DEBUGCANVASPOS(AnalyserDEBUGCANVASPOS value);
	
	/// Gets or sets the debug canvas size
	/// @ignorenaming
	external AnalyserDEBUGCANVASSIZE get DEBUGCANVASSIZE;
	external set DEBUGCANVASSIZE(AnalyserDEBUGCANVASSIZE value);
	
	/// Get the number of data values you will have to play with for the visualization
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount
	/// @returns a number
	external num getFrequencyBinCount();
	
	/// Gets the current frequency data as a byte array
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
	/// @returns a Uint8Array
	external Uint8List getByteFrequencyData();
	
	/// Gets the current waveform as a byte array
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteTimeDomainData
	/// @returns a Uint8Array
	external Uint8List getByteTimeDomainData();
	
	/// Gets the current frequency data as a float array
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
	/// @returns a Float32Array
	external Float32List getFloatFrequencyData();
	
	/// Renders the debug canvas
	external void drawDebugCanvas();
	
	/// Stops rendering the debug canvas and removes it
	external void stopDebugCanvas();
	
	/// Connects two audio nodes
	/// @param inputAudioNode defines first node to connect
	/// @param outputAudioNode defines second node to connect
	external void connectAudioNodes(Audio.AudioNode inputAudioNode, Audio.AudioNode outputAudioNode);
	
	/// Releases all associated resources
	external void dispose();
}

/// This represents an audio engine and it is responsible
/// to play, synchronize and analyse sounds throughout the application.
/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
@JS()
abstract class IAudioEngine implements IDisposable {
	
	/// Gets whether the current host supports Web Audio and thus could create AudioContexts.
	external bool get canUseWebAudio;
	
	/// Gets the current AudioContext if available.
	external Audio.AudioContext? get audioContext;
	
	/// The master gain node defines the global audio volume of your audio engine.
	external Audio.GainNode get masterGain;
	
	/// Gets whether or not mp3 are supported by your browser.
	external bool get isMP3supported;
	
	/// Gets whether or not ogg are supported by your browser.
	external bool get isOGGsupported;
	
	/// Defines if Babylon should emit a warning if WebAudio is not supported.
	/// @ignoreNaming
	external bool get WarnedWebAudioUnsupported;
	external set WarnedWebAudioUnsupported(bool value);
	
	/// Defines if the audio engine relies on a custom unlocked button.
	/// In this case, the embedded button will not be displayed.
	external bool get useCustomUnlockedButton;
	external set useCustomUnlockedButton(bool value);
	
	/// Gets whether or not the audio engine is unlocked (require first a user gesture on some browser).
	external bool get unlocked;
	
	/// Event raised when audio has been unlocked on the browser.
	external Observable<IAudioEngine> get onAudioUnlockedObservable;
	external set onAudioUnlockedObservable(Observable<IAudioEngine> value);
	
	/// Event raised when audio has been locked on the browser.
	external Observable<IAudioEngine> get onAudioLockedObservable;
	external set onAudioLockedObservable(Observable<IAudioEngine> value);
	
	/// Flags the audio engine in Locked state.
	/// This happens due to new browser policies preventing audio to autoplay.
	external void lock();
	
	/// Unlocks the audio engine once a user action has been done on the dom.
	/// This is helpful to resume play once browser policies have been satisfied.
	external void unlock();
	
	/// Gets the global volume sets on the master gain.
	/// @returns the global volume if set or -1 otherwise
	external num getGlobalVolume();
	
	/// Sets the global volume of your experience (sets on the master gain).
	/// @param newVolume Defines the new global volume of the application
	external void setGlobalVolume(num newVolume);
	
	/// Connect the audio engine to an audio analyser allowing some amazing
	/// synchornization between the sounds/music and your visualization (VuMeter for instance).
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
	/// @param analyser The analyser to connect to the engine
	external void connectToAnalyser(Analyser analyser);
}

/// Defines the interface used by display changed events
@JS()
@anonymous
class IDisplayChangedEventArgs {
	
	external factory IDisplayChangedEventArgs({dynamic? vrDisplay, bool vrSupported});
	
	/// Gets the vrDisplay object (if any)
	external dynamic? get vrDisplay;
	external set vrDisplay( dynamic? value );
	
	/// Gets a boolean indicating if webVR is supported
	external bool get vrSupported;
	external set vrSupported( bool value );
}

/// Defines the interface used by objects containing a viewport (like a camera)
@JS()
@anonymous
class IViewportOwnerLike {
	
	external factory IViewportOwnerLike({Viewport viewport});
	
	/// Gets or sets the viewport
	external Viewport get viewport;
	external set viewport( Viewport value );
}

/// The engine store class is responsible to hold all the instances of Engine and Scene created
/// during the life time of the application.
@JS()
class EngineStore {
	external factory EngineStore();
	
	/// Gets the list of created engines
	external static List<Engine> get Instances;
	external static set Instances(List<Engine> value);
	
	/// Gets the latest created engine
	external static Engine? get LastCreatedEngine;
	
	/// Gets the latest created scene
	external static Scene? get LastCreatedScene;
	
	/// Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
	/// @ignorenaming
	external static bool get UseFallbackTexture;
	external static set UseFallbackTexture(bool value);
	
	/// Texture content used if a texture cannot loaded
	/// @ignorenaming
	external static String get FallbackTexture;
	external static set FallbackTexture(String value);
}

/// Helper class that provides a small promise polyfill
@JS()
class PromisePolyfill {
	external factory PromisePolyfill();
	
	/// Static function used to check if the polyfill is required
	/// If this is the case then the function will inject the polyfill to window.Promise
	/// @param force defines a boolean used to force the injection (mostly for testing purposes)
	external static void Apply([bool? force]);
}

/// Interface for screenshot methods with describe argument called `size` as object with options
/// @link https://doc.babylonjs.com/api/classes/babylon.screenshottools
@JS()
@anonymous
class IScreenshotSize {
	
	external factory IScreenshotSize({num height, num precision, num width});
	
	/// number in pixels for canvas height
	external num get height;
	external set height( num value );
	
	/// multiplier allowing render at a higher or lower resolution
	/// If value is defined then height and width will be ignored and taken from camera
	external num get precision;
	external set precision( num value );
	
	/// number in pixels for canvas width
	external num get width;
	external set width( num value );
}

/// Class containing a set of static utilities functions
@JS()
class Tools {
	external factory Tools();
	
	/// Gets or sets the base URL to use to load assets
	external static String get BaseUrl;
	
	external static set BaseUrl(String value);
	
	/// Enable/Disable Custom HTTP Request Headers globally.
	/// default = false
	/// @see CustomRequestHeaders
	external static bool get UseCustomRequestHeaders;
	external static set UseCustomRequestHeaders(bool value);
	
	/// Custom HTTP Request Headers to be sent with XMLHttpRequests
	/// i.e. when loading files, where the server/service expects an Authorization header
	external static dynamic /* object */ get CustomRequestHeaders;
	external static set CustomRequestHeaders(dynamic /* object */ value);
	
	/// Gets or sets the retry strategy to apply when an error happens while loading an asset
	external static num Function(String url, WebRequest request, num retryIndex) get DefaultRetryStrategy;
	
	external static set DefaultRetryStrategy(num Function(String url, WebRequest request, num retryIndex) value);
	
	/// Default behaviour for cors in the application.
	/// It can be a string if the expected behavior is identical in the entire app.
	/// Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
	external static dynamic get CorsBehavior;
	
	external static set CorsBehavior(dynamic value);
	
	/// Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
	/// @ignorenaming
	external static bool get UseFallbackTexture;
	
	external static set UseFallbackTexture(bool value);
	
	/// Use this object to register external classes like custom textures or material
	/// to allow the laoders to instantiate them
	external static dynamic /* object */ get RegisteredExternalClasses;
	
	external static set RegisteredExternalClasses(dynamic /* object */ value);
	
	/// Texture content used if a texture cannot loaded
	/// @ignorenaming
	external static String get fallbackTexture;
	
	external static set fallbackTexture(String value);
	
	/// Read the content of a byte array at a specified coordinates (taking in account wrapping)
	/// @param u defines the coordinate on X axis
	/// @param v defines the coordinate on Y axis
	/// @param width defines the width of the source data
	/// @param height defines the height of the source data
	/// @param pixels defines the source byte array
	/// @param color defines the output color
	external static void FetchToRef(num u, num v, num width, num height, Uint8List pixels, Color4 color);
	
	/// Interpolates between a and b via alpha
	/// @param a The lower value (returned when alpha = 0)
	/// @param b The upper value (returned when alpha = 1)
	/// @param alpha The interpolation-factor
	/// @return The mixed value
	external static num Mix(num a, num b, num alpha);
	
	/// Tries to instantiate a new object from a given class name
	/// @param className defines the class name to instantiate
	/// @returns the new object or null if the system was not able to do the instantiation
	external static dynamic Instantiate(String className);
	
	/// Provides a slice function that will work even on IE
	/// @param data defines the array to slice
	/// @param start defines the start of the data (optional)
	/// @param end defines the end of the data (optional)
	/// @returns the new sliced array
	external static T Slice<T>(T data, [num? start, num? end]);
	
	/// Provides a slice function that will work even on IE
	/// The difference between this and Slice is that this will force-convert to array
	/// @param data defines the array to slice
	/// @param start defines the start of the data (optional)
	/// @param end defines the end of the data (optional)
	/// @returns the new sliced array
	external static List<P> SliceToArray<T, P>(T data, [num? start, num? end]);
	
	/// Polyfill for setImmediate
	/// @param action defines the action to execute after the current execution block
	external static void SetImmediate(void Function() action);
	
	/// Function indicating if a number is an exponent of 2
	/// @param value defines the value to test
	/// @returns true if the value is an exponent of 2
	external static bool IsExponentOfTwo(num value);
	
	/// Returns the nearest 32-bit single precision float representation of a Number
	/// @param value A Number.  If the parameter is of a different type, it will get converted
	/// to a number or to NaN if it cannot be converted
	/// @returns number
	external static num FloatRound(num value);
	
	/// Extracts the filename from a path
	/// @param path defines the path to use
	/// @returns the filename
	external static String GetFilename(String path);
	
	/// Extracts the "folder" part of a path (everything before the filename).
	/// @param uri The URI to extract the info from
	/// @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present
	/// @returns The "folder" part of the path
	external static String GetFolderPath(String uri, [bool? returnUnchangedIfNoSlash]);
	
	/// Extracts text content from a DOM element hierarchy
	/// Back Compat only, please use DomManagement.GetDOMTextContent instead.
	external static dynamic /* typeof [DomManagement, GetDOMTextContent] */ get GetDOMTextContent;
	external static set GetDOMTextContent(dynamic /* typeof [DomManagement, GetDOMTextContent] */ value);
	
	/// Convert an angle in radians to degrees
	/// @param angle defines the angle to convert
	/// @returns the angle in degrees
	external static num ToDegrees(num angle);
	
	/// Convert an angle in degrees to radians
	/// @param angle defines the angle to convert
	/// @returns the angle in radians
	external static num ToRadians(num angle);
	
	/// Returns an array if obj is not an array
	/// @param obj defines the object to evaluate as an array
	/// @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined
	/// @returns either obj directly if obj is an array or a new array containing obj
	external static List<dynamic>? MakeArray(dynamic obj, [bool? allowsNullUndefined]);
	
	/// Gets the pointer prefix to use
	/// @param engine defines the engine we are finding the prefix for
	/// @returns "pointer" if touch is enabled. Else returns "mouse"
	external static String GetPointerPrefix(Engine engine);
	
	/// Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
	/// @param url define the url we are trying
	/// @param element define the dom element where to configure the cors policy
	external static void SetCorsBehavior(dynamic url, ToolsSetCorsBehaviorElement element);
	
	/// Removes unwanted characters from an url
	/// @param url defines the url to clean
	/// @returns the cleaned url
	external static String CleanUrl(String url);
	
	/// Gets or sets a function used to pre-process url before using them to load assets
	external static String Function(String url) get PreprocessUrl;
	
	external static set PreprocessUrl(String Function(String url) value);
	
	/// Loads an image as an HTMLImageElement.
	/// @param input url string, ArrayBuffer, or Blob to load
	/// @param onLoad callback called when the image successfully loads
	/// @param onError callback called when the image fails to load
	/// @param offlineProvider offline provider for caching
	/// @param mimeType optional mime type
	/// @returns the HTMLImageElement of the loaded image
	external static HTML.ImageElement? LoadImage(dynamic input, void Function(dynamic img) onLoad, void Function([String? message, dynamic? exception]) onError, IOfflineProvider? offlineProvider, [String? mimeType]);
	
	/// Loads a file from a url
	/// @param url url string, ArrayBuffer, or Blob to load
	/// @param onSuccess callback called when the file successfully loads
	/// @param onProgress callback called while file is loading (if the server supports this mode)
	/// @param offlineProvider defines the offline provider for caching
	/// @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
	/// @param onError callback called when the file fails to load
	/// @returns a file request object
	external static IFileRequest LoadFile(String url, void Function(dynamic data, [String? responseURL]) onSuccess, [void Function(dynamic data)? onProgress, IOfflineProvider? offlineProvider, bool? useArrayBuffer, void Function([WebRequest? request, dynamic? exception])? onError]);
	
	/// Loads a file from a url
	/// @param url the file url to load
	/// @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
	/// @returns a promise containing an ArrayBuffer corresponding to the loaded file
	external static Promise<dynamic> LoadFileAsync(String url, [bool? useArrayBuffer]);
	
	/// Load a script (identified by an url). When the url returns, the
	/// content of this file is added into a new script element, attached to the DOM (body element)
	/// @param scriptUrl defines the url of the script to laod
	/// @param onSuccess defines the callback called when the script is loaded
	/// @param onError defines the callback to call if an error occurs
	/// @param scriptId defines the id of the script element
	external static void LoadScript(String scriptUrl, void Function() onSuccess, [void Function([String? message, dynamic? exception])? onError, String? scriptId]);
	
	/// Load an asynchronous script (identified by an url). When the url returns, the
	/// content of this file is added into a new script element, attached to the DOM (body element)
	/// @param scriptUrl defines the url of the script to laod
	/// @param scriptId defines the id of the script element
	/// @returns a promise request object
	external static Promise<void> LoadScriptAsync(String scriptUrl, [String? scriptId]);
	
	/// Loads a file from a blob
	/// @param fileToLoad defines the blob to use
	/// @param callback defines the callback to call when data is loaded
	/// @param progressCallback defines the callback to call during loading process
	/// @returns a file request object
	external static IFileRequest ReadFileAsDataURL(HTML.Blob fileToLoad, void Function(dynamic data) callback, dynamic Function(HTML.ProgressEvent ev) progressCallback);
	
	/// Reads a file from a File object
	/// @param file defines the file to load
	/// @param onSuccess defines the callback to call when data is loaded
	/// @param onProgress defines the callback to call during loading process
	/// @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
	/// @param onError defines the callback to call when an error occurs
	/// @returns a file request object
	external static IFileRequest ReadFile(HTML.File file, void Function(dynamic data) onSuccess, [dynamic Function(HTML.ProgressEvent ev)? onProgress, bool? useArrayBuffer, void Function(ReadFileError error)? onError]);
	
	/// Creates a data url from a given string content
	/// @param content defines the content to convert
	/// @returns the new data url link
	external static String FileAsURL(String content);
	
	/// Format the given number to a specific decimal format
	/// @param value defines the number to format
	/// @param decimals defines the number of decimals to use
	/// @returns the formatted string
	external static String Format(num value, [num? decimals]);
	
	/// Tries to copy an object by duplicating every property
	/// @param source defines the source object
	/// @param destination defines the target object
	/// @param doNotCopyList defines a list of properties to avoid
	/// @param mustCopyList defines a list of properties to copy (even if they start with _)
	external static void DeepCopy(dynamic source, dynamic destination, [List<String>? doNotCopyList, List<String>? mustCopyList]);
	
	/// Gets a boolean indicating if the given object has no own property
	/// @param obj defines the object to test
	/// @returns true if object has no own property
	external static bool IsEmpty(dynamic obj);
	
	/// Function used to register events at window level
	/// @param windowElement defines the Window object to use
	/// @param events defines the events to register
	external static void RegisterTopRootEvents(HTML.Window windowElement, List<ToolsRegisterTopRootEventsEvents> events);
	
	/// Function used to unregister events from window level
	/// @param windowElement defines the Window object to use
	/// @param events defines the events to unregister
	external static void UnregisterTopRootEvents(HTML.Window windowElement, List<ToolsUnregisterTopRootEventsEvents> events);
	
	/// Dumps the current bound framebuffer
	/// @param width defines the rendering width
	/// @param height defines the rendering height
	/// @param engine defines the hosting engine
	/// @param successCallback defines the callback triggered once the data are available
	/// @param mimeType defines the mime type of the result
	/// @param fileName defines the filename to download. If present, the result will automatically be downloaded
	external static void DumpFramebuffer(num width, num height, Engine engine, [void Function(String data)? successCallback, String? mimeType, String? fileName]);
	
	/// Converts the canvas data to blob.
	/// This acts as a polyfill for browsers not supporting the to blob function.
	/// @param canvas Defines the canvas to extract the data from
	/// @param successCallback Defines the callback triggered once the data are available
	/// @param mimeType Defines the mime type of the result
	external static void ToBlob(HTML.CanvasElement canvas, void Function(HTML.Blob? blob) successCallback, [String? mimeType]);
	
	/// Encodes the canvas data to base 64 or automatically download the result if filename is defined
	/// @param successCallback defines the callback triggered once the data are available
	/// @param mimeType defines the mime type of the result
	/// @param fileName defines he filename to download. If present, the result will automatically be downloaded
	external static void EncodeScreenshotCanvasData([void Function(String data)? successCallback, String? mimeType, String? fileName]);
	
	/// Downloads a blob in the browser
	/// @param blob defines the blob to download
	/// @param fileName defines the name of the downloaded file
	external static void Download(HTML.Blob blob, String fileName);
	
	/// Will return the right value of the noPreventDefault variable
	/// Needed to keep backwards compatibility to the old API.
	/// 
	/// @param args arguments passed to the attachControl function
	/// @returns the correct value for noPreventDefault
	external static bool BackCompatCameraNoPreventDefault(dynamic /* unresolved: IArguments */ args);
	
	/// Captures a screenshot of the current rendering
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine defines the rendering engine
	/// @param camera defines the source camera
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param successCallback defines the callback receives a single parameter which contains the
	/// screenshot as a string of base64-encoded characters. This string can be assigned to the
	/// src parameter of an <img> to display it
	/// @param mimeType defines the MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	external static void CreateScreenshot(Engine engine, Camera camera, dynamic size, [void Function(String data)? successCallback, String? mimeType]);
	
	/// Captures a screenshot of the current rendering
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine defines the rendering engine
	/// @param camera defines the source camera
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param mimeType defines the MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	/// @returns screenshot as a string of base64-encoded characters. This string can be assigned
	/// to the src parameter of an <img> to display it
	external static Promise<String> CreateScreenshotAsync(Engine engine, Camera camera, dynamic size, [String? mimeType]);
	
	/// Generates an image screenshot from the specified camera.
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine The engine to use for rendering
	/// @param camera The camera to use for rendering
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param successCallback The callback receives a single parameter which contains the
	/// screenshot as a string of base64-encoded characters. This string can be assigned to the
	/// src parameter of an <img> to display it
	/// @param mimeType The MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	/// @param samples Texture samples (default: 1)
	/// @param antialiasing Whether antialiasing should be turned on or not (default: false)
	/// @param fileName A name for for the downloaded file.
	external static void CreateScreenshotUsingRenderTarget(Engine engine, Camera camera, dynamic size, [void Function(String data)? successCallback, String? mimeType, num? samples, bool? antialiasing, String? fileName]);
	
	/// Generates an image screenshot from the specified camera.
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine The engine to use for rendering
	/// @param camera The camera to use for rendering
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param mimeType The MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	/// @param samples Texture samples (default: 1)
	/// @param antialiasing Whether antialiasing should be turned on or not (default: false)
	/// @param fileName A name for for the downloaded file.
	/// @returns screenshot as a string of base64-encoded characters. This string can be assigned
	/// to the src parameter of an <img> to display it
	external static Promise<String> CreateScreenshotUsingRenderTargetAsync(Engine engine, Camera camera, dynamic size, [String? mimeType, num? samples, bool? antialiasing, String? fileName]);
	
	/// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
	/// Be aware Math.random() could cause collisions, but:
	/// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
	/// @returns a pseudo random id
	external static String RandomId();
	
	/// Test if the given uri is a base64 string
	/// @param uri The uri to test
	/// @return True if the uri is a base64 string or false otherwise
	external static bool IsBase64(String uri);
	
	/// Decode the given base64 uri.
	/// @param uri The uri to decode
	/// @return The decoded base64 data.
	external static ByteBuffer DecodeBase64(String uri);
	
	/// Gets the absolute url.
	/// @param url the input url
	/// @return the absolute url
	external static String GetAbsoluteUrl(String url);
	
	/// No log
	external static num get NoneLogLevel;
	
	/// Only message logs
	external static num get MessageLogLevel;
	
	/// Only warning logs
	external static num get WarningLogLevel;
	
	/// Only error logs
	external static num get ErrorLogLevel;
	
	/// All logs
	external static num get AllLogLevel;
	
	/// Gets a value indicating the number of loading errors
	/// @ignorenaming
	external static num get errorsCount;
	
	/// Callback called when a new log is added
	external static void Function(String entry) get OnNewCacheEntry;
	external static set OnNewCacheEntry(void Function(String entry) value);
	
	/// Log a message to the console
	/// @param message defines the message to log
	external static void Log(String message);
	
	/// Write a warning message to the console
	/// @param message defines the message to log
	external static void Warn(String message);
	
	/// Write an error message to the console
	/// @param message defines the message to log
	external static void Error(String message);
	
	/// Gets current log cache (list of logs)
	external static String get LogCache;
	
	/// Clears the log cache
	external static void ClearLogCache();
	
	/// Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
	external static set LogLevels(num value);
	
	/// Checks if the window object exists
	/// Back Compat only, please use DomManagement.IsWindowObjectExist instead.
	external static dynamic /* typeof [DomManagement, IsWindowObjectExist] */ get IsWindowObjectExist;
	external static set IsWindowObjectExist(dynamic /* typeof [DomManagement, IsWindowObjectExist] */ value);
	
	/// No performance log
	external static num get PerformanceNoneLogLevel;
	
	/// Use user marks to log performance
	external static num get PerformanceUserMarkLogLevel;
	
	/// Log performance to the console
	external static num get PerformanceConsoleLogLevel;
	
	/// Sets the current performance log level
	external static set PerformanceLogLevel(num value);
	
	/// Starts a performance counter
	external static void Function(String counterName, [bool? condition]) get StartPerformanceCounter;
	external static set StartPerformanceCounter(void Function(String counterName, [bool? condition]) value);
	
	/// Ends a specific performance coutner
	external static void Function(String counterName, [bool? condition]) get EndPerformanceCounter;
	external static set EndPerformanceCounter(void Function(String counterName, [bool? condition]) value);
	
	/// Gets either window.performance.now() if supported or Date.now() else
	external static num get Now;
	
	/// This method will return the name of the class used to create the instance of the given object.
	/// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
	/// @param object the object to get the class name from
	/// @param isType defines if the object is actually a type
	/// @returns the name of the class, will be "object" for a custom data type not using the @className decorator
	external static String GetClassName(dynamic object, [bool? isType]);
	
	/// Gets the first element of an array satisfying a given predicate
	/// @param array defines the array to browse
	/// @param predicate defines the predicate to use
	/// @returns null if not found or the element
	external static T? First<T>(List<T> array, bool Function(T item) predicate);
	
	/// This method will return the name of the full name of the class, including its owning module (if any).
	/// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
	/// @param object the object to get the class name from
	/// @param isType defines if the object is actually a type
	/// @return a string that can have two forms: "moduleName.className" if module was specified when the class' Name was registered or "className" if there was not module specified.
	/// @ignorenaming
	external static String? getFullClassName(dynamic object, [bool? isType]);
	
	/// Returns a promise that resolves after the given amount of time.
	/// @param delay Number of milliseconds to delay
	/// @returns Promise that resolves after the given amount of time
	external static Promise<void> DelayAsync(num delay);
	
	/// Utility function to detect if the current user agent is Safari
	/// @returns whether or not the current user agent is safari
	external static bool IsSafari();
}

/* top level function */
/// Use this className as a decorator on a given class definition to add it a name and optionally its module.
/// You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
/// This method is the only way to get it done in all cases, even if the .js file declaring the class is minified
/// @param name The name of the class, case should be preserved
/// @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.
@JS()
external void Function(Object target) className(String name, [String? module]);

/// An implementation of a loop for asynchronous functions.
@JS()
class AsyncLoop {
	
	/// Constructor.
	/// @param iterations the number of iterations.
	/// @param func the function to run each iteration
	/// @param successCallback the callback that will be called upon succesful execution
	/// @param offset starting offset.
	external factory AsyncLoop(num iterations, void Function(AsyncLoop asyncLoop) func, void Function() successCallback, [num? offset]);
	
	/// Defines the number of iterations for the loop
	external num get iterations;
	external set iterations(num value);
	
	/// Defines the current index of the loop.
	external num get index;
	external set index(num value);
	
	/// Execute the next iteration. Must be called after the last iteration was finished.
	external void executeNext();
	
	/// Break the loop and run the success callback.
	external void breakLoop();
	
	/// Create and run an async loop.
	/// @param iterations the number of iterations.
	/// @param fn the function to run each iteration
	/// @param successCallback the callback that will be called upon succesful execution
	/// @param offset starting offset.
	/// @returns the created async loop object
	external static AsyncLoop Run(num iterations, void Function(AsyncLoop asyncLoop) fn, void Function() successCallback, [num? offset]);
	
	/// A for-loop that will run a given number of iterations synchronous and the rest async.
	/// @param iterations total number of iterations
	/// @param syncedIterations number of synchronous iterations in each async iteration.
	/// @param fn the function to call each iteration.
	/// @param callback a success call back that will be called when iterating stops.
	/// @param breakFunction a break condition (optional)
	/// @param timeout timeout settings for the setTimeout function. default - 0.
	/// @returns the created async loop object
	external static AsyncLoop SyncAsyncForLoop(num iterations, num syncedIterations, void Function(num iteration) fn, void Function() callback, [bool Function()? breakFunction, num? timeout]);
}

/// This class implement a typical dictionary using a string as key and the generic type T as value.
/// The underlying implementation relies on an associative array to ensure the best performances.
/// The value can be anything including 'null' but except 'undefined'
@JS()
class StringDictionary<T> {
	external factory StringDictionary();
	
	/// This will clear this dictionary and copy the content from the 'source' one.
	/// If the T value is a custom object, it won't be copied/cloned, the same object will be used
	/// @param source the dictionary to take the content from and copy to this dictionary
	external void copyFrom(StringDictionary<T> source);
	
	/// Get a value based from its key
	/// @param key the given key to get the matching value from
	/// @return the value if found, otherwise undefined is returned
	external T? get(String key);
	
	/// Get a value from its key or add it if it doesn't exist.
	/// This method will ensure you that a given key/data will be present in the dictionary.
	/// @param key the given key to get the matching value from
	/// @param factory the factory that will create the value if the key is not present in the dictionary.
	/// The factory will only be invoked if there's no data for the given key.
	/// @return the value corresponding to the key.
	external T getOrAddWithFactory(String key, T Function(String key) factory);
	
	/// Get a value from its key if present in the dictionary otherwise add it
	/// @param key the key to get the value from
	/// @param val if there's no such key/value pair in the dictionary add it with this value
	/// @return the value corresponding to the key
	external T getOrAdd(String key, T val);
	
	/// Check if there's a given key in the dictionary
	/// @param key the key to check for
	/// @return true if the key is present, false otherwise
	external bool contains(String key);
	
	/// Add a new key and its corresponding value
	/// @param key the key to add
	/// @param value the value corresponding to the key
	/// @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary
	external bool add(String key, T value);
	
	/// Update a specific value associated to a key
	/// @param key defines the key to use
	/// @param value defines the value to store
	/// @returns true if the value was updated (or false if the key was not found)
	external bool set(String key, T value);
	
	/// Get the element of the given key and remove it from the dictionary
	/// @param key defines the key to search
	/// @returns the value associated with the key or null if not found
	external T? getAndRemove(String key);
	
	/// Remove a key/value from the dictionary.
	/// @param key the key to remove
	/// @return true if the item was successfully deleted, false if no item with such key exist in the dictionary
	external bool remove(String key);
	
	/// Clear the whole content of the dictionary
	external void clear();
	
	/// Gets the current count
	external num get count;
	
	/// Execute a callback on each key/val of the dictionary.
	/// Note that you can remove any element in this dictionary in the callback implementation
	/// @param callback the callback to execute on a given key/value pair
	external void forEach(void Function(String key, T val) callback);
	
	/// Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
	/// If the callback returns null or undefined the method will iterate to the next key/value pair
	/// Note that you can remove any element in this dictionary in the callback implementation
	/// @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned
	/// @returns the first item
	external TRes? first<TRes>(TRes Function(String key, T val) callback);
}

/// @hidden
@JS()
abstract class ICollisionCoordinator {
	
	external Collider createCollider();
	
	external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh? excludedMesh, void Function(num collisionIndex, Vector3 newPosition, AbstractMesh? collidedMesh) onNewPosition, num collisionIndex);
	
	external void init(Scene scene);
}

/// @hidden
@JS()
class DefaultCollisionCoordinator implements ICollisionCoordinator {
	external factory DefaultCollisionCoordinator();
	
	@override
	external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh? excludedMesh, void Function(num collisionIndex, Vector3 newPosition, AbstractMesh? collidedMesh) onNewPosition, num collisionIndex);
	
	@override
	external Collider createCollider();
	
	@override
	external void init(Scene scene);
}

/// Class used to manage all inputs for the scene.
@JS()
class InputManager {
	
	/// Creates a new InputManager
	/// @param scene defines the hosting scene
	external factory InputManager(Scene scene);
	
	/// The distance in pixel that you have to move to prevent some events
	external static num get DragMovementThreshold;
	external static set DragMovementThreshold(num value);
	
	/// Time in milliseconds to wait to raise long press events if button is still pressed
	external static num get LongPressDelay;
	external static set LongPressDelay(num value);
	
	/// Time in milliseconds with two consecutive clicks will be considered as a double click
	external static num get DoubleClickDelay;
	external static set DoubleClickDelay(num value);
	
	/// If you need to check double click without raising a single click at first click, enable this flag
	external static bool get ExclusiveDoubleClickMode;
	external static set ExclusiveDoubleClickMode(bool value);
	
	/// Gets the mesh that is currently under the pointer
	external AbstractMesh? get meshUnderPointer;
	
	/// When using more than one pointer (for example in XR) you can get the mesh under the specific pointer
	/// @param pointerId the pointer id to use
	/// @returns The mesh under this pointer id or null if not found
	external AbstractMesh? getMeshUnderPointerByPointerId(num pointerId);
	
	/// Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)
	external Vector2 get unTranslatedPointer;
	
	/// Gets or sets the current on-screen X position of the pointer
	external num get pointerX;
	
	external set pointerX(num value);
	
	/// Gets or sets the current on-screen Y position of the pointer
	external num get pointerY;
	
	external set pointerY(num value);
	
	/// Use this method to simulate a pointer move on a mesh
	/// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
	/// @param pickResult pickingInfo of the object wished to simulate pointer event on
	/// @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
	external void simulatePointerMove(PickingInfo pickResult, [dynamic /* unresolved: PointerEventInit */? pointerEventInit]);
	
	/// Use this method to simulate a pointer down on a mesh
	/// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
	/// @param pickResult pickingInfo of the object wished to simulate pointer event on
	/// @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
	external void simulatePointerDown(PickingInfo pickResult, [dynamic /* unresolved: PointerEventInit */? pointerEventInit]);
	
	/// Use this method to simulate a pointer up on a mesh
	/// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
	/// @param pickResult pickingInfo of the object wished to simulate pointer event on
	/// @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
	/// @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
	external void simulatePointerUp(PickingInfo pickResult, [dynamic /* unresolved: PointerEventInit */? pointerEventInit, bool? doubleTap]);
	
	/// Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
	/// @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
	/// @returns true if the pointer was captured
	external bool isPointerCaptured([num? pointerId]);
	
	/// Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
	/// @param attachUp defines if you want to attach events to pointerup
	/// @param attachDown defines if you want to attach events to pointerdown
	/// @param attachMove defines if you want to attach events to pointermove
	/// @param elementToAttachTo defines the target DOM element to attach to (will use the canvas by default)
	external void attachControl([bool? attachUp, bool? attachDown, bool? attachMove, HTML.Element? elementToAttachTo]);
	
	/// Detaches all event handlers
	external void detachControl();
	
	/// Force the value of meshUnderPointer
	/// @param mesh defines the mesh to use
	/// @param pointerId optional pointer id when using more than one pointer. Defaults to 0
	external void setPointerOverMesh(AbstractMesh? mesh, [num? pointerId]);
	
	/// Gets the mesh under the pointer
	/// @returns a Mesh or null if no mesh is under the pointer
	external AbstractMesh? getPointerOverMesh();
}

/// This class defines the direct association between an animation and a target
@JS()
class TargetedAnimation {
	external factory TargetedAnimation();
	
	/// Animation to perform
	external Animation get animation;
	external set animation(Animation value);
	
	/// Target to animate
	external dynamic get target;
	external set target(dynamic value);
	
	/// Returns the string "TargetedAnimation"
	/// @returns "TargetedAnimation"
	external String getClassName();
	
	/// Serialize the object
	/// @returns the JSON object representing the current entity
	external dynamic serialize();
}

/// Use this class to create coordinated animations on multiple targets
@JS()
class AnimationGroup implements IDisposable {
	
	/// Instantiates a new Animation Group.
	/// This helps managing several animations at once.
	/// @see https://doc.babylonjs.com/how_to/group
	/// @param name Defines the name of the group
	/// @param scene Defines the scene the group belongs to
	external factory AnimationGroup(String name, [Scene? scene]);
	
	/// The name of the animation group
	external String get name;
	external set name(String value);
	
	/// Gets or sets the unique id of the node
	external num get uniqueId;
	external set uniqueId(num value);
	
	/// This observable will notify when one animation have ended
	external Observable<TargetedAnimation> get onAnimationEndObservable;
	external set onAnimationEndObservable(Observable<TargetedAnimation> value);
	
	/// Observer raised when one animation loops
	external Observable<TargetedAnimation> get onAnimationLoopObservable;
	external set onAnimationLoopObservable(Observable<TargetedAnimation> value);
	
	/// Observer raised when all animations have looped
	external Observable<AnimationGroup> get onAnimationGroupLoopObservable;
	external set onAnimationGroupLoopObservable(Observable<AnimationGroup> value);
	
	/// This observable will notify when all animations have ended.
	external Observable<AnimationGroup> get onAnimationGroupEndObservable;
	external set onAnimationGroupEndObservable(Observable<AnimationGroup> value);
	
	/// This observable will notify when all animations have paused.
	external Observable<AnimationGroup> get onAnimationGroupPauseObservable;
	external set onAnimationGroupPauseObservable(Observable<AnimationGroup> value);
	
	/// This observable will notify when all animations are playing.
	external Observable<AnimationGroup> get onAnimationGroupPlayObservable;
	external set onAnimationGroupPlayObservable(Observable<AnimationGroup> value);
	
	/// Gets the first frame
	external num get from;
	
	/// Gets the last frame
	external num get to;
	
	/// Define if the animations are started
	external bool get isStarted;
	
	/// Gets a value indicating that the current group is playing
	external bool get isPlaying;
	
	/// Gets or sets the speed ratio to use for all animations
	external num get speedRatio;
	
	/// Gets or sets the speed ratio to use for all animations
	external set speedRatio(num value);
	
	/// Gets or sets if all animations should loop or not
	external bool get loopAnimation;
	
	external set loopAnimation(bool value);
	
	/// Gets or sets if all animations should be evaluated additively
	external bool get isAdditive;
	
	external set isAdditive(bool value);
	
	/// Gets the targeted animations for this animation group
	external List<TargetedAnimation> get targetedAnimations;
	
	/// returning the list of animatables controlled by this animation group.
	external List<Animatable> get animatables;
	
	/// Gets the list of target animations
	external List<TargetedAnimation> get children;
	
	/// Add an animation (with its target) in the group
	/// @param animation defines the animation we want to add
	/// @param target defines the target of the animation
	/// @returns the TargetedAnimation object
	external TargetedAnimation addTargetedAnimation(Animation animation, dynamic target);
	
	/// This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
	/// It can add constant keys at begin or end
	/// @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)
	/// @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)
	/// @returns the animation group
	external AnimationGroup normalize([num? beginFrame, num? endFrame]);
	
	/// Start all animations on given targets
	/// @param loop defines if animations must loop
	/// @param speedRatio defines the ratio to apply to animation speed (1 by default)
	/// @param from defines the from key (optional)
	/// @param to defines the to key (optional)
	/// @param isAdditive defines the additive state for the resulting animatables (optional)
	/// @returns the current animation group
	external AnimationGroup start([bool? loop, num? speedRatio, num? from, num? to, bool? isAdditive]);
	
	/// Pause all animations
	/// @returns the animation group
	external AnimationGroup pause();
	
	/// Play all animations to initial state
	/// This function will start() the animations if they were not started or will restart() them if they were paused
	/// @param loop defines if animations must loop
	/// @returns the animation group
	external AnimationGroup play([bool? loop]);
	
	/// Reset all animations to initial state
	/// @returns the animation group
	external AnimationGroup reset();
	
	/// Restart animations from key 0
	/// @returns the animation group
	external AnimationGroup restart();
	
	/// Stop all animations
	/// @returns the animation group
	external AnimationGroup stop();
	
	/// Set animation weight for all animatables
	/// @param weight defines the weight to use
	/// @return the animationGroup
	/// @see https://doc.babylonjs.com/babylon101/animations#animation-weights
	external AnimationGroup setWeightForAllAnimatables(num weight);
	
	/// Synchronize and normalize all animatables with a source animatable
	/// @param root defines the root animatable to synchronize with
	/// @return the animationGroup
	/// @see https://doc.babylonjs.com/babylon101/animations#animation-weights
	external AnimationGroup syncAllAnimationsWith(Animatable root);
	
	/// Goes to a specific frame in this animation group
	/// @param frame the frame number to go to
	/// @return the animationGroup
	external AnimationGroup goToFrame(num frame);
	
	/// Dispose all associated resources
	@override
	external void dispose();
	
	/// Clone the current animation group and returns a copy
	/// @param newName defines the name of the new group
	/// @param targetConverter defines an optional function used to convert current animation targets to new ones
	/// @returns the new aniamtion group
	external AnimationGroup clone(String newName, [dynamic Function(dynamic oldTarget)? targetConverter]);
	
	/// Serializes the animationGroup to an object
	/// @returns Serialized object
	external dynamic serialize();
	
	/// Returns a new AnimationGroup object parsed from the source provided.
	/// @param parsedAnimationGroup defines the source
	/// @param scene defines the scene that will receive the animationGroup
	/// @returns a new AnimationGroup
	external static AnimationGroup Parse(dynamic parsedAnimationGroup, Scene scene);
	
	/// Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.
	/// @param sourceAnimationGroup defines the AnimationGroup containing animations to convert
	/// @param referenceFrame defines the frame that keyframes in the range will be relative to
	/// @param range defines the name of the AnimationRange belonging to the animations in the group to convert
	/// @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)
	/// @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true
	/// @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false
	external static AnimationGroup MakeAnimationAdditive(AnimationGroup sourceAnimationGroup, [num? referenceFrame, String? range, bool? cloneOriginal, String? clonedName]);
	
	/// Returns the string "AnimationGroup"
	/// @returns "AnimationGroup"
	external String getClassName();
	
	/// Creates a detailled string about the object
	/// @param fullDetails defines if the output string will support multiple levels of logging within scene loading
	/// @returns a string representing the object
	external String toString([bool? fullDetails]);
}

/// Define an interface for all classes that will hold resources
@JS()
abstract class IDisposable {
	
	/// Releases all held resources
	external void dispose();
}

/// Interface defining initialization parameters for Scene class
@JS()
@anonymous
class SceneOptions {
	
	external factory SceneOptions({bool useGeometryUniqueIdsMap, bool useMaterialMeshMap, bool useClonedMeshMap, bool virtual});
	
	/// Defines that scene should keep up-to-date a map of geometry to enable fast look-up by uniqueId
	/// It will improve performance when the number of geometries becomes important.
	external bool get useGeometryUniqueIdsMap;
	external set useGeometryUniqueIdsMap( bool value );
	
	/// Defines that each material of the scene should keep up-to-date a map of referencing meshes for fast diposing
	/// It will improve performance when the number of mesh becomes important, but might consume a bit more memory
	external bool get useMaterialMeshMap;
	external set useMaterialMeshMap( bool value );
	
	/// Defines that each mesh of the scene should keep up-to-date a map of referencing cloned meshes for fast diposing
	/// It will improve performance when the number of mesh becomes important, but might consume a bit more memory
	external bool get useClonedMeshMap;
	external set useClonedMeshMap( bool value );
	
	/// Defines if the creation of the scene should impact the engine (Eg. UtilityLayer's scene)
	external bool get virtual;
	external set virtual( bool value );
}

/// Set of assets to keep when moving a scene into an asset container.
@JS()
class KeepAssets extends AbstractScene {
	external factory KeepAssets();
}

/// Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function
@JS()
class InstantiatedEntries {
	external factory InstantiatedEntries();
	
	/// List of new root nodes (eg. nodes with no parent)
	external List<TransformNode> get rootNodes;
	external set rootNodes(List<TransformNode> value);
	
	/// List of new skeletons
	external List<Skeleton> get skeletons;
	external set skeletons(List<Skeleton> value);
	
	/// List of new animation groups
	external List<AnimationGroup> get animationGroups;
	external set animationGroups(List<AnimationGroup> value);
}

/// Container with a set of assets that can be added or removed from a scene.
@JS()
class AssetContainer extends AbstractScene {
	
	/// Instantiates an AssetContainer.
	/// @param scene The scene the AssetContainer belongs to.
	external factory AssetContainer(Scene scene);
	
	/// The scene the AssetContainer belongs to.
	external Scene get scene;
	external set scene(Scene value);
	
	/// Instantiate or clone all meshes and add the new ones to the scene.
	/// Skeletons and animation groups will all be cloned
	/// @param nameFunction defines an optional function used to get new names for clones
	/// @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)
	/// @returns a list of rootNodes, skeletons and aniamtion groups that were duplicated
	external InstantiatedEntries instantiateModelsToScene([String Function(String sourceName)? nameFunction, bool? cloneMaterials]);
	
	/// Adds all the assets from the container to the scene.
	external void addAllToScene();
	
	/// Removes all the assets in the container from the scene
	external void removeAllFromScene();
	
	/// Disposes all the assets in the container
	external void dispose();
	
	/// Removes all the assets contained in the scene and adds them to the container.
	/// @param keepAssets Set of assets to keep in the scene. (default: empty)
	external void moveAllFromScene([KeepAssets? keepAssets]);
	
	/// Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
	/// @returns the root mesh
	external Mesh createRootMesh();
	
	/// Merge animations (direct and animation groups) from this asset container into a scene
	/// @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
	/// @param animatables set of animatables to retarget to a node from the scene
	/// @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)
	/// @returns an array of the new AnimationGroup added to the scene (empty array if none)
	external List<AnimationGroup> mergeAnimationsTo(Scene? scene, List<Animatable> animatables, [Node? Function(dynamic target)? targetConverter]);
}

/// Interface used to define options for Sound class
@JS()
@anonymous
class ISoundOptions {
	
	external factory ISoundOptions({bool autoplay, bool loop, num volume, bool spatialSound, num maxDistance, bool useCustomAttenuation, num rolloffFactor, num refDistance, String distanceModel, num playbackRate, bool streaming, num length, num offset, bool skipCodecCheck});
	
	/// Does the sound autoplay once loaded.
	external bool get autoplay;
	external set autoplay( bool value );
	
	/// Does the sound loop after it finishes playing once.
	external bool get loop;
	external set loop( bool value );
	
	/// Sound's volume
	external num get volume;
	external set volume( num value );
	
	/// Is it a spatial sound?
	external bool get spatialSound;
	external set spatialSound( bool value );
	
	/// Maximum distance to hear that sound
	external num get maxDistance;
	external set maxDistance( num value );
	
	/// Uses user defined attenuation function
	external bool get useCustomAttenuation;
	external set useCustomAttenuation( bool value );
	
	/// Define the roll off factor of spatial sounds.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external num get rolloffFactor;
	external set rolloffFactor( num value );
	
	/// Define the reference distance the sound should be heard perfectly.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external num get refDistance;
	external set refDistance( num value );
	
	/// Define the distance attenuation model the sound will follow.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external String get distanceModel;
	external set distanceModel( String value );
	
	/// Defines the playback speed (1 by default)
	external num get playbackRate;
	external set playbackRate( num value );
	
	/// Defines if the sound is from a streaming source
	external bool get streaming;
	external set streaming( bool value );
	
	/// Defines an optional length (in seconds) inside the sound file
	external num get length;
	external set length( num value );
	
	/// Defines an optional offset (in seconds) inside the sound file
	external num get offset;
	external set offset( num value );
	
	/// If true, URLs will not be required to state the audio file codec to use.
	external bool get skipCodecCheck;
	external set skipCodecCheck( bool value );
}

/// Defines a sound that can be played in the application.
/// The sound can either be an ambient track or a simple sound played in reaction to a user action.
/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
@JS()
class Sound {
	
	/// Create a sound and attach it to a scene
	/// @param name Name of your sound
	/// @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams
	/// @param scene defines the scene the sound belongs to
	/// @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played
	/// @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming
	external factory Sound(String name, dynamic urlOrArrayBuffer, Scene scene, [void Function()? readyToPlayCallback, ISoundOptions? options]);
	
	/// The name of the sound in the scene.
	external String get name;
	external set name(String value);
	
	/// Does the sound autoplay once loaded.
	external bool get autoplay;
	external set autoplay(bool value);
	
	/// Does the sound loop after it finishes playing once.
	external bool get loop;
	external set loop(bool value);
	
	/// Does the sound use a custom attenuation curve to simulate the falloff
	/// happening when the source gets further away from the camera.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function
	external bool get useCustomAttenuation;
	external set useCustomAttenuation(bool value);
	
	/// The sound track id this sound belongs to.
	external num get soundTrackId;
	external set soundTrackId(num value);
	
	/// Is this sound currently played.
	external bool get isPlaying;
	external set isPlaying(bool value);
	
	/// Is this sound currently paused.
	external bool get isPaused;
	external set isPaused(bool value);
	
	/// Does this sound enables spatial sound.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external bool get spatialSound;
	external set spatialSound(bool value);
	
	/// Define the reference distance the sound should be heard perfectly.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external num get refDistance;
	external set refDistance(num value);
	
	/// Define the roll off factor of spatial sounds.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external num get rolloffFactor;
	external set rolloffFactor(num value);
	
	/// Define the max distance the sound should be heard (intensity just became 0 at this point).
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external num get maxDistance;
	external set maxDistance(num value);
	
	/// Define the distance attenuation model the sound will follow.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external String get distanceModel;
	external set distanceModel(String value);
	
	/// @hidden
	/// Back Compat
	/// 
	external dynamic Function() get onended;
	external set onended(dynamic Function() value);
	
	/// Gets or sets an object used to store user defined information for the sound.
	external dynamic get metadata;
	external set metadata(dynamic value);
	
	/// Observable event when the current playing sound finishes.
	external Observable<Sound> get onEndedObservable;
	external set onEndedObservable(Observable<Sound> value);
	
	/// Gets the current time for the sound.
	external num get currentTime;
	
	/// Release the sound and its associated resources
	external void dispose();
	
	/// Gets if the sounds is ready to be played or not.
	/// @returns true if ready, otherwise false
	external bool isReady();
	
	/// Sets the data of the sound from an audiobuffer
	/// @param audioBuffer The audioBuffer containing the data
	external void setAudioBuffer(Audio.AudioBuffer audioBuffer);
	
	/// Updates the current sounds options such as maxdistance, loop...
	/// @param options A JSON object containing values named as the object properties
	external void updateOptions(ISoundOptions options);
	
	/// Switch the panning model to HRTF:
	/// Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external void switchPanningModelToHRTF();
	
	/// Switch the panning model to Equal Power:
	/// Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external void switchPanningModelToEqualPower();
	
	/// Connect this sound to a sound track audio node like gain...
	/// @param soundTrackAudioNode the sound track audio node to connect to
	external void connectToSoundTrackAudioNode(Audio.AudioNode soundTrackAudioNode);
	
	/// Transform this sound into a directional source
	/// @param coneInnerAngle Size of the inner cone in degree
	/// @param coneOuterAngle Size of the outer cone in degree
	/// @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)
	external void setDirectionalCone(num coneInnerAngle, num coneOuterAngle, num coneOuterGain);
	
	/// Gets or sets the inner angle for the directional cone.
	external num get directionalConeInnerAngle;
	
	/// Gets or sets the inner angle for the directional cone.
	external set directionalConeInnerAngle(num value);
	
	/// Gets or sets the outer angle for the directional cone.
	external num get directionalConeOuterAngle;
	
	/// Gets or sets the outer angle for the directional cone.
	external set directionalConeOuterAngle(num value);
	
	/// Sets the position of the emitter if spatial sound is enabled
	/// @param newPosition Defines the new posisiton
	external void setPosition(Vector3 newPosition);
	
	/// Sets the local direction of the emitter if spatial sound is enabled
	/// @param newLocalDirection Defines the new local direction
	external void setLocalDirectionToMesh(Vector3 newLocalDirection);
	
	/// @hidden
	external void updateDistanceFromListener();
	
	/// Sets a new custom attenuation function for the sound.
	/// @param callback Defines the function used for the attenuation
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function
	external void setAttenuationFunction(num Function(num currentVolume, num currentDistance, num maxDistance, num refDistance, num rolloffFactor) callback);
	
	/// Play the sound
	/// @param time (optional) Start the sound after X seconds. Start immediately (0) by default.
	/// @param offset (optional) Start the sound at a specific time in seconds
	/// @param length (optional) Sound duration (in seconds)
	external void play([num? time, num? offset, num? length]);
	
	/// Stop the sound
	/// @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.
	external void stop([num? time]);
	
	/// Put the sound in pause
	external void pause();
	
	/// Sets a dedicated volume for this sounds
	/// @param newVolume Define the new volume of the sound
	/// @param time Define time for gradual change to new volume
	external void setVolume(num newVolume, [num? time]);
	
	/// Set the sound play back rate
	/// @param newPlaybackRate Define the playback rate the sound should be played at
	external void setPlaybackRate(num newPlaybackRate);
	
	/// Gets the volume of the sound.
	/// @returns the volume of the sound
	external num getVolume();
	
	/// Attach the sound to a dedicated mesh
	/// @param transformNode The transform node to connect the sound with
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh
	external void attachToMesh(TransformNode transformNode);
	
	/// Detach the sound from the previously attached mesh
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh
	external void detachFromMesh();
	
	/// Clone the current sound in the scene.
	/// @returns the new sound clone
	external Sound? clone();
	
	/// Gets the current underlying audio buffer containing the data
	/// @returns the audio buffer
	external Audio.AudioBuffer? getAudioBuffer();
	
	/// Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.
	/// @returns the source node
	external dynamic /* unresolved: AudioBufferSourceNode */? getSoundSource();
	
	/// Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.
	/// @returns the gain node
	external Audio.GainNode? getSoundGain();
	
	/// Serializes the Sound in a JSON representation
	/// @returns the JSON representation of the sound
	external dynamic serialize();
	
	/// Parse a JSON representation of a sound to innstantiate in a given scene
	/// @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)
	/// @param scene Define the scene the new parsed sound should be created in
	/// @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies
	/// @param sourceSound Define a cound place holder if do not need to instantiate a new one
	/// @returns the newly parsed sound
	external static Sound Parse(dynamic parsedSound, Scene scene, String rootUrl, [Sound? sourceSound]);
}

/// This defines an action helpful to play a defined sound on a triggered action.
@JS()
class PlaySoundAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param sound defines the sound to play
	/// @param condition defines the trigger related conditions
	external factory PlaySoundAction(dynamic triggerOptions, Sound sound, [Condition? condition]);
	
	/// Execute the action and play the sound.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action helpful to stop a defined sound on a triggered action.
@JS()
class StopSoundAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param sound defines the sound to stop
	/// @param condition defines the trigger related conditions
	external factory StopSoundAction(dynamic triggerOptions, Sound sound, [Condition? condition]);
	
	/// Execute the action and stop the sound.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This defines an action responsible to change the value of a property
/// by interpolating between its current value and the newly set one once triggered.
/// @see https://doc.babylonjs.com/how_to/how_to_use_actions
@JS()
class InterpolateValueAction extends Action {
	
	/// Instantiate the action
	/// @param triggerOptions defines the trigger options
	/// @param target defines the object containing the value to interpolate
	/// @param propertyPath defines the path to the property in the target object
	/// @param value defines the target value at the end of the interpolation
	/// @param duration deines the time it will take for the property to interpolate to the value.
	/// @param condition defines the trigger related conditions
	/// @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered
	/// @param onInterpolationDone defines a callback raised once the interpolation animation has been done
	external factory InterpolateValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [num? duration, Condition? condition, bool? stopOtherAnimations, void Function()? onInterpolationDone]);
	
	/// Defines the path of the property where the value should be interpolated
	external String get propertyPath;
	external set propertyPath(String value);
	
	/// Defines the target value at the end of the interpolation.
	external dynamic get value;
	external set value(dynamic value);
	
	/// Defines the time it will take for the property to interpolate to the value.
	external num get duration;
	external set duration(num value);
	
	/// Defines if the other scene animations should be stopped when the action has been triggered
	external bool get stopOtherAnimations;
	external set stopOtherAnimations(bool value);
	
	/// Defines a callback raised once the interpolation animation has been done.
	external void Function() get onInterpolationDone;
	external set onInterpolationDone(void Function() value);
	
	/// Observable triggered once the interpolation animation has been done.
	external Observable<InterpolateValueAction> get onInterpolationDoneObservable;
	external set onInterpolationDoneObservable(Observable<InterpolateValueAction> value);
	
	/// Execute the action starts the value interpolation.
	@override
	external void execute([ActionEvent? evt]);
	
	/// Serializes the actions and its related information.
	/// @param parent defines the object to serialize in
	/// @returns the serialized object
	@override
	external dynamic serialize(dynamic parent);
}

/// This represents the default audio engine used in babylon.
/// It is responsible to play, synchronize and analyse sounds throughout the  application.
/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
@JS()
class AudioEngine implements IAudioEngine {
	
	/// Instantiates a new audio engine.
	/// 
	/// There should be only one per page as some browsers restrict the number
	/// of audio contexts you can create.
	/// @param hostElement defines the host element where to display the mute icon if necessary
	external factory AudioEngine([HTML.Element? hostElement]);
	
	/// Gets whether the current host supports Web Audio and thus could create AudioContexts.
	@override
	external bool get canUseWebAudio;
	@override
	external set canUseWebAudio(bool value);
	
	/// The master gain node defines the global audio volume of your audio engine.
	@override
	external Audio.GainNode get masterGain;
	@override
	external set masterGain(Audio.GainNode value);
	
	/// Defines if Babylon should emit a warning if WebAudio is not supported.
	/// @ignoreNaming
	@override
	external bool get WarnedWebAudioUnsupported;
	@override
	external set WarnedWebAudioUnsupported(bool value);
	
	/// Gets whether or not mp3 are supported by your browser.
	@override
	external bool get isMP3supported;
	@override
	external set isMP3supported(bool value);
	
	/// Gets whether or not ogg are supported by your browser.
	@override
	external bool get isOGGsupported;
	@override
	external set isOGGsupported(bool value);
	
	/// Gets whether audio has been unlocked on the device.
	/// Some Browsers have strong restrictions about Audio and won t autoplay unless
	/// a user interaction has happened.
	@override
	external bool get unlocked;
	@override
	external set unlocked(bool value);
	
	/// Defines if the audio engine relies on a custom unlocked button.
	/// In this case, the embedded button will not be displayed.
	@override
	external bool get useCustomUnlockedButton;
	@override
	external set useCustomUnlockedButton(bool value);
	
	/// Event raised when audio has been unlocked on the browser.
	@override
	external Observable<IAudioEngine> get onAudioUnlockedObservable;
	@override
	external set onAudioUnlockedObservable(Observable<IAudioEngine> value);
	
	/// Event raised when audio has been locked on the browser.
	@override
	external Observable<IAudioEngine> get onAudioLockedObservable;
	@override
	external set onAudioLockedObservable(Observable<IAudioEngine> value);
	
	/// Flags the audio engine in Locked state.
	/// This happens due to new browser policies preventing audio to autoplay.
	@override
	external void lock();
	
	/// Unlocks the audio engine once a user action has been done on the dom.
	/// This is helpful to resume play once browser policies have been satisfied.
	@override
	external void unlock();
	
	/// Destroy and release the resources associated with the audio ccontext.
	@override
	external void dispose();
	
	/// Gets the global volume sets on the master gain.
	/// @returns the global volume if set or -1 otherwise
	@override
	external num getGlobalVolume();
	
	/// Sets the global volume of your experience (sets on the master gain).
	/// @param newVolume Defines the new global volume of the application
	@override
	external void setGlobalVolume(num newVolume);
	
	/// Connect the audio engine to an audio analyser allowing some amazing
	/// synchornization between the sounds/music and your visualization (VuMeter for instance).
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
	/// @param analyser The analyser to connect to the engine
	@override
	external void connectToAnalyser(Analyser analyser);
	
	/// Gets the current AudioContext if available.
	external Audio.AudioContext? get audioContext;
}

/// Options allowed during the creation of a sound track.
@JS()
@anonymous
class ISoundTrackOptions {
	
	external factory ISoundTrackOptions({num volume, bool mainTrack});
	
	/// The volume the sound track should take during creation
	external num get volume;
	external set volume( num value );
	
	/// Define if the sound track is the main sound track of the scene
	external bool get mainTrack;
	external set mainTrack( bool value );
}

/// It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.
/// It will be also used in a future release to apply effects on a specific track.
/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks
@JS()
class SoundTrack {
	
	/// Creates a new sound track.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks
	/// @param scene Define the scene the sound track belongs to
	/// @param options
	external factory SoundTrack(Scene scene, [ISoundTrackOptions? options]);
	
	/// The unique identifier of the sound track in the scene.
	external num get id;
	external set id(num value);
	
	/// The list of sounds included in the sound track.
	external List<Sound> get soundCollection;
	external set soundCollection(List<Sound> value);
	
	/// Release the sound track and its associated resources
	external void dispose();
	
	/// Adds a sound to this sound track
	/// @param sound define the cound to add
	/// @ignoreNaming
	external void addSound(Sound sound);
	
	/// Removes a sound to this sound track
	/// @param sound define the cound to remove
	/// @ignoreNaming
	external void removeSound(Sound sound);
	
	/// Set a global volume for the full sound track.
	/// @param newVolume Define the new volume of the sound track
	external void setVolume(num newVolume);
	
	/// Switch the panning model to HRTF:
	/// Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external void switchPanningModelToHRTF();
	
	/// Switch the panning model to Equal Power:
	/// Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
	external void switchPanningModelToEqualPower();
	
	/// Connect the sound track to an audio analyser allowing some amazing
	/// synchornization between the sounds/music and your visualization (VuMeter for instance).
	/// @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
	/// @param analyser The analyser to connect to the engine
	external void connectToAnalyser(Analyser analyser);
}

/// Defines the sound scene component responsible to manage any sounds
/// in a given scene.
@JS()
class AudioSceneComponent implements ISceneSerializableComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory AudioSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Gets whether audio is enabled or not.
	/// Please use related enable/disable method to switch state.
	external bool get audioEnabled;
	
	/// Gets whether audio is outputing to headphone or not.
	/// Please use the according Switch methods to change output.
	external bool get headphone;
	
	/// Gets or sets a refresh rate when using 3D audio positioning
	external num get audioPositioningRefreshRate;
	external set audioPositioningRefreshRate(num value);
	
	/// Gets the current audio listener position provider
	external Vector3 Function()? get audioListenerPositionProvider;
	
	/// Sets a custom listener position for all sounds in the scene
	/// By default, this is the position of the first active camera
	external set audioListenerPositionProvider(Vector3 Function()? value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Serializes the component data to the specified json object
	/// @param serializationObject The object to serialize to
	@override
	external void serialize(dynamic serializationObject);
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	@override
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	@override
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
	
	/// Disables audio in the associated scene.
	external void disableAudio();
	
	/// Enables audio in the associated scene.
	external void enableAudio();
	
	/// Switch audio to headphone output.
	external void switchAudioModeForHeadphones();
	
	/// Switch audio to normal speakers.
	external void switchAudioModeForNormalSpeakers();
}

/// Wraps one or more Sound objects and selects one with random weight for playback.
@JS()
class WeightedSound {
	
	/// Creates a new WeightedSound from the list of sounds given.
	/// @param loop When true a Sound will be selected and played when the current playing Sound completes.
	/// @param sounds Array of Sounds that will be selected from.
	/// @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1
	external factory WeightedSound(bool loop, List<Sound> sounds, List<num> weights);
	
	/// When true a Sound will be selected and played when the current playing Sound completes.
	external bool get loop;
	external set loop(bool value);
	
	/// A Sound is currently playing.
	external bool get isPlaying;
	external set isPlaying(bool value);
	
	/// A Sound is currently paused.
	external bool get isPaused;
	external set isPaused(bool value);
	
	/// The size of cone in degrees for a directional sound in which there will be no attenuation.
	external num get directionalConeInnerAngle;
	
	/// The size of cone in degress for a directional sound in which there will be no attenuation.
	external set directionalConeInnerAngle(num value);
	
	/// Size of cone in degrees for a directional sound outside of which there will be no sound.
	/// Listener angles between innerAngle and outerAngle will falloff linearly.
	external num get directionalConeOuterAngle;
	
	/// Size of cone in degrees for a directional sound outside of which there will be no sound.
	/// Listener angles between innerAngle and outerAngle will falloff linearly.
	external set directionalConeOuterAngle(num value);
	
	/// Playback volume.
	external num get volume;
	
	/// Playback volume.
	external set volume(num value);
	
	/// Suspend playback
	external void pause();
	
	/// Stop playback
	external void stop();
	
	/// Start playback.
	/// @param startOffset Position the clip head at a specific time in seconds.
	external void play([num? startOffset]);
}

/// Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
/// @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
@JS()
class BouncingBehavior implements Behavior<ArcRotateCamera> {
	external factory BouncingBehavior();
	
	/// The easing function used by animations
	@JS("EasingFunction")
	external static BackEase get EasingFunction_js;
	@JS("EasingFunction")
	external static set EasingFunction_js(BackEase value);
	
	/// The easing mode used by animations
	external static num get EasingMode;
	external static set EasingMode(num value);
	
	/// The duration of the animation, in milliseconds
	external num get transitionDuration;
	external set transitionDuration(num value);
	
	/// Length of the distance animated by the transition when lower radius is reached
	external num get lowerRadiusTransitionRange;
	external set lowerRadiusTransitionRange(num value);
	
	/// Length of the distance animated by the transition when upper radius is reached
	external num get upperRadiusTransitionRange;
	external set upperRadiusTransitionRange(num value);
	
	/// Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
	external bool get autoTransitionRange;
	
	/// Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
	/// Transition ranges will be set to 5% of the bounding box diagonal in world space
	external set autoTransitionRange(bool value);
	
	/// Initializes the behavior.
	@override
	external void init();
	
	/// Attaches the behavior to its arc rotate camera.
	/// @param camera Defines the camera to attach the behavior to
	@override
	external void attach(ArcRotateCamera camera);
	
	/// Detaches the behavior from its current arc rotate camera.
	@override
	external void detach();
	
	/// Stops and removes all animations that have been applied to the camera
	external void stopAllAnimations();
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.
/// @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
@JS()
class FramingBehavior implements Behavior<ArcRotateCamera> {
	external factory FramingBehavior();
	
	/// The easing function used by animations
	@JS("EasingFunction")
	external static ExponentialEase get EasingFunction_js;
	@JS("EasingFunction")
	external static set EasingFunction_js(ExponentialEase value);
	
	/// The easing mode used by animations
	external static num get EasingMode;
	external static set EasingMode(num value);
	
	/// Sets the current mode used by the behavior
	external set mode(num value);
	
	/// Gets current mode used by the behavior.
	external num get mode;
	
	/// Sets the scale applied to the radius (1 by default)
	external set radiusScale(num value);
	
	/// Gets the scale applied to the radius
	external num get radiusScale;
	
	/// Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
	external set positionScale(num value);
	
	/// Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
	external num get positionScale;
	
	/// Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
	/// behaviour is triggered, in radians.
	external set defaultElevation(num value);
	
	/// Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
	/// behaviour is triggered, in radians.
	external num get defaultElevation;
	
	/// Sets the time (in milliseconds) taken to return to the default beta position.
	/// Negative value indicates camera should not return to default.
	external set elevationReturnTime(num value);
	
	/// Gets the time (in milliseconds) taken to return to the default beta position.
	/// Negative value indicates camera should not return to default.
	external num get elevationReturnTime;
	
	/// Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
	external set elevationReturnWaitTime(num value);
	
	/// Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
	external num get elevationReturnWaitTime;
	
	/// Sets the flag that indicates if user zooming should stop animation.
	external set zoomStopsAnimation(bool value);
	
	/// Gets the flag that indicates if user zooming should stop animation.
	external bool get zoomStopsAnimation;
	
	/// Sets the transition time when framing the mesh, in milliseconds
	external set framingTime(num value);
	
	/// Gets the transition time when framing the mesh, in milliseconds
	external num get framingTime;
	
	/// Define if the behavior should automatically change the configured
	/// camera limits and sensibilities.
	external bool get autoCorrectCameraLimitsAndSensibility;
	external set autoCorrectCameraLimitsAndSensibility(bool value);
	
	/// Initializes the behavior.
	@override
	external void init();
	
	/// Attaches the behavior to its arc rotate camera.
	/// @param camera Defines the camera to attach the behavior to
	@override
	external void attach(ArcRotateCamera camera);
	
	/// Detaches the behavior from its current arc rotate camera.
	@override
	external void detach();
	
	/// Targets the given mesh and updates zoom level accordingly.
	/// @param mesh  The mesh to target.
	/// @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
	/// @param onAnimationEnd Callback triggered at the end of the framing animation
	external void zoomOnMesh(AbstractMesh mesh, [bool? focusOnOriginXZ, void Function()? onAnimationEnd]);
	
	/// Targets the given mesh with its children and updates zoom level accordingly.
	/// @param mesh  The mesh to target.
	/// @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
	/// @param onAnimationEnd Callback triggered at the end of the framing animation
	external void zoomOnMeshHierarchy(AbstractMesh mesh, [bool? focusOnOriginXZ, void Function()? onAnimationEnd]);
	
	/// Targets the given meshes with their children and updates zoom level accordingly.
	/// @param meshes  The mesh to target.
	/// @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
	/// @param onAnimationEnd Callback triggered at the end of the framing animation
	external void zoomOnMeshesHierarchy(List<AbstractMesh> meshes, [bool? focusOnOriginXZ, void Function()? onAnimationEnd]);
	
	/// Targets the bounding box info defined by its extends and updates zoom level accordingly.
	/// @param minimumWorld Determines the smaller position of the bounding box extend
	/// @param maximumWorld Determines the bigger position of the bounding box extend
	/// @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
	/// @param onAnimationEnd Callback triggered at the end of the framing animation
	external void zoomOnBoundingInfo(Vector3 minimumWorld, Vector3 maximumWorld, [bool? focusOnOriginXZ, void Function()? onAnimationEnd]);
	
	/// Stops and removes all animations that have been applied to the camera
	external void stopAllAnimations();
	
	/// Gets a value indicating if the user is moving the camera
	external bool get isUserIsMoving;
	
	/// The camera can move all the way towards the mesh.
	external static num get IgnoreBoundsSizeMode;
	external static set IgnoreBoundsSizeMode(num value);
	
	/// The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
	external static num get FitFrustumSidesMode;
	external static set FitFrustumSidesMode(num value);
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// Base class for Camera Pointer Inputs.
/// See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts
/// for example usage.
@JS()
abstract class BaseCameraPointersInput implements ICameraInput<Camera> {
	external factory BaseCameraPointersInput();
	
	/// Defines the camera the input is attached to.
	@override
	external Camera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines the buttons associated with the input to handle camera move.
	external List<num> get buttons;
	external set buttons(List<num> value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param element Defines the element the controls should be listened from
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current input.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	/// Called on pointer POINTERDOUBLETAP event.
	/// Override this method to provide functionality on POINTERDOUBLETAP event.
	external void onDoubleTap(String type);
	
	/// Called on pointer POINTERMOVE event if only a single touch is active.
	/// Override this method to provide functionality.
	external void onTouch(PointerTouch? point, num offsetX, num offsetY);
	
	/// Called on pointer POINTERMOVE event if multiple touches are active.
	/// Override this method to provide functionality.
	external void onMultiTouch(PointerTouch? pointA, PointerTouch? pointB, num previousPinchSquaredDistance, num pinchSquaredDistance, PointerTouch? previousMultiTouchPanPosition, PointerTouch? multiTouchPanPosition);
	
	/// Called on JS contextmenu event.
	/// Override this method to provide functionality.
	external void onContextMenu(HTML.PointerEvent evt);
	
	/// Called each time a new POINTERDOWN event occurs. Ie, for each button
	/// press.
	/// Override this method to provide functionality.
	external void onButtonDown(HTML.PointerEvent evt);
	
	/// Called each time a new POINTERUP event occurs. Ie, for each button
	/// release.
	/// Override this method to provide functionality.
	external void onButtonUp(HTML.PointerEvent evt);
	
	/// Called when window becomes inactive.
	/// Override this method to provide functionality.
	external void onLostFocus();
}

/// Manage the pointers inputs to control an arc rotate camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class ArcRotateCameraPointersInput extends BaseCameraPointersInput {
	external factory ArcRotateCameraPointersInput();
	
	/* Manual Fix 11 */
	
	/// Defines the camera the input is attached to.
	@override
	external ArcRotateCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Gets the class name of the current input.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Defines the buttons associated with the input to handle camera move.
	@override
	external List<num> get buttons;
	@override
	external set buttons(List<num> value);
	
	/// Defines the pointer angular sensibility  along the X axis or how fast is
	/// the camera rotating.
	external num get angularSensibilityX;
	external set angularSensibilityX(num value);
	
	/// Defines the pointer angular sensibility along the Y axis or how fast is
	/// the camera rotating.
	external num get angularSensibilityY;
	external set angularSensibilityY(num value);
	
	/// Defines the pointer pinch precision or how fast is the camera zooming.
	external num get pinchPrecision;
	external set pinchPrecision(num value);
	
	/// pinchDeltaPercentage will be used instead of pinchPrecision if different
	/// from 0.
	/// It defines the percentage of current camera.radius to use as delta when
	/// pinch zoom is used.
	external num get pinchDeltaPercentage;
	external set pinchDeltaPercentage(num value);
	
	/// When useNaturalPinchZoom is true, multi touch zoom will zoom in such
	/// that any object in the plane at the camera's target point will scale
	/// perfectly with finger motion.
	/// Overrides pinchDeltaPercentage and pinchPrecision.
	external bool get useNaturalPinchZoom;
	external set useNaturalPinchZoom(bool value);
	
	/// Defines the pointer panning sensibility or how fast is the camera moving.
	external num get panningSensibility;
	external set panningSensibility(num value);
	
	/// Defines whether panning (2 fingers swipe) is enabled through multitouch.
	external bool get multiTouchPanning;
	external set multiTouchPanning(bool value);
	
	/// Defines whether panning is enabled for both pan (2 fingers swipe) and
	/// zoom (pinch) through multitouch.
	external bool get multiTouchPanAndZoom;
	external set multiTouchPanAndZoom(bool value);
	
	/// Revers pinch action direction.
	external bool get pinchInwards;
	external set pinchInwards(bool value);
	
	/// Called on pointer POINTERMOVE event if only a single touch is active.
	@override
	external void onTouch(PointerTouch? point, num offsetX, num offsetY);
	
	/// Called on pointer POINTERDOUBLETAP event.
	@override
	external void onDoubleTap(String type);
	
	/// Called on pointer POINTERMOVE event if multiple touches are active.
	@override
	external void onMultiTouch(PointerTouch? pointA, PointerTouch? pointB, num previousPinchSquaredDistance, num pinchSquaredDistance, PointerTouch? previousMultiTouchPanPosition, PointerTouch? multiTouchPanPosition);
	
	/// Called each time a new POINTERDOWN event occurs. Ie, for each button
	/// press.
	@override
	external void onButtonDown(HTML.PointerEvent evt);
	
	/// Called each time a new POINTERUP event occurs. Ie, for each button
	/// release.
	@override
	external void onButtonUp(HTML.PointerEvent evt);
	
	/// Called when window becomes inactive.
	@override
	external void onLostFocus();
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Manage the keyboard inputs to control the movement of an arc rotate camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {
	external factory ArcRotateCameraKeyboardMoveInput();
	
	/* Manual Fix 11 */
	
	/// Defines the camera the input is attached to.
	@override
	external ArcRotateCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines the list of key codes associated with the up action (increase alpha)
	external List<num> get keysUp;
	external set keysUp(List<num> value);
	
	/// Defines the list of key codes associated with the down action (decrease alpha)
	external List<num> get keysDown;
	external set keysDown(List<num> value);
	
	/// Defines the list of key codes associated with the left action (increase beta)
	external List<num> get keysLeft;
	external set keysLeft(List<num> value);
	
	/// Defines the list of key codes associated with the right action (decrease beta)
	external List<num> get keysRight;
	external set keysRight(List<num> value);
	
	/// Defines the list of key codes associated with the reset action.
	/// Those keys reset the camera to its last stored state (with the method camera.storeState())
	external List<num> get keysReset;
	external set keysReset(List<num> value);
	
	/// Defines the panning sensibility of the inputs.
	/// (How fast is the camera panning)
	external num get panningSensibility;
	external set panningSensibility(num value);
	
	/// Defines the zooming sensibility of the inputs.
	/// (How fast is the camera zooming)
	external num get zoomingSensibility;
	external set zoomingSensibility(num value);
	
	/// Defines whether maintaining the alt key down switch the movement mode from
	/// orientation to zoom.
	external bool get useAltToZoom;
	external set useAltToZoom(bool value);
	
	/// Rotation speed of the camera
	external num get angularSpeed;
	external set angularSpeed(num value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Manage the mouse wheel inputs to control an arc rotate camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {
	external factory ArcRotateCameraMouseWheelInput();
	
	/* Manual Fix 11 */
	
	/// Defines the camera the input is attached to.
	@override
	external ArcRotateCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Gets or Set the mouse wheel precision or how fast is the camera zooming.
	external num get wheelPrecision;
	external set wheelPrecision(num value);
	
	/// wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
	/// It defines the percentage of current camera.radius to use as delta when wheel is used.
	external num get wheelDeltaPercentage;
	external set wheelDeltaPercentage(num value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Default Inputs manager for the ArcRotateCamera.
/// It groups all the default supported inputs for ease of use.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {
	
	/// Instantiates a new ArcRotateCameraInputsManager.
	/// @param camera Defines the camera the inputs belong to
	external factory ArcRotateCameraInputsManager(ArcRotateCamera camera);
	
	/// Add mouse wheel input support to the input manager.
	/// @returns the current input manager
	external ArcRotateCameraInputsManager addMouseWheel();
	
	/// Add pointers input support to the input manager.
	/// @returns the current input manager
	external ArcRotateCameraInputsManager addPointers();
	
	/// Add keyboard input support to the input manager.
	/// @returns the current input manager
	external ArcRotateCameraInputsManager addKeyboard();
	
	/// Add orientation input support to the input manager.
	/// @returns the current input manager
	external ArcRotateCameraInputsManager addVRDeviceOrientation();
	
	/// Adds gamepad input support to the ArcRotateCamera InputManager.
	/// @returns the camera inputs manager
	external ArcRotateCameraInputsManager addGamepad();
}

/// This represents an orbital type of camera.
/// 
/// This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.
/// Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.
/// @see https://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera
@JS()
class ArcRotateCamera extends TargetCamera {
	
	/// Instantiates a new ArcRotateCamera in a given scene
	/// @param name Defines the name of the camera
	/// @param alpha Defines the camera rotation along the logitudinal axis
	/// @param beta Defines the camera rotation along the latitudinal axis
	/// @param radius Defines the camera distance from its target
	/// @param target Defines the camera target
	/// @param scene Defines the scene the camera belongs to
	/// @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
	external factory ArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, Scene scene, [bool? setActiveOnSceneIfNoneActive]);
	
	/// Defines the rotation angle of the camera along the longitudinal axis.
	external num get alpha;
	external set alpha(num value);
	
	/// Defines the rotation angle of the camera along the latitudinal axis.
	external num get beta;
	external set beta(num value);
	
	/// Defines the radius of the camera from it s target point.
	external num get radius;
	external set radius(num value);
	
	/// Defines the target point of the camera.
	/// The camera looks towards it form the radius distance.
	/// Please note that you can set the target to a mesh and thus the target will be copied from mesh.position
	@override
	external Vector3 get target;
	
	@override
	external set target(Vector3 value);
	
	/// Define the current local position of the camera in the scene
	@override
	external Vector3 get position;
	
	@override
	external set position(Vector3 value);
	
	/// The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
	/// Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.
	/// DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.
	@override
	external set upVector(Vector3 value);
	
	@override
	external Vector3 get upVector;
	
	/// Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.
	external void setMatUp();
	
	/// Current inertia value on the longitudinal axis.
	/// The bigger this number the longer it will take for the camera to stop.
	external num get inertialAlphaOffset;
	external set inertialAlphaOffset(num value);
	
	/// Current inertia value on the latitudinal axis.
	/// The bigger this number the longer it will take for the camera to stop.
	external num get inertialBetaOffset;
	external set inertialBetaOffset(num value);
	
	/// Current inertia value on the radius axis.
	/// The bigger this number the longer it will take for the camera to stop.
	external num get inertialRadiusOffset;
	external set inertialRadiusOffset(num value);
	
	/// Minimum allowed angle on the longitudinal axis.
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get lowerAlphaLimit;
	external set lowerAlphaLimit(num? value);
	
	/// Maximum allowed angle on the longitudinal axis.
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get upperAlphaLimit;
	external set upperAlphaLimit(num? value);
	
	/// Minimum allowed angle on the latitudinal axis.
	/// This can help limiting how the Camera is able to move in the scene.
	external num get lowerBetaLimit;
	external set lowerBetaLimit(num value);
	
	/// Maximum allowed angle on the latitudinal axis.
	/// This can help limiting how the Camera is able to move in the scene.
	external num get upperBetaLimit;
	external set upperBetaLimit(num value);
	
	/// Minimum allowed distance of the camera to the target (The camera can not get closer).
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get lowerRadiusLimit;
	external set lowerRadiusLimit(num? value);
	
	/// Maximum allowed distance of the camera to the target (The camera can not get further).
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get upperRadiusLimit;
	external set upperRadiusLimit(num? value);
	
	/// Defines the current inertia value used during panning of the camera along the X axis.
	external num get inertialPanningX;
	external set inertialPanningX(num value);
	
	/// Defines the current inertia value used during panning of the camera along the Y axis.
	external num get inertialPanningY;
	external set inertialPanningY(num value);
	
	/// Defines the distance used to consider the camera in pan mode vs pinch/zoom.
	/// Basically if your fingers moves away from more than this distance you will be considered
	/// in pinch mode.
	external num get pinchToPanMaxDistance;
	external set pinchToPanMaxDistance(num value);
	
	/// Defines the maximum distance the camera can pan.
	/// This could help keeping the cammera always in your scene.
	external num? get panningDistanceLimit;
	external set panningDistanceLimit(num? value);
	
	/// Defines the target of the camera before paning.
	external Vector3 get panningOriginTarget;
	external set panningOriginTarget(Vector3 value);
	
	/// Defines the value of the inertia used during panning.
	/// 0 would mean stop inertia and one would mean no decelleration at all.
	external num get panningInertia;
	external set panningInertia(num value);
	
	/// Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
	external num get angularSensibilityX;
	
	external set angularSensibilityX(num value);
	
	/// Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
	external num get angularSensibilityY;
	
	external set angularSensibilityY(num value);
	
	/// Gets or Set the pointer pinch precision or how fast is the camera zooming.
	external num get pinchPrecision;
	
	external set pinchPrecision(num value);
	
	/// Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
	/// It will be used instead of pinchDeltaPrecision if different from 0.
	/// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
	external num get pinchDeltaPercentage;
	
	external set pinchDeltaPercentage(num value);
	
	/// Gets or Set the pointer use natural pinch zoom to override the pinch precision
	/// and pinch delta percentage.
	/// When useNaturalPinchZoom is true, multi touch zoom will zoom in such
	/// that any object in the plane at the camera's target point will scale
	/// perfectly with finger motion.
	external bool get useNaturalPinchZoom;
	
	external set useNaturalPinchZoom(bool value);
	
	/// Gets or Set the pointer panning sensibility or how fast is the camera moving.
	external num get panningSensibility;
	
	external set panningSensibility(num value);
	
	/// Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
	external List<num> get keysUp;
	
	external set keysUp(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
	external List<num> get keysDown;
	
	external set keysDown(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
	external List<num> get keysLeft;
	
	external set keysLeft(List<num> value);
	
	/// Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
	external List<num> get keysRight;
	
	external set keysRight(List<num> value);
	
	/// Gets or Set the mouse wheel precision or how fast is the camera zooming.
	external num get wheelPrecision;
	
	external set wheelPrecision(num value);
	
	/// Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
	/// It will be used instead of pinchDeltaPrecision if different from 0.
	/// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
	external num get wheelDeltaPercentage;
	
	external set wheelDeltaPercentage(num value);
	
	/// Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)
	external num get zoomOnFactor;
	external set zoomOnFactor(num value);
	
	/// Defines a screen offset for the camera position.
	external Vector2 get targetScreenOffset;
	external set targetScreenOffset(Vector2 value);
	
	/// Allows the camera to be completely reversed.
	/// If false the camera can not arrive upside down.
	external bool get allowUpsideDown;
	external set allowUpsideDown(bool value);
	
	/// Define if double tap/click is used to restore the previously saved state of the camera.
	external bool get useInputToRestoreState;
	external set useInputToRestoreState(bool value);
	
	/// Defines the input associated to the camera.
	/* Manual Fix 12 */
	@override
	external ArcRotateCameraInputsManager get inputs;
	@override
	external set inputs(CameraInputsManager<Camera> value);
	
	/// Defines the allowed panning axis.
	external Vector3 get panningAxis;
	external set panningAxis(Vector3 value);
	
	/// Gets the bouncing behavior of the camera if it has been enabled.
	/// @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
	external BouncingBehavior? get bouncingBehavior;
	
	/// Defines if the bouncing behavior of the camera is enabled on the camera.
	/// @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
	external bool get useBouncingBehavior;
	
	external set useBouncingBehavior(bool value);
	
	/// Gets the framing behavior of the camera if it has been enabled.
	/// @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
	external FramingBehavior? get framingBehavior;
	
	/// Defines if the framing behavior of the camera is enabled on the camera.
	/// @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
	external bool get useFramingBehavior;
	
	external set useFramingBehavior(bool value);
	
	/// Gets the auto rotation behavior of the camera if it has been enabled.
	/// @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
	external AutoRotationBehavior? get autoRotationBehavior;
	
	/// Defines if the auto rotation behavior of the camera is enabled on the camera.
	/// @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
	external bool get useAutoRotationBehavior;
	
	external set useAutoRotationBehavior(bool value);
	
	/// Observable triggered when the mesh target has been changed on the camera.
	external Observable<AbstractMesh?> get onMeshTargetChangedObservable;
	external set onMeshTargetChangedObservable(Observable<AbstractMesh?> value);
	
	/// Event raised when the camera is colliding with a mesh.
	external void Function(AbstractMesh collidedMesh) get onCollide;
	external set onCollide(void Function(AbstractMesh collidedMesh) value);
	
	/// Defines whether the camera should check collision with the objects oh the scene.
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this
	external bool get checkCollisions;
	external set checkCollisions(bool value);
	
	/// Defines the collision radius of the camera.
	/// This simulates a sphere around the camera.
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
	external Vector3 get collisionRadius;
	external set collisionRadius(Vector3 value);
	
	/// Stores the current state of the camera (alpha, beta, radius and target)
	/// @returns the camera itself
	@override
	external Camera storeState();
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Rebuilds angles (alpha, beta) and radius from the give position and target
	external void rebuildAnglesAndRadius();
	
	/// Use a position to define the current camera related information like alpha, beta and radius
	/// @param position Defines the position to set the camera at
	external void setPosition(Vector3 position);
	
	/// Defines the target the camera should look at.
	/// This will automatically adapt alpha beta and radius to fit within the new target.
	/// @param target Defines the new target as a Vector or a mesh
	/// @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center
	/// @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)
	@override
	external void setTarget(dynamic target, [bool? toBoundingCenter, bool? allowSamePosition]);
	
	/// Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.
	/// @param meshes Defines the mesh to zoom on
	/// @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
	external void zoomOn([List<AbstractMesh>? meshes, bool? doNotUpdateMaxZ]);
	
	/// Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
	/// The target will be changed but the radius
	/// @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on
	/// @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
	external void focusOn(dynamic meshesOrMinMaxVectorAndDistance, [bool? doNotUpdateMaxZ]);
	
	/// @override
	/// Override Camera.createRigCamera
	@override
	external Camera? createRigCamera(String name, num cameraIndex);
	
	/// Destroy the camera and release the current resources hold by it.
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/// The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.
/// @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
@JS()
class AutoRotationBehavior implements Behavior<ArcRotateCamera> {
	external factory AutoRotationBehavior();
	
	/// Sets the flag that indicates if user zooming should stop animation.
	external set zoomStopsAnimation(bool value);
	
	/// Gets the flag that indicates if user zooming should stop animation.
	external bool get zoomStopsAnimation;
	
	/// Sets the default speed at which the camera rotates around the model.
	external set idleRotationSpeed(num value);
	
	/// Gets the default speed at which the camera rotates around the model.
	external num get idleRotationSpeed;
	
	/// Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
	external set idleRotationWaitTime(num value);
	
	/// Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
	external num get idleRotationWaitTime;
	
	/// Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
	external set idleRotationSpinupTime(num value);
	
	/// Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
	external num get idleRotationSpinupTime;
	
	/// Gets a value indicating if the camera is currently rotating because of this behavior
	external bool get rotationInProgress;
	
	/// Initializes the behavior.
	@override
	external void init();
	
	/// Attaches the behavior to its arc rotate camera.
	/// @param camera Defines the camera to attach the behavior to
	@override
	external void attach(ArcRotateCamera camera);
	
	/// Detaches the behavior from its current arc rotate camera.
	@override
	external void detach();
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera
@JS()
class AttachToBoxBehavior implements Behavior<Mesh> {
	
	/// Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera
	/// @param ui The transform node that should be attched to the mesh
	external factory AttachToBoxBehavior(TransformNode ui);
	
	/// The name of the behavior
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The distance away from the face of the mesh that the UI should be attached to (default: 0.15)
	external num get distanceAwayFromFace;
	external set distanceAwayFromFace(num value);
	
	/// The distance from the bottom of the face that the UI should be attached to (default: 0.15)
	external num get distanceAwayFromBottomOfFace;
	external set distanceAwayFromBottomOfFace(num value);
	
	/// Initializes the behavior
	@override
	external void init();
	
	/// Attaches the AttachToBoxBehavior to the passed in mesh
	/// @param target The mesh that the specified node will be attached to
	@override
	external void attach(Mesh target);
	
	/// Detaches the behavior from the mesh
	@override
	external void detach();
}

/// A behavior that when attached to a mesh will allow the mesh to fade in and out
@JS()
class FadeInOutBehavior implements Behavior<Mesh> {
	
	/// Instatiates the FadeInOutBehavior
	external factory FadeInOutBehavior();
	
	/// Time in milliseconds to delay before fading in (Default: 0)
	external num get delay;
	external set delay(num value);
	
	/// Time in milliseconds for the mesh to fade in (Default: 300)
	external num get fadeInTime;
	external set fadeInTime(num value);
	
	/// Initializes the behavior
	@override
	external void init();
	
	/// Attaches the fade behavior on the passed in mesh
	/// @param ownerNode The mesh that will be faded in/out once attached
	@override
	external void attach(Mesh ownerNode);
	
	/// Detaches the behavior from the mesh
	@override
	external void detach();
	
	/// Triggers the mesh to begin fading in or out
	/// @param value if the object should fade in or out (true to fade in)
	external void fadeIn(bool value);
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// Class containing a set of static utilities functions for managing Pivots
/// @hidden
@JS()
class PivotTools {
	external factory PivotTools();
}

/// Class containing static functions to help procedurally build meshes
@JS()
class PlaneBuilder {
	external factory PlaneBuilder();
	
	/// Creates a plane mesh
	/// * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
	/// * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
	/// * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the plane mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#plane
	external static Mesh CreatePlane(String name, PlaneBuilderCreatePlaneOptions options, [Scene? scene]);
}

/// A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events
@JS()
class PointerDragBehavior implements Behavior<AbstractMesh> {
	
	/// Creates a pointer drag behavior that can be attached to a mesh
	/// @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
	external factory PointerDragBehavior([PointerDragBehaviorConstructorOptions? options]);
	
	/// Abstract mesh the behavior is set on
	external AbstractMesh get attachedNode;
	external set attachedNode(AbstractMesh value);
	
	/// The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)
	external num get maxDragAngle;
	external set maxDragAngle(num value);
	
	/// The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
	external num get currentDraggingPointerID;
	external set currentDraggingPointerID(num value);
	
	/// The last position where the pointer hit the drag plane in world space
	external Vector3 get lastDragPosition;
	external set lastDragPosition(Vector3 value);
	
	/// If the behavior is currently in a dragging state
	external bool get dragging;
	external set dragging(bool value);
	
	/// The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
	external num get dragDeltaRatio;
	external set dragDeltaRatio(num value);
	
	/// If the drag plane orientation should be updated during the dragging (Default: true)
	external bool get updateDragPlane;
	external set updateDragPlane(bool value);
	
	/// Fires each time the attached mesh is dragged with the pointer
	/// * delta between last drag position and current drag position in world space
	/// * dragDistance along the drag axis
	/// * dragPlaneNormal normal of the current drag plane used during the drag
	/// * dragPlanePoint in world space where the drag intersects the drag plane
	external Observable<PointerDragBehaviorOnDragObservable> get onDragObservable;
	external set onDragObservable(Observable<PointerDragBehaviorOnDragObservable> value);
	
	/// Fires each time a drag begins (eg. mouse down on mesh)
	external Observable<PointerDragBehaviorOnDragStartObservable> get onDragStartObservable;
	external set onDragStartObservable(Observable<PointerDragBehaviorOnDragStartObservable> value);
	
	/// Fires each time a drag ends (eg. mouse release after drag)
	external Observable<PointerDragBehaviorOnDragEndObservable> get onDragEndObservable;
	external set onDragEndObservable(Observable<PointerDragBehaviorOnDragEndObservable> value);
	
	/// If the attached mesh should be moved when dragged
	external bool get moveAttached;
	external set moveAttached(bool value);
	
	/// If the drag behavior will react to drag events (Default: true)
	external bool get enabled;
	external set enabled(bool value);
	
	/// If pointer events should start and release the drag (Default: true)
	external bool get startAndReleaseDragOnPointerEvents;
	external set startAndReleaseDragOnPointerEvents(bool value);
	
	/// If camera controls should be detached during the drag
	external bool get detachCameraControls;
	external set detachCameraControls(bool value);
	
	/// If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)
	external bool get useObjectOrientationForDragging;
	external set useObjectOrientationForDragging(bool value);
	
	/// Gets the options used by the behavior
	external PointerDragBehaviorOptions get options;
	
	/// Sets the options used by the behavior
	/* Manual Fix 28 */
	external set options(PointerDragBehaviorOptions value);
	
	/// Predicate to determine if it is valid to move the object to a new position when it is moved
	external bool Function(Vector3 targetPosition) get validateDrag;
	external set validateDrag(bool Function(Vector3 targetPosition) value);
	
	/// Initializes the behavior
	@override
	external void init();
	
	/// Attaches the drag behavior the passed in mesh
	/// @param ownerNode The mesh that will be dragged around once attached
	/// @param predicate Predicate to use for pick filtering
	@override
	external void attach(AbstractMesh ownerNode, [bool Function(AbstractMesh m)? predicate]);
	
	/// Force relase the drag action by code.
	external void releaseDrag();
	
	/// Simulates the start of a pointer drag event on the behavior
	/// @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
	/// @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
	/// @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
	external void startDrag([num? pointerId, Ray? fromRay, Vector3? startPickedPoint]);
	
	/// Detaches the behavior from the mesh
	@override
	external void detach();
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// A behavior that when attached to a mesh will allow the mesh to be scaled
@JS()
class MultiPointerScaleBehavior implements Behavior<Mesh> {
	
	/// Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled
	external factory MultiPointerScaleBehavior();
	
	/// Initializes the behavior
	@override
	external void init();
	
	/// Attaches the scale behavior the passed in mesh
	/// @param ownerNode The mesh that will be scaled around once attached
	@override
	external void attach(Mesh ownerNode);
	
	/// Detaches the behavior from the mesh
	@override
	external void detach();
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
@JS()
class SixDofDragBehavior implements Behavior<Mesh> {
	
	/// Instantiates a behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
	external factory SixDofDragBehavior();
	
	/// If the object should rotate to face the drag origin
	external bool get rotateDraggedObject;
	external set rotateDraggedObject(bool value);
	
	/// If the behavior is currently in a dragging state
	external bool get dragging;
	external set dragging(bool value);
	
	/// The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
	external num get dragDeltaRatio;
	external set dragDeltaRatio(num value);
	
	/// The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
	external num get currentDraggingPointerID;
	external set currentDraggingPointerID(num value);
	
	/// If camera controls should be detached during the drag
	external bool get detachCameraControls;
	external set detachCameraControls(bool value);
	
	/// Fires each time a drag starts
	external Observable<dynamic /* object */> get onDragStartObservable;
	external set onDragStartObservable(Observable<dynamic /* object */> value);
	
	/// Fires each time a drag happens
	external Observable<void> get onDragObservable;
	external set onDragObservable(Observable<void> value);
	
	/// Fires each time a drag ends (eg. mouse release after drag)
	external Observable<dynamic /* object */> get onDragEndObservable;
	external set onDragEndObservable(Observable<dynamic /* object */> value);
	
	/// Initializes the behavior
	@override
	external void init();
	
	/// Attaches the scale behavior the passed in mesh
	/// @param ownerNode The mesh that will be scaled around once attached
	@override
	external void attach(Mesh ownerNode);
	
	/// Detaches the behavior from the mesh
	@override
	external void detach();
	
	/// gets or sets behavior's name
	external String get name;
	external set name(String value);
}

/// Class used to apply inverse kinematics to bones
/// @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller
@JS()
class BoneIKController {
	
	/// Creates a new BoneIKController
	/// @param mesh defines the mesh to control
	/// @param bone defines the bone to control
	/// @param options defines options to set up the controller
	external factory BoneIKController(AbstractMesh mesh, Bone bone, [BoneIKControllerConstructorOptions? options]);
	
	/// Gets or sets the target mesh
	external AbstractMesh get targetMesh;
	external set targetMesh(AbstractMesh value);
	
	/// Gets or sets the mesh used as pole
	external AbstractMesh get poleTargetMesh;
	external set poleTargetMesh(AbstractMesh value);
	
	/// Gets or sets the bone used as pole
	external Bone? get poleTargetBone;
	external set poleTargetBone(Bone? value);
	
	/// Gets or sets the target position
	external Vector3 get targetPosition;
	external set targetPosition(Vector3 value);
	
	/// Gets or sets the pole target position
	external Vector3 get poleTargetPosition;
	external set poleTargetPosition(Vector3 value);
	
	/// Gets or sets the pole target local offset
	external Vector3 get poleTargetLocalOffset;
	external set poleTargetLocalOffset(Vector3 value);
	
	/// Gets or sets the pole angle
	external num get poleAngle;
	external set poleAngle(num value);
	
	/// Gets or sets the mesh associated with the controller
	external AbstractMesh get mesh;
	external set mesh(AbstractMesh value);
	
	/// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
	external num get slerpAmount;
	external set slerpAmount(num value);
	
	/// Gets or sets maximum allowed angle
	external num get maxAngle;
	
	external set maxAngle(num value);
	
	/// Force the controller to update the bones
	external void update();
}

/// Class used to make a bone look toward a point in space
/// @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller
@JS()
class BoneLookController {
	
	/// Create a BoneLookController
	/// @param mesh the mesh that the bone belongs to
	/// @param bone the bone that will be looking to the target
	/// @param target the target Vector3 to look at
	/// @param options optional settings:
	/// * maxYaw: the maximum angle the bone will yaw to
	/// * minYaw: the minimum angle the bone will yaw to
	/// * maxPitch: the maximum angle the bone will pitch to
	/// * minPitch: the minimum angle the bone will yaw to
	/// * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.
	/// * upAxis: the up axis of the coordinate system
	/// * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.
	/// * yawAxis: set yawAxis if the bone does not yaw on the y axis
	/// * pitchAxis: set pitchAxis if the bone does not pitch on the x axis
	/// * adjustYaw: used to make an adjustment to the yaw of the bone
	/// * adjustPitch: used to make an adjustment to the pitch of the bone
	/// * adjustRoll: used to make an adjustment to the roll of the bone
	/// 
	external factory BoneLookController(AbstractMesh mesh, Bone bone, Vector3 target, [BoneLookControllerConstructorOptions? options]);
	
	/// The target Vector3 that the bone will look at
	external Vector3 get target;
	external set target(Vector3 value);
	
	/// The mesh that the bone is attached to
	external AbstractMesh get mesh;
	external set mesh(AbstractMesh value);
	
	/// The bone that will be looking to the target
	external Bone get bone;
	external set bone(Bone value);
	
	/// The up axis of the coordinate system that is used when the bone is rotated
	external Vector3 get upAxis;
	external set upAxis(Vector3 value);
	
	/// The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD
	external int get upAxisSpace;
	external set upAxisSpace(int value);
	
	/// Used to make an adjustment to the yaw of the bone
	external num get adjustYaw;
	external set adjustYaw(num value);
	
	/// Used to make an adjustment to the pitch of the bone
	external num get adjustPitch;
	external set adjustPitch(num value);
	
	/// Used to make an adjustment to the roll of the bone
	external num get adjustRoll;
	external set adjustRoll(num value);
	
	/// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
	external num get slerpAmount;
	external set slerpAmount(num value);
	
	/// Gets or sets the minimum yaw angle that the bone can look to
	external num get minYaw;
	
	external set minYaw(num value);
	
	/// Gets or sets the maximum yaw angle that the bone can look to
	external num get maxYaw;
	
	external set maxYaw(num value);
	
	/// Gets or sets the minimum pitch angle that the bone can look to
	external num get minPitch;
	
	external set minPitch(num value);
	
	/// Gets or sets the maximum pitch angle that the bone can look to
	external num get maxPitch;
	
	external set maxPitch(num value);
	
	/// Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
	external void update();
}

/// Manage the gamepad inputs to control an arc rotate camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {
	external factory ArcRotateCameraGamepadInput();
	
	/* Manual Fix 11 */
	
	/// Defines the camera the input is attached to.
	@override
	external ArcRotateCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines the gamepad the input is gathering event from.
	external Gamepad? get gamepad;
	external set gamepad(Gamepad? value);
	
	/// Defines the gamepad rotation sensiblity.
	/// This is the threshold from when rotation starts to be accounted for to prevent jittering.
	external num get gamepadRotationSensibility;
	external set gamepadRotationSensibility(num value);
	
	/// Defines the gamepad move sensiblity.
	/// This is the threshold from when moving starts to be accounted for for to prevent jittering.
	external num get gamepadMoveSensibility;
	external set gamepadMoveSensibility(num value);
	
	/// Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
	external bool get invertYAxis;
	
	external set invertYAxis(bool value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Manage the device orientation inputs (gyroscope) to control an arc rotate camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class ArcRotateCameraVRDeviceOrientationInput implements ICameraInput<ArcRotateCamera> {
	
	/// Instantiate a new ArcRotateCameraVRDeviceOrientationInput.
	external factory ArcRotateCameraVRDeviceOrientationInput();
	
	/* Manual Fix 11 */
	
	/// Defines the camera the input is attached to.
	@override
	external ArcRotateCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines a correction factor applied on the alpha value retrieved from the orientation events.
	external num get alphaCorrection;
	external set alphaCorrection(num value);
	
	/// Defines a correction factor applied on the gamma value retrieved from the orientation events.
	external num get gammaCorrection;
	external set gammaCorrection(num value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Listen to mouse events to control the camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FlyCameraMouseInput implements ICameraInput<FlyCamera> {
	
	/// Listen to mouse events to control the camera.
	/// @param touchEnabled Define if touch is enabled. (Default is true.)
	/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
	external factory FlyCameraMouseInput([bool? touchEnabled]);
	
	/// Defines the camera the input is attached to.
	@override
	external FlyCamera? get camera;
	@override
	external set camera(FlyCamera? value);
	
	/// Defines if touch is enabled. (Default is true.)
	external bool get touchEnabled;
	external set touchEnabled(bool value);
	
	/// Defines the buttons associated with the input to handle camera rotation.
	external List<num> get buttons;
	external set buttons(List<num> value);
	
	/// Assign buttons for Yaw control.
	external List<num> get buttonsYaw;
	external set buttonsYaw(List<num> value);
	
	/// Assign buttons for Pitch control.
	external List<num> get buttonsPitch;
	external set buttonsPitch(List<num> value);
	
	/// Assign buttons for Roll control.
	external List<num> get buttonsRoll;
	external set buttonsRoll(List<num> value);
	
	/// Detect if any button is being pressed while mouse is moved.
	/// -1 = Mouse locked.
	/// 0 = Left button.
	/// 1 = Middle Button.
	/// 2 = Right Button.
	external num get activeButton;
	external set activeButton(num value);
	
	/// Defines the pointer's angular sensibility, to control the camera rotation speed.
	/// Higher values reduce its sensitivity.
	external num get angularSensibility;
	external set angularSensibility(num value);
	
	/// Attach the mouse control to the HTML DOM element.
	/// @param noPreventDefault Defines whether events caught by the controls should call preventdefault().
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current input.
	/// @returns the class name.
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input's friendly name.
	@override
	external String getSimpleName();
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Default Inputs manager for the FlyCamera.
/// It groups all the default supported inputs for ease of use.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FlyCameraInputsManager extends CameraInputsManager<FlyCamera> {
	
	/// Instantiates a new FlyCameraInputsManager.
	/// @param camera Defines the camera the inputs belong to.
	external factory FlyCameraInputsManager(FlyCamera camera);
	
	/// Add keyboard input support to the input manager.
	/// @returns the new FlyCameraKeyboardMoveInput().
	external FlyCameraInputsManager addKeyboard();
	
	/// Add mouse input support to the input manager.
	/// @param touchEnabled Enable touch screen support.
	/// @returns the new FlyCameraMouseInput().
	external FlyCameraInputsManager addMouse([bool? touchEnabled]);
}

/// This is a flying camera, designed for 3D movement and rotation in all directions,
/// such as in a 3D Space Shooter or a Flight Simulator.
@JS()
class FlyCamera extends TargetCamera {
	
	/// Instantiates a FlyCamera.
	/// This is a flying camera, designed for 3D movement and rotation in all directions,
	/// such as in a 3D Space Shooter or a Flight Simulator.
	/// @param name Define the name of the camera in the scene.
	/// @param position Define the starting position of the camera in the scene.
	/// @param scene Define the scene the camera belongs to.
	/// @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active, if no other camera has been defined as active.
	external factory FlyCamera(String name, Vector3 position, Scene scene, [bool? setActiveOnSceneIfNoneActive]);
	
	/// Define the collision ellipsoid of the camera.
	/// This is helpful for simulating a camera body, like a player's body.
	/// @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
	external Vector3 get ellipsoid;
	external set ellipsoid(Vector3 value);
	
	/// Define an offset for the position of the ellipsoid around the camera.
	/// This can be helpful if the camera is attached away from the player's body center,
	/// such as at its head.
	external Vector3 get ellipsoidOffset;
	external set ellipsoidOffset(Vector3 value);
	
	/// Enable or disable collisions of the camera with the rest of the scene objects.
	external bool get checkCollisions;
	external set checkCollisions(bool value);
	
	/// Enable or disable gravity on the camera.
	external bool get applyGravity;
	external set applyGravity(bool value);
	
	/// Define the current direction the camera is moving to.
	@override
	external Vector3 get cameraDirection;
	@override
	external set cameraDirection(Vector3 value);
	
	/// Define the current local rotation of the camera as a quaternion to prevent Gimbal lock.
	/// This overrides and empties cameraRotation.
	@override
	external Quaternion get rotationQuaternion;
	@override
	external set rotationQuaternion(Quaternion value);
	
	/// Slowly correct the Roll to its original value after a Pitch+Yaw rotation.
	external num get rollCorrect;
	external set rollCorrect(num value);
	
	/// Mimic a banked turn, Rolling the camera when Yawing.
	/// It's recommended to use rollCorrect = 10 for faster banking correction.
	external bool get bankedTurn;
	external set bankedTurn(bool value);
	
	/// Limit in radians for how much Roll banking will add. (Default: 90°)
	external num get bankedTurnLimit;
	external set bankedTurnLimit(num value);
	
	/// Value of 0 disables the banked Roll.
	/// Value of 1 is equal to the Yaw angle in radians.
	external num get bankedTurnMultiplier;
	external set bankedTurnMultiplier(num value);
	
	/// The inputs manager loads all the input sources, such as keyboard and mouse.
	/* Manual Fix 13 */
	@override
	external FlyCameraInputsManager get inputs;
	@override
	external set inputs(CameraInputsManager<Camera> value);
	
	/// Gets the input sensibility for mouse input.
	/// Higher values reduce sensitivity.
	external num get angularSensibility;
	
	/// Sets the input sensibility for a mouse input.
	/// Higher values reduce sensitivity.
	external set angularSensibility(num value);
	
	/// Get the keys for camera movement forward.
	external List<num> get keysForward;
	
	/// Set the keys for camera movement forward.
	external set keysForward(List<num> value);
	
	/// Get the keys for camera movement backward.
	external List<num> get keysBackward;
	
	external set keysBackward(List<num> value);
	
	/// Get the keys for camera movement up.
	external List<num> get keysUp;
	
	/// Set the keys for camera movement up.
	external set keysUp(List<num> value);
	
	/// Get the keys for camera movement down.
	external List<num> get keysDown;
	
	/// Set the keys for camera movement down.
	external set keysDown(List<num> value);
	
	/// Get the keys for camera movement left.
	external List<num> get keysLeft;
	
	/// Set the keys for camera movement left.
	external set keysLeft(List<num> value);
	
	/// Set the keys for camera movement right.
	external List<num> get keysRight;
	
	/// Set the keys for camera movement right.
	external set keysRight(List<num> value);
	
	/// Event raised when the camera collides with a mesh in the scene.
	external void Function(AbstractMesh collidedMesh) get onCollide;
	external set onCollide(void Function(AbstractMesh collidedMesh) value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach a control from the HTML DOM element.
	/// The camera will stop reacting to that input.
	@override
	external void detachControl();
	
	/// Get the mask that the camera ignores in collision events.
	external num get collisionMask;
	
	/// Set the mask that the camera ignores in collision events.
	external set collisionMask(num value);
	
	/// Restore the Roll to its target value at the rate specified.
	/// @param rate - Higher means slower restoring.
	/// @hidden
	external void restoreRoll(num rate);
	
	/// Destroy the camera and release the current resources held by it.
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Get the current object class name.
	/// @returns the class name.
	@override
	external String getClassName();
}

/// Listen to keyboard events to control the camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FlyCameraKeyboardInput implements ICameraInput<FlyCamera> {
	external factory FlyCameraKeyboardInput();
	
	/// Defines the camera the input is attached to.
	@override
	external FlyCamera? get camera;
	@override
	external set camera(FlyCamera? value);
	
	/// The list of keyboard keys used to control the forward move of the camera.
	external List<num> get keysForward;
	external set keysForward(List<num> value);
	
	/// The list of keyboard keys used to control the backward move of the camera.
	external List<num> get keysBackward;
	external set keysBackward(List<num> value);
	
	/// The list of keyboard keys used to control the forward move of the camera.
	external List<num> get keysUp;
	external set keysUp(List<num> value);
	
	/// The list of keyboard keys used to control the backward move of the camera.
	external List<num> get keysDown;
	external set keysDown(List<num> value);
	
	/// The list of keyboard keys used to control the right strafe move of the camera.
	external List<num> get keysRight;
	external set keysRight(List<num> value);
	
	/// The list of keyboard keys used to control the left strafe move of the camera.
	external List<num> get keysLeft;
	external set keysLeft(List<num> value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Manage the mouse wheel inputs to control a follow camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FollowCameraMouseWheelInput implements ICameraInput<FollowCamera> {
	external factory FollowCameraMouseWheelInput();
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 14 */
	@override
	external FollowCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)
	external bool get axisControlRadius;
	external set axisControlRadius(bool value);
	
	/// Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)
	external bool get axisControlHeight;
	external set axisControlHeight(bool value);
	
	/// Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)
	external bool get axisControlRotation;
	external set axisControlRotation(bool value);
	
	/// Gets or Set the mouse wheel precision or how fast is the camera moves in
	/// relation to mouseWheel events.
	external num get wheelPrecision;
	external set wheelPrecision(num value);
	
	/// wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
	/// It defines the percentage of current camera.radius to use as delta when wheel is used.
	external num get wheelDeltaPercentage;
	external set wheelDeltaPercentage(num value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Manage the pointers inputs to control an follow camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FollowCameraPointersInput extends BaseCameraPointersInput {
	external factory FollowCameraPointersInput();
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 14 */
	@override
	external FollowCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Gets the class name of the current input.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Defines the pointer angular sensibility along the X axis or how fast is
	/// the camera rotating.
	/// A negative number will reverse the axis direction.
	external num get angularSensibilityX;
	external set angularSensibilityX(num value);
	
	/// Defines the pointer angular sensibility along the Y axis or how fast is
	/// the camera rotating.
	/// A negative number will reverse the axis direction.
	external num get angularSensibilityY;
	external set angularSensibilityY(num value);
	
	/// Defines the pointer pinch precision or how fast is the camera zooming.
	/// A negative number will reverse the axis direction.
	external num get pinchPrecision;
	external set pinchPrecision(num value);
	
	/// pinchDeltaPercentage will be used instead of pinchPrecision if different
	/// from 0.
	/// It defines the percentage of current camera.radius to use as delta when
	/// pinch zoom is used.
	external num get pinchDeltaPercentage;
	external set pinchDeltaPercentage(num value);
	
	/// Pointer X axis controls zoom. (X axis modifies camera.radius value.)
	external bool get axisXControlRadius;
	external set axisXControlRadius(bool value);
	
	/// Pointer X axis controls height. (X axis modifies camera.heightOffset value.)
	external bool get axisXControlHeight;
	external set axisXControlHeight(bool value);
	
	/// Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)
	external bool get axisXControlRotation;
	external set axisXControlRotation(bool value);
	
	/// Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)
	external bool get axisYControlRadius;
	external set axisYControlRadius(bool value);
	
	/// Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)
	external bool get axisYControlHeight;
	external set axisYControlHeight(bool value);
	
	/// Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)
	external bool get axisYControlRotation;
	external set axisYControlRotation(bool value);
	
	/// Pinch controls zoom. (Pinch modifies camera.radius value.)
	external bool get axisPinchControlRadius;
	external set axisPinchControlRadius(bool value);
	
	/// Pinch controls height. (Pinch modifies camera.heightOffset value.)
	external bool get axisPinchControlHeight;
	external set axisPinchControlHeight(bool value);
	
	/// Pinch controls angle. (Pinch modifies camera.rotationOffset value.)
	external bool get axisPinchControlRotation;
	external set axisPinchControlRotation(bool value);
	
	/// Log error messages if basic misconfiguration has occurred.
	external bool get warningEnable;
	external set warningEnable(bool value);
	
	@override
	external void onTouch(PointerTouch? pointA, num offsetX, num offsetY);
	
	@override
	external void onMultiTouch(PointerTouch? pointA, PointerTouch? pointB, num previousPinchSquaredDistance, num pinchSquaredDistance, PointerTouch? previousMultiTouchPanPosition, PointerTouch? multiTouchPanPosition);
	
	/// Update the current camera state depending on the inputs that have been used this frame.
	/// This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
	external void Function() get checkInputs;
	external set checkInputs(void Function() value);
}

/// Default Inputs manager for the FollowCamera.
/// It groups all the default supported inputs for ease of use.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FollowCameraInputsManager extends CameraInputsManager<FollowCamera> {
	
	/// Instantiates a new FollowCameraInputsManager.
	/// @param camera Defines the camera the inputs belong to
	external factory FollowCameraInputsManager(FollowCamera camera);
	
	/// Add keyboard input support to the input manager.
	/// @returns the current input manager
	external FollowCameraInputsManager addKeyboard();
	
	/// Add mouse wheel input support to the input manager.
	/// @returns the current input manager
	external FollowCameraInputsManager addMouseWheel();
	
	/// Add pointers input support to the input manager.
	/// @returns the current input manager
	external FollowCameraInputsManager addPointers();
	
	/// Add orientation input support to the input manager.
	/// @returns the current input manager
	external FollowCameraInputsManager addVRDeviceOrientation();
}

/// A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and
/// an arc rotate version arcFollowCamera are available.
/// @see https://doc.babylonjs.com/features/cameras#follow-camera
@JS()
class FollowCamera extends TargetCamera {
	
	/// Instantiates the follow camera.
	/// @see https://doc.babylonjs.com/features/cameras#follow-camera
	/// @param name Define the name of the camera in the scene
	/// @param position Define the position of the camera
	/// @param scene Define the scene the camera belong to
	/// @param lockedTarget Define the target of the camera
	external factory FollowCamera(String name, Vector3 position, Scene scene, [AbstractMesh? lockedTarget]);
	
	/// Distance the follow camera should follow an object at
	external num get radius;
	external set radius(num value);
	
	/// Minimum allowed distance of the camera to the axis of rotation
	/// (The camera can not get closer).
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get lowerRadiusLimit;
	external set lowerRadiusLimit(num? value);
	
	/// Maximum allowed distance of the camera to the axis of rotation
	/// (The camera can not get further).
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get upperRadiusLimit;
	external set upperRadiusLimit(num? value);
	
	/// Define a rotation offset between the camera and the object it follows
	external num get rotationOffset;
	external set rotationOffset(num value);
	
	/// Minimum allowed angle to camera position relative to target object.
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get lowerRotationOffsetLimit;
	external set lowerRotationOffsetLimit(num? value);
	
	/// Maximum allowed angle to camera position relative to target object.
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get upperRotationOffsetLimit;
	external set upperRotationOffsetLimit(num? value);
	
	/// Define a height offset between the camera and the object it follows.
	/// It can help following an object from the top (like a car chaing a plane)
	external num get heightOffset;
	external set heightOffset(num value);
	
	/// Minimum allowed height of camera position relative to target object.
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get lowerHeightOffsetLimit;
	external set lowerHeightOffsetLimit(num? value);
	
	/// Maximum allowed height of camera position relative to target object.
	/// This can help limiting how the Camera is able to move in the scene.
	external num? get upperHeightOffsetLimit;
	external set upperHeightOffsetLimit(num? value);
	
	/// Define how fast the camera can accelerate to follow it s target.
	external num get cameraAcceleration;
	external set cameraAcceleration(num value);
	
	/// Define the speed limit of the camera following an object.
	external num get maxCameraSpeed;
	external set maxCameraSpeed(num value);
	
	/// Define the target of the camera.
	@override
	external AbstractMesh? get lockedTarget;
	@override
	/* Manual Fix 23 */
	external set lockedTarget(dynamic? value);
	
	/// Defines the input associated with the camera.
	/* Manual Fix 15 */
	@override
	external FollowCameraInputsManager get inputs;
	@override
	external set inputs(CameraInputsManager<Camera> value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the camera class name.
	/// @returns the class name
	@override
	external String getClassName();
}

/// Arc Rotate version of the follow camera.
/// It still follows a Defined mesh but in an Arc Rotate Camera fashion.
/// @see https://doc.babylonjs.com/features/cameras#follow-camera
@JS()
class ArcFollowCamera extends TargetCamera {
	
	/// Instantiates a new ArcFollowCamera
	/// @see https://doc.babylonjs.com/features/cameras#follow-camera
	/// @param name Define the name of the camera
	/// @param alpha Define the rotation angle of the camera around the logitudinal axis
	/// @param beta Define the rotation angle of the camera around the elevation axis
	/// @param radius Define the radius of the camera from its target point
	/// @param target Define the target of the camera
	/// @param scene Define the scene the camera belongs to
	external factory ArcFollowCamera(String name, num alpha, num beta, num radius, AbstractMesh? target, Scene scene);
	
	/// The longitudinal angle of the camera
	external num get alpha;
	external set alpha(num value);
	
	/// The latitudinal angle of the camera
	external num get beta;
	external set beta(num value);
	
	/// The radius of the camera from its target
	external num get radius;
	external set radius(num value);
	
	/// Returns the class name of the object.
	/// It is mostly used internally for serialization purposes.
	@override
	external String getClassName();
}

/// Manage the keyboard inputs to control the movement of a follow camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FollowCameraKeyboardMoveInput implements ICameraInput<FollowCamera> {
	external factory FollowCameraKeyboardMoveInput();
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 14 */
	@override
	external FollowCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Defines the list of key codes associated with the up action (increase heightOffset)
	external List<num> get keysHeightOffsetIncr;
	external set keysHeightOffsetIncr(List<num> value);
	
	/// Defines the list of key codes associated with the down action (decrease heightOffset)
	external List<num> get keysHeightOffsetDecr;
	external set keysHeightOffsetDecr(List<num> value);
	
	/// Defines whether the Alt modifier key is required to move up/down (alter heightOffset)
	external bool get keysHeightOffsetModifierAlt;
	external set keysHeightOffsetModifierAlt(bool value);
	
	/// Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)
	external bool get keysHeightOffsetModifierCtrl;
	external set keysHeightOffsetModifierCtrl(bool value);
	
	/// Defines whether the Shift modifier key is required to move up/down (alter heightOffset)
	external bool get keysHeightOffsetModifierShift;
	external set keysHeightOffsetModifierShift(bool value);
	
	/// Defines the list of key codes associated with the left action (increase rotationOffset)
	external List<num> get keysRotationOffsetIncr;
	external set keysRotationOffsetIncr(List<num> value);
	
	/// Defines the list of key codes associated with the right action (decrease rotationOffset)
	external List<num> get keysRotationOffsetDecr;
	external set keysRotationOffsetDecr(List<num> value);
	
	/// Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)
	external bool get keysRotationOffsetModifierAlt;
	external set keysRotationOffsetModifierAlt(bool value);
	
	/// Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)
	external bool get keysRotationOffsetModifierCtrl;
	external set keysRotationOffsetModifierCtrl(bool value);
	
	/// Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)
	external bool get keysRotationOffsetModifierShift;
	external set keysRotationOffsetModifierShift(bool value);
	
	/// Defines the list of key codes associated with the zoom-in action (decrease radius)
	external List<num> get keysRadiusIncr;
	external set keysRadiusIncr(List<num> value);
	
	/// Defines the list of key codes associated with the zoom-out action (increase radius)
	external List<num> get keysRadiusDecr;
	external set keysRadiusDecr(List<num> value);
	
	/// Defines whether the Alt modifier key is required to zoom in/out (alter radius value)
	external bool get keysRadiusModifierAlt;
	external set keysRadiusModifierAlt(bool value);
	
	/// Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)
	external bool get keysRadiusModifierCtrl;
	external set keysRadiusModifierCtrl(bool value);
	
	/// Defines whether the Shift modifier key is required to zoom in/out (alter radius value)
	external bool get keysRadiusModifierShift;
	external set keysRadiusModifierShift(bool value);
	
	/// Defines the rate of change of heightOffset.
	external num get heightSensibility;
	external set heightSensibility(num value);
	
	/// Defines the rate of change of rotationOffset.
	external num get rotationSensibility;
	external set rotationSensibility(num value);
	
	/// Defines the rate of change of radius.
	external num get radiusSensibility;
	external set radiusSensibility(num value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	/// @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current input.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
/// Screen rotation is taken into account.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraDeviceOrientationInput implements ICameraInput<FreeCamera> {
	
	/// Instantiates a new input
	/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
	external factory FreeCameraDeviceOrientationInput();
	
	/// Can be used to detect if a device orientation sensor is available on a device
	/// @param timeout amount of time in milliseconds to wait for a response from the sensor (default: infinite)
	/// @returns a promise that will resolve on orientation change
	external static Promise<dynamic> WaitForOrientationChangeAsync([num? timeout]);
	
	/// Attach the input controls to a specific dom element to get the input from.
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	/* Manual Fix 17 */
	external set checkInputs(void Function() value);
	
	/// Defines the camera the input is attached to.
	external FreeCamera? get camera;
	external set camera(FreeCamera? value);
}

/// Manage the gamepad inputs to control a free camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {
	external factory FreeCameraGamepadInput();
	
	/// Define the camera the input is attached to.
	/* Manual Fix 16 */
	@override
	external FreeCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Define the Gamepad controlling the input
	external Gamepad? get gamepad;
	external set gamepad(Gamepad? value);
	
	/// Defines the gamepad rotation sensiblity.
	/// This is the threshold from when rotation starts to be accounted for to prevent jittering.
	external num get gamepadAngularSensibility;
	external set gamepadAngularSensibility(num value);
	
	/// Defines the gamepad move sensiblity.
	/// This is the threshold from when moving starts to be accounted for for to prevent jittering.
	external num get gamepadMoveSensibility;
	external set gamepadMoveSensibility(num value);
	
	/// Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
	external bool get invertYAxis;
	
	external set invertYAxis(bool value);
	
	/// Attach the input controls to a specific dom element to get the input from.
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/* enum */
abstract class JoystickAxis {
	
	/// X axis
	static const int X = 1;
	
	/// Y axis
	static const int Y = 2;
	
	/// Z axis
	static const int Z = 3;
}

/// Represents the different customization options available
/// for VirtualJoystick
@JS()
@anonymous
class VirtualJoystickCustomizations {
	
	external factory VirtualJoystickCustomizations({num puckSize, num containerSize, String color, String puckImage, String containerImage, VirtualJoystickCustomizationsPosition position, bool alwaysVisible, bool limitToContainer});
	
	/// Size of the joystick's puck
	external num get puckSize;
	external set puckSize( num value );
	
	/// Size of the joystick's container
	external num get containerSize;
	external set containerSize( num value );
	
	/// Color of the joystick && puck
	external String get color;
	external set color( String value );
	
	/// Image URL for the joystick's puck
	external String get puckImage;
	external set puckImage( String value );
	
	/// Image URL for the joystick's container
	external String get containerImage;
	external set containerImage( String value );
	
	/// Defines the unmoving position of the joystick container
	external VirtualJoystickCustomizationsPosition get position;
	external set position( VirtualJoystickCustomizationsPosition value );
	
	/// Defines whether or not the joystick container is always visible
	external bool get alwaysVisible;
	external set alwaysVisible( bool value );
	
	/// Defines whether or not to limit the movement of the puck to the joystick's container
	external bool get limitToContainer;
	external set limitToContainer( bool value );
}

/// Class used to define virtual joystick (used in touch mode)
@JS()
class VirtualJoystick {
	
	/// Creates a new virtual joystick
	/// @param leftJoystick defines that the joystick is for left hand (false by default)
	/// @param customizations Defines the options we want to customize the VirtualJoystick
	external factory VirtualJoystick([bool? leftJoystick, VirtualJoystickCustomizations? customizations]);
	
	/// Gets or sets a boolean indicating that left and right values must be inverted
	external bool get reverseLeftRight;
	external set reverseLeftRight(bool value);
	
	/// Gets or sets a boolean indicating that up and down values must be inverted
	external bool get reverseUpDown;
	external set reverseUpDown(bool value);
	
	/// Gets the offset value for the position (ie. the change of the position value)
	external Vector3 get deltaPosition;
	external set deltaPosition(Vector3 value);
	
	/// Gets a boolean indicating if the virtual joystick was pressed
	external bool get pressed;
	external set pressed(bool value);
	
	/// Canvas the virtual joystick will render onto, default z-index of this is 5
	external static HTML.CanvasElement? get Canvas;
	external static set Canvas(HTML.CanvasElement? value);
	
	/// boolean indicating whether or not the joystick's puck's movement should be limited to the joystick's container area
	external bool get limitToContainer;
	external set limitToContainer(bool value);
	
	/// Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)
	/// @param newJoystickSensibility defines the new sensibility
	external void setJoystickSensibility(num newJoystickSensibility);
	
	/// Change the color of the virtual joystick
	/// @param newColor a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")
	external void setJoystickColor(String newColor);
	
	/// Size of the joystick's container
	external set containerSize(num value);
	
	external num get containerSize;
	
	/// Size of the joystick's puck
	external set puckSize(num value);
	
	external num get puckSize;
	
	/// Clears the set position of the joystick
	external void clearPosition();
	
	/// Defines whether or not the joystick container is always visible
	external set alwaysVisible(bool value);
	
	external bool get alwaysVisible;
	
	/// Sets the constant position of the Joystick container
	/// @param x X axis coordinate
	/// @param y Y axis coordinate
	external void setPosition(num x, num y);
	
	/// Defines a callback to call when the joystick is touched
	/// @param action defines the callback
	external void setActionOnTouch(dynamic Function() action);
	
	/// Defines which axis you'd like to control for left & right
	/// @param axis defines the axis to use
	external void setAxisForLeftRight(int axis);
	
	/// Defines which axis you'd like to control for up & down
	/// @param axis defines the axis to use
	external void setAxisForUpDown(int axis);
	
	/// Loads `urlPath` to be used for the container's image
	/// @param urlPath defines the urlPath of an image to use
	external void setContainerImage(String urlPath);
	
	/// Loads `urlPath` to be used for the puck's image
	/// @param urlPath defines the urlPath of an image to use
	external void setPuckImage(String urlPath);
	
	/// Release internal HTML canvas
	external void releaseCanvas();
}

/// Manage the Virtual Joystick inputs to control the movement of a free camera.
/// @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
@JS()
class FreeCameraVirtualJoystickInput implements ICameraInput<FreeCamera> {
	external factory FreeCameraVirtualJoystickInput();
	
	/// Defines the camera the input is attached to.
	/* Manual Fix 16 */
	@override
	external FreeCamera? get camera;
	@override
	external set camera(Camera? value);
	
	/// Gets the left stick of the virtual joystick.
	/// @returns The virtual Joystick
	external VirtualJoystick getLeftJoystick();
	
	/// Gets the right stick of the virtual joystick.
	/// @returns The virtual Joystick
	external VirtualJoystick getRightJoystick();
	
	/// Attach the input controls to a specific dom element to get the input from.
	@override
	external void attachControl([bool? noPreventDefault]);
	
	/// Detach the current controls from the specified dom element.
	@override
	external void detachControl();
	
	/// Gets the class name of the current intput.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Get the friendly name associated with the input class.
	/// @returns the input friendly name
	@override
	external String getSimpleName();
	
	@override
	external void Function() get checkInputs;
	@override
	external set checkInputs(void Function() value);
}

/// This represents a FPS type of camera controlled by touch.
/// This is like a universal camera minus the Gamepad controls.
/// @see https://doc.babylonjs.com/features/cameras#universal-camera
@JS()
class TouchCamera extends FreeCamera {
	
	/// Instantiates a new touch camera.
	/// This represents a FPS type of camera controlled by touch.
	/// This is like a universal camera minus the Gamepad controls.
	/// @see https://doc.babylonjs.com/features/cameras#universal-camera
	/// @param name Define the name of the camera in the scene
	/// @param position Define the start position of the camera in the scene
	/// @param scene Define the scene the camera belongs to
	external factory TouchCamera(String name, Vector3 position, Scene scene);
	
	/// Defines the touch sensibility for rotation.
	/// The higher the faster.
	external num get touchAngularSensibility;
	
	external set touchAngularSensibility(num value);
	
	/// Defines the touch sensibility for move.
	/// The higher the faster.
	external num get touchMoveSensibility;
	
	external set touchMoveSensibility(num value);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/// This is a camera specifically designed to react to device orientation events such as a modern mobile device
/// being tilted forward or back and left or right.
@JS()
class DeviceOrientationCamera extends FreeCamera {
	
	/// Creates a new device orientation camera
	/// @param name The name of the camera
	/// @param position The start position camera
	/// @param scene The scene the camera belongs to
	external factory DeviceOrientationCamera(String name, Vector3 position, Scene scene);
	
	/// Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)
	external bool get disablePointerInputWhenUsingDeviceOrientation;
	
	external set disablePointerInputWhenUsingDeviceOrientation(bool value);
	
	/// Enabled turning on the y axis when the orientation sensor is active
	/// @param dragFactor the factor that controls the turn speed (default: 1/300)
	external void enableHorizontalDragging([num? dragFactor]);
	
	/// Gets the current instance class name ("DeviceOrientationCamera").
	/// This helps avoiding instanceof at run time.
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Reset the camera to its default orientation on the specified axis only.
	/// @param axis The axis to reset
	external void resetToCurrentRotation([Axis? axis]);
}

/* enum */
abstract class Xbox360Button {
	
	/// A
	static const int A = 1;
	
	/// B
	static const int B = 2;
	
	/// X
	static const int X = 3;
	
	/// Y
	static const int Y = 4;
	
	/// Left button
	static const int LB = 5;
	
	/// Right button
	static const int RB = 6;
	
	/// Back
	static const int Back = 9;
	
	/// Start
	static const int Start = 10;
	
	/// Left stick
	static const int LeftStick = 11;
	
	/// Right stick
	static const int RightStick = 12;
}

/* enum */
abstract class Xbox360Dpad {
	
	/// Up
	static const int Up = 13;
	
	/// Down
	static const int Down = 14;
	
	/// Left
	static const int Left = 15;
	
	/// Right
	static const int Right = 16;
}

/// Defines a XBox360 gamepad
@JS()
class Xbox360Pad extends Gamepad {
	
	/// Creates a new XBox360 gamepad object
	/// @param id defines the id of this gamepad
	/// @param index defines its index
	/// @param gamepad defines the internal HTML gamepad object
	/// @param xboxOne defines if it is a XBox One gamepad
	external factory Xbox360Pad(String id, num index, dynamic gamepad, [bool? xboxOne]);
	
	/// Observable raised when a button is pressed
	external Observable<int> get onButtonDownObservable;
	external set onButtonDownObservable(Observable<int> value);
	
	/// Observable raised when a button is released
	external Observable<int> get onButtonUpObservable;
	external set onButtonUpObservable(Observable<int> value);
	
	/// Observable raised when a pad is pressed
	external Observable<int> get onPadDownObservable;
	external set onPadDownObservable(Observable<int> value);
	
	/// Observable raised when a pad is released
	external Observable<int> get onPadUpObservable;
	external set onPadUpObservable(Observable<int> value);
	
	/// Defines the callback to call when left trigger is pressed
	/// @param callback defines the callback to use
	external void onlefttriggerchanged(void Function(num value) callback);
	
	/// Defines the callback to call when right trigger is pressed
	/// @param callback defines the callback to use
	external void onrighttriggerchanged(void Function(num value) callback);
	
	/// Gets the left trigger value
	external num get leftTrigger;
	
	/// Sets the left trigger value
	external set leftTrigger(num value);
	
	/// Gets the right trigger value
	external num get rightTrigger;
	
	/// Sets the right trigger value
	external set rightTrigger(num value);
	
	/// Defines the callback to call when a button is pressed
	/// @param callback defines the callback to use
	external void onbuttondown(void Function(int buttonPressed) callback);
	
	/// Defines the callback to call when a button is released
	/// @param callback defines the callback to use
	external void onbuttonup(void Function(int buttonReleased) callback);
	
	/// Defines the callback to call when a pad is pressed
	/// @param callback defines the callback to use
	external void ondpaddown(void Function(int dPadPressed) callback);
	
	/// Defines the callback to call when a pad is released
	/// @param callback defines the callback to use
	external void ondpadup(void Function(int dPadReleased) callback);
	
	/// Gets the value of the `A` button
	external num get buttonA;
	
	/// Sets the value of the `A` button
	external set buttonA(num value);
	
	/// Gets the value of the `B` button
	external num get buttonB;
	
	/// Sets the value of the `B` button
	external set buttonB(num value);
	
	/// Gets the value of the `X` button
	external num get buttonX;
	
	/// Sets the value of the `X` button
	external set buttonX(num value);
	
	/// Gets the value of the `Y` button
	external num get buttonY;
	
	/// Sets the value of the `Y` button
	external set buttonY(num value);
	
	/// Gets the value of the `Start` button
	external num get buttonStart;
	
	/// Sets the value of the `Start` button
	external set buttonStart(num value);
	
	/// Gets the value of the `Back` button
	external num get buttonBack;
	
	/// Sets the value of the `Back` button
	external set buttonBack(num value);
	
	/// Gets the value of the `Left` button
	external num get buttonLB;
	
	/// Sets the value of the `Left` button
	external set buttonLB(num value);
	
	/// Gets the value of the `Right` button
	external num get buttonRB;
	
	/// Sets the value of the `Right` button
	external set buttonRB(num value);
	
	/// Gets the value of the Left joystick
	external num get buttonLeftStick;
	
	/// Sets the value of the Left joystick
	external set buttonLeftStick(num value);
	
	/// Gets the value of the Right joystick
	external num get buttonRightStick;
	
	/// Sets the value of the Right joystick
	external set buttonRightStick(num value);
	
	/// Gets the value of D-pad up
	external num get dPadUp;
	
	/// Sets the value of D-pad up
	external set dPadUp(num value);
	
	/// Gets the value of D-pad down
	external num get dPadDown;
	
	/// Sets the value of D-pad down
	external set dPadDown(num value);
	
	/// Gets the value of D-pad left
	external num get dPadLeft;
	
	/// Sets the value of D-pad left
	external set dPadLeft(num value);
	
	/// Gets the value of D-pad right
	external num get dPadRight;
	
	/// Sets the value of D-pad right
	external set dPadRight(num value);
	
	/// Force the gamepad to synchronize with device values
	@override
	external void update();
	
	/// Disposes the gamepad
	@override
	external void dispose();
}

/* enum */
abstract class DualShockButton {
	
	/// Cross
	static const int Cross = 1;
	
	/// Circle
	static const int Circle = 2;
	
	/// Square
	static const int Square = 3;
	
	/// Triangle
	static const int Triangle = 4;
	
	/// L1
	static const int L1 = 5;
	
	/// R1
	static const int R1 = 6;
	
	/// Share
	static const int Share = 9;
	
	/// Options
	static const int Options = 10;
	
	/// Left stick
	static const int LeftStick = 11;
	
	/// Right stick
	static const int RightStick = 12;
}

/* enum */
abstract class DualShockDpad {
	
	/// Up
	static const int Up = 13;
	
	/// Down
	static const int Down = 14;
	
	/// Left
	static const int Left = 15;
	
	/// Right
	static const int Right = 16;
}

/// Defines a DualShock gamepad
@JS()
class DualShockPad extends Gamepad {
	
	/// Creates a new DualShock gamepad object
	/// @param id defines the id of this gamepad
	/// @param index defines its index
	/// @param gamepad defines the internal HTML gamepad object
	external factory DualShockPad(String id, num index, dynamic gamepad);
	
	/// Observable raised when a button is pressed
	external Observable<int> get onButtonDownObservable;
	external set onButtonDownObservable(Observable<int> value);
	
	/// Observable raised when a button is released
	external Observable<int> get onButtonUpObservable;
	external set onButtonUpObservable(Observable<int> value);
	
	/// Observable raised when a pad is pressed
	external Observable<int> get onPadDownObservable;
	external set onPadDownObservable(Observable<int> value);
	
	/// Observable raised when a pad is released
	external Observable<int> get onPadUpObservable;
	external set onPadUpObservable(Observable<int> value);
	
	/// Defines the callback to call when left trigger is pressed
	/// @param callback defines the callback to use
	external void onlefttriggerchanged(void Function(num value) callback);
	
	/// Defines the callback to call when right trigger is pressed
	/// @param callback defines the callback to use
	external void onrighttriggerchanged(void Function(num value) callback);
	
	/// Gets the left trigger value
	external num get leftTrigger;
	
	/// Sets the left trigger value
	external set leftTrigger(num value);
	
	/// Gets the right trigger value
	external num get rightTrigger;
	
	/// Sets the right trigger value
	external set rightTrigger(num value);
	
	/// Defines the callback to call when a button is pressed
	/// @param callback defines the callback to use
	external void onbuttondown(void Function(int buttonPressed) callback);
	
	/// Defines the callback to call when a button is released
	/// @param callback defines the callback to use
	external void onbuttonup(void Function(int buttonReleased) callback);
	
	/// Defines the callback to call when a pad is pressed
	/// @param callback defines the callback to use
	external void ondpaddown(void Function(int dPadPressed) callback);
	
	/// Defines the callback to call when a pad is released
	/// @param callback defines the callback to use
	external void ondpadup(void Function(int dPadReleased) callback);
	
	/// Gets the value of the `Cross` button
	external num get buttonCross;
	
	/// Sets the value of the `Cross` button
	external set buttonCross(num value);
	
	/// Gets the value of the `Circle` button
	external num get buttonCircle;
	
	/// Sets the value of the `Circle` button
	external set buttonCircle(num value);
	
	/// Gets the value of the `Square` button
	external num get buttonSquare;
	
	/// Sets the value of the `Square` button
	external set buttonSquare(num value);
	
	/// Gets the value of the `Triangle` button
	external num get buttonTriangle;
	
	/// Sets the value of the `Triangle` button
	external set buttonTriangle(num value);
	
	/// Gets the value of the `Options` button
	external num get buttonOptions;
	
	/// Sets the value of the `Options` button
	external set buttonOptions(num value);
	
	/// Gets the value of the `Share` button
	external num get buttonShare;
	
	/// Sets the value of the `Share` button
	external set buttonShare(num value);
	
	/// Gets the value of the `L1` button
	external num get buttonL1;
	
	/// Sets the value of the `L1` button
	external set buttonL1(num value);
	
	/// Gets the value of the `R1` button
	external num get buttonR1;
	
	/// Sets the value of the `R1` button
	external set buttonR1(num value);
	
	/// Gets the value of the Left joystick
	external num get buttonLeftStick;
	
	/// Sets the value of the Left joystick
	external set buttonLeftStick(num value);
	
	/// Gets the value of the Right joystick
	external num get buttonRightStick;
	
	/// Sets the value of the Right joystick
	external set buttonRightStick(num value);
	
	/// Gets the value of D-pad up
	external num get dPadUp;
	
	/// Sets the value of D-pad up
	external set dPadUp(num value);
	
	/// Gets the value of D-pad down
	external num get dPadDown;
	
	/// Sets the value of D-pad down
	external set dPadDown(num value);
	
	/// Gets the value of D-pad left
	external num get dPadLeft;
	
	/// Sets the value of D-pad left
	external set dPadLeft(num value);
	
	/// Gets the value of D-pad right
	external num get dPadRight;
	
	/// Sets the value of D-pad right
	external set dPadRight(num value);
	
	/// Force the gamepad to synchronize with device values
	@override
	external void update();
	
	/// Disposes the gamepad
	@override
	external void dispose();
}

/// Manager for handling gamepads
@JS()
class GamepadManager {
	
	/// Initializes the gamepad manager
	/// @param _scene BabylonJS scene
	external factory GamepadManager([Scene? _scene]);
	
	/// observable to be triggered when the gamepad controller has been connected
	external Observable<Gamepad> get onGamepadConnectedObservable;
	external set onGamepadConnectedObservable(Observable<Gamepad> value);
	
	/// observable to be triggered when the gamepad controller has been disconnected
	external Observable<Gamepad> get onGamepadDisconnectedObservable;
	external set onGamepadDisconnectedObservable(Observable<Gamepad> value);
	
	/// The gamepads in the game pad manager
	external List<Gamepad> get gamepads;
	
	/// Get the gamepad controllers based on type
	/// @param type The type of gamepad controller
	/// @returns Nullable gamepad
	external Gamepad? getGamepadByType([num? type]);
	
	/// Disposes the gamepad manager
	external void dispose();
}

/// Defines the gamepad scene component responsible to manage gamepads in a given scene
@JS()
class GamepadSystemSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory GamepadSystemSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/// The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
/// which still works and will still be found in many Playgrounds.
/// @see https://doc.babylonjs.com/features/cameras#universal-camera
@JS()
class UniversalCamera extends TouchCamera {
	
	/// The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
	/// which still works and will still be found in many Playgrounds.
	/// @see https://doc.babylonjs.com/features/cameras#universal-camera
	/// @param name Define the name of the camera in the scene
	/// @param position Define the start position of the camera in the scene
	/// @param scene Define the scene the camera belongs to
	external factory UniversalCamera(String name, Vector3 position, Scene scene);
	
	/// Defines the gamepad rotation sensiblity.
	/// This is the threshold from when rotation starts to be accounted for to prevent jittering.
	external num get gamepadAngularSensibility;
	
	external set gamepadAngularSensibility(num value);
	
	/// Defines the gamepad move sensiblity.
	/// This is the threshold from when moving starts to be accounted for for to prevent jittering.
	external num get gamepadMoveSensibility;
	
	external set gamepadMoveSensibility(num value);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/// This represents a FPS type of camera. This is only here for back compat purpose.
/// Please use the UniversalCamera instead as both are identical.
/// @see https://doc.babylonjs.com/features/cameras#universal-camera
@JS()
class GamepadCamera extends UniversalCamera {
	
	/// Instantiates a new Gamepad Camera
	/// This represents a FPS type of camera. This is only here for back compat purpose.
	/// Please use the UniversalCamera instead as both are identical.
	/// @see https://doc.babylonjs.com/features/cameras#universal-camera
	/// @param name Define the name of the camera in the scene
	/// @param position Define the start position of the camera in the scene
	/// @param scene Define the scene the camera belongs to
	external factory GamepadCamera(String name, Vector3 position, Scene scene);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get passPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get passCubePixelShader;

/// PassPostProcess which produces an output the same as it's input
@JS()
class PassPostProcess extends PostProcess {
	
	/// Creates the PassPostProcess
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType The type of texture to be used when performing the post processing.
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory PassPostProcess(String name, dynamic options, [Camera? camera, num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// Gets a string identifying the name of the class
	/// @returns "PassPostProcess" string
	@override
	external String getClassName();
}

/// PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)
@JS()
class PassCubePostProcess extends PostProcess {
	
	/// Creates the PassCubePostProcess
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType The type of texture to be used when performing the post processing.
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory PassCubePostProcess(String name, dynamic options, [Camera? camera, num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// Gets or sets the cube face to display.
	/// * 0 is +X
	/// * 1 is -X
	/// * 2 is +Y
	/// * 3 is -Y
	/// * 4 is +Z
	/// * 5 is -Z
	external num get face;
	
	external set face(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "PassCubePostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get anaglyphPixelShader;

/// Postprocess used to generate anaglyphic rendering
@JS()
class AnaglyphPostProcess extends PostProcess {
	
	/// Creates a new AnaglyphPostProcess
	/// @param name defines postprocess name
	/// @param options defines creation options or target ratio scale
	/// @param rigCameras defines cameras using this postprocess
	/// @param samplingMode defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)
	/// @param engine defines hosting engine
	/// @param reusable defines if the postprocess will be reused multiple times per frame
	external factory AnaglyphPostProcess(String name, dynamic options, List<Camera> rigCameras, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// Gets a string identifying the name of the class
	/// @returns "AnaglyphPostProcess" string
	@override
	external String getClassName();
}

/// Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
/// @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
@JS()
class AnaglyphArcRotateCamera extends ArcRotateCamera {
	
	/// Creates a new AnaglyphArcRotateCamera
	/// @param name defines camera name
	/// @param alpha defines alpha angle (in radians)
	/// @param beta defines beta angle (in radians)
	/// @param radius defines radius
	/// @param target defines camera target
	/// @param interaxialDistance defines distance between each color axis
	/// @param scene defines the hosting scene
	external factory AnaglyphArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, num interaxialDistance, Scene scene);
	
	/// Gets camera class name
	/// @returns AnaglyphArcRotateCamera
	@override
	external String getClassName();
}

/// Camera used to simulate anaglyphic rendering (based on FreeCamera)
/// @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
@JS()
class AnaglyphFreeCamera extends FreeCamera {
	
	/// Creates a new AnaglyphFreeCamera
	/// @param name defines camera name
	/// @param position defines initial position
	/// @param interaxialDistance defines distance between each color axis
	/// @param scene defines the hosting scene
	external factory AnaglyphFreeCamera(String name, Vector3 position, num interaxialDistance, Scene scene);
	
	/// Gets camera class name
	/// @returns AnaglyphFreeCamera
	@override
	external String getClassName();
}

/// Camera used to simulate anaglyphic rendering (based on GamepadCamera)
/// @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
@JS()
class AnaglyphGamepadCamera extends GamepadCamera {
	
	/// Creates a new AnaglyphGamepadCamera
	/// @param name defines camera name
	/// @param position defines initial position
	/// @param interaxialDistance defines distance between each color axis
	/// @param scene defines the hosting scene
	external factory AnaglyphGamepadCamera(String name, Vector3 position, num interaxialDistance, Scene scene);
	
	/// Gets camera class name
	/// @returns AnaglyphGamepadCamera
	@override
	external String getClassName();
}

/// Camera used to simulate anaglyphic rendering (based on UniversalCamera)
/// @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
@JS()
class AnaglyphUniversalCamera extends UniversalCamera {
	
	/// Creates a new AnaglyphUniversalCamera
	/// @param name defines camera name
	/// @param position defines initial position
	/// @param interaxialDistance defines distance between each color axis
	/// @param scene defines the hosting scene
	external factory AnaglyphUniversalCamera(String name, Vector3 position, num interaxialDistance, Scene scene);
	
	/// Gets camera class name
	/// @returns AnaglyphUniversalCamera
	@override
	external String getClassName();
}

/// Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
/// @see https://doc.babylonjs.com/features/cameras
@JS()
class StereoscopicArcRotateCamera extends ArcRotateCamera {
	
	/// Creates a new StereoscopicArcRotateCamera
	/// @param name defines camera name
	/// @param alpha defines alpha angle (in radians)
	/// @param beta defines beta angle (in radians)
	/// @param radius defines radius
	/// @param target defines camera target
	/// @param interaxialDistance defines distance between each color axis
	/// @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
	/// @param scene defines the hosting scene
	external factory StereoscopicArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
	
	/// Gets camera class name
	/// @returns StereoscopicArcRotateCamera
	@override
	external String getClassName();
}

/// Camera used to simulate stereoscopic rendering (based on FreeCamera)
/// @see https://doc.babylonjs.com/features/cameras
@JS()
class StereoscopicFreeCamera extends FreeCamera {
	
	/// Creates a new StereoscopicFreeCamera
	/// @param name defines camera name
	/// @param position defines initial position
	/// @param interaxialDistance defines distance between each color axis
	/// @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
	/// @param scene defines the hosting scene
	external factory StereoscopicFreeCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
	
	/// Gets camera class name
	/// @returns StereoscopicFreeCamera
	@override
	external String getClassName();
}

/// Camera used to simulate stereoscopic rendering (based on GamepadCamera)
/// @see https://doc.babylonjs.com/features/cameras
@JS()
class StereoscopicGamepadCamera extends GamepadCamera {
	
	/// Creates a new StereoscopicGamepadCamera
	/// @param name defines camera name
	/// @param position defines initial position
	/// @param interaxialDistance defines distance between each color axis
	/// @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
	/// @param scene defines the hosting scene
	external factory StereoscopicGamepadCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
	
	/// Gets camera class name
	/// @returns StereoscopicGamepadCamera
	@override
	external String getClassName();
}

/// Camera used to simulate stereoscopic rendering (based on UniversalCamera)
/// @see https://doc.babylonjs.com/features/cameras
@JS()
class StereoscopicUniversalCamera extends UniversalCamera {
	
	/// Creates a new StereoscopicUniversalCamera
	/// @param name defines camera name
	/// @param position defines initial position
	/// @param interaxialDistance defines distance between each color axis
	/// @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
	/// @param scene defines the hosting scene
	external factory StereoscopicUniversalCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
	
	/// Gets camera class name
	/// @returns StereoscopicUniversalCamera
	@override
	external String getClassName();
}

/// This represents a free type of camera. It can be useful in First Person Shooter game for instance.
/// It is identical to the Free Camera and simply adds by default a virtual joystick.
/// Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
/// @see https://doc.babylonjs.com/features/cameras#virtual-joysticks-camera
@JS()
class VirtualJoysticksCamera extends FreeCamera {
	
	/// Intantiates a VirtualJoysticksCamera. It can be useful in First Person Shooter game for instance.
	/// It is identical to the Free Camera and simply adds by default a virtual joystick.
	/// Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
	/// @see https://doc.babylonjs.com/features/cameras#virtual-joysticks-camera
	/// @param name Define the name of the camera in the scene
	/// @param position Define the start position of the camera in the scene
	/// @param scene Define the scene the camera belongs to
	external factory VirtualJoysticksCamera(String name, Vector3 position, Scene scene);
	
	/// Gets the current object class name.
	/// @return the class name
	@override
	external String getClassName();
}

/// This represents all the required metrics to create a VR camera.
/// @see https://doc.babylonjs.com/babylon101/cameras#device-orientation-camera
@JS()
class VRCameraMetrics {
	external factory VRCameraMetrics();
	
	/// Define the horizontal resolution off the screen.
	external num get hResolution;
	external set hResolution(num value);
	
	/// Define the vertical resolution off the screen.
	external num get vResolution;
	external set vResolution(num value);
	
	/// Define the horizontal screen size.
	external num get hScreenSize;
	external set hScreenSize(num value);
	
	/// Define the vertical screen size.
	external num get vScreenSize;
	external set vScreenSize(num value);
	
	/// Define the vertical screen center position.
	external num get vScreenCenter;
	external set vScreenCenter(num value);
	
	/// Define the distance of the eyes to the screen.
	external num get eyeToScreenDistance;
	external set eyeToScreenDistance(num value);
	
	/// Define the distance between both lenses
	external num get lensSeparationDistance;
	external set lensSeparationDistance(num value);
	
	/// Define the distance between both viewer's eyes.
	external num get interpupillaryDistance;
	external set interpupillaryDistance(num value);
	
	/// Define the distortion factor of the VR postprocess.
	/// Please, touch with care.
	external List<num> get distortionK;
	external set distortionK(List<num> value);
	
	/// Define the chromatic aberration correction factors for the VR post process.
	external List<num> get chromaAbCorrection;
	external set chromaAbCorrection(List<num> value);
	
	/// Define the scale factor of the post process.
	/// The smaller the better but the slower.
	external num get postProcessScaleFactor;
	external set postProcessScaleFactor(num value);
	
	/// Define an offset for the lens center.
	external num get lensCenterOffset;
	external set lensCenterOffset(num value);
	
	/// Define if the current vr camera should compensate the distortion of the lense or not.
	external bool get compensateDistortion;
	external set compensateDistortion(bool value);
	
	/// Defines if multiview should be enabled when rendering (Default: false)
	external bool get multiviewEnabled;
	external set multiviewEnabled(bool value);
	
	/// Gets the rendering aspect ratio based on the provided resolutions.
	external num get aspectRatio;
	
	/// Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.
	external num get aspectRatioFov;
	
	/// @hidden
	external Matrix get leftHMatrix;
	
	/// @hidden
	external Matrix get rightHMatrix;
	
	/// @hidden
	external Matrix get leftPreViewMatrix;
	
	/// @hidden
	external Matrix get rightPreViewMatrix;
	
	/// Get the default VRMetrics based on the most generic setup.
	/// @returns the default vr metrics
	external static VRCameraMetrics GetDefault();
}

/* var */
/// @hidden
@JS()
external dynamic get vrDistortionCorrectionPixelShader;

/// VRDistortionCorrectionPostProcess used for mobile VR
@JS()
class VRDistortionCorrectionPostProcess extends PostProcess {
	
	/// Initializes the VRDistortionCorrectionPostProcess
	/// @param name The name of the effect.
	/// @param camera The camera to apply the render pass to.
	/// @param isRightEye If this is for the right eye distortion
	/// @param vrMetrics All the required metrics for the VR camera
	external factory VRDistortionCorrectionPostProcess(String name, Camera camera, bool isRightEye, VRCameraMetrics vrMetrics);
	
	/// Gets a string identifying the name of the class
	/// @returns "VRDistortionCorrectionPostProcess" string
	@override
	external String getClassName();
}

/// Camera used to simulate VR rendering (based on ArcRotateCamera)
/// @see https://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
@JS()
class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera {
	
	/// Creates a new VRDeviceOrientationArcRotateCamera
	/// @param name defines camera name
	/// @param alpha defines the camera rotation along the logitudinal axis
	/// @param beta defines the camera rotation along the latitudinal axis
	/// @param radius defines the camera distance from its target
	/// @param target defines the camera target
	/// @param scene defines the scene the camera belongs to
	/// @param compensateDistortion defines if the camera needs to compensate the lens distorsion
	/// @param vrCameraMetrics defines the vr metrics associated to the camera
	external factory VRDeviceOrientationArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, Scene scene, [bool? compensateDistortion, VRCameraMetrics? vrCameraMetrics]);
	
	/// Gets camera class name
	/// @returns VRDeviceOrientationArcRotateCamera
	@override
	external String getClassName();
}

/// Camera used to simulate VR rendering (based on FreeCamera)
/// @see https://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
@JS()
class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {
	
	/// Creates a new VRDeviceOrientationFreeCamera
	/// @param name defines camera name
	/// @param position defines the start position of the camera
	/// @param scene defines the scene the camera belongs to
	/// @param compensateDistortion defines if the camera needs to compensate the lens distorsion
	/// @param vrCameraMetrics defines the vr metrics associated to the camera
	external factory VRDeviceOrientationFreeCamera(String name, Vector3 position, Scene scene, [bool? compensateDistortion, VRCameraMetrics? vrCameraMetrics]);
	
	/// Gets camera class name
	/// @returns VRDeviceOrientationFreeCamera
	@override
	external String getClassName();
}

/// Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)
/// @see https://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
@JS()
class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera {
	
	/// Creates a new VRDeviceOrientationGamepadCamera
	/// @param name defines camera name
	/// @param position defines the start position of the camera
	/// @param scene defines the scene the camera belongs to
	/// @param compensateDistortion defines if the camera needs to compensate the lens distorsion
	/// @param vrCameraMetrics defines the vr metrics associated to the camera
	external factory VRDeviceOrientationGamepadCamera(String name, Vector3 position, Scene scene, [bool? compensateDistortion, VRCameraMetrics? vrCameraMetrics]);
	
	/// Gets camera class name
	/// @returns VRDeviceOrientationGamepadCamera
	@override
	external String getClassName();
}

/// A class extending Texture allowing drawing on a texture
/// @see https://doc.babylonjs.com/how_to/dynamictexture
@JS()
class DynamicTexture extends Texture {
	
	/// Creates a DynamicTexture
	/// @param name defines the name of the texture
	/// @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height
	/// @param scene defines the scene where you want the texture
	/// @param generateMipMaps defines the use of MinMaps or not (default is false)
	/// @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
	/// @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)
	/// @param invertY defines if the texture needs to be inverted on the y axis during loading
	external factory DynamicTexture(String name, dynamic options, Scene? scene, bool generateMipMaps, [num? samplingMode, num? format, bool? invertY]);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "DynamicTexture"
	@override
	external String getClassName();
	
	/// Gets the current state of canRescale
	@override
	external bool get canRescale;
	
	/// Scales the texture
	/// @param ratio the scale factor to apply to both width and height
	@override
	external void scale(num ratio);
	
	/// Resizes the texture
	/// @param width the new width
	/// @param height the new height
	external void scaleTo(num width, num height);
	
	/// Gets the context of the canvas used by the texture
	/// @returns the canvas context of the dynamic texture
	external HTML.CanvasRenderingContext2D getContext();
	
	/// Clears the texture
	external void clear();
	
	/// Updates the texture
	/// @param invertY defines the direction for the Y axis (default is true - y increases downwards)
	/// @param premulAlpha defines if alpha is stored as premultiplied (default is false)
	external void update([bool? invertY, bool? premulAlpha]);
	
	/// Draws text onto the texture
	/// @param text defines the text to be drawn
	/// @param x defines the placement of the text from the left
	/// @param y defines the placement of the text from the top when invertY is true and from the bottom when false
	/// @param font defines the font to be used with font-style, font-size, font-name
	/// @param color defines the color used for the text
	/// @param clearColor defines the color for the canvas, use null to not overwrite canvas
	/// @param invertY defines the direction for the Y axis (default is true - y increases downwards)
	/// @param update defines whether texture is immediately update (default is true)
	external void drawText(String text, num? x, num? y, String font, String? color, String clearColor, [bool? invertY, bool? update]);
	
	/// Clones the texture
	/// @returns the clone of the texture.
	@override
	external DynamicTexture? clone();
	
	/// Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
	/// @returns a serialized dynamic texture object
	@override
	external dynamic serialize();
}

/// Class containing static functions to help procedurally build meshes
@JS()
class GroundBuilder {
	external factory GroundBuilder();
	
	/// Creates a ground mesh
	/// * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
	/// * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the ground mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#ground
	external static Mesh CreateGround(String name, GroundBuilderCreateGroundOptions options, dynamic scene);
	
	/// Creates a tiled ground mesh
	/// * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
	/// * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
	/// * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
	/// * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the tiled ground mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground
	external static Mesh CreateTiledGround(String name, GroundBuilderCreateTiledGroundOptions options, [Scene? scene]);
	
	/// Creates a ground mesh from a height map
	/// * The parameter `url` sets the URL of the height map image resource.
	/// * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
	/// * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
	/// * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
	/// * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
	/// * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
	/// * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
	/// * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param url defines the url to the height map
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the ground mesh
	/// @see https://doc.babylonjs.com/babylon101/height_map
	/// @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map
	external static GroundMesh CreateGroundFromHeightMap(String name, String url, GroundBuilderCreateGroundFromHeightMapOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class TorusBuilder {
	external factory TorusBuilder();
	
	/// Creates a torus mesh
	/// * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
	/// * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
	/// * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the torus mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#torus
	external static Mesh CreateTorus(String name, TorusBuilderCreateTorusOptions options, dynamic scene);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class CylinderBuilder {
	external factory CylinderBuilder();
	
	/// Creates a cylinder or a cone mesh
	/// * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
	/// * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
	/// * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
	/// * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
	/// * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
	/// * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
	/// * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
	/// * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).
	/// * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
	/// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
	/// * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
	/// * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
	/// * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
	/// * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
	/// * If `enclose` is false, a ring surface is one element.
	/// * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
	/// * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the cylinder mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
	external static Mesh CreateCylinder(String name, CylinderBuilderCreateCylinderOptions options, dynamic scene);
}

/* enum */
abstract class WebXRState {
	
	/// Transitioning to being in XR mode
	static const int ENTERING_XR = 1;
	
	/// Transitioning to non XR mode
	static const int EXITING_XR = 2;
	
	/// In XR mode and presenting
	static const int IN_XR = 3;
	
	/// Not entered XR mode
	static const int NOT_IN_XR = 4;
}

/* enum */
abstract class WebXRTrackingState {
	
	/// No transformation received, device is not being tracked
	static const int NOT_TRACKING = 1;
	
	/// Tracking lost - using emulated position
	static const int TRACKING_LOST = 2;
	
	/// Transformation tracking works normally
	static const int TRACKING = 3;
}

/// Abstraction of the XR render target
@JS()
abstract class WebXRRenderTarget implements IDisposable {
	
	/// xrpresent context of the canvas which can be used to display/mirror xr content
	external WebGL.RenderingContext get canvasContext;
	external set canvasContext(WebGL.RenderingContext value);
	
	/// xr layer for the canvas
	external dynamic? get xrLayer;
	external set xrLayer(dynamic? value);
	
	/// Initializes the xr layer for the session
	/// @param xrSession xr session
	/// @returns a promise that will resolve once the XR Layer has been created
	external Promise<dynamic> initializeXRLayerAsync(dynamic xrSession);
}

/// COnfiguration object for WebXR output canvas
@JS()
class WebXRManagedOutputCanvasOptions {
	external factory WebXRManagedOutputCanvasOptions();
	
	/// An optional canvas in case you wish to create it yourself and provide it here.
	/// If not provided, a new canvas will be created
	external HTML.CanvasElement get canvasElement;
	external set canvasElement(HTML.CanvasElement value);
	
	/// Options for this XR Layer output
	external XRWebGLLayerInit get canvasOptions;
	external set canvasOptions(XRWebGLLayerInit value);
	
	/// CSS styling for a newly created canvas (if not provided)
	external String get newCanvasCssStyle;
	external set newCanvasCssStyle(String value);
	
	/// Get the default values of the configuration object
	/// @param engine defines the engine to use (can be null)
	/// @returns default values of this configuration object
	external static WebXRManagedOutputCanvasOptions GetDefaults([ThinEngine? engine]);
}

/// Creates a canvas that is added/removed from the webpage when entering/exiting XR
@JS()
class WebXRManagedOutputCanvas implements WebXRRenderTarget {
	
	/// Initializes the canvas to be added/removed upon entering/exiting xr
	/// @param _xrSessionManager The XR Session manager
	/// @param _options optional configuration for this canvas output. defaults will be used if not provided
	external factory WebXRManagedOutputCanvas(WebXRSessionManager _xrSessionManager, [WebXRManagedOutputCanvasOptions? _options]);
	
	/// Rendering context of the canvas which can be used to display/mirror xr content
	@override
	external WebGL.RenderingContext get canvasContext;
	@override
	external set canvasContext(WebGL.RenderingContext value);
	
	/// xr layer for the canvas
	@override
	external dynamic? get xrLayer;
	@override
	external set xrLayer(dynamic? value);
	
	/// Obseervers registered here will be triggered when the xr layer was initialized
	external Observable<dynamic> get onXRLayerInitObservable;
	external set onXRLayerInitObservable(Observable<dynamic> value);
	
	/// Disposes of the object
	@override
	external void dispose();
	
	/// Initializes the xr layer for the session
	/// @param xrSession xr session
	/// @returns a promise that will resolve once the XR Layer has been created
	@override
	external Promise<dynamic> initializeXRLayerAsync(dynamic xrSession);
}

/// Manages an XRSession to work with Babylon's engine
/// @see https://doc.babylonjs.com/how_to/webxr_session_manager
@JS()
class WebXRSessionManager implements IDisposable {
	
	/// Constructs a WebXRSessionManager, this must be initialized within a user action before usage
	/// @param scene The scene which the session should be created for
	external factory WebXRSessionManager(Scene scene);
	
	/// The scene which the session should be created for
	external Scene get scene;
	external set scene(Scene value);
	
	/// The base reference space from which the session started. good if you want to reset your
	/// reference space
	external dynamic get baseReferenceSpace;
	external set baseReferenceSpace(dynamic value);
	
	/// Current XR frame
	external dynamic? get currentFrame;
	external set currentFrame(dynamic? value);
	
	/// WebXR timestamp updated every frame
	external num get currentTimestamp;
	external set currentTimestamp(num value);
	
	/// Used just in case of a failure to initialize an immersive session.
	/// The viewer reference space is compensated using this height, creating a kind of "viewer-floor" reference space
	external num get defaultHeightCompensation;
	external set defaultHeightCompensation(num value);
	
	/// Fires every time a new xrFrame arrives which can be used to update the camera
	external Observable<dynamic> get onXRFrameObservable;
	external set onXRFrameObservable(Observable<dynamic> value);
	
	/// Fires when the reference space changed
	external Observable<dynamic> get onXRReferenceSpaceChanged;
	external set onXRReferenceSpaceChanged(Observable<dynamic> value);
	
	/// Fires when the xr session is ended either by the device or manually done
	external Observable<dynamic> get onXRSessionEnded;
	external set onXRSessionEnded(Observable<dynamic> value);
	
	/// Fires when the xr session is ended either by the device or manually done
	external Observable<dynamic> get onXRSessionInit;
	external set onXRSessionInit(Observable<dynamic> value);
	
	/// Underlying xr session
	external dynamic get session;
	external set session(dynamic value);
	
	/// The viewer (head position) reference space. This can be used to get the XR world coordinates
	/// or get the offset the player is currently at.
	external dynamic get viewerReferenceSpace;
	external set viewerReferenceSpace(dynamic value);
	
	/// The current reference space used in this session. This reference space can constantly change!
	/// It is mainly used to offset the camera's position.
	external dynamic get referenceSpace;
	
	/// Set a new reference space and triggers the observable
	external set referenceSpace(dynamic value);
	
	/// Disposes of the session manager
	@override
	external void dispose();
	
	/// Stops the xrSession and restores the render loop
	/// @returns Promise which resolves after it exits XR
	external Promise<void> exitXRAsync();
	
	/// Gets the correct render target texture to be rendered this frame for this eye
	/// @param eye the eye for which to get the render target
	/// @returns the render target for the specified eye
	external RenderTargetTexture getRenderTargetTextureForEye(dynamic eye);
	
	/// Creates a WebXRRenderTarget object for the XR session
	/// @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web
	/// @param options optional options to provide when creating a new render target
	/// @returns a WebXR render target to which the session can render
	external WebXRRenderTarget getWebXRRenderTarget([WebXRManagedOutputCanvasOptions? options]);
	
	/// Initializes the manager
	/// After initialization enterXR can be called to start an XR session
	/// @returns Promise which resolves after it is initialized
	external Promise<void> initializeAsync();
	
	/// Initializes an xr session
	/// @param xrSessionMode mode to initialize
	/// @param xrSessionInit defines optional and required values to pass to the session builder
	/// @returns a promise which will resolve once the session has been initialized
	external Promise<dynamic> initializeSessionAsync([dynamic? xrSessionMode, XRSessionInit? xrSessionInit]);
	
	/// Checks if a session would be supported for the creation options specified
	/// @param sessionMode session mode to check if supported eg. immersive-vr
	/// @returns A Promise that resolves to true if supported and false if not
	external Promise<bool> isSessionSupportedAsync(dynamic sessionMode);
	
	/// Resets the reference space to the one started the session
	external void resetReferenceSpace();
	
	/// Starts rendering to the xr layer
	external void runXRRenderLoop();
	
	/// Sets the reference space on the xr session
	/// @param referenceSpaceType space to set
	/// @returns a promise that will resolve once the reference space has been set
	external Promise<dynamic> setReferenceSpaceTypeAsync([dynamic? referenceSpaceType]);
	
	/// Updates the render state of the session
	/// @param state state to set
	/// @returns a promise that resolves once the render state has been updated
	external Promise<void> updateRenderStateAsync(dynamic state);
	
	/// Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser
	/// @param sessionMode defines the session to test
	/// @returns a promise with boolean as final value
	external static Promise<bool> IsSessionSupportedAsync(dynamic sessionMode);
}

/// WebXR Camera which holds the views for the xrSession
/// @see https://doc.babylonjs.com/how_to/webxr_camera
@JS()
class WebXRCamera extends FreeCamera {
	
	/// Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager
	/// @param name the name of the camera
	/// @param scene the scene to add the camera to
	/// @param _xrSessionManager a constructed xr session manager
	external factory WebXRCamera(String name, Scene scene, WebXRSessionManager _xrSessionManager);
	
	/// Observable raised before camera teleportation
	external Observable<Vector3> get onBeforeCameraTeleport;
	external set onBeforeCameraTeleport(Observable<Vector3> value);
	
	/// Observable raised after camera teleportation
	external Observable<Vector3> get onAfterCameraTeleport;
	external set onAfterCameraTeleport(Observable<Vector3> value);
	
	/// Notifies when the camera's tracking state has changed.
	/// Notice - will also be triggered when tracking has started (at the beginning of the session)
	external Observable<int> get onTrackingStateChanged;
	external set onTrackingStateChanged(Observable<int> value);
	
	/// Should position compensation execute on first frame.
	/// This is used when copying the position from a native (non XR) camera
	external bool get compensateOnFirstFrame;
	external set compensateOnFirstFrame(bool value);
	
	/// Get the current XR tracking state of the camera
	external int get trackingState;
	
	/// Return the user's height, unrelated to the current ground.
	/// This will be the y position of this camera, when ground level is 0.
	external num get realWorldHeight;
	
	/// Sets this camera's transformation based on a non-vr camera
	/// @param otherCamera the non-vr camera to copy the transformation from
	/// @param resetToBaseReferenceSpace should XR reset to the base reference space
	external void setTransformationFromNonVRCamera([Camera? otherCamera, bool? resetToBaseReferenceSpace]);
	
	/// Gets the current instance class name ("WebXRCamera").
	/// @returns the class name
	@override
	external String getClassName();
}

/// Defining the interface required for a (webxr) feature
@JS()
abstract class IWebXRFeature implements IDisposable {
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// Should auto-attach be disabled?
	external bool get disableAutoAttach;
	external set disableAutoAttach(bool value);
	
	/// Attach the feature to the session
	/// Will usually be called by the features manager
	/// 
	/// @param force should attachment be forced (even when already attached)
	/// @returns true if successful.
	external bool attach([bool? force]);
	
	/// Detach the feature from the session
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	external bool detach();
	
	/// This function will be executed during before enabling the feature and can be used to not-allow enabling it.
	/// Note that at this point the session has NOT started, so this is purely checking if the browser supports it
	/// 
	/// @returns whether or not the feature is compatible in this environment
	external bool isCompatible();
	
	/// Was this feature disposed;
	external bool get isDisposed;
	external set isDisposed(bool value);
	
	/// The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)
	external String get xrNativeFeatureName;
	external set xrNativeFeatureName(String value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// A list of the currently available features without referencing them
@JS()
class WebXRFeatureName {
	external factory WebXRFeatureName();
	
	/// The name of the anchor system feature
	external static String get ANCHOR_SYSTEM;
	
	/// The name of the background remover feature
	external static String get BACKGROUND_REMOVER;
	
	/// The name of the hit test feature
	external static String get HIT_TEST;
	
	/// physics impostors for xr controllers feature
	external static String get PHYSICS_CONTROLLERS;
	
	/// The name of the plane detection feature
	external static String get PLANE_DETECTION;
	
	/// The name of the pointer selection feature
	external static String get POINTER_SELECTION;
	
	/// The name of the teleportation feature
	external static String get TELEPORTATION;
	
	/// The name of the feature points feature.
	external static String get FEATURE_POINTS;
	
	/// The name of the hand tracking feature.
	external static String get HAND_TRACKING;
}

/// The WebXR features manager is responsible of enabling or disabling features required for the current XR session.
/// It is mainly used in AR sessions.
/// 
/// A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).
@JS()
class WebXRFeaturesManager implements IDisposable {
	
	/// constructs a new features manages.
	/// 
	/// @param _xrSessionManager an instance of WebXRSessionManager
	external factory WebXRFeaturesManager(WebXRSessionManager _xrSessionManager);
	
	/// Used to register a module. After calling this function a developer can use this feature in the scene.
	/// Mainly used internally.
	/// 
	/// @param featureName the name of the feature to register
	/// @param constructorFunction the function used to construct the module
	/// @param version the (babylon) version of the module
	/// @param stable is that a stable version of this module
	external static void AddWebXRFeature(String featureName, dynamic constructorFunction, [num? version, bool? stable]);
	
	/// Returns a constructor of a specific feature.
	/// 
	/// @param featureName the name of the feature to construct
	/// @param version the version of the feature to load
	/// @param xrSessionManager the xrSessionManager. Used to construct the module
	/// @param options optional options provided to the module.
	/// @returns a function that, when called, will return a new instance of this feature
	external static IWebXRFeature Function() ConstructFeature(String featureName, num? version, WebXRSessionManager xrSessionManager, [dynamic? options]);
	
	/// Can be used to return the list of features currently registered
	/// 
	/// @returns an Array of available features
	external static List<String> GetAvailableFeatures();
	
	/// Gets the versions available for a specific feature
	/// @param featureName the name of the feature
	/// @returns an array with the available versions
	external static List<String> GetAvailableVersions(String featureName);
	
	/// Return the latest unstable version of this feature
	/// @param featureName the name of the feature to search
	/// @returns the version number. if not found will return -1
	external static num GetLatestVersionOfFeature(String featureName);
	
	/// Return the latest stable version of this feature
	/// @param featureName the name of the feature to search
	/// @returns the version number. if not found will return -1
	external static num GetStableVersionOfFeature(String featureName);
	
	/// Attach a feature to the current session. Mainly used when session started to start the feature effect.
	/// Can be used during a session to start a feature
	/// @param featureName the name of feature to attach
	external void attachFeature(String featureName);
	
	/// Can be used inside a session or when the session ends to detach a specific feature
	/// @param featureName the name of the feature to detach
	external void detachFeature(String featureName);
	
	/// Used to disable an already-enabled feature
	/// The feature will be disposed and will be recreated once enabled.
	/// @param featureName the feature to disable
	/// @returns true if disable was successful
	external bool disableFeature(dynamic featureName);
	
	/// dispose this features manager
	@override
	external void dispose();
	
	/// Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.
	/// If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.
	/// 
	/// @param featureName the name of the feature to load or the class of the feature
	/// @param version optional version to load. if not provided the latest version will be enabled
	/// @param moduleOptions options provided to the module. Ses the module documentation / constructor
	/// @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible
	/// @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.
	/// @returns a new constructed feature or throws an error if feature not found.
	external IWebXRFeature enableFeature(dynamic featureName, [dynamic? version, dynamic? moduleOptions, bool? attachIfPossible, bool? required]);
	
	/// get the implementation of an enabled feature.
	/// @param featureName the name of the feature to load
	/// @returns the feature class, if found
	external IWebXRFeature getEnabledFeature(String featureName);
	
	/// Get the list of enabled features
	/// @returns an array of enabled features
	external List<String> getEnabledFeatures();
	
	/// This function will exten the session creation configuration object with enabled features.
	/// If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,
	/// according to the defined "required" variable, provided during enableFeature call
	/// @param xrSessionInit the xr Session init object to extend
	/// 
	/// @returns an extended XRSessionInit object
	external XRSessionInit extendXRSessionInitObject(XRSessionInit xrSessionInit);
}

/// Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)
/// @see https://doc.babylonjs.com/how_to/webxr_experience_helpers
@JS()
class WebXRExperienceHelper implements IDisposable {
	
	/// Creates a WebXRExperienceHelper
	/// @param scene The scene the helper should be created in
	external factory WebXRExperienceHelper();
	
	/// Camera used to render xr content
	external WebXRCamera get camera;
	external set camera(WebXRCamera value);
	
	/// A features manager for this xr session
	external WebXRFeaturesManager get featuresManager;
	external set featuresManager(WebXRFeaturesManager value);
	
	/// Observers registered here will be triggered after the camera's initial transformation is set
	/// This can be used to set a different ground level or an extra rotation.
	/// 
	/// Note that ground level is considered to be at 0. The height defined by the XR camera will be added
	/// to the position set after this observable is done executing.
	external Observable<WebXRCamera> get onInitialXRPoseSetObservable;
	external set onInitialXRPoseSetObservable(Observable<WebXRCamera> value);
	
	/// Fires when the state of the experience helper has changed
	external Observable<int> get onStateChangedObservable;
	external set onStateChangedObservable(Observable<int> value);
	
	/// Session manager used to keep track of xr session
	external WebXRSessionManager get sessionManager;
	external set sessionManager(WebXRSessionManager value);
	
	/// The current state of the XR experience (eg. transitioning, in XR or not in XR)
	external int get state;
	external set state(int value);
	
	/// Creates the experience helper
	/// @param scene the scene to attach the experience helper to
	/// @returns a promise for the experience helper
	external static Promise<WebXRExperienceHelper> CreateAsync(Scene scene);
	
	/// Disposes of the experience helper
	@override
	external void dispose();
	
	/// Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
	/// @param sessionMode options for the XR session
	/// @param referenceSpaceType frame of reference of the XR session
	/// @param renderTarget the output canvas that will be used to enter XR mode
	/// @param sessionCreationOptions optional XRSessionInit object to init the session with
	/// @returns promise that resolves after xr mode has entered
	external Promise<WebXRSessionManager> enterXRAsync(dynamic sessionMode, dynamic referenceSpaceType, [WebXRRenderTarget? renderTarget, XRSessionInit? sessionCreationOptions]);
	
	/// Exits XR mode and returns the scene to its original state
	/// @returns promise that resolves after xr mode has exited
	external Promise<void> exitXRAsync();
}

/// X-Y values for axes in WebXR
@JS()
@anonymous
class IWebXRMotionControllerAxesValue {
	
	external factory IWebXRMotionControllerAxesValue({num x, num y});
	
	/// The value of the x axis
	external num get x;
	external set x( num value );
	
	/// The value of the y-axis
	external num get y;
	external set y( num value );
}

/// changed / previous values for the values of this component
@JS()
@anonymous
class IWebXRMotionControllerComponentChangesValues<T> {
	
	external factory IWebXRMotionControllerComponentChangesValues({T current, T previous});
	
	/// current (this frame) value
	external T get current;
	external set current( T value );
	
	/// previous (last change) value
	external T get previous;
	external set previous( T value );
}

/// Represents changes in the component between current frame and last values recorded
@JS()
@anonymous
class IWebXRMotionControllerComponentChanges {
	
	external factory IWebXRMotionControllerComponentChanges({IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue> axes, IWebXRMotionControllerComponentChangesValues<bool> pressed, IWebXRMotionControllerComponentChangesValues<bool> touched, IWebXRMotionControllerComponentChangesValues<num> value});
	
	/// will be populated with previous and current values if axes changed
	external IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue> get axes;
	external set axes( IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue> value );
	
	/// will be populated with previous and current values if pressed changed
	external IWebXRMotionControllerComponentChangesValues<bool> get pressed;
	external set pressed( IWebXRMotionControllerComponentChangesValues<bool> value );
	
	/// will be populated with previous and current values if touched changed
	external IWebXRMotionControllerComponentChangesValues<bool> get touched;
	external set touched( IWebXRMotionControllerComponentChangesValues<bool> value );
	
	/// will be populated with previous and current values if value changed
	external IWebXRMotionControllerComponentChangesValues<num> get value;
	external set value( IWebXRMotionControllerComponentChangesValues<num> value );
}

/// This class represents a single component (for example button or thumbstick) of a motion controller
@JS()
class WebXRControllerComponent implements IDisposable {
	
	/// Creates a new component for a motion controller.
	/// It is created by the motion controller itself
	/// 
	/// @param id the id of this component
	/// @param type the type of the component
	/// @param _buttonIndex index in the buttons array of the gamepad
	/// @param _axesIndices indices of the values in the axes array of the gamepad
	external factory WebXRControllerComponent(String id, dynamic type, [num? _buttonIndex, List<num>? _axesIndices]);
	
	/// the id of this component
	external String get id;
	external set id(String value);
	
	/// the type of the component
	external dynamic get type;
	external set type(dynamic value);
	
	/// button component type
	external static dynamic get BUTTON_TYPE;
	external static set BUTTON_TYPE(dynamic value);
	
	/// squeeze component type
	external static dynamic get SQUEEZE_TYPE;
	external static set SQUEEZE_TYPE(dynamic value);
	
	/// Thumbstick component type
	external static dynamic get THUMBSTICK_TYPE;
	external static set THUMBSTICK_TYPE(dynamic value);
	
	/// Touchpad component type
	external static dynamic get TOUCHPAD_TYPE;
	external static set TOUCHPAD_TYPE(dynamic value);
	
	/// trigger component type
	external static dynamic get TRIGGER_TYPE;
	external static set TRIGGER_TYPE(dynamic value);
	
	/// If axes are available for this component (like a touchpad or thumbstick) the observers will be notified when
	/// the axes data changes
	external Observable<WebXRControllerComponentOnAxisValueChangedObservable> get onAxisValueChangedObservable;
	external set onAxisValueChangedObservable(Observable<WebXRControllerComponentOnAxisValueChangedObservable> value);
	
	/// Observers registered here will be triggered when the state of a button changes
	/// State change is either pressed / touched / value
	external Observable<WebXRControllerComponent> get onButtonStateChangedObservable;
	external set onButtonStateChangedObservable(Observable<WebXRControllerComponent> value);
	
	/// The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }
	external IWebXRMotionControllerAxesValue get axes;
	
	/// Get the changes. Elements will be populated only if they changed with their previous and current value
	external IWebXRMotionControllerComponentChanges get changes;
	
	/// Return whether or not the component changed the last frame
	external bool get hasChanges;
	
	/// is the button currently pressed
	external bool get pressed;
	
	/// is the button currently touched
	external bool get touched;
	
	/// Get the current value of this component
	external num get value;
	
	/// Dispose this component
	@override
	external void dispose();
	
	/// Are there axes correlating to this component
	/// @return true is axes data is available
	external bool isAxes();
	
	/// Is this component a button (hence - pressable)
	/// @returns true if can be pressed
	external bool isButton();
	
	/// update this component using the gamepad object it is in. Called on every frame
	/// @param nativeController the native gamepad controller object
	external void update(IMinimalMotionControllerObject nativeController);
}

/// Interface used for the result of ImportMeshAsync
@JS()
@anonymous
class ISceneLoaderAsyncResult {
	
	external factory ISceneLoaderAsyncResult({List<AbstractMesh> meshes, List<IParticleSystem> particleSystems, List<Skeleton> skeletons, List<AnimationGroup> animationGroups, List<TransformNode> transformNodes, List<Geometry> geometries, List<Light> lights});
	
	/// The array of loaded meshes
	external List<AbstractMesh> get meshes;
	external set meshes( List<AbstractMesh> value );
	
	/// The array of loaded particle systems
	external List<IParticleSystem> get particleSystems;
	external set particleSystems( List<IParticleSystem> value );
	
	/// The array of loaded skeletons
	external List<Skeleton> get skeletons;
	external set skeletons( List<Skeleton> value );
	
	/// The array of loaded animation groups
	external List<AnimationGroup> get animationGroups;
	external set animationGroups( List<AnimationGroup> value );
	
	/// The array of loaded transform nodes
	external List<TransformNode> get transformNodes;
	external set transformNodes( List<TransformNode> value );
	
	/// The array of loaded geometries
	external List<Geometry> get geometries;
	external set geometries( List<Geometry> value );
	
	/// The array of loaded lights
	external List<Light> get lights;
	external set lights( List<Light> value );
}

/// Interface used to represent data loading progression
@JS()
@anonymous
class ISceneLoaderProgressEvent {
	
	external factory ISceneLoaderProgressEvent({bool lengthComputable, num loaded, num total});
	
	/// Defines if data length to load can be evaluated
	external bool get lengthComputable;
	external set lengthComputable( bool value );
	
	/// Defines the loaded data length
	external num get loaded;
	external set loaded( num value );
	
	/// Defines the data length to load
	external num get total;
	external set total( num value );
}

/// Interface used by SceneLoader plugins to define supported file extensions
@JS()
@anonymous
class ISceneLoaderPluginExtensions {
}

/// Interface used by SceneLoader plugin factory
@JS()
abstract class ISceneLoaderPluginFactory {
	
	/// Defines the name of the factory
	external String get name;
	external set name(String value);
	
	/// Function called to create a new plugin
	/// @return the new plugin
	external dynamic createPlugin();
	
	/// The callback that returns true if the data can be directly loaded.
	/// @param data string containing the file data
	/// @returns if the data can be loaded directly
	external bool canDirectLoad(String data);
}

/// Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync
@JS()
abstract class ISceneLoaderPluginBase {
	
	/// The friendly name of this plugin.
	external String get name;
	external set name(String value);
	
	/// The file extensions supported by this plugin.
	external dynamic get extensions;
	external set extensions(dynamic value);
	
	/// The callback called when loading from a url.
	/// @param scene scene loading this url
	/// @param url url to load
	/// @param onSuccess callback called when the file successfully loads
	/// @param onProgress callback called while file is loading (if the server supports this mode)
	/// @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
	/// @param onError callback called when the file fails to load
	/// @returns a file request object
	external IFileRequest requestFile(Scene scene, String url, void Function(dynamic data, [WebRequest? request]) onSuccess, [void Function(ISceneLoaderProgressEvent ev)? onProgress, bool? useArrayBuffer, void Function(dynamic error)? onError]);
	
	/// The callback called when loading from a file object.
	/// @param scene scene loading this file
	/// @param file defines the file to load
	/// @param onSuccess defines the callback to call when data is loaded
	/// @param onProgress defines the callback to call during loading process
	/// @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
	/// @param onError defines the callback to call when an error occurs
	/// @returns a file request object
	external IFileRequest readFile(Scene scene, HTML.File file, void Function(dynamic data) onSuccess, [dynamic Function(ISceneLoaderProgressEvent ev)? onProgress, bool? useArrayBuffer, void Function(dynamic error)? onError]);
	
	/// The callback that returns true if the data can be directly loaded.
	/// @param data string containing the file data
	/// @returns if the data can be loaded directly
	external bool canDirectLoad(String data);
	
	/// The callback that returns the data to pass to the plugin if the data can be directly loaded.
	/// @param scene scene loading this data
	/// @param data string containing the data
	/// @returns data to pass to the plugin
	external dynamic directLoad(Scene scene, String data);
	
	/// The callback that allows custom handling of the root url based on the response url.
	/// @param rootUrl the original root url
	/// @param responseURL the response url if available
	/// @returns the new root url
	external String rewriteRootURL(String rootUrl, [String? responseURL]);
}

/// Interface used to define a SceneLoader plugin
@JS()
abstract class ISceneLoaderPlugin implements ISceneLoaderPluginBase {
	
	/// Import meshes into a scene.
	/// @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
	/// @param scene The scene to import into
	/// @param data The data to import
	/// @param rootUrl The root url for scene and resources
	/// @param meshes The meshes array to import into
	/// @param particleSystems The particle systems array to import into
	/// @param skeletons The skeletons array to import into
	/// @param onError The callback when import fails
	/// @returns True if successful or false otherwise
	external bool importMesh(dynamic meshesNames, Scene scene, dynamic data, String rootUrl, List<AbstractMesh> meshes, List<IParticleSystem> particleSystems, List<Skeleton> skeletons, [void Function(String message, [dynamic? exception])? onError]);
	
	/// Load into a scene.
	/// @param scene The scene to load into
	/// @param data The data to import
	/// @param rootUrl The root url for scene and resources
	/// @param onError The callback when import fails
	/// @returns True if successful or false otherwise
	external bool load(Scene scene, dynamic data, String rootUrl, [void Function(String message, [dynamic? exception])? onError]);
	
	/// Load into an asset container.
	/// @param scene The scene to load into
	/// @param data The data to import
	/// @param rootUrl The root url for scene and resources
	/// @param onError The callback when import fails
	/// @returns The loaded asset container
	external AssetContainer loadAssetContainer(Scene scene, dynamic data, String rootUrl, [void Function(String message, [dynamic? exception])? onError]);
}

/// Interface used to define an async SceneLoader plugin
@JS()
abstract class ISceneLoaderPluginAsync implements ISceneLoaderPluginBase {
	
	/// Import meshes into a scene.
	/// @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
	/// @param scene The scene to import into
	/// @param data The data to import
	/// @param rootUrl The root url for scene and resources
	/// @param onProgress The callback when the load progresses
	/// @param fileName Defines the name of the file to load
	/// @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)
	external Promise<ISceneLoaderAsyncResult> importMeshAsync(dynamic meshesNames, Scene scene, dynamic data, String rootUrl, [void Function(ISceneLoaderProgressEvent event)? onProgress, String? fileName]);
	
	/// Load into a scene.
	/// @param scene The scene to load into
	/// @param data The data to import
	/// @param rootUrl The root url for scene and resources
	/// @param onProgress The callback when the load progresses
	/// @param fileName Defines the name of the file to load
	/// @returns Nothing
	external Promise<void> loadAsync(Scene scene, dynamic data, String rootUrl, [void Function(ISceneLoaderProgressEvent event)? onProgress, String? fileName]);
	
	/// Load into an asset container.
	/// @param scene The scene to load into
	/// @param data The data to import
	/// @param rootUrl The root url for scene and resources
	/// @param onProgress The callback when the load progresses
	/// @param fileName Defines the name of the file to load
	/// @returns The loaded asset container
	external Promise<AssetContainer> loadAssetContainerAsync(Scene scene, dynamic data, String rootUrl, [void Function(ISceneLoaderProgressEvent event)? onProgress, String? fileName]);
}

/* enum */
abstract class SceneLoaderAnimationGroupLoadingMode {
	
	/// Reset all old animations to initial state then dispose them.
	static const int Clean = 1;
	
	/// Stop all old animations.
	static const int Stop = 2;
	
	/// Restart old animations from first frame.
	static const int Sync = 3;
	
	/// Old animations remains untouched.
	static const int NoSync = 4;
}

/// Defines a plugin registered by the SceneLoader
@JS()
@anonymous
class IRegisteredPlugin {
	
	external factory IRegisteredPlugin({dynamic plugin, bool isBinary});
	
	/// Defines the plugin to use
	external dynamic get plugin;
	external set plugin( dynamic value );
	
	/// Defines if the plugin supports binary data
	external bool get isBinary;
	external set isBinary( bool value );
}

/// Class used to load scene from various file formats using registered plugins
/// @see https://doc.babylonjs.com/how_to/load_from_any_file_type
@JS()
class SceneLoader {
	external factory SceneLoader();
	
	/// No logging while loading
	external static num get NO_LOGGING;
	
	/// Minimal logging while loading
	external static num get MINIMAL_LOGGING;
	
	/// Summary logging while loading
	external static num get SUMMARY_LOGGING;
	
	/// Detailled logging while loading
	external static num get DETAILED_LOGGING;
	
	/// Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
	external static bool get ForceFullSceneLoadingForIncremental;
	
	external static set ForceFullSceneLoadingForIncremental(bool value);
	
	/// Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
	external static bool get ShowLoadingScreen;
	
	external static set ShowLoadingScreen(bool value);
	
	/// Defines the current logging level (while loading the scene)
	/// @ignorenaming
	external static num get loggingLevel;
	
	external static set loggingLevel(num value);
	
	/// Gets or set a boolean indicating if matrix weights must be cleaned upon loading
	external static bool get CleanBoneMatrixWeights;
	
	external static set CleanBoneMatrixWeights(bool value);
	
	/// Event raised when a plugin is used to load a scene
	external static Observable<dynamic> get OnPluginActivatedObservable;
	external static set OnPluginActivatedObservable(Observable<dynamic> value);
	
	/// Gets the default plugin (used to load Babylon files)
	/// @returns the .babylon plugin
	external static IRegisteredPlugin GetDefaultPlugin();
	
	/// Gets a plugin that can load the given extension
	/// @param extension defines the extension to load
	/// @returns a plugin or null if none works
	external static dynamic GetPluginForExtension(String extension);
	
	/// Gets a boolean indicating that the given extension can be loaded
	/// @param extension defines the extension to load
	/// @returns true if the extension is supported
	external static bool IsPluginForExtensionAvailable(String extension);
	
	/// Adds a new plugin to the list of registered plugins
	/// @param plugin defines the plugin to add
	external static void RegisterPlugin(dynamic plugin);
	
	/// Import meshes into a scene
	/// @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene the instance of BABYLON.Scene to append to
	/// @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param onError a callback with the scene, a message, and possibly an exception when import fails
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded plugin
	external static dynamic? ImportMesh(dynamic meshNames, String rootUrl, [dynamic? sceneFilename, Scene? scene, dynamic? onSuccess, void Function(ISceneLoaderProgressEvent event)? onProgress, void Function(Scene scene, String message, [dynamic? exception])? onError, String? pluginExtension]);
	
	/// Import meshes into a scene
	/// @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene the instance of BABYLON.Scene to append to
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups
	external static Promise<ISceneLoaderAsyncResult> ImportMeshAsync(dynamic meshNames, String rootUrl, [dynamic? sceneFilename, Scene? scene, void Function(ISceneLoaderProgressEvent event)? onProgress, String? pluginExtension]);
	
	/// Load a scene
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param engine is the instance of BABYLON.Engine to use to create the scene
	/// @param onSuccess a callback with the scene when import succeeds
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param onError a callback with the scene, a message, and possibly an exception when import fails
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded plugin
	external static dynamic? Load(String rootUrl, [dynamic? sceneFilename, Engine? engine, void Function(Scene scene)? onSuccess, void Function(ISceneLoaderProgressEvent event)? onProgress, void Function(Scene scene, String message, [dynamic? exception])? onError, String? pluginExtension]);
	
	/// Load a scene
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param engine is the instance of BABYLON.Engine to use to create the scene
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded scene
	external static Promise<Scene> LoadAsync(String rootUrl, [dynamic? sceneFilename, Engine? engine, void Function(ISceneLoaderProgressEvent event)? onProgress, String? pluginExtension]);
	
	/// Append a scene
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene is the instance of BABYLON.Scene to append to
	/// @param onSuccess a callback with the scene when import succeeds
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param onError a callback with the scene, a message, and possibly an exception when import fails
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded plugin
	external static dynamic? Append(String rootUrl, [dynamic? sceneFilename, Scene? scene, void Function(Scene scene)? onSuccess, void Function(ISceneLoaderProgressEvent event)? onProgress, void Function(Scene scene, String message, [dynamic? exception])? onError, String? pluginExtension]);
	
	/// Append a scene
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene is the instance of BABYLON.Scene to append to
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The given scene
	external static Promise<Scene> AppendAsync(String rootUrl, [dynamic? sceneFilename, Scene? scene, void Function(ISceneLoaderProgressEvent event)? onProgress, String? pluginExtension]);
	
	/// Load a scene into an asset container
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
	/// @param onSuccess a callback with the scene when import succeeds
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param onError a callback with the scene, a message, and possibly an exception when import fails
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded plugin
	external static dynamic? LoadAssetContainer(String rootUrl, [dynamic? sceneFilename, Scene? scene, void Function(AssetContainer assets)? onSuccess, void Function(ISceneLoaderProgressEvent event)? onProgress, void Function(Scene scene, String message, [dynamic? exception])? onError, String? pluginExtension]);
	
	/// Load a scene into an asset container
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)
	/// @param scene is the instance of Scene to append to
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns The loaded asset container
	external static Promise<AssetContainer> LoadAssetContainerAsync(String rootUrl, [String? sceneFilename, Scene? scene, void Function(ISceneLoaderProgressEvent event)? onProgress, String? pluginExtension]);
	
	/// Import animations from a file into a scene
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
	/// @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
	/// @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
	/// @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
	/// @param onSuccess a callback with the scene when import succeeds
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param onError a callback with the scene, a message, and possibly an exception when import fails
	/// @param pluginExtension the extension used to determine the plugin
	external static void ImportAnimations(String rootUrl, [dynamic? sceneFilename, Scene? scene, bool? overwriteAnimations, int? animationGroupLoadingMode, dynamic Function(dynamic target)? targetConverter, void Function(Scene scene)? onSuccess, void Function(ISceneLoaderProgressEvent event)? onProgress, void Function(Scene scene, String message, [dynamic? exception])? onError, String? pluginExtension]);
	
	/// Import animations from a file into a scene
	/// @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
	/// @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
	/// @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
	/// @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
	/// @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
	/// @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
	/// @param onSuccess a callback with the scene when import succeeds
	/// @param onProgress a callback with a progress event for each file being loaded
	/// @param onError a callback with the scene, a message, and possibly an exception when import fails
	/// @param pluginExtension the extension used to determine the plugin
	/// @returns the updated scene with imported animations
	external static Promise<Scene> ImportAnimationsAsync(String rootUrl, [dynamic? sceneFilename, Scene? scene, bool? overwriteAnimations, int? animationGroupLoadingMode, dynamic Function(dynamic target)? targetConverter, void Function(Scene scene)? onSuccess, void Function(ISceneLoaderProgressEvent event)? onProgress, void Function(Scene scene, String message, [dynamic? exception])? onError, String? pluginExtension]);
}

/// The schema of motion controller layout.
/// No object will be initialized using this interface
/// This is used just to define the profile.
@JS()
@anonymous
class IMotionControllerLayout {
	
	external factory IMotionControllerLayout({String assetPath, dynamic /* object */ components, String /* [[", , "], [", xr-standard, "]] */ gamepadMapping, String rootNodeName, String selectComponentId});
	
	/// Path to load the assets. Usually relative to the base path
	external String get assetPath;
	external set assetPath( String value );
	
	/// Available components (unsorted)
	external dynamic /* object */ get components;
	external set components( dynamic /* object */ value );
	
	/// Is it xr standard mapping or not
	external String /* [[", , "], [", xr-standard, "]] */ get gamepadMapping;
	external set gamepadMapping( String /* [[", , "], [", xr-standard, "]] */ value );
	
	/// Base root node of this entire model
	external String get rootNodeName;
	external set rootNodeName( String value );
	
	/// Defines the main button component id
	external String get selectComponentId;
	external set selectComponentId( String value );
}

/// A definition for the layout map in the input profile
@JS()
@anonymous
class IMotionControllerLayoutMap {
}

/// The XR Input profile schema
/// Profiles can be found here:
/// https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/registry/profiles
@JS()
@anonymous
class IMotionControllerProfile {
	
	external factory IMotionControllerProfile({List<String> fallbackProfileIds, IMotionControllerLayoutMap layouts, String profileId});
	
	/// fallback profiles for this profileId
	external List<String> get fallbackProfileIds;
	external set fallbackProfileIds( List<String> value );
	
	/// The layout map, with handedness as key
	external IMotionControllerLayoutMap get layouts;
	external set layouts( IMotionControllerLayoutMap value );
	
	/// The id of this profile
	/// correlates to the profile(s) in the xrInput.profiles array
	external String get profileId;
	external set profileId( String value );
}

/// A helper-interface for the 3 meshes needed for controller button animation
/// The meshes are provided to the _lerpButtonTransform function to calculate the current position of the value mesh
@JS()
@anonymous
class IMotionControllerButtonMeshMap {
	
	external factory IMotionControllerButtonMeshMap({AbstractMesh pressedMesh, AbstractMesh unpressedMesh, AbstractMesh valueMesh});
	
	/// the mesh that defines the pressed value mesh position.
	/// This is used to find the max-position of this button
	external AbstractMesh get pressedMesh;
	external set pressedMesh( AbstractMesh value );
	
	/// the mesh that defines the unpressed value mesh position.
	/// This is used to find the min (or initial) position of this button
	external AbstractMesh get unpressedMesh;
	external set unpressedMesh( AbstractMesh value );
	
	/// The mesh that will be changed when value changes
	external AbstractMesh get valueMesh;
	external set valueMesh( AbstractMesh value );
}

/// A helper-interface for the 3 meshes needed for controller axis animation.
/// This will be expanded when touchpad animations are fully supported
/// The meshes are provided to the _lerpAxisTransform function to calculate the current position of the value mesh
@JS()
@anonymous
class IMotionControllerMeshMap {
	
	external factory IMotionControllerMeshMap({AbstractMesh maxMesh, AbstractMesh minMesh, AbstractMesh valueMesh});
	
	/// the mesh that defines the maximum value mesh position.
	external AbstractMesh get maxMesh;
	external set maxMesh( AbstractMesh value );
	
	/// the mesh that defines the minimum value mesh position.
	external AbstractMesh get minMesh;
	external set minMesh( AbstractMesh value );
	
	/// The mesh that will be changed when axis value changes
	external AbstractMesh get valueMesh;
	external set valueMesh( AbstractMesh value );
}

/// The elements needed for change-detection of the gamepad objects in motion controllers
@JS()
@anonymous
class IMinimalMotionControllerObject {
	
	external factory IMinimalMotionControllerObject({List<num> axes, List<IMinimalMotionControllerObjectButtons> buttons, List<IMinimalMotionControllerObjectHapticActuators> hapticActuators});
	
	/// Available axes of this controller
	external List<num> get axes;
	external set axes( List<num> value );
	
	/// An array of available buttons
	external List<IMinimalMotionControllerObjectButtons> get buttons;
	external set buttons( List<IMinimalMotionControllerObjectButtons> value );
	
	/// EXPERIMENTAL haptic support.
	external List<IMinimalMotionControllerObjectHapticActuators> get hapticActuators;
	external set hapticActuators( List<IMinimalMotionControllerObjectHapticActuators> value );
}

/// An Abstract Motion controller
/// This class receives an xrInput and a profile layout and uses those to initialize the components
/// Each component has an observable to check for changes in value and state
@JS()
abstract class WebXRAbstractMotionController implements IDisposable {
	
	/// constructs a new abstract motion controller
	/// @param scene the scene to which the model of the controller will be added
	/// @param layout The profile layout to load
	/// @param gamepadObject The gamepad object correlating to this controller
	/// @param handedness handedness (left/right/none) of this controller
	/// @param _doNotLoadControllerMesh set this flag to ignore the mesh loading
	external factory WebXRAbstractMotionController(Scene scene, IMotionControllerLayout layout, IMinimalMotionControllerObject gamepadObject, dynamic handedness, [bool? _doNotLoadControllerMesh]);
	
	external Scene get scene;
	external set scene(Scene value);
	
	external IMotionControllerLayout get layout;
	external set layout(IMotionControllerLayout value);
	
	/// The gamepad object correlating to this controller
	external IMinimalMotionControllerObject get gamepadObject;
	external set gamepadObject(IMinimalMotionControllerObject value);
	
	/// handedness (left/right/none) of this controller
	external dynamic get handedness;
	external set handedness(dynamic value);
	
	/// A map of components (WebXRControllerComponent) in this motion controller
	/// Components have a ComponentType and can also have both button and axis definitions
	external dynamic /* object */ get components;
	
	/// Disable the model's animation. Can be set at any time.
	external bool get disableAnimation;
	external set disableAnimation(bool value);
	
	/// Observers registered here will be triggered when the model of this controller is done loading
	external Observable<WebXRAbstractMotionController> get onModelLoadedObservable;
	external set onModelLoadedObservable(Observable<WebXRAbstractMotionController> value);
	
	/// The profile id of this motion controller
	external String get profileId;
	external set profileId(String value);
	
	/// The root mesh of the model. It is null if the model was not yet initialized
	external AbstractMesh? get rootMesh;
	external set rootMesh(AbstractMesh? value);
	
	/// Dispose this controller, the model mesh and all its components
	@override
	external void dispose();
	
	/// Returns all components of specific type
	/// @param type the type to search for
	/// @return an array of components with this type
	external List<WebXRControllerComponent> getAllComponentsOfType(dynamic type);
	
	/// get a component based an its component id as defined in layout.components
	/// @param id the id of the component
	/// @returns the component correlates to the id or undefined if not found
	external WebXRControllerComponent getComponent(String id);
	
	/// Get the list of components available in this motion controller
	/// @returns an array of strings correlating to available components
	external List<String> getComponentIds();
	
	/// Get the first component of specific type
	/// @param type type of component to find
	/// @return a controller component or null if not found
	external WebXRControllerComponent? getComponentOfType(dynamic type);
	
	/// Get the main (Select) component of this controller as defined in the layout
	/// @returns the main component of this controller
	external WebXRControllerComponent getMainComponent();
	
	/// Loads the model correlating to this controller
	/// When the mesh is loaded, the onModelLoadedObservable will be triggered
	/// @returns A promise fulfilled with the result of the model loading
	external Promise<bool> loadModel();
	
	/// Update this model using the current XRFrame
	/// @param xrFrame the current xr frame to use and update the model
	external void updateFromXRFrame(dynamic xrFrame);
	
	/// Backwards compatibility due to a deeply-integrated typo
	external dynamic get handness;
	
	/// Pulse (vibrate) this controller
	/// If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called
	/// Consecutive calls to this function will cancel the last pulse call
	/// 
	/// @param value the strength of the pulse in 0.0...1.0 range
	/// @param duration Duration of the pulse in milliseconds
	/// @param hapticActuatorIndex optional index of actuator (will usually be 0)
	/// @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued
	external Promise<bool> pulse(num value, num duration, [num? hapticActuatorIndex]);
	
	/// Update the model itself with the current frame data
	/// @param xrFrame the frame to use for updating the model mesh
	external void updateModel(dynamic xrFrame);
}

/// A generic trigger-only motion controller for WebXR
@JS()
class WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {
	
	external factory WebXRGenericTriggerMotionController(Scene scene, IMinimalMotionControllerObject gamepadObject, dynamic handedness);
	
	/// Static version of the profile id of this controller
	external static String get ProfileId;
	external static set ProfileId(String value);
	
	@override
	external String get profileId;
	@override
	external set profileId(String value);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class SphereBuilder {
	external factory SphereBuilder();
	
	/// Creates a sphere mesh
	/// * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
	/// * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
	/// * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
	/// * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
	/// * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the sphere mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#sphere
	external static Mesh CreateSphere(String name, SphereBuilderCreateSphereOptions options, [Scene? scene]);
}

/// A profiled motion controller has its profile loaded from an online repository.
/// The class is responsible of loading the model, mapping the keys and enabling model-animations
@JS()
class WebXRProfiledMotionController extends WebXRAbstractMotionController {
	
	external factory WebXRProfiledMotionController(Scene scene, dynamic xrInput, IMotionControllerProfile _profile, String _repositoryUrl);
	
	/// The profile ID of this controller. Will be populated when the controller initializes.
	@override
	external String get profileId;
	@override
	external set profileId(String value);
	
	@override
	external void dispose();
}

/// The MotionController Manager manages all registered motion controllers and loads the right one when needed.
/// 
/// When this repository is complete: https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets
/// it should be replaced with auto-loaded controllers.
/// 
/// When using a model try to stay as generic as possible. Eventually there will be no need in any of the controller classes
@JS()
class WebXRMotionControllerManager {
	external factory WebXRMotionControllerManager();
	
	/// The base URL of the online controller repository. Can be changed at any time.
	external static String get BaseRepositoryUrl;
	external static set BaseRepositoryUrl(String value);
	
	/// Which repository gets priority - local or online
	external static bool get PrioritizeOnlineRepository;
	external static set PrioritizeOnlineRepository(bool value);
	
	/// Use the online repository, or use only locally-defined controllers
	external static bool get UseOnlineRepository;
	external static set UseOnlineRepository(bool value);
	
	/// Clear the cache used for profile loading and reload when requested again
	external static void ClearProfilesCache();
	
	/// Register the default fallbacks.
	/// This function is called automatically when this file is imported.
	external static void DefaultFallbacks();
	
	/// Find a fallback profile if the profile was not found. There are a few predefined generic profiles.
	/// @param profileId the profile to which a fallback needs to be found
	/// @return an array with corresponding fallback profiles
	external static List<String> FindFallbackWithProfileId(String profileId);
	
	/// When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.
	/// The order of search:
	/// 
	/// 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller
	/// 2) (If not found) search in the gamepad id and try using it (legacy versions only)
	/// 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)
	/// 4) return the generic trigger controller if none were found
	/// 
	/// @param xrInput the xrInput to which a new controller is initialized
	/// @param scene the scene to which the model will be added
	/// @param forceProfile force a certain profile for this controller
	/// @return A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found
	external static Promise<WebXRAbstractMotionController> GetMotionControllerWithXRInput(dynamic xrInput, Scene scene, [String? forceProfile]);
	
	/// Register a new controller based on its profile. This function will be called by the controller classes themselves.
	/// 
	/// If you are missing a profile, make sure it is imported in your source, otherwise it will not register.
	/// 
	/// @param type the profile type to register
	/// @param constructFunction the function to be called when loading this profile
	external static void RegisterController(String type, dynamic constructFunction);
	
	/// Register a fallback to a specific profile.
	/// @param profileId the profileId that will receive the fallbacks
	/// @param fallbacks A list of fallback profiles
	external static void RegisterFallbacksForProfileId(String profileId, List<String> fallbacks);
	
	/// Will update the list of profiles available in the repository
	/// @return a promise that resolves to a map of profiles available online
	external static Promise<dynamic /* object */> UpdateProfilesList();
}

/// Configuration options for the WebXR controller creation
@JS()
@anonymous
class IWebXRControllerOptions {
	
	external factory IWebXRControllerOptions({bool disableMotionControllerAnimation, bool doNotLoadControllerMesh, String forceControllerProfile, num renderingGroupId});
	
	/// Should the controller mesh be animated when a user interacts with it
	/// The pressed buttons / thumbstick and touchpad animations will be disabled
	external bool get disableMotionControllerAnimation;
	external set disableMotionControllerAnimation( bool value );
	
	/// Do not load the controller mesh, in case a different mesh needs to be loaded.
	external bool get doNotLoadControllerMesh;
	external set doNotLoadControllerMesh( bool value );
	
	/// Force a specific controller type for this controller.
	/// This can be used when creating your own profile or when testing different controllers
	external String get forceControllerProfile;
	external set forceControllerProfile( String value );
	
	/// Defines a rendering group ID for meshes that will be loaded.
	/// This is for the default controllers only.
	external num get renderingGroupId;
	external set renderingGroupId( num value );
}

/// Represents an XR controller
@JS()
class WebXRInputSource {
	
	/// Creates the input source object
	/// @see https://doc.babylonjs.com/how_to/webxr_controllers_support
	/// @param _scene the scene which the controller should be associated to
	/// @param inputSource the underlying input source for the controller
	/// @param _options options for this controller creation
	external factory WebXRInputSource(Scene _scene, dynamic inputSource, [IWebXRControllerOptions? _options]);
	
	/// The underlying input source for the controller
	external dynamic get inputSource;
	external set inputSource(dynamic value);
	
	/// Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if thats the case only the pointer from the head will be availible
	external AbstractMesh get grip;
	external set grip(AbstractMesh value);
	
	/// If available, this is the gamepad object related to this controller.
	/// Using this object it is possible to get click events and trackpad changes of the
	/// webxr controller that is currently being used.
	external WebXRAbstractMotionController get motionController;
	external set motionController(WebXRAbstractMotionController value);
	
	/// Event that fires when the controller is removed/disposed.
	/// The object provided as event data is this controller, after associated assets were disposed.
	/// uniqueId is still available.
	external Observable<WebXRInputSource> get onDisposeObservable;
	external set onDisposeObservable(Observable<WebXRInputSource> value);
	
	/// Will be triggered when the mesh associated with the motion controller is done loading.
	/// It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh
	/// A shortened version of controller -> motion controller -> on mesh loaded.
	external Observable<AbstractMesh> get onMeshLoadedObservable;
	external set onMeshLoadedObservable(Observable<AbstractMesh> value);
	
	/// Observers registered here will trigger when a motion controller profile was assigned to this xr controller
	external Observable<WebXRAbstractMotionController> get onMotionControllerInitObservable;
	external set onMotionControllerInitObservable(Observable<WebXRAbstractMotionController> value);
	
	/// Pointer which can be used to select objects or attach a visible laser to
	external AbstractMesh get pointer;
	external set pointer(AbstractMesh value);
	
	/// Get this controllers unique id
	external String get uniqueId;
	
	/// Disposes of the object
	external void dispose();
	
	/// Gets a world space ray coming from the pointer or grip
	/// @param result the resulting ray
	/// @param gripIfAvailable use the grip mesh instead of the pointer, if available
	external void getWorldPointerRayToRef(Ray result, [bool? gripIfAvailable]);
	
	/// Updates the controller pose based on the given XRFrame
	/// @param xrFrame xr frame to update the pose with
	/// @param referenceSpace reference space to use
	external void updateFromXRFrame(dynamic xrFrame, dynamic referenceSpace);
}

/// The schema for initialization options of the XR Input class
@JS()
@anonymous
class IWebXRInputOptions {
	
	external factory IWebXRInputOptions({bool doNotLoadControllerMeshes, String forceInputProfile, bool disableOnlineControllerRepository, String customControllersRepositoryURL, bool disableControllerAnimation, IWebXRControllerOptions controllerOptions});
	
	/// If set to true no model will be automatically loaded
	external bool get doNotLoadControllerMeshes;
	external set doNotLoadControllerMeshes( bool value );
	
	/// If set, this profile will be used for all controllers loaded (for example "microsoft-mixed-reality")
	/// If not found, the xr input profile data will be used.
	/// Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/
	external String get forceInputProfile;
	external set forceInputProfile( String value );
	
	/// Do not send a request to the controller repository to load the profile.
	/// 
	/// Instead, use the controllers available in babylon itself.
	external bool get disableOnlineControllerRepository;
	external set disableOnlineControllerRepository( bool value );
	
	/// A custom URL for the controllers repository
	external String get customControllersRepositoryURL;
	external set customControllersRepositoryURL( String value );
	
	/// Should the controller model's components not move according to the user input
	external bool get disableControllerAnimation;
	external set disableControllerAnimation( bool value );
	
	/// Optional options to pass to the controller. Will be overridden by the Input options where applicable
	external IWebXRControllerOptions get controllerOptions;
	external set controllerOptions( IWebXRControllerOptions value );
}

/// XR input used to track XR inputs such as controllers/rays
@JS()
class WebXRInput implements IDisposable {
	
	/// Initializes the WebXRInput
	/// @param xrSessionManager the xr session manager for this session
	/// @param xrCamera the WebXR camera for this session. Mainly used for teleportation
	/// @param options = initialization options for this xr input
	external factory WebXRInput(WebXRSessionManager xrSessionManager, WebXRCamera xrCamera, [IWebXRInputOptions? options]);
	
	/// the xr session manager for this session
	external WebXRSessionManager get xrSessionManager;
	external set xrSessionManager(WebXRSessionManager value);
	
	/// the WebXR camera for this session. Mainly used for teleportation
	external WebXRCamera get xrCamera;
	external set xrCamera(WebXRCamera value);
	
	/// XR controllers being tracked
	external List<WebXRInputSource> get controllers;
	external set controllers(List<WebXRInputSource> value);
	
	/// Event when a controller has been connected/added
	external Observable<WebXRInputSource> get onControllerAddedObservable;
	external set onControllerAddedObservable(Observable<WebXRInputSource> value);
	
	/// Event when a controller has been removed/disconnected
	external Observable<WebXRInputSource> get onControllerRemovedObservable;
	external set onControllerRemovedObservable(Observable<WebXRInputSource> value);
	
	/// Disposes of the object
	@override
	external void dispose();
}

/// This is the base class for all WebXR features.
/// Since most features require almost the same resources and callbacks, this class can be used to simplify the development
/// Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class
@JS()
abstract class WebXRAbstractFeature implements IWebXRFeature {
	
	/// Construct a new (abstract) WebXR feature
	/// @param _xrSessionManager the xr session manager for this feature
	external factory WebXRAbstractFeature(WebXRSessionManager _xrSessionManager);
	
	/// Is this feature disposed?
	@override
	external bool get isDisposed;
	@override
	external set isDisposed(bool value);
	
	/// Should auto-attach be disabled?
	@override
	external bool get disableAutoAttach;
	@override
	external set disableAutoAttach(bool value);
	
	/// The name of the native xr feature name (like anchor, hit-test, or hand-tracking)
	@override
	external String get xrNativeFeatureName;
	@override
	external set xrNativeFeatureName(String value);
	
	/// Is this feature attached
	@override
	external bool get attached;
	
	/// attach this feature
	/// 
	/// @param force should attachment be forced (even when already attached)
	/// @returns true if successful, false is failed or already attached
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// 
	/// @returns true if successful, false if failed or already detached
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// This function will be executed during before enabling the feature and can be used to not-allow enabling it.
	/// Note that at this point the session has NOT started, so this is purely checking if the browser supports it
	/// 
	/// @returns whether or not the feature is compatible in this environment
	@override
	external bool isCompatible();
}

/// Renders a layer on top of an existing scene
@JS()
class UtilityLayerRenderer implements IDisposable {
	
	/// Instantiates a UtilityLayerRenderer
	/// @param originalScene the original scene that will be rendered on top of
	/// @param handleEvents boolean indicating if the utility layer should handle events
	external factory UtilityLayerRenderer(Scene originalScene, [bool? handleEvents]);
	
	/// the original scene that will be rendered on top of
	external Scene get originalScene;
	external set originalScene(Scene value);
	
	/// Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
	/// @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
	/// @returns the camera that is used when rendering the utility layer
	external Camera getRenderCamera([bool? getRigParentIfPossible]);
	
	/// Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
	/// @param cam the camera that should be used when rendering the utility layer
	external void setRenderCamera(Camera? cam);
	
	/// If the picking should be done on the utility layer prior to the actual scene (Default: true)
	external bool get pickUtilitySceneFirst;
	external set pickUtilitySceneFirst(bool value);
	
	/// A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
	external static UtilityLayerRenderer get DefaultUtilityLayer;
	
	/// A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
	external static UtilityLayerRenderer get DefaultKeepDepthUtilityLayer;
	
	/// The scene that is rendered on top of the original scene
	external Scene get utilityLayerScene;
	external set utilityLayerScene(Scene value);
	
	/// If the utility layer should automatically be rendered on top of existing scene
	external bool get shouldRender;
	external set shouldRender(bool value);
	
	/// If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene
	external bool get onlyCheckPointerDownEvents;
	external set onlyCheckPointerDownEvents(bool value);
	
	/// If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)
	external bool get processAllEvents;
	external set processAllEvents(bool value);
	
	/// Observable raised when the pointer move from the utility layer scene to the main scene
	external Observable<num> get onPointerOutObservable;
	external set onPointerOutObservable(Observable<num> value);
	
	/// Gets or sets a predicate that will be used to indicate utility meshes present in the main scene
	external bool Function(AbstractMesh? mesh) get mainSceneTrackerPredicate;
	external set mainSceneTrackerPredicate(bool Function(AbstractMesh? mesh) value);
	
	/// Renders the utility layers scene on top of the original scene
	external void render();
	
	/// Disposes of the renderer
	@override
	external void dispose();
}

/// Options interface for the pointer selection module
@JS()
@anonymous
class IWebXRControllerPointerSelectionOptions {
	
	external factory IWebXRControllerPointerSelectionOptions({Scene customUtilityLayerScene, bool disablePointerUpOnTouchOut, bool forceGazeMode, num gazeModePointerMovedFactor, String overrideButtonId, num renderingGroupId, num timeToSelect, bool useUtilityLayer, WebXRCamera gazeCamera, WebXRInput xrInput, bool disableScenePointerVectorUpdate, bool enablePointerSelectionOnAllControllers, dynamic preferredHandedness, bool disableSwitchOnClick, num maxPointerDistance});
	
	/// if provided, this scene will be used to render meshes.
	external Scene get customUtilityLayerScene;
	external set customUtilityLayerScene( Scene value );
	
	/// Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)
	/// If not disabled, the last picked point will be used to execute a pointer up event
	/// If disabled, pointer up event will be triggered right after the pointer down event.
	/// Used in screen and gaze target ray mode only
	external bool get disablePointerUpOnTouchOut;
	external set disablePointerUpOnTouchOut( bool value );
	
	/// For gaze mode for tracked-pointer / controllers (time to select instead of button press)
	external bool get forceGazeMode;
	external set forceGazeMode( bool value );
	
	/// Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved
	/// to start a new countdown to the pointer down event.
	/// Defaults to 1.
	external num get gazeModePointerMovedFactor;
	external set gazeModePointerMovedFactor( num value );
	
	/// Different button type to use instead of the main component
	external String get overrideButtonId;
	external set overrideButtonId( String value );
	
	/// use this rendering group id for the meshes (optional)
	external num get renderingGroupId;
	external set renderingGroupId( num value );
	
	/// The amount of time in milliseconds it takes between pick found something to a pointer down event.
	/// Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events
	/// 3000 means 3 seconds between pointing at something and selecting it
	external num get timeToSelect;
	external set timeToSelect( num value );
	
	/// Should meshes created here be added to a utility layer or the main scene
	external bool get useUtilityLayer;
	external set useUtilityLayer( bool value );
	
	/// Optional WebXR camera to be used for gaze selection
	external WebXRCamera get gazeCamera;
	external set gazeCamera( WebXRCamera value );
	
	/// the xr input to use with this pointer selection
	external WebXRInput get xrInput;
	external set xrInput( WebXRInput value );
	
	/// Should the scene pointerX and pointerY update be disabled
	/// This is required for fullscreen AR GUI, but might slow down other experiences.
	/// Disable in VR, if not needed.
	/// The first rig camera (left eye) will be used to calculate the projection
	external bool get disableScenePointerVectorUpdate;
	external set disableScenePointerVectorUpdate( bool value );
	
	/// Enable pointer selection on all controllers instead of switching between them
	external bool get enablePointerSelectionOnAllControllers;
	external set enablePointerSelectionOnAllControllers( bool value );
	
	/// The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.
	/// If switch is enabled, it will still allow the user to switch between the different controllers
	external dynamic get preferredHandedness;
	external set preferredHandedness( dynamic value );
	
	/// Disable switching the pointer selection from one controller to the other.
	/// If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene
	external bool get disableSwitchOnClick;
	external set disableSwitchOnClick( bool value );
	
	/// The maximum distance of the pointer selection feature. Defaults to 100.
	external num get maxPointerDistance;
	external set maxPointerDistance( num value );
}

/// A module that will enable pointer selection for motion controllers of XR Input Sources
@JS()
class WebXRControllerPointerSelection extends WebXRAbstractFeature {
	
	/// constructs a new background remover module
	/// @param _xrSessionManager the session manager for this module
	/// @param _options read-only options to be used in this module
	external factory WebXRControllerPointerSelection(WebXRSessionManager _xrSessionManager, IWebXRControllerPointerSelectionOptions _options);
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// Disable lighting on the laser pointer (so it will always be visible)
	external bool get disablePointerLighting;
	external set disablePointerLighting(bool value);
	
	/// Disable lighting on the selection mesh (so it will always be visible)
	external bool get disableSelectionMeshLighting;
	external set disableSelectionMeshLighting(bool value);
	
	/// Should the laser pointer be displayed
	external bool get displayLaserPointer;
	external set displayLaserPointer(bool value);
	
	/// Should the selection mesh be displayed (The ring at the end of the laser pointer)
	external bool get displaySelectionMesh;
	external set displaySelectionMesh(bool value);
	
	/// This color will be set to the laser pointer when selection is triggered
	external Color3 get laserPointerPickedColor;
	external set laserPointerPickedColor(Color3 value);
	
	/// Default color of the laser pointer
	external Color3 get laserPointerDefaultColor;
	external set laserPointerDefaultColor(Color3 value);
	
	/// default color of the selection ring
	external Color3 get selectionMeshDefaultColor;
	external set selectionMeshDefaultColor(Color3 value);
	
	/// This color will be applied to the selection ring when selection is triggered
	external Color3 get selectionMeshPickedColor;
	external set selectionMeshPickedColor(Color3 value);
	
	/// Optional filter to be used for ray selection.  This predicate shares behavior with
	/// scene.pointerMovePredicate which takes priority if it is also assigned.
	external bool Function(AbstractMesh mesh) get raySelectionPredicate;
	external set raySelectionPredicate(bool Function(AbstractMesh mesh) value);
	
	/// attach this feature
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Will get the mesh under a specific pointer.
	/// `scene.meshUnderPointer` will only return one mesh - either left or right.
	/// @param controllerId the controllerId to check
	/// @returns The mesh under pointer or null if no mesh is under the pointer
	external AbstractMesh? getMeshUnderPointer(String controllerId);
	
	/// Get the xr controller that correlates to the pointer id in the pointer event
	/// 
	/// @param id the pointer id to search for
	/// @returns the controller that correlates to this id or null if not found
	external WebXRInputSource? getXRControllerByPointerId(num id);
	
	/// @hidden
	external Color3 get lasterPointerDefaultColor;
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
	
	/// Releases all held resources
	external void dispose();
}

/// Button which can be used to enter a different mode of XR
@JS()
class WebXREnterExitUIButton {
	
	/// Creates a WebXREnterExitUIButton
	/// @param element button element
	/// @param sessionMode XR initialization session mode
	/// @param referenceSpaceType the type of reference space to be used
	external factory WebXREnterExitUIButton(HTML.Element element, dynamic sessionMode, dynamic referenceSpaceType);
	
	/// button element
	external HTML.Element get element;
	external set element(HTML.Element value);
	
	/// XR initialization options for the button
	external dynamic get sessionMode;
	external set sessionMode(dynamic value);
	
	/// Reference space type
	external dynamic get referenceSpaceType;
	external set referenceSpaceType(dynamic value);
	
	/// Extendable function which can be used to update the button's visuals when the state changes
	/// @param activeButton the current active button in the UI
	external void update(WebXREnterExitUIButton? activeButton);
}

/// Options to create the webXR UI
@JS()
class WebXREnterExitUIOptions {
	external factory WebXREnterExitUIOptions();
	
	/// User provided buttons to enable/disable WebXR. The system will provide default if not set
	external List<WebXREnterExitUIButton> get customButtons;
	external set customButtons(List<WebXREnterExitUIButton> value);
	
	/// A reference space type to use when creating the default button.
	/// Default is local-floor
	external dynamic get referenceSpaceType;
	external set referenceSpaceType(dynamic value);
	
	/// Context to enter xr with
	external WebXRRenderTarget? get renderTarget;
	external set renderTarget(WebXRRenderTarget? value);
	
	/// A session mode to use when creating the default button.
	/// Default is immersive-vr
	external dynamic get sessionMode;
	external set sessionMode(dynamic value);
	
	/// A list of optional features to init the session with
	external List<String> get optionalFeatures;
	external set optionalFeatures(List<String> value);
	
	/// A list of optional features to init the session with
	external List<String> get requiredFeatures;
	external set requiredFeatures(List<String> value);
	
	/// If defined, this function will be executed if the UI encounters an error when entering XR
	external void Function(dynamic error) get onError;
	external set onError(void Function(dynamic error) value);
}

/// UI to allow the user to enter/exit XR mode
@JS()
class WebXREnterExitUI implements IDisposable {
	
	/// 
	/// @param scene babylon scene object to use
	/// @param options (read-only) version of the options passed to this UI
	external factory WebXREnterExitUI();
	
	/// version of the options passed to this UI
	external WebXREnterExitUIOptions get options;
	external set options(WebXREnterExitUIOptions value);
	
	/// The HTML Div Element to which buttons are added.
	external HTML.DivElement get overlay;
	
	/// Fired every time the active button is changed.
	/// 
	/// When xr is entered via a button that launches xr that button will be the callback parameter
	/// 
	/// When exiting xr the callback parameter will be null)
	external Observable<WebXREnterExitUIButton?> get activeButtonChangedObservable;
	external set activeButtonChangedObservable(Observable<WebXREnterExitUIButton?> value);
	
	/// Creates UI to allow the user to enter/exit XR mode
	/// @param scene the scene to add the ui to
	/// @param helper the xr experience helper to enter/exit xr with
	/// @param options options to configure the UI
	/// @returns the created ui
	external static Promise<WebXREnterExitUI> CreateAsync(Scene scene, WebXRExperienceHelper helper, WebXREnterExitUIOptions options);
	
	/// Disposes of the XR UI component
	@override
	external void dispose();
}

/// Class containing static functions to help procedurally build meshes
@JS()
class LinesBuilder {
	external factory LinesBuilder();
	
	/// Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
	/// * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
	/// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
	/// * The parameter `lines` is an array of lines, each line being an array of successive Vector3
	/// * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
	/// * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
	/// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
	/// * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
	/// * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system
	/// @param name defines the name of the new line system
	/// @param options defines the options used to create the line system
	/// @param scene defines the hosting scene
	/// @returns a new line system mesh
	external static LinesMesh CreateLineSystem(String name, LinesBuilderCreateLineSystemOptions options, Scene? scene);
	
	/// Creates a line mesh
	/// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
	/// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
	/// * The parameter `points` is an array successive Vector3
	/// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
	/// * The optional parameter `colors` is an array of successive Color4, one per line point
	/// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
	/// * When updating an instance, remember that only point positions can change, not the number of points
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#lines
	/// @param name defines the name of the new line system
	/// @param options defines the options used to create the line system
	/// @param scene defines the hosting scene
	/// @returns a new line mesh
	external static LinesMesh CreateLines(String name, LinesBuilderCreateLinesOptions options, [Scene? scene]);
	
	/// Creates a dashed line mesh
	/// * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
	/// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
	/// * The parameter `points` is an array successive Vector3
	/// * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
	/// * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
	/// * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
	/// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
	/// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
	/// * When updating an instance, remember that only point positions can change, not the number of points
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the dashed line mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
	external static LinesMesh CreateDashedLines(String name, LinesBuilderCreateDashedLinesOptions options, [Scene? scene]);
}

/// Construction options for a timer
@JS()
@anonymous
class ITimerOptions<T> {
	
	external factory ITimerOptions({num timeout, Observable<T> contextObservable, ITimerOptionsObservableParameters observableParameters, bool Function([ITimerData<T>? data]) breakCondition, void Function(ITimerData<dynamic> data) onEnded, void Function(ITimerData<dynamic> data) onAborted, void Function(ITimerData<dynamic> data) onTick});
	
	/// Time-to-end
	external num get timeout;
	external set timeout( num value );
	
	/// The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.
	/// Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if
	/// you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time
	external Observable<T> get contextObservable;
	external set contextObservable( Observable<T> value );
	
	/// Optional parameters when adding an observer to the observable
	external ITimerOptionsObservableParameters get observableParameters;
	external set observableParameters( ITimerOptionsObservableParameters value );
	
	/// An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!
	external bool Function([ITimerData<T>? data]) get breakCondition;
	external set breakCondition( bool Function([ITimerData<T>? data]) value );
	
	/// Will be triggered when the time condition has met
	external void Function(ITimerData<dynamic> data) get onEnded;
	external set onEnded( void Function(ITimerData<dynamic> data) value );
	
	/// Will be triggered when the break condition has met (prematurely ended)
	external void Function(ITimerData<dynamic> data) get onAborted;
	external set onAborted( void Function(ITimerData<dynamic> data) value );
	
	/// Optional function to execute on each tick (or count)
	external void Function(ITimerData<dynamic> data) get onTick;
	external set onTick( void Function(ITimerData<dynamic> data) value );
}

/// An interface defining the data sent by the timer
@JS()
@anonymous
class ITimerData<T> {
	
	external factory ITimerData({num startTime, num currentTime, num deltaTime, num completeRate, T payload});
	
	/// When did it start
	external num get startTime;
	external set startTime( num value );
	
	/// Time now
	external num get currentTime;
	external set currentTime( num value );
	
	/// Time passed since started
	external num get deltaTime;
	external set deltaTime( num value );
	
	/// How much is completed, in [0.0...1.0].
	/// Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls
	external num get completeRate;
	external set completeRate( num value );
	
	/// What the registered observable sent in the last count
	external T get payload;
	external set payload( T value );
}

/* enum */
abstract class TimerState {
	
	/// Timer initialized, not yet started
	static const int INIT = 1;
	
	/// Timer started and counting
	static const int STARTED = 2;
	
	/// Timer ended (whether aborted or time reached)
	static const int ENDED = 3;
}

/* top level function */
/// A simple version of the timer. Will take options and start the timer immediately after calling it
/// 
/// @param options options with which to initialize this timer
@JS()
external Observer<dynamic>? setAndStartTimer(ITimerOptions<dynamic> options);

/// An advanced implementation of a timer class
@JS()
class AdvancedTimer<T extends dynamic> implements IDisposable {
	
	/// Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.
	/// @param options construction options for this advanced timer
	external factory AdvancedTimer(ITimerOptions<T> options);
	
	/// Will notify each time the timer calculates the remaining time
	external Observable<ITimerData<T>> get onEachCountObservable;
	external set onEachCountObservable(Observable<ITimerData<T>> value);
	
	/// Will trigger when the timer was aborted due to the break condition
	external Observable<ITimerData<T>> get onTimerAbortedObservable;
	external set onTimerAbortedObservable(Observable<ITimerData<T>> value);
	
	/// Will trigger when the timer ended successfully
	external Observable<ITimerData<T>> get onTimerEndedObservable;
	external set onTimerEndedObservable(Observable<ITimerData<T>> value);
	
	/// Will trigger when the timer state has changed
	external Observable<int> get onStateChangedObservable;
	external set onStateChangedObservable(Observable<int> value);
	
	/// set a breaking condition for this timer. Default is to never break during count
	/// @param predicate the new break condition. Returns true to break, false otherwise
	external set breakCondition(bool Function(ITimerData<T> data) value);
	
	/// Reset ALL associated observables in this advanced timer
	external void clearObservables();
	
	/// Will start a new iteration of this timer. Only one instance of this timer can run at a time.
	/// 
	/// @param timeToEnd how much time to measure until timer ended
	external void start([num? timeToEnd]);
	
	/// Will force a stop on the next tick.
	external void stop();
	
	/// Dispose this timer, clearing all resources
	@override
	external void dispose();
}

/// The options container for the teleportation module
@JS()
@anonymous
class IWebXRTeleportationOptions {
	
	external factory IWebXRTeleportationOptions({Scene customUtilityLayerScene, IWebXRTeleportationOptionsDefaultTargetMeshOptions defaultTargetMeshOptions, List<AbstractMesh> floorMeshes, num renderingGroupId, bool snapPointsOnly, List<Vector3> snapPositions, num snapToPositionRadius, AbstractMesh teleportationTargetMesh, num timeToTeleport, bool useMainComponentOnly, bool useUtilityLayer, WebXRInput xrInput, List<AbstractMesh> pickBlockerMeshes, dynamic forceHandedness, AbstractMesh Function(List<Vector3> points) generateRayPathMesh});
	
	/// if provided, this scene will be used to render meshes.
	external Scene get customUtilityLayerScene;
	external set customUtilityLayerScene( Scene value );
	
	/// Values to configure the default target mesh
	external IWebXRTeleportationOptionsDefaultTargetMeshOptions get defaultTargetMeshOptions;
	external set defaultTargetMeshOptions( IWebXRTeleportationOptionsDefaultTargetMeshOptions value );
	
	/// A list of meshes to use as floor meshes.
	/// Meshes can be added and removed after initializing the feature using the
	/// addFloorMesh and removeFloorMesh functions
	/// If empty, rotation will still work
	external List<AbstractMesh> get floorMeshes;
	external set floorMeshes( List<AbstractMesh> value );
	
	/// use this rendering group id for the meshes (optional)
	external num get renderingGroupId;
	external set renderingGroupId( num value );
	
	/// Should teleportation move only to snap points
	external bool get snapPointsOnly;
	external set snapPointsOnly( bool value );
	
	/// An array of points to which the teleportation will snap to.
	/// If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.
	external List<Vector3> get snapPositions;
	external set snapPositions( List<Vector3> value );
	
	/// How close should the teleportation ray be in order to snap to position.
	/// Default to 0.8 units (meters)
	external num get snapToPositionRadius;
	external set snapToPositionRadius( num value );
	
	/// Provide your own teleportation mesh instead of babylon's wonderful doughnut.
	/// If you want to support rotation, make sure your mesh has a direction indicator.
	/// 
	/// When left untouched, the default mesh will be initialized.
	external AbstractMesh get teleportationTargetMesh;
	external set teleportationTargetMesh( AbstractMesh value );
	
	/// If main component is used (no thumbstick), how long should the "long press" take before teleport
	external num get timeToTeleport;
	external set timeToTeleport( num value );
	
	/// Disable using the thumbstick and use the main component (usually trigger) on long press.
	/// This will be automatically true if the controller doesn't have a thumbstick or touchpad.
	external bool get useMainComponentOnly;
	external set useMainComponentOnly( bool value );
	
	/// Should meshes created here be added to a utility layer or the main scene
	external bool get useUtilityLayer;
	external set useUtilityLayer( bool value );
	
	/// Babylon XR Input class for controller
	external WebXRInput get xrInput;
	external set xrInput( WebXRInput value );
	
	/// Meshes that the teleportation ray cannot go through
	external List<AbstractMesh> get pickBlockerMeshes;
	external set pickBlockerMeshes( List<AbstractMesh> value );
	
	/// Should teleport work only on a specific hand?
	external dynamic get forceHandedness;
	external set forceHandedness( dynamic value );
	
	/// If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default
	external AbstractMesh Function(List<Vector3> points) get generateRayPathMesh;
	external set generateRayPathMesh( AbstractMesh Function(List<Vector3> points) value );
}

/// This is a teleportation feature to be used with WebXR-enabled motion controllers.
/// When enabled and attached, the feature will allow a user to move around and rotate in the scene using
/// the input of the attached controllers.
@JS()
class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {
	
	/// constructs a new anchor system
	/// @param _xrSessionManager an instance of WebXRSessionManager
	/// @param _options configuration object for this feature
	external factory WebXRMotionControllerTeleportation(WebXRSessionManager _xrSessionManager, IWebXRTeleportationOptions _options);
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the webxr specs version
	external static num get Version;
	
	/// Is movement backwards enabled
	external bool get backwardsMovementEnabled;
	external set backwardsMovementEnabled(bool value);
	
	/// Distance to travel when moving backwards
	external num get backwardsTeleportationDistance;
	external set backwardsTeleportationDistance(num value);
	
	/// The distance from the user to the inspection point in the direction of the controller
	/// A higher number will allow the user to move further
	/// defaults to 5 (meters, in xr units)
	external num get parabolicCheckRadius;
	external set parabolicCheckRadius(num value);
	
	/// Should the module support parabolic ray on top of direct ray
	/// If enabled, the user will be able to point "at the sky" and move according to predefined radius distance
	/// Very helpful when moving between floors / different heights
	external bool get parabolicRayEnabled;
	external set parabolicRayEnabled(bool value);
	
	/// The second type of ray - straight line.
	/// Should it be enabled or should the parabolic line be the only one.
	external bool get straightRayEnabled;
	external set straightRayEnabled(bool value);
	
	/// How much rotation should be applied when rotating right and left
	external num get rotationAngle;
	external set rotationAngle(num value);
	
	/// Is rotation enabled when moving forward?
	/// Disabling this feature will prevent the user from deciding the direction when teleporting
	external bool get rotationEnabled;
	
	/// Sets wether rotation is enabled or not
	/// @param enabled is rotation enabled when teleportation is shown
	external set rotationEnabled(bool value);
	
	/// Exposes the currently set teleportation target mesh.
	external AbstractMesh? get teleportationTargetMesh;
	
	/// Get the snapPointsOnly flag
	external bool get snapPointsOnly;
	
	/// Sets the snapPointsOnly flag
	/// @param snapToPoints should teleportation be exclusively to snap points
	external set snapPointsOnly(bool value);
	
	/// Add a new mesh to the floor meshes array
	/// @param mesh the mesh to use as floor mesh
	external void addFloorMesh(AbstractMesh mesh);
	
	/// Add a new snap-to point to fix teleportation to this position
	/// @param newSnapPoint The new Snap-To point
	external void addSnapPoint(Vector3 newSnapPoint);
	
	@override
	external bool attach([bool? force]);
	
	@override
	external bool detach();
	
	@override
	external void dispose();
	
	/// Remove a mesh from the floor meshes array
	/// @param mesh the mesh to remove
	external void removeFloorMesh(AbstractMesh mesh);
	
	/// Remove a mesh from the floor meshes array using its name
	/// @param name the mesh name to remove
	external void removeFloorMeshByName(String name);
	
	/// This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array
	/// @param snapPointToRemove the point (or a clone of it) to be removed from the array
	/// @returns was the point found and removed or not
	external bool removeSnapPoint(Vector3 snapPointToRemove);
	
	/// This function sets a selection feature that will be disabled when
	/// the forward ray is shown and will be reattached when hidden.
	/// This is used to remove the selection rays when moving.
	/// @param selectionFeature the feature to disable when forward movement is enabled
	external void setSelectionFeature(IWebXRFeature? selectionFeature);
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// Options for the default xr helper
@JS()
class WebXRDefaultExperienceOptions {
	external factory WebXRDefaultExperienceOptions();
	
	/// Enable or disable default UI to enter XR
	external bool get disableDefaultUI;
	external set disableDefaultUI(bool value);
	
	/// Should teleportation not initialize. defaults to false.
	external bool get disableTeleportation;
	external set disableTeleportation(bool value);
	
	/// Floor meshes that will be used for teleport
	external List<AbstractMesh> get floorMeshes;
	external set floorMeshes(List<AbstractMesh> value);
	
	/// If set to true, the first frame will not be used to reset position
	/// The first frame is mainly used when copying transformation from the old camera
	/// Mainly used in AR
	external bool get ignoreNativeCameraTransformation;
	external set ignoreNativeCameraTransformation(bool value);
	
	/// Disable the controller mesh-loading. Can be used if you want to load your own meshes
	external IWebXRInputOptions get inputOptions;
	external set inputOptions(IWebXRInputOptions value);
	
	/// optional configuration for the output canvas
	external WebXRManagedOutputCanvasOptions get outputCanvasOptions;
	external set outputCanvasOptions(WebXRManagedOutputCanvasOptions value);
	
	/// optional UI options. This can be used among other to change session mode and reference space type
	external WebXREnterExitUIOptions get uiOptions;
	external set uiOptions(WebXREnterExitUIOptions value);
	
	/// When loading teleportation and pointer select, use stable versions instead of latest.
	external bool get useStablePlugins;
	external set useStablePlugins(bool value);
	
	/// An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes
	external num get renderingGroupId;
	external set renderingGroupId(num value);
	
	/// A list of optional features to init the session with
	/// If set to true, all features we support will be added
	external dynamic get optionalFeatures;
	external set optionalFeatures(dynamic value);
}

/// Default experience which provides a similar setup to the previous webVRExperience
@JS()
class WebXRDefaultExperience {
	
	external factory WebXRDefaultExperience();
	
	/// Base experience
	external WebXRExperienceHelper get baseExperience;
	external set baseExperience(WebXRExperienceHelper value);
	
	/// Enables ui for entering/exiting xr
	external WebXREnterExitUI get enterExitUI;
	external set enterExitUI(WebXREnterExitUI value);
	
	/// Input experience extension
	external WebXRInput get input;
	external set input(WebXRInput value);
	
	/// Enables laser pointer and selection
	external WebXRControllerPointerSelection get pointerSelection;
	external set pointerSelection(WebXRControllerPointerSelection value);
	
	/// Default target xr should render to
	external WebXRRenderTarget get renderTarget;
	external set renderTarget(WebXRRenderTarget value);
	
	/// Enables teleportation
	external WebXRMotionControllerTeleportation get teleportation;
	external set teleportation(WebXRMotionControllerTeleportation value);
	
	/// Creates the default xr experience
	/// @param scene scene
	/// @param options options for basic configuration
	/// @returns resulting WebXRDefaultExperience
	external static Promise<WebXRDefaultExperience> CreateAsync(Scene scene, [WebXRDefaultExperienceOptions? options]);
	
	/// DIsposes of the experience helper
	external void dispose();
}

/// Options to modify the vr teleportation behavior.
@JS()
@anonymous
class VRTeleportationOptions {
	
	external factory VRTeleportationOptions({String floorMeshName, List<Mesh> floorMeshes, num teleportationMode, num teleportationTime, num teleportationSpeed, EasingFunction easingFunction});
	
	/// The name of the mesh which should be used as the teleportation floor. (default: null)
	external String get floorMeshName;
	external set floorMeshName( String value );
	
	/// A list of meshes to be used as the teleportation floor. (default: empty)
	external List<Mesh> get floorMeshes;
	external set floorMeshes( List<Mesh> value );
	
	/// The teleportation mode. (default: TELEPORTATIONMODE_CONSTANTTIME)
	external num get teleportationMode;
	external set teleportationMode( num value );
	
	/// The duration of the animation in ms, apply when animationMode is TELEPORTATIONMODE_CONSTANTTIME. (default 122ms)
	external num get teleportationTime;
	external set teleportationTime( num value );
	
	/// The speed of the animation in distance/sec, apply when animationMode is TELEPORTATIONMODE_CONSTANTSPEED. (default 20 units / sec)
	external num get teleportationSpeed;
	external set teleportationSpeed( num value );
	
	/// The easing function used in the animation or null for Linear. (default CircleEase)
	external EasingFunction get easingFunction;
	external set easingFunction( EasingFunction value );
}

/// Options to modify the vr experience helper's behavior.
@JS()
@anonymous
class VRExperienceHelperOptions {
	
	external factory VRExperienceHelperOptions({bool createDeviceOrientationCamera, bool createFallbackVRDeviceOrientationFreeCamera, bool laserToggle, List<Mesh> floorMeshes, VRCameraMetrics vrDeviceOrientationCameraMetrics, bool useXR});
	
	/// Create a DeviceOrientationCamera to be used as your out of vr camera. (default: true)
	external bool get createDeviceOrientationCamera;
	external set createDeviceOrientationCamera( bool value );
	
	/// Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found. (default: true)
	external bool get createFallbackVRDeviceOrientationFreeCamera;
	external set createFallbackVRDeviceOrientationFreeCamera( bool value );
	
	/// Uses the main button on the controller to toggle the laser casted. (default: true)
	external bool get laserToggle;
	external set laserToggle( bool value );
	
	/// A list of meshes to be used as the teleportation floor. If specified, teleportation will be enabled (default: undefined)
	external List<Mesh> get floorMeshes;
	external set floorMeshes( List<Mesh> value );
	
	/// Distortion metrics for the fallback vrDeviceOrientationCamera (default: VRCameraMetrics.Default)
	external VRCameraMetrics get vrDeviceOrientationCameraMetrics;
	external set vrDeviceOrientationCameraMetrics( VRCameraMetrics value );
	
	/// Defines if WebXR should be used instead of WebVR (if available)
	external bool get useXR;
	external set useXR( bool value );
}

/// Event containing information after VR has been entered
@JS()
class OnAfterEnteringVRObservableEvent {
	external factory OnAfterEnteringVRObservableEvent();
	
	/// If entering vr was successful
	external bool get success;
	external set success(bool value);
}

/// Helps to quickly add VR support to an existing scene.
/// See https://doc.babylonjs.com/how_to/webvr_helper
@JS()
class VRExperienceHelper {
	
	/// Instantiates a VRExperienceHelper.
	/// Helps to quickly add VR support to an existing scene.
	/// @param scene The scene the VRExperienceHelper belongs to.
	/// @param webVROptions Options to modify the vr experience helper's behavior.
	external factory VRExperienceHelper(Scene scene, [VRExperienceHelperOptions? webVROptions]);
	
	/// Options to modify the vr experience helper's behavior.
	external VRExperienceHelperOptions get webVROptions;
	external set webVROptions(VRExperienceHelperOptions value);
	
	/// Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)
	external bool get enableGazeEvenWhenNoPointerLock;
	external set enableGazeEvenWhenNoPointerLock(bool value);
	
	/// Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected
	external bool get exitVROnDoubleTap;
	external set exitVROnDoubleTap(bool value);
	
	/// Observable raised right before entering VR.
	external Observable<VRExperienceHelper> get onEnteringVRObservable;
	external set onEnteringVRObservable(Observable<VRExperienceHelper> value);
	
	/// Observable raised when entering VR has completed.
	external Observable<OnAfterEnteringVRObservableEvent> get onAfterEnteringVRObservable;
	external set onAfterEnteringVRObservable(Observable<OnAfterEnteringVRObservableEvent> value);
	
	/// Observable raised when exiting VR.
	external Observable<VRExperienceHelper> get onExitingVRObservable;
	external set onExitingVRObservable(Observable<VRExperienceHelper> value);
	
	/// Observable raised when controller mesh is loaded.
	external Observable<WebVRController> get onControllerMeshLoadedObservable;
	external set onControllerMeshLoadedObservable(Observable<WebVRController> value);
	
	/// Return this.onEnteringVRObservable
	/// Note: This one is for backward compatibility. Please use onEnteringVRObservable directly
	external Observable<VRExperienceHelper> get onEnteringVR;
	
	/// Return this.onExitingVRObservable
	/// Note: This one is for backward compatibility. Please use onExitingVRObservable directly
	external Observable<VRExperienceHelper> get onExitingVR;
	
	/// Return this.onControllerMeshLoadedObservable
	/// Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly
	external Observable<WebVRController> get onControllerMeshLoaded;
	
	/// Observable raised when a new mesh is selected based on meshSelectionPredicate
	external Observable<AbstractMesh> get onNewMeshSelected;
	external set onNewMeshSelected(Observable<AbstractMesh> value);
	
	/// Observable raised when a new mesh is selected based on meshSelectionPredicate.
	/// This observable will provide the mesh and the controller used to select the mesh
	external Observable<VRExperienceHelperOnMeshSelectedWithController> get onMeshSelectedWithController;
	external set onMeshSelectedWithController(Observable<VRExperienceHelperOnMeshSelectedWithController> value);
	
	/// Observable raised when a new mesh is picked based on meshSelectionPredicate
	external Observable<PickingInfo> get onNewMeshPicked;
	external set onNewMeshPicked(Observable<PickingInfo> value);
	
	/// Observable raised before camera teleportation
	external Observable<Vector3> get onBeforeCameraTeleport;
	external set onBeforeCameraTeleport(Observable<Vector3> value);
	
	/// Observable raised after camera teleportation
	external Observable<Vector3> get onAfterCameraTeleport;
	external set onAfterCameraTeleport(Observable<Vector3> value);
	
	/// Observable raised when current selected mesh gets unselected
	external Observable<AbstractMesh> get onSelectedMeshUnselected;
	external set onSelectedMeshUnselected(Observable<AbstractMesh> value);
	
	/// To be optionaly changed by user to define custom ray selection
	external bool Function(AbstractMesh mesh) get raySelectionPredicate;
	external set raySelectionPredicate(bool Function(AbstractMesh mesh) value);
	
	/// To be optionaly changed by user to define custom selection logic (after ray selection)
	external bool Function(AbstractMesh mesh) get meshSelectionPredicate;
	external set meshSelectionPredicate(bool Function(AbstractMesh mesh) value);
	
	/// Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.
	external bool get teleportationEnabled;
	external set teleportationEnabled(bool value);
	
	/// The mesh used to display where the user is going to teleport.
	external Mesh get teleportationTarget;
	
	/// Sets the mesh to be used to display where the user is going to teleport.
	external set teleportationTarget(Mesh value);
	
	/// The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller
	/// when set bakeCurrentTransformIntoVertices will be called on the mesh.
	/// See https://doc.babylonjs.com/resources/baking_transformations
	external Mesh get gazeTrackerMesh;
	
	external set gazeTrackerMesh(Mesh value);
	
	/// If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes
	external bool get updateGazeTrackerScale;
	external set updateGazeTrackerScale(bool value);
	
	/// If the gaze trackers color should be updated when selecting meshes
	external bool get updateGazeTrackerColor;
	external set updateGazeTrackerColor(bool value);
	
	/// If the controller laser color should be updated when selecting meshes
	external bool get updateControllerLaserColor;
	external set updateControllerLaserColor(bool value);
	
	/// The gaze tracking mesh corresponding to the left controller
	external Mesh? get leftControllerGazeTrackerMesh;
	
	/// The gaze tracking mesh corresponding to the right controller
	external Mesh? get rightControllerGazeTrackerMesh;
	
	/// If the ray of the gaze should be displayed.
	external bool get displayGaze;
	
	/// Sets if the ray of the gaze should be displayed.
	external set displayGaze(bool value);
	
	/// If the ray of the LaserPointer should be displayed.
	external bool get displayLaserPointer;
	
	/// Sets if the ray of the LaserPointer should be displayed.
	external set displayLaserPointer(bool value);
	
	/// The deviceOrientationCamera used as the camera when not in VR.
	external DeviceOrientationCamera? get deviceOrientationCamera;
	
	/// Based on the current WebVR support, returns the current VR camera used.
	external Camera? get currentVRCamera;
	
	/// The webVRCamera which is used when in VR.
	external WebVRFreeCamera get webVRCamera;
	
	/// The deviceOrientationCamera that is used as a fallback when vr device is not connected.
	external VRDeviceOrientationFreeCamera? get vrDeviceOrientationCamera;
	
	/// The html button that is used to trigger entering into VR.
	external HTML.ButtonElement? get vrButton;
	
	/// Defines whether or not Pointer lock should be requested when switching to
	/// full screen.
	external bool get requestPointerLockOnFullScreen;
	external set requestPointerLockOnFullScreen(bool value);
	
	/// If asking to force XR, this will be populated with the default xr experience
	external WebXRDefaultExperience get xr;
	external set xr(WebXRDefaultExperience value);
	
	/// Was the XR test done already. If this is true AND this.xr exists, xr is initialized.
	/// If this is true and no this.xr, xr exists but is not supported, using WebVR.
	external bool get xrTestDone;
	external set xrTestDone(bool value);
	
	/// Gets a value indicating if we are currently in VR mode.
	external bool get isInVRMode;
	
	/// Attempt to enter VR. If a headset is connected and ready, will request present on that.
	/// Otherwise, will use the fullscreen API.
	external void enterVR();
	
	/// Attempt to exit VR, or fullscreen.
	external void exitVR();
	
	/// The position of the vr experience helper.
	external Vector3 get position;
	
	/// Sets the position of the vr experience helper.
	external set position(Vector3 value);
	
	/// Enables controllers and user interactions such as selecting and object or clicking on an object.
	external void enableInteractions();
	
	/// Adds a floor mesh to be used for teleportation.
	/// @param floorMesh the mesh to be used for teleportation.
	external void addFloorMesh(Mesh floorMesh);
	
	/// Removes a floor mesh from being used for teleportation.
	/// @param floorMesh the mesh to be removed.
	external void removeFloorMesh(Mesh floorMesh);
	
	/// Enables interactions and teleportation using the VR controllers and gaze.
	/// @param vrTeleportationOptions options to modify teleportation behavior.
	external void enableTeleportation([VRTeleportationOptions? vrTeleportationOptions]);
	
	/// Time Constant Teleportation Mode
	external static num get TELEPORTATIONMODE_CONSTANTTIME;
	
	/// Speed Constant Teleportation Mode
	external static num get TELEPORTATIONMODE_CONSTANTSPEED;
	
	/// Teleports the users feet to the desired location
	/// @param location The location where the user's feet should be placed
	external void teleportCamera(Vector3 location);
	
	/// Permanently set new colors for the laser pointer
	/// @param color the new laser color
	/// @param pickedColor the new laser color when picked mesh detected
	external void setLaserColor(Color3 color, [Color3? pickedColor]);
	
	/// Set lighting enabled / disabled on the laser pointer of both controllers
	/// @param enabled should the lighting be enabled on the laser pointer
	external void setLaserLightingState([bool? enabled]);
	
	/// Permanently set new colors for the gaze pointer
	/// @param color the new gaze color
	/// @param pickedColor the new gaze color when picked mesh detected
	external void setGazeColor(Color3 color, [Color3? pickedColor]);
	
	/// Sets the color of the laser ray from the vr controllers.
	/// @param color new color for the ray.
	external void changeLaserColor(Color3 color);
	
	/// Sets the color of the ray from the vr headsets gaze.
	/// @param color new color for the ray.
	external void changeGazeColor(Color3 color);
	
	/// Exits VR and disposes of the vr experience helper
	external void dispose();
	
	/// Gets the name of the VRExperienceHelper class
	/// @returns "VRExperienceHelper"
	external String getClassName();
}

/// Contains an array of blocks representing the octree
@JS()
@anonymous
class IOctreeContainer<T> {
	
	external factory IOctreeContainer({List<OctreeBlock<T>> blocks});
	
	/// Blocks within the octree
	external List<OctreeBlock<T>> get blocks;
	external set blocks( List<OctreeBlock<T>> value );
}

/// Class used to store a cell in an octree
/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
@JS()
class OctreeBlock<T> {
	
	/// Creates a new block
	/// @param minPoint defines the minimum vector (in world space) of the block's bounding box
	/// @param maxPoint defines the maximum vector (in world space) of the block's bounding box
	/// @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
	/// @param depth defines the current depth of this block in the octree
	/// @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)
	/// @param creationFunc defines a callback to call when an element is added to the block
	external factory OctreeBlock(Vector3 minPoint, Vector3 maxPoint, num capacity, num depth, num maxDepth, void Function(T entry, OctreeBlock<T> block) creationFunc);
	
	/// Gets the content of the current block
	external List<T> get entries;
	external set entries(List<T> value);
	
	/// Gets the list of block children
	external List<OctreeBlock<T>> get blocks;
	external set blocks(List<OctreeBlock<T>> value);
	
	/// Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
	external num get capacity;
	
	/// Gets the minimum vector (in world space) of the block's bounding box
	external Vector3 get minPoint;
	
	/// Gets the maximum vector (in world space) of the block's bounding box
	external Vector3 get maxPoint;
	
	/// Add a new element to this block
	/// @param entry defines the element to add
	external void addEntry(T entry);
	
	/// Remove an element from this block
	/// @param entry defines the element to remove
	external void removeEntry(T entry);
	
	/// Add an array of elements to this block
	/// @param entries defines the array of elements to add
	external void addEntries(List<T> entries);
	
	/// Test if the current block intersects the furstum planes and if yes, then add its content to the selection array
	/// @param frustumPlanes defines the frustum planes to test
	/// @param selection defines the array to store current content if selection is positive
	/// @param allowDuplicate defines if the selection array can contains duplicated entries
	external void select(List<Plane> frustumPlanes, SmartArrayNoDuplicate<T> selection, [bool? allowDuplicate]);
	
	/// Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array
	/// @param sphereCenter defines the bounding sphere center
	/// @param sphereRadius defines the bounding sphere radius
	/// @param selection defines the array to store current content if selection is positive
	/// @param allowDuplicate defines if the selection array can contains duplicated entries
	external void intersects(Vector3 sphereCenter, num sphereRadius, SmartArrayNoDuplicate<T> selection, [bool? allowDuplicate]);
	
	/// Test if the current block intersect with the given ray and if yes, then add its content to the selection array
	/// @param ray defines the ray to test with
	/// @param selection defines the array to store current content if selection is positive
	external void intersectsRay(Ray ray, SmartArrayNoDuplicate<T> selection);
	
	/// Subdivide the content into child blocks (this block will then be empty)
	external void createInnerBlocks();
}

/// Octrees are a really powerful data structure that can quickly select entities based on space coordinates.
/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
@JS()
class Octree<T> {
	
	/// Creates a octree
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
	/// @param creationFunc function to be used to instatiate the octree
	/// @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)
	/// @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)
	external factory Octree(void Function(T entry, OctreeBlock<T> block) creationFunc, [num? maxBlockCapacity, num? maxDepth]);
	
	/// Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)
	external num get maxDepth;
	external set maxDepth(num value);
	
	/// Blocks within the octree containing objects
	external List<OctreeBlock<T>> get blocks;
	external set blocks(List<OctreeBlock<T>> value);
	
	/// Content stored in the octree
	external List<T> get dynamicContent;
	external set dynamicContent(List<T> value);
	
	/// Updates the octree by adding blocks for the passed in meshes within the min and max world parameters
	/// @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
	/// @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
	/// @param entries meshes to be added to the octree blocks
	external void update(Vector3 worldMin, Vector3 worldMax, List<T> entries);
	
	/// Adds a mesh to the octree
	/// @param entry Mesh to add to the octree
	external void addMesh(T entry);
	
	/// Remove an element from the octree
	/// @param entry defines the element to remove
	external void removeMesh(T entry);
	
	/// Selects an array of meshes within the frustum
	/// @param frustumPlanes The frustum planes to use which will select all meshes within it
	/// @param allowDuplicate If duplicate objects are allowed in the resulting object array
	/// @returns array of meshes within the frustum
	external SmartArray<T> select(List<Plane> frustumPlanes, [bool? allowDuplicate]);
	
	/// Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array
	/// @param sphereCenter defines the bounding sphere center
	/// @param sphereRadius defines the bounding sphere radius
	/// @param allowDuplicate defines if the selection array can contains duplicated entries
	/// @returns an array of objects that intersect the sphere
	external SmartArray<T> intersects(Vector3 sphereCenter, num sphereRadius, [bool? allowDuplicate]);
	
	/// Test if the octree intersect with the given ray and if yes, then add its content to resulting array
	/// @param ray defines the ray to test with
	/// @returns array of intersected objects
	external SmartArray<T> intersectsRay(Ray ray);
	
	/// Adds a mesh into the octree block if it intersects the block
	external static void Function(AbstractMesh entry, OctreeBlock<AbstractMesh> block) get CreationFuncForMeshes;
	external static set CreationFuncForMeshes(void Function(AbstractMesh entry, OctreeBlock<AbstractMesh> block) value);
	
	/// Adds a submesh into the octree block if it intersects the block
	external static void Function(SubMesh entry, OctreeBlock<SubMesh> block) get CreationFuncForSubMeshes;
	external static set CreationFuncForSubMeshes(void Function(SubMesh entry, OctreeBlock<SubMesh> block) value);
}

/// Defines the octree scene component responsible to manage any octrees
/// in a given scene.
@JS()
class OctreeSceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory OctreeSceneComponent(Scene scene);
	
	/// The component name help to identify the component in the list of scene components.
	external String get name;
	
	/// The scene the component belongs to.
	external Scene get scene;
	external set scene(Scene value);
	
	/// Indicates if the meshes have been checked to make sure they are isEnabled()
	external bool get checksIsEnabled;
	
	/// Registers the component in a given scene
	external void register();
	
	/// Return the list of active meshes
	/// @returns the list of active meshes
	external ISmartArrayLike<AbstractMesh> getActiveMeshCandidates();
	
	/// Return the list of active sub meshes
	/// @param mesh The mesh to get the candidates sub meshes from
	/// @returns the list of active sub meshes
	external ISmartArrayLike<SubMesh> getActiveSubMeshCandidates(AbstractMesh mesh);
	
	/// Return the list of sub meshes intersecting with a given local ray
	/// @param mesh defines the mesh to find the submesh for
	/// @param localRay defines the ray in local space
	/// @returns the list of intersecting sub meshes
	external ISmartArrayLike<SubMesh> getIntersectingSubMeshCandidates(AbstractMesh mesh, Ray localRay);
	
	/// Return the list of sub meshes colliding with a collider
	/// @param mesh defines the mesh to find the submesh for
	/// @param collider defines the collider to evaluate the collision against
	/// @returns the list of colliding sub meshes
	external ISmartArrayLike<SubMesh> getCollidingSubMeshCandidates(AbstractMesh mesh, Collider collider);
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	external void rebuild();
	
	/// Disposes the component and the associated ressources.
	external void dispose();
}

/// Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI
@JS()
@anonymous
class GizmoAxisCache {
	
	external factory GizmoAxisCache({List<Mesh> gizmoMeshes, List<Mesh> colliderMeshes, StandardMaterial material, StandardMaterial hoverMaterial, StandardMaterial disableMaterial, bool active});
	
	/// Mesh used to runder the Gizmo
	external List<Mesh> get gizmoMeshes;
	external set gizmoMeshes( List<Mesh> value );
	
	/// Mesh used to detect user interaction with Gizmo
	external List<Mesh> get colliderMeshes;
	external set colliderMeshes( List<Mesh> value );
	
	/// Material used to inicate color of gizmo mesh
	external StandardMaterial get material;
	external set material( StandardMaterial value );
	
	/// Material used to inicate hover state of the Gizmo
	external StandardMaterial get hoverMaterial;
	external set hoverMaterial( StandardMaterial value );
	
	/// Material used to inicate disabled state of the Gizmo
	external StandardMaterial get disableMaterial;
	external set disableMaterial( StandardMaterial value );
	
	/// Used to indicate Active state of the Gizmo
	external bool get active;
	external set active( bool value );
}

/// Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
@JS()
class Gizmo implements IDisposable {
	
	/// Creates a gizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	external factory Gizmo([UtilityLayerRenderer? gizmoLayer]);
	
	/// The utility layer the gizmo will be added to
	external UtilityLayerRenderer get gizmoLayer;
	external set gizmoLayer(UtilityLayerRenderer value);
	
	/// Ratio for the scale of the gizmo (Default: 1)
	external set scaleRatio(num value);
	
	external num get scaleRatio;
	
	/// True when the mouse pointer is hovered a gizmo mesh
	external bool get isHovered;
	
	/// Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
	/// * When set, interactions will be enabled
	external AbstractMesh? get attachedMesh;
	
	external set attachedMesh(AbstractMesh? value);
	
	/// Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)
	/// * When set, interactions will be enabled
	external Node? get attachedNode;
	
	external set attachedNode(Node? value);
	
	/// Disposes and replaces the current meshes in the gizmo with the specified mesh
	/// @param mesh The mesh to replace the default mesh of the gizmo
	external void setCustomMesh(Mesh mesh);
	
	/// If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
	external set updateGizmoRotationToMatchAttachedMesh(bool value);
	
	external bool get updateGizmoRotationToMatchAttachedMesh;
	
	/// If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
	external bool get updateGizmoPositionToMatchAttachedMesh;
	external set updateGizmoPositionToMatchAttachedMesh(bool value);
	
	/// When set, the gizmo will always appear the same size no matter where the camera is (default: true)
	external bool get updateScale;
	external set updateScale(bool value);
	
	/// Subscribes to pointer up, down, and hover events. Used for responsive gizmos.
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
	/// @returns {Observer<PointerInfo>} pointerObserver
	external static Observer<PointerInfo> GizmoAxisPointerObserver(UtilityLayerRenderer gizmoLayer, dynamic /* unresolved: Map */ gizmoAxisCache);
	
	/// Disposes of the gizmo
	@override
	external void dispose();
}

/// Single plane drag gizmo
@JS()
class PlaneDragGizmo extends Gizmo {
	
	/// Creates a PlaneDragGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param dragPlaneNormal The axis normal to which the gizmo will be able to drag on
	/// @param color The color of the gizmo
	external factory PlaneDragGizmo(Vector3 dragPlaneNormal, [Color3? color, UtilityLayerRenderer? gizmoLayer, PositionGizmo? parent]);
	
	/// Drag behavior responsible for the gizmos dragging interactions
	external PointerDragBehavior get dragBehavior;
	external set dragBehavior(PointerDragBehavior value);
	
	/// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
	external num get snapDistance;
	external set snapDistance(num value);
	
	/// Event that fires each time the gizmo snaps to a new location.
	/// * snapDistance is the the change in distance
	external Observable<PlaneDragGizmoOnSnapObservable> get onSnapObservable;
	external set onSnapObservable(Observable<PlaneDragGizmoOnSnapObservable> value);
	
	/// If the gizmo is enabled
	external set isEnabled(bool value);
	
	external bool get isEnabled;
	
	/// Disposes of the gizmo
	@override
	external void dispose();
}

/// Single plane rotation gizmo
@JS()
class PlaneRotationGizmo extends Gizmo {
	
	/// Creates a PlaneRotationGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param planeNormal The normal of the plane which the gizmo will be able to rotate on
	/// @param color The color of the gizmo
	/// @param tessellation Amount of tessellation to be used when creating rotation circles
	/// @param useEulerRotation Use and update Euler angle instead of quaternion
	/// @param thickness display gizmo axis thickness
	external factory PlaneRotationGizmo(Vector3 planeNormal, [Color3? color, UtilityLayerRenderer? gizmoLayer, num? tessellation, RotationGizmo? parent, bool? useEulerRotation, num? thickness]);
	
	/// Drag behavior responsible for the gizmos dragging interactions
	external PointerDragBehavior get dragBehavior;
	external set dragBehavior(PointerDragBehavior value);
	
	/// Rotation distance in radians that the gizmo will snap to (Default: 0)
	external num get snapDistance;
	external set snapDistance(num value);
	
	/// Event that fires each time the gizmo snaps to a new location.
	/// * snapDistance is the the change in distance
	external Observable<PlaneRotationGizmoOnSnapObservable> get onSnapObservable;
	external set onSnapObservable(Observable<PlaneRotationGizmoOnSnapObservable> value);
	
	/// If the gizmo is enabled
	external set isEnabled(bool value);
	
	external bool get isEnabled;
	
	/// Disposes of the gizmo
	@override
	external void dispose();
}

/// Gizmo that enables rotating a mesh along 3 axis
@JS()
class RotationGizmo extends Gizmo {
	
	/// Creates a RotationGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param tessellation Amount of tessellation to be used when creating rotation circles
	/// @param useEulerRotation Use and update Euler angle instead of quaternion
	/// @param thickness display gizmo axis thickness
	external factory RotationGizmo([UtilityLayerRenderer? gizmoLayer, num? tessellation, bool? useEulerRotation, num? thickness, GizmoManager? gizmoManager]);
	
	/// Internal gizmo used for interactions on the x axis
	external PlaneRotationGizmo get xGizmo;
	external set xGizmo(PlaneRotationGizmo value);
	
	/// Internal gizmo used for interactions on the y axis
	external PlaneRotationGizmo get yGizmo;
	external set yGizmo(PlaneRotationGizmo value);
	
	/// Internal gizmo used for interactions on the z axis
	external PlaneRotationGizmo get zGizmo;
	external set zGizmo(PlaneRotationGizmo value);
	
	/// Fires an event when any of it's sub gizmos are dragged
	external Observable<dynamic> get onDragStartObservable;
	external set onDragStartObservable(Observable<dynamic> value);
	
	/// Fires an event when any of it's sub gizmos are released from dragging
	external Observable<dynamic> get onDragEndObservable;
	external set onDragEndObservable(Observable<dynamic> value);
	
	@override
	external AbstractMesh? get attachedMesh;
	
	@override
	external set attachedMesh(AbstractMesh? value);
	
	@override
	external Node? get attachedNode;
	
	@override
	external set attachedNode(Node? value);
	
	/// True when the mouse pointer is hovering a gizmo mesh
	@override
	external bool get isHovered;
	
	@override
	external set updateGizmoRotationToMatchAttachedMesh(bool value);
	
	@override
	external bool get updateGizmoRotationToMatchAttachedMesh;
	
	/// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
	external set snapDistance(num value);
	
	external num get snapDistance;
	
	/// Ratio for the scale of the gizmo (Default: 1)
	@override
	external set scaleRatio(num value);
	
	@override
	external num get scaleRatio;
	
	/// Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
	/// @param mesh Axis gizmo mesh
	/// @param cache Gizmo axis definition used for reactive gizmo UI
	external void addToAxisCache(Mesh mesh, GizmoAxisCache cache);
	
	/// Disposes of the gizmo
	@override
	external void dispose();
	
	/// CustomMeshes are not supported by this gizmo
	/// @param mesh The mesh to replace the default mesh of the gizmo
	@override
	external void setCustomMesh(Mesh mesh);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class PolyhedronBuilder {
	external factory PolyhedronBuilder();
	
	/// Creates a polyhedron mesh
	/// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
	/// * The parameter `size` (positive float, default 1) sets the polygon size
	/// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
	/// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
	/// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
	/// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
	/// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the polyhedron mesh
	/// @see https://doc.babylonjs.com/how_to/polyhedra_shapes
	external static Mesh CreatePolyhedron(String name, PolyhedronBuilderCreatePolyhedronOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class BoxBuilder {
	external factory BoxBuilder();
	
	/// Creates a box mesh
	/// * The parameter `size` sets the size (float) of each box side (default 1)
	/// * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
	/// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
	/// * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @see https://doc.babylonjs.com/how_to/set_shapes#box
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the box mesh
	external static Mesh CreateBox(String name, BoxBuilderCreateBoxOptions options, [Scene? scene]);
}

/// Single axis scale gizmo
@JS()
class AxisScaleGizmo extends Gizmo {
	
	/// Creates an AxisScaleGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param dragAxis The axis which the gizmo will be able to scale on
	/// @param color The color of the gizmo
	/// @param thickness display gizmo axis thickness
	external factory AxisScaleGizmo(Vector3 dragAxis, [Color3? color, UtilityLayerRenderer? gizmoLayer, ScaleGizmo? parent, num? thickness]);
	
	/// Drag behavior responsible for the gizmos dragging interactions
	external PointerDragBehavior get dragBehavior;
	external set dragBehavior(PointerDragBehavior value);
	
	/// Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)
	external num get snapDistance;
	external set snapDistance(num value);
	
	/// Event that fires each time the gizmo snaps to a new location.
	/// * snapDistance is the the change in distance
	external Observable<AxisScaleGizmoOnSnapObservable> get onSnapObservable;
	external set onSnapObservable(Observable<AxisScaleGizmoOnSnapObservable> value);
	
	/// If the scaling operation should be done on all axis (default: false)
	external bool get uniformScaling;
	external set uniformScaling(bool value);
	
	/// Custom sensitivity value for the drag strength
	external num get sensitivity;
	external set sensitivity(num value);
	
	/// If the gizmo is enabled
	external set isEnabled(bool value);
	
	external bool get isEnabled;
	
	/// Disposes of the gizmo
	@override
	external void dispose();
	
	/// Disposes and replaces the current meshes in the gizmo with the specified mesh
	/// @param mesh The mesh to replace the default mesh of the gizmo
	/// @param useGizmoMaterial If the gizmo's default material should be used (default: false)
	@override
	external void setCustomMesh(Mesh mesh, [bool? useGizmoMaterial]);
}

/// Gizmo that enables scaling a mesh along 3 axis
@JS()
class ScaleGizmo extends Gizmo {
	
	/// Creates a ScaleGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param thickness display gizmo axis thickness
	external factory ScaleGizmo([UtilityLayerRenderer? gizmoLayer, num? thickness, GizmoManager? gizmoManager]);
	
	/// Internal gizmo used for interactions on the x axis
	external AxisScaleGizmo get xGizmo;
	external set xGizmo(AxisScaleGizmo value);
	
	/// Internal gizmo used for interactions on the y axis
	external AxisScaleGizmo get yGizmo;
	external set yGizmo(AxisScaleGizmo value);
	
	/// Internal gizmo used for interactions on the z axis
	external AxisScaleGizmo get zGizmo;
	external set zGizmo(AxisScaleGizmo value);
	
	/// Internal gizmo used to scale all axis equally
	external AxisScaleGizmo get uniformScaleGizmo;
	external set uniformScaleGizmo(AxisScaleGizmo value);
	
	/// Fires an event when any of it's sub gizmos are dragged
	external Observable<dynamic> get onDragStartObservable;
	external set onDragStartObservable(Observable<dynamic> value);
	
	/// Fires an event when any of it's sub gizmos are released from dragging
	external Observable<dynamic> get onDragEndObservable;
	external set onDragEndObservable(Observable<dynamic> value);
	
	@override
	external AbstractMesh? get attachedMesh;
	
	@override
	external set attachedMesh(AbstractMesh? value);
	
	@override
	external Node? get attachedNode;
	
	@override
	external set attachedNode(Node? value);
	
	/// True when the mouse pointer is hovering a gizmo mesh
	@override
	external bool get isHovered;
	
	@override
	external set updateGizmoRotationToMatchAttachedMesh(bool value);
	
	@override
	external bool get updateGizmoRotationToMatchAttachedMesh;
	
	/// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
	external set snapDistance(num value);
	
	external num get snapDistance;
	
	/// Ratio for the scale of the gizmo (Default: 1)
	@override
	external set scaleRatio(num value);
	
	@override
	external num get scaleRatio;
	
	/// Sensitivity factor for dragging (Default: 1)
	external set sensitivity(num value);
	
	external num get sensitivity;
	
	/// Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
	/// @param mesh Axis gizmo mesh
	/// @param cache Gizmo axis definition used for reactive gizmo UI
	external void addToAxisCache(Mesh mesh, GizmoAxisCache cache);
	
	/// Disposes of the gizmo
	@override
	external void dispose();
}

/// Bounding box gizmo
@JS()
class BoundingBoxGizmo extends Gizmo {
	
	/// Creates an BoundingBoxGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param color The color of the gizmo
	external factory BoundingBoxGizmo([Color3? color, UtilityLayerRenderer? gizmoLayer]);
	
	/// If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)
	external bool get ignoreChildren;
	external set ignoreChildren(bool value);
	
	/// Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)
	external bool Function(AbstractMesh abstractMesh)? get includeChildPredicate;
	external set includeChildPredicate(bool Function(AbstractMesh abstractMesh)? value);
	
	/// The size of the rotation spheres attached to the bounding box (Default: 0.1)
	external num get rotationSphereSize;
	external set rotationSphereSize(num value);
	
	/// The size of the scale boxes attached to the bounding box (Default: 0.1)
	external num get scaleBoxSize;
	external set scaleBoxSize(num value);
	
	/// If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)
	/// Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true
	external bool get fixedDragMeshScreenSize;
	external set fixedDragMeshScreenSize(bool value);
	
	/// If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box
	/// Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true
	external bool get fixedDragMeshBoundsSize;
	external set fixedDragMeshBoundsSize(bool value);
	
	/// The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)
	external num get fixedDragMeshScreenSizeDistanceFactor;
	external set fixedDragMeshScreenSizeDistanceFactor(num value);
	
	/// Fired when a rotation sphere or scale box is dragged
	external Observable<dynamic /* object */> get onDragStartObservable;
	external set onDragStartObservable(Observable<dynamic /* object */> value);
	
	/// Fired when a scale box is dragged
	external Observable<dynamic /* object */> get onScaleBoxDragObservable;
	external set onScaleBoxDragObservable(Observable<dynamic /* object */> value);
	
	/// Fired when a scale box drag is ended
	external Observable<dynamic /* object */> get onScaleBoxDragEndObservable;
	external set onScaleBoxDragEndObservable(Observable<dynamic /* object */> value);
	
	/// Fired when a rotation sphere is dragged
	external Observable<dynamic /* object */> get onRotationSphereDragObservable;
	external set onRotationSphereDragObservable(Observable<dynamic /* object */> value);
	
	/// Fired when a rotation sphere drag is ended
	external Observable<dynamic /* object */> get onRotationSphereDragEndObservable;
	external set onRotationSphereDragEndObservable(Observable<dynamic /* object */> value);
	
	/// Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)
	external Vector3? get scalePivot;
	external set scalePivot(Vector3? value);
	
	/// Sets the color of the bounding box gizmo
	/// @param color the color to set
	external void setColor(Color3 color);
	
	/// Updates the bounding box information for the Gizmo
	external void updateBoundingBox();
	
	/// Enables rotation on the specified axis and disables rotation on the others
	/// @param axis The list of axis that should be enabled (eg. "xy" or "xyz")
	external void setEnabledRotationAxis(String axis);
	
	/// Enables/disables scaling
	/// @param enable if scaling should be enabled
	/// @param homogeneousScaling defines if scaling should only be homogeneous
	external void setEnabledScaling(bool enable, [bool? homogeneousScaling]);
	
	/// Enables a pointer drag behavior on the bounding box of the gizmo
	external void enableDragBehavior();
	
	/// Disposes of the gizmo
	@override
	external void dispose();
	
	/// Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)
	/// @param mesh the mesh to wrap in the bounding box mesh and make not pickable
	/// @returns the bounding box mesh with the passed in mesh as a child
	external static Mesh MakeNotPickableAndWrapInBoundingBox(Mesh mesh);
	
	/// CustomMeshes are not supported by this gizmo
	/// @param mesh The mesh to replace the default mesh of the gizmo
	@override
	external void setCustomMesh(Mesh mesh);
}

/// Helps setup gizmo's in the scene to rotate/scale/position nodes
@JS()
class GizmoManager implements IDisposable {
	
	/// Instatiates a gizmo manager
	/// @param scene the scene to overlay the gizmos on top of
	/// @param thickness display gizmo axis thickness
	/// @param utilityLayer the layer where gizmos are rendered
	/// @param keepDepthUtilityLayer the layer where occluded gizmos are rendered
	external factory GizmoManager(Scene scene, [num? thickness, UtilityLayerRenderer? utilityLayer, UtilityLayerRenderer? keepDepthUtilityLayer]);
	
	/// Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time
	external GizmoManagerGizmos get gizmos;
	external set gizmos(GizmoManagerGizmos value);
	
	/// When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh
	external bool get clearGizmoOnEmptyPointerEvent;
	external set clearGizmoOnEmptyPointerEvent(bool value);
	
	/// Fires an event when the manager is attached to a mesh
	external Observable<AbstractMesh?> get onAttachedToMeshObservable;
	external set onAttachedToMeshObservable(Observable<AbstractMesh?> value);
	
	/// Fires an event when the manager is attached to a node
	external Observable<Node?> get onAttachedToNodeObservable;
	external set onAttachedToNodeObservable(Observable<Node?> value);
	
	/// When bounding box gizmo is enabled, this can be used to track drag/end events
	external SixDofDragBehavior get boundingBoxDragBehavior;
	external set boundingBoxDragBehavior(SixDofDragBehavior value);
	
	/// Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)
	external List<AbstractMesh>? get attachableMeshes;
	external set attachableMeshes(List<AbstractMesh>? value);
	
	/// Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)
	external List<Node>? get attachableNodes;
	external set attachableNodes(List<Node>? value);
	
	/// If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)
	external bool get usePointerToAttachGizmos;
	external set usePointerToAttachGizmos(bool value);
	
	/// Utility layer that the bounding box gizmo belongs to
	external UtilityLayerRenderer get keepDepthUtilityLayer;
	
	/// Utility layer that all gizmos besides bounding box belong to
	external UtilityLayerRenderer get utilityLayer;
	
	/// True when the mouse pointer is hovering a gizmo mesh
	external bool get isHovered;
	
	/// Attaches a set of gizmos to the specified mesh
	/// @param mesh The mesh the gizmo's should be attached to
	external void attachToMesh(AbstractMesh? mesh);
	
	/// Attaches a set of gizmos to the specified node
	/// @param node The node the gizmo's should be attached to
	external void attachToNode(Node? node);
	
	/// If the position gizmo is enabled
	external set positionGizmoEnabled(bool value);
	
	external bool get positionGizmoEnabled;
	
	/// If the rotation gizmo is enabled
	external set rotationGizmoEnabled(bool value);
	
	external bool get rotationGizmoEnabled;
	
	/// If the scale gizmo is enabled
	external set scaleGizmoEnabled(bool value);
	
	external bool get scaleGizmoEnabled;
	
	/// If the boundingBox gizmo is enabled
	external set boundingBoxGizmoEnabled(bool value);
	
	external bool get boundingBoxGizmoEnabled;
	
	/// Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
	/// @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
	external void addToAxisCache(dynamic /* unresolved: Map */ gizmoAxisCache);
	
	/// Disposes of the gizmo manager
	@override
	external void dispose();
}

/// Gizmo that enables dragging a mesh along 3 axis
@JS()
class PositionGizmo extends Gizmo {
	
	/// Creates a PositionGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param thickness display gizmo axis thickness
	external factory PositionGizmo([UtilityLayerRenderer? gizmoLayer, num? thickness, GizmoManager? gizmoManager]);
	
	/// Internal gizmo used for interactions on the x axis
	external AxisDragGizmo get xGizmo;
	external set xGizmo(AxisDragGizmo value);
	
	/// Internal gizmo used for interactions on the y axis
	external AxisDragGizmo get yGizmo;
	external set yGizmo(AxisDragGizmo value);
	
	/// Internal gizmo used for interactions on the z axis
	external AxisDragGizmo get zGizmo;
	external set zGizmo(AxisDragGizmo value);
	
	/// Internal gizmo used for interactions on the yz plane
	external PlaneDragGizmo get xPlaneGizmo;
	external set xPlaneGizmo(PlaneDragGizmo value);
	
	/// Internal gizmo used for interactions on the xz plane
	external PlaneDragGizmo get yPlaneGizmo;
	external set yPlaneGizmo(PlaneDragGizmo value);
	
	/// Internal gizmo used for interactions on the xy plane
	external PlaneDragGizmo get zPlaneGizmo;
	external set zPlaneGizmo(PlaneDragGizmo value);
	
	/// Fires an event when any of it's sub gizmos are dragged
	external Observable<dynamic> get onDragStartObservable;
	external set onDragStartObservable(Observable<dynamic> value);
	
	/// Fires an event when any of it's sub gizmos are released from dragging
	external Observable<dynamic> get onDragEndObservable;
	external set onDragEndObservable(Observable<dynamic> value);
	
	@override
	external AbstractMesh? get attachedMesh;
	
	@override
	external set attachedMesh(AbstractMesh? value);
	
	@override
	external Node? get attachedNode;
	
	@override
	external set attachedNode(Node? value);
	
	/// True when the mouse pointer is hovering a gizmo mesh
	@override
	external bool get isHovered;
	
	/// If the planar drag gizmo is enabled
	/// setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.
	external set planarGizmoEnabled(bool value);
	
	external bool get planarGizmoEnabled;
	
	@override
	external set updateGizmoRotationToMatchAttachedMesh(bool value);
	
	@override
	external bool get updateGizmoRotationToMatchAttachedMesh;
	
	/// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
	external set snapDistance(num value);
	
	external num get snapDistance;
	
	/// Ratio for the scale of the gizmo (Default: 1)
	@override
	external set scaleRatio(num value);
	
	@override
	external num get scaleRatio;
	
	/// Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
	/// @param mesh Axis gizmo mesh
	/// @param cache Gizmo axis definition used for reactive gizmo UI
	external void addToAxisCache(Mesh mesh, GizmoAxisCache cache);
	
	/// Disposes of the gizmo
	@override
	external void dispose();
	
	/// CustomMeshes are not supported by this gizmo
	/// @param mesh The mesh to replace the default mesh of the gizmo
	@override
	external void setCustomMesh(Mesh mesh);
}

/// Single axis drag gizmo
@JS()
class AxisDragGizmo extends Gizmo {
	
	/// Creates an AxisDragGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	/// @param dragAxis The axis which the gizmo will be able to drag on
	/// @param color The color of the gizmo
	/// @param thickness display gizmo axis thickness
	external factory AxisDragGizmo(Vector3 dragAxis, [Color3? color, UtilityLayerRenderer? gizmoLayer, PositionGizmo? parent, num? thickness]);
	
	/// Drag behavior responsible for the gizmos dragging interactions
	external PointerDragBehavior get dragBehavior;
	external set dragBehavior(PointerDragBehavior value);
	
	/// Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
	external num get snapDistance;
	external set snapDistance(num value);
	
	/// Event that fires each time the gizmo snaps to a new location.
	/// * snapDistance is the the change in distance
	external Observable<AxisDragGizmoOnSnapObservable> get onSnapObservable;
	external set onSnapObservable(Observable<AxisDragGizmoOnSnapObservable> value);
	
	/// If the gizmo is enabled
	external set isEnabled(bool value);
	
	external bool get isEnabled;
	
	/// Disposes of the gizmo
	@override
	external void dispose();
}

/// Interface used to define scene explorer extensibility option
@JS()
@anonymous
class IExplorerExtensibilityOption {
	
	external factory IExplorerExtensibilityOption({String label, void Function(dynamic entity) action});
	
	/// Define the option label
	external String get label;
	external set label( String value );
	
	/// Defines the action to execute on click
	external void Function(dynamic entity) get action;
	external set action( void Function(dynamic entity) value );
}

/// Defines a group of actions associated with a predicate to use when extending the Inspector scene explorer
@JS()
@anonymous
class IExplorerExtensibilityGroup {
	
	external factory IExplorerExtensibilityGroup({bool Function(dynamic entity) predicate, List<IExplorerExtensibilityOption> entries});
	
	/// Defines a predicate to test if a given type mut be extended
	external bool Function(dynamic entity) get predicate;
	external set predicate( bool Function(dynamic entity) value );
	
	/// Gets the list of options added to a type
	external List<IExplorerExtensibilityOption> get entries;
	external set entries( List<IExplorerExtensibilityOption> value );
}

/// Interface used to define the options to use to create the Inspector
@JS()
@anonymous
class IInspectorOptions {
	
	external factory IInspectorOptions({bool overlay, HTML.Element globalRoot, bool showExplorer, bool showInspector, bool embedMode, bool handleResize, bool enablePopup, bool enableClose, List<IExplorerExtensibilityGroup> explorerExtensibility, String inspectorURL, int initialTab});
	
	/// Display in overlay mode (default: false)
	external bool get overlay;
	external set overlay( bool value );
	
	/// HTML element to use as root (the parent of the rendering canvas will be used as default value)
	external HTML.Element get globalRoot;
	external set globalRoot( HTML.Element value );
	
	/// Display the Scene explorer
	external bool get showExplorer;
	external set showExplorer( bool value );
	
	/// Display the property inspector
	external bool get showInspector;
	external set showInspector( bool value );
	
	/// Display in embed mode (both panes on the right)
	external bool get embedMode;
	external set embedMode( bool value );
	
	/// let the Inspector handles resize of the canvas when panes are resized (default to true)
	external bool get handleResize;
	external set handleResize( bool value );
	
	/// Allow the panes to popup (default: true)
	external bool get enablePopup;
	external set enablePopup( bool value );
	
	/// Allow the panes to be closed by users (default: true)
	external bool get enableClose;
	external set enableClose( bool value );
	
	/// Optional list of extensibility entries
	external List<IExplorerExtensibilityGroup> get explorerExtensibility;
	external set explorerExtensibility( List<IExplorerExtensibilityGroup> value );
	
	/// Optional URL to get the inspector script from (by default it uses the babylonjs CDN).
	external String get inspectorURL;
	external set inspectorURL( String value );
	
	/// Optional initial tab (default to DebugLayerTab.Properties)
	external int get initialTab;
	external set initialTab( int value );
}

/* enum */
abstract class DebugLayerTab {
	
	/// Properties tag (default)
	static const int Properties = 1;
	
	/// Debug tab
	static const int Debug = 2;
	
	/// Statistics tab
	static const int Statistics = 3;
	
	/// Tools tab
	static const int Tools = 4;
	
	/// Settings tab
	static const int Settings = 5;
}

/// The debug layer (aka Inspector) is the go to tool in order to better understand
/// what is happening in your scene
/// @see https://doc.babylonjs.com/features/playground_debuglayer
@JS()
class DebugLayer {
	
	/// Instantiates a new debug layer.
	/// The debug layer (aka Inspector) is the go to tool in order to better understand
	/// what is happening in your scene
	/// @see https://doc.babylonjs.com/features/playground_debuglayer
	/// @param scene Defines the scene to inspect
	external factory DebugLayer(Scene scene);
	
	/// Define the url to get the inspector script from.
	/// By default it uses the babylonjs CDN.
	/// @ignoreNaming
	external static String get InspectorURL;
	external static set InspectorURL(String value);
	
	/// Observable triggered when a property is changed through the inspector.
	external dynamic get onPropertyChangedObservable;
	
	/// Select a specific entity in the scene explorer and highlight a specific block in that entity property grid
	/// @param entity defines the entity to select
	/// @param lineContainerTitles defines the specific blocks to highlight (could be a string or an array of strings)
	external void select(dynamic entity, [dynamic? lineContainerTitles]);
	
	/// Get if the inspector is visible or not.
	/// @returns true if visible otherwise, false
	external bool isVisible();
	
	/// Hide the inspector and close its window.
	external void hide();
	
	/// Update the scene in the inspector
	external void setAsActiveScene();
	
	/// Launch the debugLayer.
	/// @param config Define the configuration of the inspector
	/// @return a promise fulfilled when the debug layer is visible
	external Promise<DebugLayer> show([IInspectorOptions? config]);
}

/// As raycast might be hard to debug, the RayHelper can help rendering the different rays
/// in order to better appreciate the issue one might have.
/// @see https://doc.babylonjs.com/babylon101/raycasts#debugging
@JS()
class RayHelper {
	
	/// Instantiate a new ray helper.
	/// As raycast might be hard to debug, the RayHelper can help rendering the different rays
	/// in order to better appreciate the issue one might have.
	/// @see https://doc.babylonjs.com/babylon101/raycasts#debugging
	/// @param ray Defines the ray we are currently tryin to visualize
	external factory RayHelper(Ray ray);
	
	/// Defines the ray we are currently tryin to visualize.
	external Ray? get ray;
	external set ray(Ray? value);
	
	/// Helper function to create a colored helper in a scene in one line.
	/// @param ray Defines the ray we are currently tryin to visualize
	/// @param scene Defines the scene the ray is used in
	/// @param color Defines the color we want to see the ray in
	/// @returns The newly created ray helper.
	external static RayHelper CreateAndShow(Ray ray, Scene scene, Color3 color);
	
	/// Shows the ray we are willing to debug.
	/// @param scene Defines the scene the ray needs to be rendered in
	/// @param color Defines the color the ray needs to be rendered in
	external void show(Scene scene, [Color3? color]);
	
	/// Hides the ray we are debugging.
	external void hide();
	
	/// Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.
	/// @param mesh Defines the mesh we want the helper attached to
	/// @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)
	/// @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)
	/// @param length Defines the length of the ray
	external void attachToMesh(AbstractMesh mesh, [Vector3? meshSpaceDirection, Vector3? meshSpaceOrigin, num? length]);
	
	/// Detach the ray helper from the mesh it has previously been attached to.
	external void detachFromMesh();
	
	/// Dispose the helper and release its associated resources.
	external void dispose();
}

/// Defines the options associated with the creation of a SkeletonViewer.
@JS()
@anonymous
class ISkeletonViewerOptions {
	
	external factory ISkeletonViewerOptions({bool pauseAnimations, bool returnToRest, num displayMode, ISkeletonViewerDisplayOptions displayOptions, bool computeBonesUsingShaders, bool useAllBones});
	
	/// Should the system pause animations before building the Viewer?
	external bool get pauseAnimations;
	external set pauseAnimations( bool value );
	
	/// Should the system return the skeleton to rest before building?
	external bool get returnToRest;
	external set returnToRest( bool value );
	
	/// public Display Mode of the Viewer
	external num get displayMode;
	external set displayMode( num value );
	
	/// Flag to toggle if the Viewer should use the CPU for animations or not?
	external ISkeletonViewerDisplayOptions get displayOptions;
	external set displayOptions( ISkeletonViewerDisplayOptions value );
	
	/// Flag to toggle if the Viewer should use the CPU for animations or not?
	external bool get computeBonesUsingShaders;
	external set computeBonesUsingShaders( bool value );
	
	/// Flag ignore non weighted bones
	external bool get useAllBones;
	external set useAllBones( bool value );
}

/// Defines how to display the various bone meshes for the viewer.
@JS()
@anonymous
class ISkeletonViewerDisplayOptions {
	
	external factory ISkeletonViewerDisplayOptions({num midStep, num midStepFactor, num sphereBaseSize, num sphereScaleUnit, num sphereFactor, bool spurFollowsChild, bool showLocalAxes, num localAxesSize});
	
	/// How far down to start tapering the bone spurs
	external num get midStep;
	external set midStep( num value );
	
	/// How big is the midStep?
	external num get midStepFactor;
	external set midStepFactor( num value );
	
	/// Base for the Sphere Size
	external num get sphereBaseSize;
	external set sphereBaseSize( num value );
	
	/// The ratio of the sphere to the longest bone in units
	external num get sphereScaleUnit;
	external set sphereScaleUnit( num value );
	
	/// Ratio for the Sphere Size
	external num get sphereFactor;
	external set sphereFactor( num value );
	
	/// Whether a spur should attach its far end to the child bone position
	external bool get spurFollowsChild;
	external set spurFollowsChild( bool value );
	
	/// Whether to show local axes or not
	external bool get showLocalAxes;
	external set showLocalAxes( bool value );
	
	/// Length of each local axis
	external num get localAxesSize;
	external set localAxesSize( num value );
}

/// Defines the constructor options for the BoneWeight Shader.
@JS()
@anonymous
class IBoneWeightShaderOptions {
	
	external factory IBoneWeightShaderOptions({Skeleton skeleton, Color3 colorBase, Color3 colorZero, Color3 colorQuarter, Color3 colorHalf, Color3 colorFull, num targetBoneIndex});
	
	/// Skeleton to Map
	external Skeleton get skeleton;
	external set skeleton( Skeleton value );
	
	/// Colors for Uninfluenced bones
	external Color3 get colorBase;
	external set colorBase( Color3 value );
	
	/// Colors for 0.0-0.25 Weight bones
	external Color3 get colorZero;
	external set colorZero( Color3 value );
	
	/// Color for 0.25-0.5 Weight Influence
	external Color3 get colorQuarter;
	external set colorQuarter( Color3 value );
	
	/// Color for 0.5-0.75 Weight Influence
	external Color3 get colorHalf;
	external set colorHalf( Color3 value );
	
	/// Color for 0.75-1 Weight Influence
	external Color3 get colorFull;
	external set colorFull( Color3 value );
	
	/// Color for Zero Weight Influence
	external num get targetBoneIndex;
	external set targetBoneIndex( num value );
}

/// Simple structure of the gradient steps for the Color Map.
@JS()
@anonymous
class ISkeletonMapShaderColorMapKnot {
	
	external factory ISkeletonMapShaderColorMapKnot({Color3 color, num location});
	
	/// Color of the Knot
	external Color3 get color;
	external set color( Color3 value );
	
	/// Location of the Knot
	external num get location;
	external set location( num value );
}

/// Defines the constructor options for the SkeletonMap Shader.
@JS()
@anonymous
class ISkeletonMapShaderOptions {
	
	external factory ISkeletonMapShaderOptions({Skeleton skeleton, List<ISkeletonMapShaderColorMapKnot> colorMap});
	
	/// Skeleton to Map
	external Skeleton get skeleton;
	external set skeleton( Skeleton value );
	
	/// Array of ColorMapKnots that make the gradient must be ordered with knot[i].location < knot[i+1].location
	external List<ISkeletonMapShaderColorMapKnot> get colorMap;
	external set colorMap( List<ISkeletonMapShaderColorMapKnot> value );
}

/// Class containing static functions to help procedurally build meshes
@JS()
class RibbonBuilder {
	external factory RibbonBuilder();
	
	/// Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
	/// * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
	/// * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
	/// * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
	/// * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
	/// * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
	/// * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
	/// * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
	/// * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
	/// * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the ribbon mesh
	/// @see https://doc.babylonjs.com/how_to/ribbon_tutorial
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	external static Mesh CreateRibbon(String name, RibbonBuilderCreateRibbonOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class ShapeBuilder {
	external factory ShapeBuilder();
	
	/// Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
	/// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
	/// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
	/// * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
	/// * The parameter `scale` (float, default 1) is the value to scale the shape.
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
	/// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the extruded shape mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
	external static Mesh ExtrudeShape(String name, ShapeBuilderExtrudeShapeOptions options, [Scene? scene]);
	
	/// Creates an custom extruded shape mesh.
	/// The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
	/// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
	/// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
	/// * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
	/// * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
	/// * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
	/// * It must returns a float value that will be the scale value applied to the shape on each path point
	/// * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
	/// * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
	/// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the custom extruded shape mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
	external static Mesh ExtrudeShapeCustom(String name, ShapeBuilderExtrudeShapeCustomOptions options, [Scene? scene]);
}

/* enum */
abstract class DeviceType {
	
	/// Generic
	static const int Generic = 1;
	
	/// Keyboard
	static const int Keyboard = 2;
	
	/// Mouse
	static const int Mouse = 3;
	
	/// Touch Pointers
	static const int Touch = 4;
	
	/// PS4 Dual Shock
	static const int DualShock = 5;
	
	/// Xbox
	static const int Xbox = 6;
	
	/// Switch Controller
	static const int Switch = 7;
}

/* enum */
abstract class PointerInput {
	
	/// Horizontal Axis
	static const int Horizontal = 1;
	
	/// Vertical Axis
	static const int Vertical = 2;
	
	/// Left Click or Touch
	static const int LeftClick = 3;
	
	/// Middle Click
	static const int MiddleClick = 4;
	
	/// Right Click
	static const int RightClick = 5;
	
	/// Browser Back
	static const int BrowserBack = 6;
	
	/// Browser Forward
	static const int BrowserForward = 7;
}

/* enum */
abstract class DualShockInput {
	
	/// Cross
	static const int Cross = 1;
	
	/// Circle
	static const int Circle = 2;
	
	/// Square
	static const int Square = 3;
	
	/// Triangle
	static const int Triangle = 4;
	
	/// L1
	static const int L1 = 5;
	
	/// R1
	static const int R1 = 6;
	
	/// L2
	static const int L2 = 7;
	
	/// R2
	static const int R2 = 8;
	
	/// Share
	static const int Share = 9;
	
	/// Options
	static const int Options = 10;
	
	/// L3
	static const int L3 = 11;
	
	/// R3
	static const int R3 = 12;
	
	/// DPadUp
	static const int DPadUp = 13;
	
	/// DPadDown
	static const int DPadDown = 14;
	
	/// DPadLeft
	static const int DPadLeft = 15;
	
	/// DRight
	static const int DPadRight = 16;
	
	/// Home
	static const int Home = 17;
	
	/// TouchPad
	static const int TouchPad = 18;
	
	/// LStickXAxis
	static const int LStickXAxis = 19;
	
	/// LStickYAxis
	static const int LStickYAxis = 20;
	
	/// RStickXAxis
	static const int RStickXAxis = 21;
	
	/// RStickYAxis
	static const int RStickYAxis = 22;
}

/* enum */
abstract class XboxInput {
	
	/// A
	static const int A = 1;
	
	/// B
	static const int B = 2;
	
	/// X
	static const int X = 3;
	
	/// Y
	static const int Y = 4;
	
	/// LB
	static const int LB = 5;
	
	/// RB
	static const int RB = 6;
	
	/// LT
	static const int LT = 7;
	
	/// RT
	static const int RT = 8;
	
	/// Back
	static const int Back = 9;
	
	/// Start
	static const int Start = 10;
	
	/// LS
	static const int LS = 11;
	
	/// RS
	static const int RS = 12;
	
	/// DPadUp
	static const int DPadUp = 13;
	
	/// DPadDown
	static const int DPadDown = 14;
	
	/// DPadLeft
	static const int DPadLeft = 15;
	
	/// DRight
	static const int DPadRight = 16;
	
	/// Home
	static const int Home = 17;
	
	/// LStickXAxis
	static const int LStickXAxis = 18;
	
	/// LStickYAxis
	static const int LStickYAxis = 19;
	
	/// RStickXAxis
	static const int RStickXAxis = 20;
	
	/// RStickYAxis
	static const int RStickYAxis = 21;
}

/* enum */
abstract class SwitchInput {
	
	/// B
	static const int B = 1;
	
	/// A
	static const int A = 2;
	
	/// Y
	static const int Y = 3;
	
	/// X
	static const int X = 4;
	
	/// L
	static const int L = 5;
	
	/// R
	static const int R = 6;
	
	/// ZL
	static const int ZL = 7;
	
	/// ZR
	static const int ZR = 8;
	
	/// Minus
	static const int Minus = 9;
	
	/// Plus
	static const int Plus = 10;
	
	/// LS
	static const int LS = 11;
	
	/// RS
	static const int RS = 12;
	
	/// DPadUp
	static const int DPadUp = 13;
	
	/// DPadDown
	static const int DPadDown = 14;
	
	/// DPadLeft
	static const int DPadLeft = 15;
	
	/// DRight
	static const int DPadRight = 16;
	
	/// Home
	static const int Home = 17;
	
	/// Capture
	static const int Capture = 18;
	
	/// LStickXAxis
	static const int LStickXAxis = 19;
	
	/// LStickYAxis
	static const int LStickYAxis = 20;
	
	/// RStickXAxis
	static const int RStickXAxis = 21;
	
	/// RStickYAxis
	static const int RStickYAxis = 22;
}

/// This class will take all inputs from Keyboard, Pointer, and
/// any Gamepads and provide a polling system that all devices
/// will use.  This class assumes that there will only be one
/// pointer device and one keyboard.
@JS()
class DeviceInputSystem implements IDisposable {
	
	external factory DeviceInputSystem();
	
	/// Returns onDeviceConnected callback property
	/// @returns Callback with function to execute when a device is connected
	external void Function(int deviceType, num deviceSlot) get onDeviceConnected;
	
	/// Sets callback function when a device is connected and executes against all connected devices
	/// @param callback Function to execute when a device is connected
	external set onDeviceConnected(void Function(int deviceType, num deviceSlot) value);
	
	/// Callback to be triggered when a device is disconnected
	external void Function(int deviceType, num deviceSlot) get onDeviceDisconnected;
	external set onDeviceDisconnected(void Function(int deviceType, num deviceSlot) value);
	
	/// Callback to be triggered when event driven input is updated
	external void Function(int deviceType, num deviceSlot, num inputIndex, num? previousState, num? currentState) get onInputChanged;
	external set onInputChanged(void Function(int deviceType, num deviceSlot, num inputIndex, num? previousState, num? currentState) value);
	
	/// Creates a new DeviceInputSystem instance
	/// @param engine Engine to pull input element from
	/// @returns The new instance
	external static DeviceInputSystem Create(Engine engine);
	
	/// Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
	/// @param deviceType Enum specifiying device type
	/// @param deviceSlot "Slot" or index that device is referenced in
	/// @param inputIndex Id of input to be checked
	/// @returns Current value of input
	external num pollInput(int deviceType, num deviceSlot, num inputIndex);
	
	/// Dispose of all the eventlisteners
	@override
	external void dispose();
}

/// Class that handles all input for a specific device
@JS()
class DeviceSource<T extends int> {
	
	/// Default Constructor
	/// @param deviceInputSystem Reference to DeviceInputSystem
	/// @param deviceType Type of device
	/// @param deviceSlot "Slot" or index that device is referenced in
	external factory DeviceSource(DeviceInputSystem deviceInputSystem, int deviceType, [num? deviceSlot]);
	
	/// Type of device
	external int get deviceType;
	
	/// "Slot" or index that device is referenced in
	external num get deviceSlot;
	
	/// Observable to handle device input changes per device
	external Observable<DeviceSourceOnInputChangedObservable> get onInputChangedObservable;
	
	/// Get input for specific input
	/// @param inputIndex index of specific input on device
	/// @returns Input value from DeviceInputSystem
	external num getInput(T inputIndex);
}

/// Class to keep track of devices
@JS()
class DeviceSourceManager implements IDisposable {
	
	/// Default Constructor
	/// @param engine engine to pull input element from
	external factory DeviceSourceManager(Engine engine);
	
	/// Observable to be triggered when after a device is connected, any new observers added will be triggered against already connected devices
	external Observable<DeviceSource<int>> get onDeviceConnectedObservable;
	
	/// Observable to be triggered when after a device is disconnected
	external Observable<DeviceSource<int>> get onDeviceDisconnectedObservable;
	
	/// Gets a DeviceSource, given a type and slot
	/// @param deviceType Enum specifying device type
	/// @param deviceSlot "Slot" or index that device is referenced in
	/// @returns DeviceSource object
	external DeviceSource<T>? getDeviceSource<T extends int>(T deviceType, [num? deviceSlot]);
	
	/// Gets an array of DeviceSource objects for a given device type
	/// @param deviceType Enum specifying device type
	/// @returns Array of DeviceSource objects
	external List<DeviceSource<T>> getDeviceSources<T extends int>(T deviceType);
	
	/// Returns a read-only list of all available devices
	/// @returns Read-only array with active devices
	external List<DeviceSource<int>> getDevices();
	
	/// Dispose of DeviceInputSystem and other parts
	@override
	external void dispose();
}

/// Options to create the null engine
@JS()
class NullEngineOptions {
	external factory NullEngineOptions();
	
	/// Render width (Default: 512)
	external num get renderWidth;
	external set renderWidth(num value);
	
	/// Render height (Default: 256)
	external num get renderHeight;
	external set renderHeight(num value);
	
	/// Texture size (Default: 512)
	external num get textureSize;
	external set textureSize(num value);
	
	/// If delta time between frames should be constant
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	external bool get deterministicLockstep;
	external set deterministicLockstep(bool value);
	
	/// Maximum about of steps between frames (Default: 4)
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	external num get lockstepMaxSteps;
	external set lockstepMaxSteps(num value);
	
	/// Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default
	external bool get useHighPrecisionMatrix;
	external set useHighPrecisionMatrix(bool value);
}

/// The null engine class provides support for headless version of babylon.js.
/// This can be used in server side scenario or for testing purposes
@JS()
class NullEngine extends Engine {
	
	external factory NullEngine([NullEngineOptions? options]);
	
	/// Gets a boolean indicating that the engine is running in deterministic lock step mode
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @returns true if engine is in deterministic lock step mode
	@override
	external bool isDeterministicLockStep();
	
	/// Gets the max steps when engine is running in deterministic lock step
	/// @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
	/// @returns the max steps
	@override
	external num getLockstepMaxSteps();
	
	/// Gets the current hardware scaling level.
	/// By default the hardware scaling level is computed from the window device ratio.
	/// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
	/// @returns a number indicating the current hardware scaling level
	@override
	external num getHardwareScalingLevel();
	
	/// Creates a vertex buffer
	/// @param vertices the data for the vertex buffer
	/// @returns the new WebGL static buffer
	@override
	external DataBuffer createVertexBuffer(dynamic vertices);
	
	/// Creates a new index buffer
	/// @param indices defines the content of the index buffer
	/// @param updatable defines if the index buffer must be updatable
	/// @returns a new webGL buffer
	@override
	external DataBuffer createIndexBuffer(dynamic indices, [bool? updatable]);
	
	/// Clear the current render buffer or the current render target (if any is set up)
	/// @param color defines the color to use
	/// @param backBuffer defines if the back buffer must be cleared
	/// @param depth defines if the depth buffer must be cleared
	/// @param stencil defines if the stencil buffer must be cleared
	@override
	external void clear(Color4? color, bool backBuffer, bool depth, [bool? stencil]);
	
	/// Gets the current render width
	/// @param useScreen defines if screen size must be used (or the current render target if any)
	/// @returns a number defining the current render width
	@override
	external num getRenderWidth([bool? useScreen]);
	
	/// Gets the current render height
	/// @param useScreen defines if screen size must be used (or the current render target if any)
	/// @returns a number defining the current render height
	@override
	external num getRenderHeight([bool? useScreen]);
	
	/// Set the WebGL's viewport
	/// @param viewport defines the viewport element to be used
	/// @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
	/// @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
	@override
	external void setViewport(Viewport viewport, [num? requiredWidth, num? requiredHeight]);
	
	@override
	external WebGL.Program createShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, String? defines, [WebGL.RenderingContext? context, List<String>? transformFeedbackVaryings]);
	
	/// Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
	/// @param pipelineContext defines the pipeline context to use
	/// @param uniformsNames defines the list of uniform names
	/// @returns an array of webGL uniform locations
	@override
	external List<WebGL.UniformLocation>? getUniforms(IPipelineContext pipelineContext, List<String> uniformsNames);
	
	/// Gets the lsit of active attributes for a given webGL program
	/// @param pipelineContext defines the pipeline context to use
	/// @param attributesNames defines the list of attribute names to get
	/// @returns an array of indices indicating the offset of each attribute
	@override
	external List<num> getAttributes(IPipelineContext pipelineContext, List<String> attributesNames);
	
	/// Binds an effect to the webGL context
	/// @param effect defines the effect to bind
	@override
	external void bindSamplers(Effect effect);
	
	/// Activates an effect, mkaing it the current one (ie. the one used for rendering)
	/// @param effect defines the effect to activate
	@override
	external void enableEffect(Effect? effect);
	
	/// Set various states to the webGL context
	/// @param culling defines backface culling state
	/// @param zOffset defines the value to apply to zOffset (0 by default)
	/// @param force defines if states must be applied even if cache is up to date
	/// @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)
	@override
	external void setState(bool culling, [num? zOffset, bool? force, bool? reverseSide]);
	
	/// Set the value of an uniform to an array of int32
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if value was set
	@override
	external bool setIntArray(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of int32 (stored as vec2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if value was set
	@override
	external bool setIntArray2(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of int32 (stored as vec3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if value was set
	@override
	external bool setIntArray3(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of int32 (stored as vec4)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of int32 to store
	/// @returns true if value was set
	@override
	external bool setIntArray4(WebGL.UniformLocation? uniform, Int32List array);
	
	/// Set the value of an uniform to an array of float32
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of float32 to store
	/// @returns true if value was set
	external bool setFloatArray(WebGL.UniformLocation uniform, Float32List array);
	
	/// Set the value of an uniform to an array of float32 (stored as vec2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of float32 to store
	/// @returns true if value was set
	external bool setFloatArray2(WebGL.UniformLocation uniform, Float32List array);
	
	/// Set the value of an uniform to an array of float32 (stored as vec3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of float32 to store
	/// @returns true if value was set
	external bool setFloatArray3(WebGL.UniformLocation uniform, Float32List array);
	
	/// Set the value of an uniform to an array of float32 (stored as vec4)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of float32 to store
	/// @returns true if value was set
	external bool setFloatArray4(WebGL.UniformLocation uniform, Float32List array);
	
	/// Set the value of an uniform to an array of number
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if value was set
	@override
	external bool setArray(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of number (stored as vec2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if value was set
	@override
	external bool setArray2(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of number (stored as vec3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if value was set
	@override
	external bool setArray3(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of number (stored as vec4)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param array defines the array of number to store
	/// @returns true if value was set
	@override
	external bool setArray4(WebGL.UniformLocation? uniform, List<num> array);
	
	/// Set the value of an uniform to an array of float32 (stored as matrices)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param matrices defines the array of float32 to store
	/// @returns true if value was set
	@override
	external bool setMatrices(WebGL.UniformLocation? uniform, Float32List matrices);
	
	/// Set the value of an uniform to a matrix (3x3)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param matrix defines the Float32Array representing the 3x3 matrix to store
	/// @returns true if value was set
	@override
	external bool setMatrix3x3(WebGL.UniformLocation? uniform, Float32List matrix);
	
	/// Set the value of an uniform to a matrix (2x2)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param matrix defines the Float32Array representing the 2x2 matrix to store
	/// @returns true if value was set
	@override
	external bool setMatrix2x2(WebGL.UniformLocation? uniform, Float32List matrix);
	
	/// Set the value of an uniform to a number (float)
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param value defines the float number to store
	/// @returns true if value was set
	@override
	external bool setFloat(WebGL.UniformLocation? uniform, num value);
	
	/// Set the value of an uniform to a vec2
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param x defines the 1st component of the value
	/// @param y defines the 2nd component of the value
	/// @returns true if value was set
	@override
	external bool setFloat2(WebGL.UniformLocation? uniform, num x, num y);
	
	/// Set the value of an uniform to a vec3
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param x defines the 1st component of the value
	/// @param y defines the 2nd component of the value
	/// @param z defines the 3rd component of the value
	/// @returns true if value was set
	@override
	external bool setFloat3(WebGL.UniformLocation? uniform, num x, num y, num z);
	
	/// Set the value of an uniform to a boolean
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param bool defines the boolean to store
	/// @returns true if value was set
	external bool setBool(WebGL.UniformLocation uniform, num bool);
	
	/// Set the value of an uniform to a vec4
	/// @param uniform defines the webGL uniform location where to store the value
	/// @param x defines the 1st component of the value
	/// @param y defines the 2nd component of the value
	/// @param z defines the 3rd component of the value
	/// @param w defines the 4th component of the value
	/// @returns true if value was set
	@override
	external bool setFloat4(WebGL.UniformLocation? uniform, num x, num y, num z, num w);
	
	/// Sets the current alpha mode
	/// @param mode defines the mode to use (one of the Engine.ALPHA_XXX)
	/// @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
	@override
	external void setAlphaMode(num mode, [bool? noDepthWriteChange]);
	
	/// Bind webGl buffers directly to the webGL context
	/// @param vertexBuffers defines the vertex buffer to bind
	/// @param indexBuffer defines the index buffer to bind
	/// @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
	/// @param vertexStrideSize defines the vertex stride of the vertex buffer
	/// @param effect defines the effect associated with the vertex buffer
	@override
	external void bindBuffers(dynamic /* object */ vertexBuffers, DataBuffer? indexBuffer, Effect effect);
	
	/// Force the entire cache to be cleared
	/// You should not have to use this function unless your engine needs to share the webGL context with another engine
	/// @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
	@override
	external void wipeCaches([bool? bruteForce]);
	
	/// Send a draw order
	/// @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
	/// @param indexStart defines the starting index
	/// @param indexCount defines the number of index to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	@override
	external void draw(bool useTriangles, num indexStart, num indexCount, [num? instancesCount]);
	
	/// Draw a list of indexed primitives
	/// @param fillMode defines the primitive to use
	/// @param indexStart defines the starting index
	/// @param indexCount defines the number of index to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	@override
	external void drawElementsType(num fillMode, num indexStart, num indexCount, [num? instancesCount]);
	
	/// Draw a list of unindexed primitives
	/// @param fillMode defines the primitive to use
	/// @param verticesStart defines the index of first vertex to draw
	/// @param verticesCount defines the count of vertices to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	@override
	external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num? instancesCount]);
	
	/// Usually called from Texture.ts.
	/// Passed information to create a WebGLTexture
	/// @param urlArg defines a value which contains one of the following:
	/// * A conventional http URL, e.g. 'http://...' or 'file://...'
	/// * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
	/// * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
	/// @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
	/// @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
	/// @param scene needed for loading to the correct scene
	/// @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
	/// @param onLoad optional callback to be called upon successful completion
	/// @param onError optional callback to be called upon failure
	/// @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
	/// @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
	/// @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
	/// @param forcedExtension defines the extension to use to pick the right loader
	/// @param mimeType defines an optional mime type
	/// @returns a InternalTexture for assignment back into BABYLON.Texture
	@override
	external InternalTexture createTexture(String? urlArg, bool noMipmap, bool invertY, ISceneLike? scene, [num? samplingMode, void Function()? onLoad, void Function(String message, dynamic exception)? onError, dynamic? buffer, InternalTexture? fallback, num? format, String? forcedExtension, String? mimeType, dynamic? loaderOptions]);
	
	/// Creates a new render target texture
	/// @param size defines the size of the texture
	/// @param options defines the options used to create the texture
	/// @returns a new render target texture stored in an InternalTexture
	@override
	external InternalTexture createRenderTargetTexture(dynamic size, dynamic options);
	
	/// Update the sampling mode of a given texture
	/// @param samplingMode defines the required sampling mode
	/// @param texture defines the texture to update
	@override
	external void updateTextureSamplingMode(num samplingMode, InternalTexture texture, [bool? generateMipMaps]);
	
	/// Binds the frame buffer to the specified texture.
	/// @param texture The texture to render to or null for the default canvas
	/// @param faceIndex The face of the texture to render to in case of cube texture
	/// @param requiredWidth The width of the target to render to
	/// @param requiredHeight The height of the target to render to
	/// @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
	/// @param lodLevel defines le lod level to bind to the frame buffer
	@override
	external void bindFramebuffer(InternalTexture texture, [num? faceIndex, num? requiredWidth, num? requiredHeight, bool? forceFullscreenViewport, num? lodLevel, num? layer]);
	
	/// Unbind the current render target texture from the webGL context
	/// @param texture defines the render target texture to unbind
	/// @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
	/// @param onBeforeUnbind defines a function which will be called before the effective unbind
	@override
	external void unBindFramebuffer(InternalTexture texture, [bool? disableGenerateMipMaps, void Function()? onBeforeUnbind]);
	
	/// Creates a dynamic vertex buffer
	/// @param vertices the data for the dynamic vertex buffer
	/// @returns the new WebGL dynamic buffer
	@override
	external DataBuffer createDynamicVertexBuffer(dynamic vertices);
	
	/// Update the content of a dynamic texture
	/// @param texture defines the texture to update
	/// @param canvas defines the canvas containing the source
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param premulAlpha defines if alpha is stored as premultiplied
	/// @param format defines the format of the data
	/// @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)
	@override
	external void updateDynamicTexture(InternalTexture? texture, HTML.CanvasElement canvas, [bool? invertY, bool? premulAlpha, num? format, bool? forceBindTexture]);
	
	/// Gets a boolean indicating if all created effects are ready
	/// @returns true if all effects are ready
	@override
	external bool areAllEffectsReady();
	
	/// @hidden
	/// Get the current error code of the webGL context
	/// @returns the error code
	/// @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
	@override
	external num getError();
	
	/// Update a dynamic index buffer
	/// @param indexBuffer defines the target index buffer
	/// @param indices defines the data to update
	/// @param offset defines the offset in the target index buffer where update should start
	@override
	/* Manual Fix 32 */
	external void updateDynamicIndexBuffer(dynamic indexBuffer, dynamic indices, [num? offset]);
	
	/// Updates a dynamic vertex buffer.
	/// @param vertexBuffer the vertex buffer to update
	/// @param vertices the data used to update the vertex buffer
	/// @param byteOffset the byte offset of the data (optional)
	/// @param byteLength the byte length of the data (optional)
	@override
	/* Manual Fix 34 */
	external void updateDynamicVertexBuffer(dynamic vertexBuffer, dynamic vertices, [num? byteOffset, num? byteLength]);
	
	/// Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
	@override
	external void releaseEffects();
	
	@override
	external void displayLoadingUI();
	
	@override
	external void hideLoadingUI();
}

/// Class used to define an additional view for the engine
/// @see https://doc.babylonjs.com/how_to/multi_canvases
@JS()
class EngineView {
	external factory EngineView();
	
	/// Defines the canvas where to render the view
	external HTML.CanvasElement get target;
	external set target(HTML.CanvasElement value);
	
	/// Defines an optional camera used to render the view (will use active camera else)
	external Camera get camera;
	external set camera(Camera value);
}

/* var */
/// @hidden
@JS()
external dynamic get rgbdEncodePixelShader;

/// Raw texture data and descriptor sufficient for WebGL texture upload
@JS()
@anonymous
class EnvironmentTextureInfo {
	
	external factory EnvironmentTextureInfo({num version, num width, dynamic irradiance, dynamic specular});
	
	/// Version of the environment map
	external num get version;
	external set version( num value );
	
	/// Width of image
	external num get width;
	external set width( num value );
	
	/// Irradiance information stored in the file.
	external dynamic get irradiance;
	external set irradiance( dynamic value );
	
	/// Specular information stored in the file.
	external dynamic get specular;
	external set specular( dynamic value );
}

/// Defines One Image in the file. It requires only the position in the file
/// as well as the length.
@JS()
@anonymous
class BufferImageData {
	
	external factory BufferImageData({num length, num position});
	
	/// Length of the image data.
	external num get length;
	external set length( num value );
	
	/// Position of the data from the null terminator delimiting the end of the JSON.
	external num get position;
	external set position( num value );
}

/// Defines the specular data enclosed in the file.
/// This corresponds to the version 1 of the data.
@JS()
@anonymous
class EnvironmentTextureSpecularInfoV1 {
	
	external factory EnvironmentTextureSpecularInfoV1({num specularDataPosition, List<BufferImageData> mipmaps, num lodGenerationScale});
	
	/// Defines where the specular Payload is located. It is a runtime value only not stored in the file.
	external num get specularDataPosition;
	external set specularDataPosition( num value );
	
	/// This contains all the images data needed to reconstruct the cubemap.
	external List<BufferImageData> get mipmaps;
	external set mipmaps( List<BufferImageData> value );
	
	/// Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.
	external num get lodGenerationScale;
	external set lodGenerationScale( num value );
}

/// Sets of helpers addressing the serialization and deserialization of environment texture
/// stored in a BabylonJS env file.
/// Those files are usually stored as .env files.
@JS()
class EnvironmentTextureTools {
	external factory EnvironmentTextureTools();
	
	/// Gets the environment info from an env file.
	/// @param data The array buffer containing the .env bytes.
	/// @returns the environment file info (the json header) if successfully parsed.
	external static EnvironmentTextureInfo? GetEnvInfo(dynamic data);
	
	/// Creates an environment texture from a loaded cube texture.
	/// @param texture defines the cube texture to convert in env file
	/// @return a promise containing the environment data if succesfull.
	external static Promise<ByteBuffer> CreateEnvTextureAsync(BaseTexture texture);
	
	/// Creates the ArrayBufferViews used for initializing environment texture image data.
	/// @param data the image data
	/// @param info parameters that determine what views will be created for accessing the underlying buffer
	/// @return the views described by info providing access to the underlying buffer
	external static List<List<dynamic>> CreateImageDataArrayBufferViews(dynamic data, EnvironmentTextureInfo info);
	
	/// Uploads the texture info contained in the env file to the GPU.
	/// @param texture defines the internal texture to upload to
	/// @param data defines the data to load
	/// @param info defines the texture info retrieved through the GetEnvInfo method
	/// @returns a promise
	external static Promise<void> UploadEnvLevelsAsync(InternalTexture texture, dynamic data, EnvironmentTextureInfo info);
	
	/// Uploads the levels of image data to the GPU.
	/// @param texture defines the internal texture to upload to
	/// @param imageData defines the array buffer views of image data [mipmap][face]
	/// @returns a promise
	external static Promise<void> UploadLevelsAsync(InternalTexture texture, List<List<dynamic>> imageData);
	
	/// Uploads spherical polynomials information to the texture.
	/// @param texture defines the texture we are trying to upload the information to
	/// @param info defines the environment texture info retrieved through the GetEnvInfo method
	external static void UploadEnvSpherical(InternalTexture texture, EnvironmentTextureInfo info);
}

/// Class used to inline functions in shader code
@JS()
class ShaderCodeInliner {
	
	/// Initializes the inliner
	/// @param sourceCode shader code source to inline
	/// @param numMaxIterations maximum number of iterations (used to detect recursive calls)
	external factory ShaderCodeInliner(String sourceCode, [num? numMaxIterations]);
	
	/// Gets or sets the token used to mark the functions to inline
	external String get inlineToken;
	external set inlineToken(String value);
	
	/// Gets or sets the debug mode
	external bool get debug;
	external set debug(bool value);
	
	/// Gets the code after the inlining process
	external String get code;
	
	/// Start the processing of the shader code
	external void processCode();
}

/// Container for accessors for natively-stored mesh data buffers.
@JS()
class NativeDataBuffer extends DataBuffer {
	external factory NativeDataBuffer();
	
	/// Accessor value used to identify/retrieve a natively-stored index buffer.
	external dynamic get nativeIndexBuffer;
	external set nativeIndexBuffer(dynamic value);
	
	/// Accessor value used to identify/retrieve a natively-stored vertex buffer.
	external dynamic get nativeVertexBuffer;
	external set nativeVertexBuffer(dynamic value);
}

/// @hidden
@JS()
class NativeTexture extends InternalTexture {
	external factory NativeTexture();
	
	external InternalTexture getInternalTexture();
	
	external num getViewCount();
}

/// @hidden
@JS()
class NativeEngine extends Engine {
	
	external factory NativeEngine();
	
	@override
	external num getHardwareScalingLevel();
	
	@override
	external void dispose();
	
	/// Gets host document
	/// @returns the host document object
	@override
	external HTML.Document? getHostDocument();
	
	@override
	external void clear(Color4? color, bool backBuffer, bool depth, [bool? stencil]);
	
	@override
	external NativeDataBuffer createIndexBuffer(dynamic indices, [bool? updateable]);
	
	@override
	external NativeDataBuffer createVertexBuffer(dynamic data, [bool? updateable]);
	
	@override
	/* Manual Fix 19 */
	external void bindBuffers(dynamic /* object */ vertexBuffers, DataBuffer? indexBuffer, Effect effect);
	
	@override
	/* Manual Fix 18 */
	external WebGL.VertexArrayObject recordVertexArrayObject(dynamic vertexBuffers, DataBuffer? indexBuffer, Effect effect);
	
	@override
	external void bindVertexArrayObject(WebGL.VertexArrayObject vertexArray, [DataBuffer? indexBuffer]);
	
	@override
	external void releaseVertexArrayObject(WebGL.VertexArrayObject vertexArray);
	
	@override
	external List<num> getAttributes(IPipelineContext pipelineContext, List<String> attributesNames);
	
	/// Draw a list of indexed primitives
	/// @param fillMode defines the primitive to use
	/// @param indexStart defines the starting index
	/// @param indexCount defines the number of index to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	@override
	external void drawElementsType(num fillMode, num indexStart, num indexCount, [num? instancesCount]);
	
	/// Draw a list of unindexed primitives
	/// @param fillMode defines the primitive to use
	/// @param verticesStart defines the index of first vertex to draw
	/// @param verticesCount defines the count of vertices to draw
	/// @param instancesCount defines the number of instances to draw (if instanciation is enabled)
	@override
	external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num? instancesCount]);
	
	@override
	external IPipelineContext createPipelineContext();
	
	@override
	/* Manual Fix 20 */
	external WebGL.Program createRawShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, [WebGL.RenderingContext? context, List<String>? transformFeedbackVaryings]);
	
	@override
	/* Manual Fix 21 */
	external WebGL.Program createShaderProgram(IPipelineContext pipelineContext, String vertexCode, String fragmentCode, String? defines, [WebGL.RenderingContext? context, List<String>? transformFeedbackVaryings]);
	
	@override
	external List<WebGL.UniformLocation>? getUniforms(IPipelineContext pipelineContext, List<String> uniformsNames);
	
	@override
	external void bindUniformBlock(IPipelineContext pipelineContext, String blockName, num index);
	
	@override
	external void bindSamplers(Effect effect);
	
	external void setMatrix(WebGL.UniformLocation uniform, Matrix matrix);
	
	@override
	external num getRenderWidth([bool? useScreen]);
	
	@override
	external num getRenderHeight([bool? useScreen]);
	
	@override
	external void setViewport(Viewport viewport, [num? requiredWidth, num? requiredHeight]);
	
	@override
	external void setState(bool culling, [num? zOffset, bool? force, bool? reverseSide]);
	
	/// Set the z offset to apply to current rendering
	/// @param value defines the offset to apply
	@override
	external void setZOffset(num value);
	
	/// Gets the current value of the zOffset
	/// @returns the current zOffset state
	@override
	external num getZOffset();
	
	/// Enable or disable depth buffering
	/// @param enable defines the state to set
	@override
	external void setDepthBuffer(bool enable);
	
	/// Gets a boolean indicating if depth writing is enabled
	/// @returns the current depth writing state
	@override
	external bool getDepthWrite();
	
	@override
	external void setDepthFunctionToGreater();
	
	@override
	external void setDepthFunctionToGreaterOrEqual();
	
	@override
	external void setDepthFunctionToLess();
	
	@override
	external void setDepthFunctionToLessOrEqual();
	
	/// Enable or disable depth writing
	/// @param enable defines the state to set
	@override
	external void setDepthWrite(bool enable);
	
	/// Enable or disable color writing
	/// @param enable defines the state to set
	@override
	external void setColorWrite(bool enable);
	
	/// Gets a boolean indicating if color writing is enabled
	/// @returns the current color writing state
	@override
	external bool getColorWrite();
	
	/// Sets alpha constants used by some alpha blending modes
	/// @param r defines the red component
	/// @param g defines the green component
	/// @param b defines the blue component
	/// @param a defines the alpha component
	@override
	external void setAlphaConstants(num r, num g, num b, num a);
	
	/// Sets the current alpha mode
	/// @param mode defines the mode to use (one of the BABYLON.Constants.ALPHA_XXX)
	/// @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
	@override
	external void setAlphaMode(num mode, [bool? noDepthWriteChange]);
	
	/// Gets the current alpha mode
	/// @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
	/// @returns the current alpha mode
	@override
	external num getAlphaMode();
	
	@override
	external bool setInt(WebGL.UniformLocation? uniform, num int);
	
	@override
	external bool setIntArray(WebGL.UniformLocation? uniform, Int32List array);
	
	@override
	external bool setIntArray2(WebGL.UniformLocation? uniform, Int32List array);
	
	@override
	external bool setIntArray3(WebGL.UniformLocation? uniform, Int32List array);
	
	@override
	external bool setIntArray4(WebGL.UniformLocation? uniform, Int32List array);
	
	external bool setFloatArray(WebGL.UniformLocation uniform, Float32List array);
	
	external bool setFloatArray2(WebGL.UniformLocation uniform, Float32List array);
	
	external bool setFloatArray3(WebGL.UniformLocation uniform, Float32List array);
	
	external bool setFloatArray4(WebGL.UniformLocation uniform, Float32List array);
	
	@override
	external bool setArray(WebGL.UniformLocation? uniform, List<num> array);
	
	@override
	external bool setArray2(WebGL.UniformLocation? uniform, List<num> array);
	
	@override
	external bool setArray3(WebGL.UniformLocation? uniform, List<num> array);
	
	@override
	external bool setArray4(WebGL.UniformLocation? uniform, List<num> array);
	
	@override
	external bool setMatrices(WebGL.UniformLocation? uniform, Float32List matrices);
	
	@override
	external bool setMatrix3x3(WebGL.UniformLocation? uniform, Float32List matrix);
	
	@override
	external bool setMatrix2x2(WebGL.UniformLocation? uniform, Float32List matrix);
	
	@override
	external bool setFloat(WebGL.UniformLocation? uniform, num value);
	
	@override
	external bool setFloat2(WebGL.UniformLocation? uniform, num x, num y);
	
	@override
	external bool setFloat3(WebGL.UniformLocation? uniform, num x, num y, num z);
	
	@override
	external bool setFloat4(WebGL.UniformLocation? uniform, num x, num y, num z, num w);
	
	external bool setColor3(WebGL.UniformLocation uniform, Color3 color3);
	
	external bool setColor4(WebGL.UniformLocation uniform, Color3 color3, num alpha);
	
	@override
	external void wipeCaches([bool? bruteForce]);
	
	/// Update the content of a dynamic texture
	/// @param texture defines the texture to update
	/// @param canvas defines the canvas containing the source
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param premulAlpha defines if alpha is stored as premultiplied
	/// @param format defines the format of the data
	/// @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)
	@override
	external void updateDynamicTexture(InternalTexture? texture, HTML.CanvasElement canvas, [bool? invertY, bool? premulAlpha, num? format, bool? forceBindTexture]);
	
	/// Usually called from Texture.ts.
	/// Passed information to create a WebGLTexture
	/// @param url defines a value which contains one of the following:
	/// * A conventional http URL, e.g. 'http://...' or 'file://...'
	/// * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
	/// * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
	/// @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
	/// @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
	/// @param scene needed for loading to the correct scene
	/// @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
	/// @param onLoad optional callback to be called upon successful completion
	/// @param onError optional callback to be called upon failure
	/// @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
	/// @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
	/// @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
	/// @param forcedExtension defines the extension to use to pick the right loader
	/// @param mimeType defines an optional mime type
	/// @param loaderOptions options to be passed to the loader
	/// @returns a InternalTexture for assignment back into BABYLON.Texture
	@override
	external InternalTexture createTexture(String? url, bool noMipmap, bool invertY, ISceneLike? scene, [num? samplingMode, void Function()? onLoad, void Function(String message, dynamic exception)? onError, dynamic? buffer, InternalTexture? fallback, num? format, String? forcedExtension, String? mimeType, dynamic? loaderOptions]);
	
	/// Creates a cube texture
	/// @param rootUrl defines the url where the files to load is located
	/// @param scene defines the current scene
	/// @param files defines the list of files to load (1 per face)
	/// @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
	/// @param onLoad defines an optional callback raised when the texture is loaded
	/// @param onError defines an optional callback raised if there is an issue to load the texture
	/// @param format defines the format of the data
	/// @param forcedExtension defines the extension to use to pick the right loader
	/// @param createPolynomials if a polynomial sphere should be created for the cube texture
	/// @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
	/// @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
	/// @param fallback defines texture to use while falling back when (compressed) texture file not found.
	/// @returns the cube texture as an InternalTexture
	@override
	external InternalTexture createCubeTexture(String rootUrl, Scene? scene, List<String>? files, [bool? noMipmap, void Function([dynamic? data])? onLoad, void Function([String? message, dynamic? exception])? onError, num? format, dynamic? forcedExtension, bool? createPolynomials, num? lodScale, num? lodOffset, InternalTexture? fallback, dynamic? loaderOptions]);
	
	@override
	external NativeTexture createRenderTargetTexture(dynamic size, dynamic options);
	
	@override
	external void updateTextureSamplingMode(num samplingMode, InternalTexture texture, [bool? generateMipMaps]);
	
	@override
	external void bindFramebuffer(InternalTexture texture, [num? faceIndex, num? requiredWidth, num? requiredHeight, bool? forceFullscreenViewport, num? lodLevel, num? layer]);
	
	@override
	external void unBindFramebuffer(InternalTexture texture, [bool? disableGenerateMipMaps, void Function()? onBeforeUnbind]);
	
	@override
	external DataBuffer createDynamicVertexBuffer(dynamic data);
	
	@override
	/* Manual Fix 31 */
	external void updateDynamicIndexBuffer(dynamic indexBuffer, dynamic indices, [num? offset]);
	
	/// Updates a dynamic vertex buffer.
	/// @param vertexBuffer the vertex buffer to update
	/// @param data the data used to update the vertex buffer
	/// @param byteOffset the byte offset of the data (optional)
	/// @param byteLength the byte length of the data (optional)
	@override
	/* Manual Fix 33 */
	external void updateDynamicVertexBuffer(dynamic vertexBuffer, dynamic data, [num? byteOffset, num? byteLength]);
	
	@override
	external void releaseEffects();
}

/// Gather the list of clipboard event types as constants.
@JS()
class ClipboardEventTypes {
	external factory ClipboardEventTypes();
	
	/// The clipboard event is fired when a copy command is active (pressed).
	external static num get COPY;
	
	/// The clipboard event is fired when a cut command is active (pressed).
	external static num get CUT;
	
	/// The clipboard event is fired when a paste command is active (pressed).
	external static num get PASTE;
}

/// This class is used to store clipboard related info for the onClipboardObservable event.
@JS()
class ClipboardInfo {
	
	/// Creates an instance of ClipboardInfo.
	/// @param type Defines the type of event (BABYLON.ClipboardEventTypes)
	/// @param event Defines the related dom event
	external factory ClipboardInfo(num type, HTML.ClipboardEvent event);
	
	/// Defines the type of event (BABYLON.ClipboardEventTypes)
	external num get type;
	external set type(num value);
	
	/// Defines the related dom event
	external HTML.ClipboardEvent get event;
	external set event(HTML.ClipboardEvent value);
	
	/// Get the clipboard event's type from the keycode.
	/// @param keyCode Defines the keyCode for the current keyboard event.
	/// @return {number}
	external static num GetTypeFromCharacter(num keyCode);
}

/// Google Daydream controller
@JS()
class DaydreamController extends WebVRController {
	
	/// Creates a new DaydreamController from a gamepad
	/// @param vrGamepad the gamepad that the controller should be created from
	external factory DaydreamController(dynamic vrGamepad);
	
	/// Base Url for the controller model.
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// File name for the controller model.
	external static String get MODEL_FILENAME;
	external static set MODEL_FILENAME(String value);
	
	/// Gamepad Id prefix used to identify Daydream Controller.
	external static String get GAMEPAD_ID_PREFIX;
	
	/// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
	/// @param scene scene in which to add meshes
	/// @param meshLoaded optional callback function that will be called if the mesh loads successfully.
	@override
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded]);
}

/// Gear VR Controller
@JS()
class GearVRController extends WebVRController {
	
	/// Creates a new GearVRController from a gamepad
	/// @param vrGamepad the gamepad that the controller should be created from
	external factory GearVRController(dynamic vrGamepad);
	
	/// Base Url for the controller model.
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// File name for the controller model.
	external static String get MODEL_FILENAME;
	external static set MODEL_FILENAME(String value);
	
	/// Gamepad Id prefix used to identify this controller.
	external static String get GAMEPAD_ID_PREFIX;
	
	/// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
	/// @param scene scene in which to add meshes
	/// @param meshLoaded optional callback function that will be called if the mesh loads successfully.
	@override
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded]);
}

/// Generic Controller
@JS()
class GenericController extends WebVRController {
	
	/// Creates a new GenericController from a gamepad
	/// @param vrGamepad the gamepad that the controller should be created from
	external factory GenericController(dynamic vrGamepad);
	
	/// Base Url for the controller model.
	external static String get MODEL_BASE_URL;
	
	/// File name for the controller model.
	external static String get MODEL_FILENAME;
	
	/// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
	/// @param scene scene in which to add meshes
	/// @param meshLoaded optional callback function that will be called if the mesh loads successfully.
	@override
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded]);
}

/// Oculus Touch Controller
@JS()
class OculusTouchController extends WebVRController {
	
	/// Creates a new OculusTouchController from a gamepad
	/// @param vrGamepad the gamepad that the controller should be created from
	external factory OculusTouchController(dynamic vrGamepad);
	
	/// Base Url for the controller model.
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// File name for the left controller model.
	external static String get MODEL_LEFT_FILENAME;
	external static set MODEL_LEFT_FILENAME(String value);
	
	/// File name for the right controller model.
	external static String get MODEL_RIGHT_FILENAME;
	external static set MODEL_RIGHT_FILENAME(String value);
	
	/// Base Url for the Quest controller model.
	external static String get QUEST_MODEL_BASE_URL;
	external static set QUEST_MODEL_BASE_URL(String value);
	
	/// Fired when the secondary trigger on this controller is modified
	external Observable<ExtendedGamepadButton> get onSecondaryTriggerStateChangedObservable;
	external set onSecondaryTriggerStateChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the thumb rest on this controller is modified
	external Observable<ExtendedGamepadButton> get onThumbRestChangedObservable;
	external set onThumbRestChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
	/// @param scene scene in which to add meshes
	/// @param meshLoaded optional callback function that will be called if the mesh loads successfully.
	@override
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded]);
	
	/// Fired when the A button on this controller is modified
	external Observable<ExtendedGamepadButton> get onAButtonStateChangedObservable;
	
	/// Fired when the B button on this controller is modified
	external Observable<ExtendedGamepadButton> get onBButtonStateChangedObservable;
	
	/// Fired when the X button on this controller is modified
	external Observable<ExtendedGamepadButton> get onXButtonStateChangedObservable;
	
	/// Fired when the Y button on this controller is modified
	external Observable<ExtendedGamepadButton> get onYButtonStateChangedObservable;
}

/// Vive Controller
@JS()
class ViveController extends WebVRController {
	
	/// Creates a new ViveController from a gamepad
	/// @param vrGamepad the gamepad that the controller should be created from
	external factory ViveController(dynamic vrGamepad);
	
	/// Base Url for the controller model.
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// File name for the controller model.
	external static String get MODEL_FILENAME;
	external static set MODEL_FILENAME(String value);
	
	/// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
	/// @param scene scene in which to add meshes
	/// @param meshLoaded optional callback function that will be called if the mesh loads successfully.
	@override
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded]);
	
	/// Fired when the left button on this controller is modified
	external Observable<ExtendedGamepadButton> get onLeftButtonStateChangedObservable;
	
	/// Fired when the right button on this controller is modified
	external Observable<ExtendedGamepadButton> get onRightButtonStateChangedObservable;
	
	/// Fired when the menu button on this controller is modified
	external Observable<ExtendedGamepadButton> get onMenuButtonStateChangedObservable;
}

/// Defines the WindowsMotionController object that the state of the windows motion controller
@JS()
class WindowsMotionController extends WebVRController {
	
	/// Creates a new WindowsMotionController from a gamepad
	/// @param vrGamepad the gamepad that the controller should be created from
	external factory WindowsMotionController(dynamic vrGamepad);
	
	/// The base url used to load the left and right controller models
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// The name of the left controller model file
	external static String get MODEL_LEFT_FILENAME;
	external static set MODEL_LEFT_FILENAME(String value);
	
	/// The name of the right controller model file
	external static String get MODEL_RIGHT_FILENAME;
	external static set MODEL_RIGHT_FILENAME(String value);
	
	/// The controller name prefix for this controller type
	external static String get GAMEPAD_ID_PREFIX;
	
	/// Fired when the trackpad on this controller is clicked
	external Observable<ExtendedGamepadButton> get onTrackpadChangedObservable;
	external set onTrackpadChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the trackpad on this controller is modified
	external Observable<StickValues> get onTrackpadValuesChangedObservable;
	external set onTrackpadValuesChangedObservable(Observable<StickValues> value);
	
	/// The current x and y values of this controller's trackpad
	external StickValues get trackpad;
	external set trackpad(StickValues value);
	
	/// Fired when the trigger on this controller is modified
	external Observable<ExtendedGamepadButton> get onTriggerButtonStateChangedObservable;
	
	/// Fired when the menu button on this controller is modified
	external Observable<ExtendedGamepadButton> get onMenuButtonStateChangedObservable;
	
	/// Fired when the grip button on this controller is modified
	external Observable<ExtendedGamepadButton> get onGripButtonStateChangedObservable;
	
	/// Fired when the thumbstick button on this controller is modified
	external Observable<ExtendedGamepadButton> get onThumbstickButtonStateChangedObservable;
	
	/// Fired when the touchpad button on this controller is modified
	external Observable<ExtendedGamepadButton> get onTouchpadButtonStateChangedObservable;
	
	/// Fired when the touchpad values on this controller are modified
	external Observable<StickValues> get onTouchpadValuesChangedObservable;
	
	/// Called once per frame by the engine.
	@override
	external void update();
	
	/// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
	/// @param scene scene in which to add meshes
	/// @param meshLoaded optional callback function that will be called if the mesh loads successfully.
	@override
	external void initControllerMesh(Scene scene, [void Function(AbstractMesh mesh)? meshLoaded, bool? forceDefault]);
	
	/// Gets the ray of the controller in the direction the controller is pointing
	/// @param length the length the resulting ray should be
	/// @returns a ray in the direction the controller is pointing
	@override
	external Ray getForwardRay([num? length]);
	
	/// Disposes of the controller
	@override
	external void dispose();
}

/// This class represents a new windows motion controller in XR.
@JS()
class XRWindowsMotionController extends WindowsMotionController {
	
	/// Construct a new XR-Based windows motion controller
	/// 
	/// @param gamepadInfo the gamepad object from the browser
	external factory XRWindowsMotionController(dynamic gamepadInfo);
	
	/// holds the thumbstick values (X,Y)
	external StickValues get thumbstickValues;
	external set thumbstickValues(StickValues value);
	
	/// Fired when the thumbstick on this controller is clicked
	external Observable<ExtendedGamepadButton> get onThumbstickStateChangedObservable;
	external set onThumbstickStateChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the thumbstick on this controller is modified
	external Observable<StickValues> get onThumbstickValuesChangedObservable;
	external set onThumbstickValuesChangedObservable(Observable<StickValues> value);
	
	/// Fired when the touchpad button on this controller is modified
	@override
	external Observable<ExtendedGamepadButton> get onTrackpadChangedObservable;
	@override
	external set onTrackpadChangedObservable(Observable<ExtendedGamepadButton> value);
	
	/// Fired when the touchpad values on this controller are modified
	@override
	external Observable<StickValues> get onTrackpadValuesChangedObservable;
	@override
	external set onTrackpadValuesChangedObservable(Observable<StickValues> value);
	
	/// Fired when the thumbstick button on this controller is modified
	/// here to prevent breaking changes
	@override
	external Observable<ExtendedGamepadButton> get onThumbstickButtonStateChangedObservable;
	
	/// Disposes the class with joy
	@override
	external void dispose();
}

/// A directional light is defined by a direction (what a surprise!).
/// The light is emitted from everywhere in the specified direction, and has an infinite range.
/// An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
/// Documentation: https://doc.babylonjs.com/babylon101/lights
@JS()
class DirectionalLight extends ShadowLight {
	
	/// Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
	/// The directional light is emitted from everywhere in the given direction.
	/// It can cast shadows.
	/// Documentation : https://doc.babylonjs.com/babylon101/lights
	/// @param name The friendly name of the light
	/// @param direction The direction of the light
	/// @param scene The scene the light belongs to
	external factory DirectionalLight(String name, Vector3 direction, Scene scene);
	
	/// Fix frustum size for the shadow generation. This is disabled if the value is 0.
	external num get shadowFrustumSize;
	
	/// Specifies a fix frustum size for the shadow generation.
	external set shadowFrustumSize(num value);
	
	/// Gets the shadow projection scale against the optimal computed one.
	/// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
	/// This does not impact in fixed frustum size (shadowFrustumSize being set)
	external num get shadowOrthoScale;
	
	/// Sets the shadow projection scale against the optimal computed one.
	/// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
	/// This does not impact in fixed frustum size (shadowFrustumSize being set)
	external set shadowOrthoScale(num value);
	
	/// Automatically compute the projection matrix to best fit (including all the casters)
	/// on each frame.
	external bool get autoUpdateExtends;
	external set autoUpdateExtends(bool value);
	
	/// Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)
	/// on each frame. autoUpdateExtends must be set to true for this to work
	external bool get autoCalcShadowZBounds;
	external set autoCalcShadowZBounds(bool value);
	
	/// Returns the string "DirectionalLight".
	/// @return The class name
	@override
	external String getClassName();
	
	/// Returns the integer 1.
	/// @return The light Type id as a constant defines in Light.LIGHTTYPEID_x
	@override
	external num getTypeID();
	
	/// Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The directional light
	@override
	external DirectionalLight transferToEffect(Effect effect, String lightIndex);
	
	@override
	external Light transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);
	
	/// Gets the minZ used for shadow according to both the scene and the light.
	/// 
	/// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
	/// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
	/// @param activeCamera The camera we are returning the min for
	/// @returns the depth min z
	@override
	external num getDepthMinZ(Camera activeCamera);
	
	/// Gets the maxZ used for shadow according to both the scene and the light.
	/// 
	/// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
	/// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
	/// @param activeCamera The camera we are returning the max for
	/// @returns the depth max z
	@override
	external num getDepthMaxZ(Camera activeCamera);
	
	/// Prepares the list of defines specific to the light type.
	/// @param defines the list of defines
	/// @param lightIndex defines the index of the light for the effect
	@override
	external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
	
	/// The light id in the scene (used in scene.findLighById for instance)
	@override
	external String get id;
	@override
	external set id(String value);
	
	/// The position the shdow will be casted from.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// In 2d mode (needCube being false), the direction used to cast the shadow.
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// The friendly name of the light in the scene.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the shadow projection clipping minimum z value.
	external num get shadowMinZ;
	external set shadowMinZ(num value);
	
	/// Defines the shadow projection clipping maximum z value.
	external num get shadowMaxZ;
	external set shadowMaxZ(num value);
	
	/// Gets the scene the light belongs to.
	/// @returns The scene
	@override
	external Scene getScene();
}

/// Class containing static functions to help procedurally build meshes
@JS()
class HemisphereBuilder {
	external factory HemisphereBuilder();
	
	/// Creates a hemisphere mesh
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the hemisphere mesh
	external static Mesh CreateHemisphere(String name, HemisphereBuilderCreateHemisphereOptions options, dynamic scene);
}

/// A spot light is defined by a position, a direction, an angle, and an exponent.
/// These values define a cone of light starting from the position, emitting toward the direction.
/// The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
/// and the exponent defines the speed of the decay of the light with distance (reach).
/// Documentation: https://doc.babylonjs.com/babylon101/lights
@JS()
class SpotLight extends ShadowLight {
	
	/// Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
	/// It can cast shadows.
	/// Documentation : https://doc.babylonjs.com/babylon101/lights
	/// @param name The light friendly name
	/// @param position The position of the spot light in the scene
	/// @param direction The direction of the light in the scene
	/// @param angle The cone angle of the light in Radians
	/// @param exponent The light decay speed with the distance from the emission spot
	/// @param scene The scene the lights belongs to
	external factory SpotLight(String name, Vector3 position, Vector3 direction, num angle, num exponent, Scene scene);
	
	/// Gets the cone angle of the spot light in Radians.
	external num get angle;
	
	/// Sets the cone angle of the spot light in Radians.
	external set angle(num value);
	
	/// Only used in gltf falloff mode, this defines the angle where
	/// the directional falloff will start before cutting at angle which could be seen
	/// as outer angle.
	external num get innerAngle;
	
	/// Only used in gltf falloff mode, this defines the angle where
	/// the directional falloff will start before cutting at angle which could be seen
	/// as outer angle.
	external set innerAngle(num value);
	
	/// Allows scaling the angle of the light for shadow generation only.
	external num get shadowAngleScale;
	
	/// Allows scaling the angle of the light for shadow generation only.
	external set shadowAngleScale(num value);
	
	/// The light decay speed with the distance from the emission spot.
	external num get exponent;
	external set exponent(num value);
	
	/// Allows reading the projecton texture
	external Matrix get projectionTextureMatrix;
	
	/// Gets the near clip of the Spotlight for texture projection.
	external num get projectionTextureLightNear;
	
	/// Sets the near clip of the Spotlight for texture projection.
	external set projectionTextureLightNear(num value);
	
	/// Gets the far clip of the Spotlight for texture projection.
	external num get projectionTextureLightFar;
	
	/// Sets the far clip of the Spotlight for texture projection.
	external set projectionTextureLightFar(num value);
	
	/// Gets the Up vector of the Spotlight for texture projection.
	external Vector3 get projectionTextureUpDirection;
	
	/// Sets the Up vector of the Spotlight for texture projection.
	external set projectionTextureUpDirection(Vector3 value);
	
	/// Gets the projection texture of the light.
	external BaseTexture? get projectionTexture;
	
	/// Sets the projection texture of the light.
	external set projectionTexture(BaseTexture? value);
	
	/// Returns the string "SpotLight".
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Returns the integer 2.
	/// @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
	@override
	external num getTypeID();
	
	/// Sets the passed Effect "effect" with the Light textures.
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The light
	@override
	external Light transferTexturesToEffect(Effect effect, String lightIndex);
	
	/// Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The spot light
	@override
	external SpotLight transferToEffect(Effect effect, String lightIndex);
	
	/* Manual Fix 10 */
	
	@override
	external Light transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);
	
	/// Disposes the light and the associated resources.
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
	
	/// Prepares the list of defines specific to the light type.
	/// @param defines the list of defines
	/// @param lightIndex defines the index of the light for the effect
	@override
	external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
	
	/// The light id in the scene (used in scene.findLighById for instance)
	@override
	external String get id;
	@override
	external set id(String value);
	
	/// The position the shdow will be casted from.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// In 2d mode (needCube being false), the direction used to cast the shadow.
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// The friendly name of the light in the scene.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the shadow projection clipping minimum z value.
	external num get shadowMinZ;
	external set shadowMinZ(num value);
	
	/// Defines the shadow projection clipping maximum z value.
	external num get shadowMaxZ;
	external set shadowMaxZ(num value);
	
	/// Gets the scene the light belongs to.
	/// @returns The scene
	@override
	external Scene getScene();
}

/// Gizmo that enables viewing a light
@JS()
class LightGizmo extends Gizmo {
	
	/// Creates a LightGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	external factory LightGizmo([UtilityLayerRenderer? gizmoLayer]);
	
	/// Event that fires each time the gizmo is clicked
	external Observable<Light> get onClickedObservable;
	external set onClickedObservable(Observable<Light> value);
	
	/// The light that the gizmo is attached to
	external set light(Light? value);
	
	external Light? get light;
	
	/// Gets the material used to render the light gizmo
	external StandardMaterial get material;
	
	/// Disposes of the light gizmo
	@override
	external void dispose();
}

/// Gizmo that enables viewing a camera
@JS()
class CameraGizmo extends Gizmo {
	
	/// Creates a CameraGizmo
	/// @param gizmoLayer The utility layer the gizmo will be added to
	external factory CameraGizmo([UtilityLayerRenderer? gizmoLayer]);
	
	/// Event that fires each time the gizmo is clicked
	external Observable<Camera> get onClickedObservable;
	external set onClickedObservable(Observable<Camera> value);
	
	/// Gets or sets a boolean indicating if frustum lines must be rendered (true by default))
	external bool get displayFrustum;
	
	external set displayFrustum(bool value);
	
	/// The camera that the gizmo is attached to
	external set camera(Camera? value);
	
	external Camera? get camera;
	
	/// Gets the material used to render the camera gizmo
	external StandardMaterial get material;
	
	/// Disposes of the camera gizmo
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get backgroundFragmentDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get backgroundUboDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get backgroundPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get backgroundVertexDeclaration;

/* var */
/// @hidden
@JS()
external dynamic get backgroundVertexShader;

/// Background material used to create an efficient environement around your scene.
@JS()
class BackgroundMaterial extends PushMaterial {
	
	/// Instantiates a Background Material in the given scene
	/// @param name The friendly name of the material
	/// @param scene The scene to add the material to
	external factory BackgroundMaterial(String name, Scene scene);
	
	/// Standard reflectance value at parallel view angle.
	external static num get StandardReflectance0;
	external static set StandardReflectance0(num value);
	
	/// Standard reflectance value at grazing angle.
	external static num get StandardReflectance90;
	external static set StandardReflectance90(num value);
	
	/// Key light Color (multiply against the environement texture)
	external Color3 get primaryColor;
	external set primaryColor(Color3 value);
	
	/// Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
	/// The color opposite to the primary color is used at the level chosen to define what the black area would look.
	external dynamic get primaryColorShadowLevel;
	
	external set primaryColorShadowLevel(dynamic value);
	
	/// Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
	/// The primary color is used at the level chosen to define what the white area would look.
	external dynamic get primaryColorHighlightLevel;
	
	external set primaryColorHighlightLevel(dynamic value);
	
	/// Reflection Texture used in the material.
	/// Should be author in a specific way for the best result (refer to the documentation).
	external BaseTexture? get reflectionTexture;
	external set reflectionTexture(BaseTexture? value);
	
	/// Reflection Texture level of blur.
	/// 
	/// Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
	/// texture twice.
	external dynamic get reflectionBlur;
	external set reflectionBlur(dynamic value);
	
	/// Diffuse Texture used in the material.
	/// Should be author in a specific way for the best result (refer to the documentation).
	external BaseTexture? get diffuseTexture;
	external set diffuseTexture(BaseTexture? value);
	
	/// Specify the list of lights casting shadow on the material.
	/// All scene shadow lights will be included if null.
	external List<IShadowLight>? get shadowLights;
	external set shadowLights(List<IShadowLight>? value);
	
	/// Helps adjusting the shadow to a softer level if required.
	/// 0 means black shadows and 1 means no shadows.
	external dynamic get shadowLevel;
	external set shadowLevel(dynamic value);
	
	/// In case of opacity Fresnel or reflection falloff, this is use as a scene center.
	/// It is usually zero but might be interesting to modify according to your setup.
	external Vector3 get sceneCenter;
	external set sceneCenter(Vector3 value);
	
	/// This helps specifying that the material is falling off to the sky box at grazing angle.
	/// This helps ensuring a nice transition when the camera goes under the ground.
	external bool get opacityFresnel;
	external set opacityFresnel(bool value);
	
	/// This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
	/// This helps adding a mirror texture on the ground.
	external bool get reflectionFresnel;
	external set reflectionFresnel(bool value);
	
	/// This helps specifying the falloff radius off the reflection texture from the sceneCenter.
	/// This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
	external num get reflectionFalloffDistance;
	external set reflectionFalloffDistance(num value);
	
	/// This specifies the weight of the reflection against the background in case of reflection Fresnel.
	external num get reflectionAmount;
	external set reflectionAmount(num value);
	
	/// This specifies the weight of the reflection at grazing angle.
	external num get reflectionReflectance0;
	external set reflectionReflectance0(num value);
	
	/// This specifies the weight of the reflection at a perpendicular point of view.
	external num get reflectionReflectance90;
	external set reflectionReflectance90(num value);
	
	/// Sets the reflection reflectance fresnel values according to the default standard
	/// empirically know to work well :-)
	external set reflectionStandardFresnelWeight(num value);
	
	/// Helps to directly use the maps channels instead of their level.
	external bool get useRGBColor;
	external set useRGBColor(bool value);
	
	/// This helps reducing the banding effect that could occur on the background.
	external bool get enableNoise;
	external set enableNoise(bool value);
	
	/// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
	/// Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
	/// Recommended to be keep at 1.0 except for special cases.
	external num get fovMultiplier;
	
	external set fovMultiplier(num value);
	
	/// Enable the FOV adjustment feature controlled by fovMultiplier.
	external bool get useEquirectangularFOV;
	external set useEquirectangularFOV(bool value);
	
	/// Number of Simultaneous lights allowed on the material.
	external dynamic get maxSimultaneousLights;
	external set maxSimultaneousLights(dynamic value);
	
	/// Make the material only render shadows
	external bool get shadowOnly;
	external set shadowOnly(bool value);
	
	/// Gets the image processing configuration used either in this material.
	external ImageProcessingConfiguration? get imageProcessingConfiguration;
	
	/// Sets the Default image processing configuration used either in the this material.
	/// 
	/// If sets to null, the scene one is in use.
	external set imageProcessingConfiguration(ImageProcessingConfiguration? value);
	
	/// Gets wether the color curves effect is enabled.
	external bool get cameraColorCurvesEnabled;
	
	/// Sets wether the color curves effect is enabled.
	external set cameraColorCurvesEnabled(bool value);
	
	/// Gets wether the color grading effect is enabled.
	external bool get cameraColorGradingEnabled;
	
	/// Gets wether the color grading effect is enabled.
	external set cameraColorGradingEnabled(bool value);
	
	/// Gets wether tonemapping is enabled or not.
	external bool get cameraToneMappingEnabled;
	
	/// Sets wether tonemapping is enabled or not
	external set cameraToneMappingEnabled(bool value);
	
	/// The camera exposure used on this material.
	/// This property is here and not in the camera to allow controlling exposure without full screen post process.
	/// This corresponds to a photographic exposure.
	external dynamic get cameraExposure;
	
	/// The camera exposure used on this material.
	/// This property is here and not in the camera to allow controlling exposure without full screen post process.
	/// This corresponds to a photographic exposure.
	external set cameraExposure(dynamic value);
	
	/// Gets The camera contrast used on this material.
	external dynamic get cameraContrast;
	
	/// Sets The camera contrast used on this material.
	external set cameraContrast(dynamic value);
	
	/// Gets the Color Grading 2D Lookup Texture.
	external BaseTexture? get cameraColorGradingTexture;
	
	/// Sets the Color Grading 2D Lookup Texture.
	external set cameraColorGradingTexture(BaseTexture? value);
	
	/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
	/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
	/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
	/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
	external ColorCurves? get cameraColorCurves;
	
	/// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
	/// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
	/// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
	/// corresponding to low luminance, medium luminance, and high luminance areas respectively.
	external set cameraColorCurves(ColorCurves? value);
	
	/// Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
	/// Setting this flag to true (not done automatically!) will convert it back to RGB.
	external bool get switchToBGR;
	external set switchToBGR(bool value);
	
	/// Gets a boolean indicating that current material needs to register RTT
	@override
	external bool get hasRenderTargetTextures;
	
	/// The entire material has been created in order to prevent overdraw.
	/// @returns false
	@override
	external bool needAlphaTesting();
	
	/// The entire material has been created in order to prevent overdraw.
	/// @returns true if blending is enable
	@override
	external bool needAlphaBlending();
	
	/// Checks wether the material is ready to be rendered for a given mesh.
	/// @param mesh The mesh to render
	/// @param subMesh The submesh to check against
	/// @param useInstances Specify wether or not the material is used with instances
	/// @returns true if all the dependencies are ready (Textures, Effects...)
	@override
	external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool? useInstances]);
	
	/// Build the uniform buffer used in the material.
	external void buildUniformLayout();
	
	/// Unbind the material.
	@override
	external void unbind();
	
	/// Bind only the world matrix to the material.
	/// @param world The world matrix to bind.
	@override
	external void bindOnlyWorldMatrix(Matrix world);
	
	/// Bind the material for a dedicated submeh (every used meshes will be considered opaque).
	/// @param world The world matrix to bind.
	/// @param subMesh The submesh to bind for.
	@override
	external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
	
	/// Checks to see if a texture is used in the material.
	/// @param texture - Base texture to use.
	/// @returns - Boolean specifying if a texture is used in the material.
	@override
	external bool hasTexture(BaseTexture texture);
	
	/// Dispose the material.
	/// @param forceDisposeEffect Force disposal of the associated effect.
	/// @param forceDisposeTextures Force disposal of the associated textures.
	@override
	external void dispose([bool? forceDisposeEffect, bool? forceDisposeTextures, bool? notBoundToMesh]);
	
	/// Clones the material.
	/// @param name The cloned name.
	/// @returns The cloned material.
	@override
	external BackgroundMaterial? clone(String name);
	
	/// Serializes the current material to its JSON representation.
	/// @returns The JSON representation.
	@override
	external dynamic serialize();
	
	/// Gets the class name of the material
	/// @returns "BackgroundMaterial"
	@override
	external String getClassName();
	
	/// Parse a JSON input to create back a background material.
	/// @param source The JSON data to parse
	/// @param scene The scene to create the parsed material in
	/// @param rootUrl The root url of the assets the material depends upon
	/// @returns the instantiated BackgroundMaterial.
	@override
	external static BackgroundMaterial? Parse(dynamic source, Scene scene, String rootUrl);
}

/// Represents the different options available during the creation of
/// a Environment helper.
/// 
/// This can control the default ground, skybox and image processing setup of your scene.
@JS()
@anonymous
class IEnvironmentHelperOptions {
	
	external factory IEnvironmentHelperOptions({bool createGround, num groundSize, dynamic groundTexture, Color3 groundColor, num groundOpacity, bool enableGroundShadow, num groundShadowLevel, bool enableGroundMirror, num groundMirrorSizeRatio, num groundMirrorBlurKernel, num groundMirrorAmount, num groundMirrorFresnelWeight, num groundMirrorFallOffDistance, num groundMirrorTextureType, num groundYBias, bool createSkybox, num skyboxSize, dynamic skyboxTexture, Color3 skyboxColor, num backgroundYRotation, bool sizeAuto, Vector3 rootPosition, bool setupImageProcessing, dynamic environmentTexture, num cameraExposure, num cameraContrast, bool toneMappingEnabled});
	
	/// Specifies whether or not to create a ground.
	/// True by default.
	external bool get createGround;
	external set createGround( bool value );
	
	/// Specifies the ground size.
	/// 15 by default.
	external num get groundSize;
	external set groundSize( num value );
	
	/// The texture used on the ground for the main color.
	/// Comes from the BabylonJS CDN by default.
	/// 
	/// Remarks: Can be either a texture or a url.
	external dynamic get groundTexture;
	external set groundTexture( dynamic value );
	
	/// The color mixed in the ground texture by default.
	/// BabylonJS clearColor by default.
	external Color3 get groundColor;
	external set groundColor( Color3 value );
	
	/// Specifies the ground opacity.
	/// 1 by default.
	external num get groundOpacity;
	external set groundOpacity( num value );
	
	/// Enables the ground to receive shadows.
	/// True by default.
	external bool get enableGroundShadow;
	external set enableGroundShadow( bool value );
	
	/// Helps preventing the shadow to be fully black on the ground.
	/// 0.5 by default.
	external num get groundShadowLevel;
	external set groundShadowLevel( num value );
	
	/// Creates a mirror texture attach to the ground.
	/// false by default.
	external bool get enableGroundMirror;
	external set enableGroundMirror( bool value );
	
	/// Specifies the ground mirror size ratio.
	/// 0.3 by default as the default kernel is 64.
	external num get groundMirrorSizeRatio;
	external set groundMirrorSizeRatio( num value );
	
	/// Specifies the ground mirror blur kernel size.
	/// 64 by default.
	external num get groundMirrorBlurKernel;
	external set groundMirrorBlurKernel( num value );
	
	/// Specifies the ground mirror visibility amount.
	/// 1 by default
	external num get groundMirrorAmount;
	external set groundMirrorAmount( num value );
	
	/// Specifies the ground mirror reflectance weight.
	/// This uses the standard weight of the background material to setup the fresnel effect
	/// of the mirror.
	/// 1 by default.
	external num get groundMirrorFresnelWeight;
	external set groundMirrorFresnelWeight( num value );
	
	/// Specifies the ground mirror Falloff distance.
	/// This can helps reducing the size of the reflection.
	/// 0 by Default.
	external num get groundMirrorFallOffDistance;
	external set groundMirrorFallOffDistance( num value );
	
	/// Specifies the ground mirror texture type.
	/// Unsigned Int by Default.
	external num get groundMirrorTextureType;
	external set groundMirrorTextureType( num value );
	
	/// Specifies a bias applied to the ground vertical position to prevent z-fighting with
	/// the shown objects.
	external num get groundYBias;
	external set groundYBias( num value );
	
	/// Specifies whether or not to create a skybox.
	/// True by default.
	external bool get createSkybox;
	external set createSkybox( bool value );
	
	/// Specifies the skybox size.
	/// 20 by default.
	external num get skyboxSize;
	external set skyboxSize( num value );
	
	/// The texture used on the skybox for the main color.
	/// Comes from the BabylonJS CDN by default.
	/// 
	/// Remarks: Can be either a texture or a url.
	external dynamic get skyboxTexture;
	external set skyboxTexture( dynamic value );
	
	/// The color mixed in the skybox texture by default.
	/// BabylonJS clearColor by default.
	external Color3 get skyboxColor;
	external set skyboxColor( Color3 value );
	
	/// The background rotation around the Y axis of the scene.
	/// This helps aligning the key lights of your scene with the background.
	/// 0 by default.
	external num get backgroundYRotation;
	external set backgroundYRotation( num value );
	
	/// Compute automatically the size of the elements to best fit with the scene.
	external bool get sizeAuto;
	external set sizeAuto( bool value );
	
	/// Default position of the rootMesh if autoSize is not true.
	external Vector3 get rootPosition;
	external set rootPosition( Vector3 value );
	
	/// Sets up the image processing in the scene.
	/// true by default.
	external bool get setupImageProcessing;
	external set setupImageProcessing( bool value );
	
	/// The texture used as your environment texture in the scene.
	/// Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.
	/// 
	/// Remarks: Can be either a texture or a url.
	external dynamic get environmentTexture;
	external set environmentTexture( dynamic value );
	
	/// The value of the exposure to apply to the scene.
	/// 0.6 by default if setupImageProcessing is true.
	external num get cameraExposure;
	external set cameraExposure( num value );
	
	/// The value of the contrast to apply to the scene.
	/// 1.6 by default if setupImageProcessing is true.
	external num get cameraContrast;
	external set cameraContrast( num value );
	
	/// Specifies whether or not tonemapping should be enabled in the scene.
	/// true by default if setupImageProcessing is true.
	external bool get toneMappingEnabled;
	external set toneMappingEnabled( bool value );
}

/// The Environment helper class can be used to add a fully featuread none expensive background to your scene.
/// It includes by default a skybox and a ground relying on the BackgroundMaterial.
/// It also helps with the default setup of your imageProcessing configuration.
@JS()
class EnvironmentHelper {
	
	/// constructor
	/// @param options Defines the options we want to customize the helper
	/// @param scene The scene to add the material to
	external factory EnvironmentHelper(IEnvironmentHelperOptions options, Scene scene);
	
	/// Gets the root mesh created by the helper.
	external Mesh get rootMesh;
	
	/// Gets the skybox created by the helper.
	external Mesh? get skybox;
	
	/// Gets the skybox texture created by the helper.
	external BaseTexture? get skyboxTexture;
	
	/// Gets the skybox material created by the helper.
	external BackgroundMaterial? get skyboxMaterial;
	
	/// Gets the ground mesh created by the helper.
	external Mesh? get ground;
	
	/// Gets the ground texture created by the helper.
	external BaseTexture? get groundTexture;
	
	/// Gets the ground mirror created by the helper.
	external MirrorTexture? get groundMirror;
	
	/// Gets the ground mirror render list to helps pushing the meshes
	/// you wish in the ground reflection.
	external List<AbstractMesh>? get groundMirrorRenderList;
	
	/// Gets the ground material created by the helper.
	external BackgroundMaterial? get groundMaterial;
	
	/// This observable will be notified with any error during the creation of the environment,
	/// mainly texture creation errors.
	external Observable<EnvironmentHelperOnErrorObservable> get onErrorObservable;
	external set onErrorObservable(Observable<EnvironmentHelperOnErrorObservable> value);
	
	/// Updates the background according to the new options
	/// @param options
	external void updateOptions(IEnvironmentHelperOptions options);
	
	/// Sets the primary color of all the available elements.
	/// @param color the main color to affect to the ground and the background
	external void setMainColor(Color3 color);
	
	/// Dispose all the elements created by the Helper.
	external void dispose();
}

/// Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.
/// As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.
/// This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
/// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
@JS()
abstract class TextureDome<T extends Texture> extends TransformNode {
	
	/// Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.
	/// @param name Element's name, child elements will append suffixes for their own names.
	/// @param textureUrlOrElement defines the url(s) or the (video) HTML element to use
	/// @param options An object containing optional or exposed sub element properties
	external factory TextureDome(String name, dynamic textureUrlOrElement, TextureDomeConstructorOptions options, Scene scene, [void Function([String? message, dynamic? exception])? onError]);
	
	external void Function([String? message, dynamic? exception])? get onError;
	external set onError(void Function([String? message, dynamic? exception])? value);
	
	/// Define the source as a Monoscopic panoramic 360/180.
	external static num get MODE_MONOSCOPIC;
	
	/// Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.
	external static num get MODE_TOPBOTTOM;
	
	/// Define the source as a Stereoscopic Side by Side panoramic 360/180.
	external static num get MODE_SIDEBYSIDE;
	
	/// Gets the texture being displayed on the sphere
	external T get texture;
	
	/// Sets the texture being displayed on the sphere
	external set texture(T value);
	
	/// Gets the mesh used for the dome.
	external Mesh get mesh;
	
	/// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
	/// Also see the options.resolution property.
	external num get fovMultiplier;
	
	external set fovMultiplier(num value);
	
	/// Gets or set the current texture mode for the texture. It can be:
	/// * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
	/// * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
	/// * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
	external num get textureMode;
	
	/// Sets the current texture mode for the texture. It can be:
	/// * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
	/// * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
	/// * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
	external set textureMode(num value);
	
	/// Is it a 180 degrees dome (half dome) or 360 texture (full dome)
	external bool get halfDome;
	
	/// Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.
	external set halfDome(bool value);
	
	/// Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly
	external set crossEye(bool value);
	
	/// Is it a cross-eye texture?
	external bool get crossEye;
	
	/// The background material of this dome.
	external BackgroundMaterial get material;
	
	/// Observable raised when an error occured while loading the 360 image
	external Observable<String> get onLoadErrorObservable;
	external set onLoadErrorObservable(Observable<String> value);
	
	/// Releases resources associated with this node.
	/// @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
	/// @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
	@override
	external void dispose([bool? doNotRecurse, bool? disposeMaterialAndTextures]);
}

/// Display a 360 degree photo on an approximately spherical surface, useful for VR applications or skyboxes.
/// As a subclass of TransformNode, this allow parenting to the camera with different locations in the scene.
/// This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
/// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
@JS()
class PhotoDome extends TextureDome<Texture> {
	external factory PhotoDome();
	
	/// Define the image as a Monoscopic panoramic 360 image.
	@override
	external static num get MODE_MONOSCOPIC;
	
	/// Define the image as a Stereoscopic TopBottom/OverUnder panoramic 360 image.
	@override
	external static num get MODE_TOPBOTTOM;
	
	/// Define the image as a Stereoscopic Side by Side panoramic 360 image.
	@override
	external static num get MODE_SIDEBYSIDE;
	
	/// Gets or sets the texture being displayed on the sphere
	external Texture get photoTexture;
	
	/// sets the texture being displayed on the sphere
	external set photoTexture(Texture value);
	
	/// Gets the current video mode for the video. It can be:
	/// * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
	/// * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
	/// * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
	external num get imageMode;
	
	/// Sets the current video mode for the video. It can be:
	/// * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
	/// * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
	/// * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
	external set imageMode(num value);
}

/// Direct draw surface info
/// @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide
@JS()
@anonymous
class DDSInfo {
	
	external factory DDSInfo({num width, num height, num mipmapCount, bool isFourCC, bool isRGB, bool isLuminance, bool isCube, bool isCompressed, num dxgiFormat, num textureType, SphericalPolynomial sphericalPolynomial});
	
	/// Width of the texture
	external num get width;
	external set width( num value );
	
	/// Width of the texture
	external num get height;
	external set height( num value );
	
	/// Number of Mipmaps for the texture
	/// @see https://en.wikipedia.org/wiki/Mipmap
	external num get mipmapCount;
	external set mipmapCount( num value );
	
	/// If the textures format is a known fourCC format
	/// @see https://www.fourcc.org/
	external bool get isFourCC;
	external set isFourCC( bool value );
	
	/// If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format
	external bool get isRGB;
	external set isRGB( bool value );
	
	/// If the texture is a lumincance format
	external bool get isLuminance;
	external set isLuminance( bool value );
	
	/// If this is a cube texture
	/// @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps
	external bool get isCube;
	external set isCube( bool value );
	
	/// If the texture is a compressed format eg. FOURCC_DXT1
	external bool get isCompressed;
	external set isCompressed( bool value );
	
	/// The dxgiFormat of the texture
	/// @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format
	external num get dxgiFormat;
	external set dxgiFormat( num value );
	
	/// Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT
	external num get textureType;
	external set textureType( num value );
	
	/// Sphericle polynomial created for the dds texture
	external SphericalPolynomial get sphericalPolynomial;
	external set sphericalPolynomial( SphericalPolynomial value );
}

/// Class used to provide DDS decompression tools
@JS()
class DDSTools {
	external factory DDSTools();
	
	/// Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)
	external static bool get StoreLODInAlphaChannel;
	external static set StoreLODInAlphaChannel(bool value);
	
	/// Gets DDS information from an array buffer
	/// @param data defines the array buffer view to read data from
	/// @returns the DDS information
	external static DDSInfo GetDDSInfo(dynamic data);
	
	/// Uploads DDS Levels to a Babylon Texture
	/// @hidden
	external static void UploadDDSLevels(ThinEngine engine, InternalTexture texture, dynamic data, DDSInfo info, bool loadMipmaps, num faces, [num? lodIndex, num? currentFace]);
}

/// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
/// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
@JS()
class KhronosTextureContainer {
	
	/// Creates a new KhronosTextureContainer
	/// @param data contents of the KTX container file
	/// @param facesExpected should be either 1 or 6, based whether a cube texture or or
	/// @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
	/// @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
	external factory KhronosTextureContainer(dynamic data, num facesExpected, [bool? threeDExpected, bool? textureArrayExpected]);
	
	/// contents of the KTX container file
	external dynamic get data;
	external set data(dynamic value);
	
	/// Gets the openGL type
	external num get glType;
	external set glType(num value);
	
	/// Gets the openGL type size
	external num get glTypeSize;
	external set glTypeSize(num value);
	
	/// Gets the openGL format
	external num get glFormat;
	external set glFormat(num value);
	
	/// Gets the openGL internal format
	external num get glInternalFormat;
	external set glInternalFormat(num value);
	
	/// Gets the base internal format
	external num get glBaseInternalFormat;
	external set glBaseInternalFormat(num value);
	
	/// Gets image width in pixel
	external num get pixelWidth;
	external set pixelWidth(num value);
	
	/// Gets image height in pixel
	external num get pixelHeight;
	external set pixelHeight(num value);
	
	/// Gets image depth in pixels
	external num get pixelDepth;
	external set pixelDepth(num value);
	
	/// Gets the number of array elements
	external num get numberOfArrayElements;
	external set numberOfArrayElements(num value);
	
	/// Gets the number of faces
	external num get numberOfFaces;
	external set numberOfFaces(num value);
	
	/// Gets the number of mipmap levels
	external num get numberOfMipmapLevels;
	external set numberOfMipmapLevels(num value);
	
	/// Gets the bytes of key value data
	external num get bytesOfKeyValueData;
	external set bytesOfKeyValueData(num value);
	
	/// Gets the load type
	external num get loadType;
	external set loadType(num value);
	
	/// If the container has been made invalid (eg. constructor failed to correctly load array buffer)
	external bool get isInvalid;
	external set isInvalid(bool value);
	
	/// Uploads KTX content to a Babylon Texture.
	/// It is assumed that the texture has already been created & is currently bound
	/// @hidden
	external void uploadLevels(InternalTexture texture, bool loadMipmaps);
	
	/// Checks if the given data starts with a KTX file identifier.
	/// @param data the data to check
	/// @returns true if the data is a KTX file or false otherwise
	external static bool IsValid(dynamic data);
}

/// Helper class to push actions to a pool of workers.
@JS()
class WorkerPool implements IDisposable {
	
	/// Constructor
	/// @param workers Array of workers to use for actions
	external factory WorkerPool(List<HTML.Worker> workers);
	
	/// Terminates all workers and clears any pending actions.
	@override
	external void dispose();
	
	/// Pushes an action to the worker pool. If all the workers are active, the action will be
	/// pended until a worker has completed its action.
	/// @param action The action to perform. Call onComplete when the action is complete.
	external void push(void Function(HTML.Worker worker, void Function() onComplete) action);
}

/// Class for loading KTX2 files
@JS()
class KhronosTextureContainer2 {
	
	/// Constructor
	/// @param engine The engine to use
	/// @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
	external factory KhronosTextureContainer2(ThinEngine engine, [num? numWorkers]);
	
	/// URLs to use when loading the KTX2 decoder module as well as its dependencies
	/// If a url is null, the default url is used (pointing to https://preview.babylonjs.com)
	/// Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary
	/// Urls you can change:
	/// URLConfig.jsDecoderModule
	/// URLConfig.wasmUASTCToASTC
	/// URLConfig.wasmUASTCToBC7
	/// URLConfig.wasmUASTCToRGBA_UNORM
	/// URLConfig.wasmUASTCToRGBA_SRGB
	/// URLConfig.jsMSCTranscoder
	/// URLConfig.wasmMSCTranscoder
	/// You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#9
	external static KhronosTextureContainer2URLConfig get URLConfig;
	external static set URLConfig(KhronosTextureContainer2URLConfig value);
	
	/// Default number of workers used to handle data decoding
	external static num get DefaultNumWorkers;
	external static set DefaultNumWorkers(num value);
	
	/// @hidden
	external Promise<void> uploadAsync(dynamic data, InternalTexture internalTexture, [dynamic? options]);
	
	/// Stop all async operations and release resources.
	external void dispose();
	
	/// Checks if the given data starts with a KTX2 file identifier.
	/// @param data the data to check
	/// @returns true if the data is a KTX2 file or false otherwise
	external static bool IsValid(dynamic data);
}

/// Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
/// As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.
/// This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
/// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
@JS()
class VideoDome extends TextureDome<VideoTexture> {
	external factory VideoDome();
	
	/// Define the video source as a Monoscopic panoramic 360 video.
	@override
	external static num get MODE_MONOSCOPIC;
	
	/// Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.
	@override
	external static num get MODE_TOPBOTTOM;
	
	/// Define the video source as a Stereoscopic Side by Side panoramic 360 video.
	@override
	external static num get MODE_SIDEBYSIDE;
	
	/// Get the video texture associated with this video dome
	external VideoTexture get videoTexture;
	
	/// Get the video mode of this dome
	external num get videoMode;
	
	/// Set the video mode of this dome.
	/// @see textureMode
	external set videoMode(num value);
}

/// This class can be used to get instrumentation data from a Babylon engine
/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
@JS()
class EngineInstrumentation implements IDisposable {
	
	/// Instantiates a new engine instrumentation.
	/// This class can be used to get instrumentation data from a Babylon engine
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
	/// @param engine Defines the engine to instrument
	external factory EngineInstrumentation(Engine engine);
	
	/// Define the instrumented engine.
	external Engine get engine;
	external set engine(Engine value);
	
	/// Gets the perf counter used for GPU frame time
	external PerfCounter get gpuFrameTimeCounter;
	
	/// Gets the GPU frame time capture status
	external bool get captureGPUFrameTime;
	
	/// Enable or disable the GPU frame time capture
	external set captureGPUFrameTime(bool value);
	
	/// Gets the perf counter used for shader compilation time
	external PerfCounter get shaderCompilationTimeCounter;
	
	/// Gets the shader compilation time capture status
	external bool get captureShaderCompilationTime;
	
	/// Enable or disable the shader compilation time capture
	external set captureShaderCompilationTime(bool value);
	
	/// Dispose and release associated resources.
	@override
	external void dispose();
}

/// This class can be used to get instrumentation data from a Babylon engine
/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#sceneinstrumentation
@JS()
class SceneInstrumentation implements IDisposable {
	
	/// Instantiates a new scene instrumentation.
	/// This class can be used to get instrumentation data from a Babylon engine
	/// @see https://doc.babylonjs.com/how_to/optimizing_your_scene#sceneinstrumentation
	/// @param scene Defines the scene to instrument
	external factory SceneInstrumentation(Scene scene);
	
	/// Defines the scene to instrument
	external Scene get scene;
	external set scene(Scene value);
	
	/// Gets the perf counter used for active meshes evaluation time
	external PerfCounter get activeMeshesEvaluationTimeCounter;
	
	/// Gets the active meshes evaluation time capture status
	external bool get captureActiveMeshesEvaluationTime;
	
	/// Enable or disable the active meshes evaluation time capture
	external set captureActiveMeshesEvaluationTime(bool value);
	
	/// Gets the perf counter used for render targets render time
	external PerfCounter get renderTargetsRenderTimeCounter;
	
	/// Gets the render targets render time capture status
	external bool get captureRenderTargetsRenderTime;
	
	/// Enable or disable the render targets render time capture
	external set captureRenderTargetsRenderTime(bool value);
	
	/// Gets the perf counter used for particles render time
	external PerfCounter get particlesRenderTimeCounter;
	
	/// Gets the particles render time capture status
	external bool get captureParticlesRenderTime;
	
	/// Enable or disable the particles render time capture
	external set captureParticlesRenderTime(bool value);
	
	/// Gets the perf counter used for sprites render time
	external PerfCounter get spritesRenderTimeCounter;
	
	/// Gets the sprites render time capture status
	external bool get captureSpritesRenderTime;
	
	/// Enable or disable the sprites render time capture
	external set captureSpritesRenderTime(bool value);
	
	/// Gets the perf counter used for physics time
	external PerfCounter get physicsTimeCounter;
	
	/// Gets the physics time capture status
	external bool get capturePhysicsTime;
	
	/// Enable or disable the physics time capture
	external set capturePhysicsTime(bool value);
	
	/// Gets the perf counter used for animations time
	external PerfCounter get animationsTimeCounter;
	
	/// Gets the animations time capture status
	external bool get captureAnimationsTime;
	
	/// Enable or disable the animations time capture
	external set captureAnimationsTime(bool value);
	
	/// Gets the perf counter used for frame time capture
	external PerfCounter get frameTimeCounter;
	
	/// Gets the frame time capture status
	external bool get captureFrameTime;
	
	/// Enable or disable the frame time capture
	external set captureFrameTime(bool value);
	
	/// Gets the perf counter used for inter-frames time capture
	external PerfCounter get interFrameTimeCounter;
	
	/// Gets the inter-frames time capture status
	external bool get captureInterFrameTime;
	
	/// Enable or disable the inter-frames time capture
	external set captureInterFrameTime(bool value);
	
	/// Gets the perf counter used for render time capture
	external PerfCounter get renderTimeCounter;
	
	/// Gets the render time capture status
	external bool get captureRenderTime;
	
	/// Enable or disable the render time capture
	external set captureRenderTime(bool value);
	
	/// Gets the perf counter used for camera render time capture
	external PerfCounter get cameraRenderTimeCounter;
	
	/// Gets the camera render time capture status
	external bool get captureCameraRenderTime;
	
	/// Enable or disable the camera render time capture
	external set captureCameraRenderTime(bool value);
	
	/// Gets the perf counter used for draw calls
	external PerfCounter get drawCallsCounter;
	
	/// Dispose and release associated resources.
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get glowMapGenerationPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get glowMapGenerationVertexShader;

/// Effect layer options. This helps customizing the behaviour
/// of the effect layer.
@JS()
@anonymous
class IEffectLayerOptions {
	
	external factory IEffectLayerOptions({num mainTextureRatio, num mainTextureFixedSize, num alphaBlendingMode, Camera? camera, num renderingGroupId});
	
	/// Multiplication factor apply to the canvas size to compute the render target size
	/// used to generated the objects (the smaller the faster).
	external num get mainTextureRatio;
	external set mainTextureRatio( num value );
	
	/// Enforces a fixed size texture to ensure effect stability across devices.
	external num get mainTextureFixedSize;
	external set mainTextureFixedSize( num value );
	
	/// Alpha blending mode used to apply the blur. Default depends of the implementation.
	external num get alphaBlendingMode;
	external set alphaBlendingMode( num value );
	
	/// The camera attached to the layer.
	external Camera? get camera;
	external set camera( Camera? value );
	
	/// The rendering group to draw the layer in.
	external num get renderingGroupId;
	external set renderingGroupId( num value );
}

/// The effect layer Helps adding post process effect blended with the main pass.
/// 
/// This can be for instance use to generate glow or higlight effects on the scene.
/// 
/// The effect layer class can not be used directly and is intented to inherited from to be
/// customized per effects.
@JS()
abstract class EffectLayer {
	
	/// Instantiates a new effect Layer and references it in the scene.
	/// @param name The name of the layer
	/// @param scene The scene to use the layer in
	external factory EffectLayer(String name, Scene scene);
	
	/// The name of the layer
	external String get name;
	external set name(String value);
	
	/// The clear color of the texture used to generate the glow map.
	external Color4 get neutralColor;
	external set neutralColor(Color4 value);
	
	/// Specifies whether the highlight layer is enabled or not.
	external bool get isEnabled;
	external set isEnabled(bool value);
	
	/// Gets the camera attached to the layer.
	external Camera? get camera;
	
	/// Gets the rendering group id the layer should render in.
	external num get renderingGroupId;
	
	external set renderingGroupId(num value);
	
	/// Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer
	external bool get disableBoundingBoxesFromEffectLayer;
	external set disableBoundingBoxesFromEffectLayer(bool value);
	
	/// An event triggered when the effect layer has been disposed.
	external Observable<EffectLayer> get onDisposeObservable;
	external set onDisposeObservable(Observable<EffectLayer> value);
	
	/// An event triggered when the effect layer is about rendering the main texture with the glowy parts.
	external Observable<EffectLayer> get onBeforeRenderMainTextureObservable;
	external set onBeforeRenderMainTextureObservable(Observable<EffectLayer> value);
	
	/// An event triggered when the generated texture is being merged in the scene.
	external Observable<EffectLayer> get onBeforeComposeObservable;
	external set onBeforeComposeObservable(Observable<EffectLayer> value);
	
	/// An event triggered when the mesh is rendered into the effect render target.
	external Observable<AbstractMesh> get onBeforeRenderMeshToEffect;
	external set onBeforeRenderMeshToEffect(Observable<AbstractMesh> value);
	
	/// An event triggered after the mesh has been rendered into the effect render target.
	external Observable<AbstractMesh> get onAfterRenderMeshToEffect;
	external set onAfterRenderMeshToEffect(Observable<AbstractMesh> value);
	
	/// An event triggered when the generated texture has been merged in the scene.
	external Observable<EffectLayer> get onAfterComposeObservable;
	external set onAfterComposeObservable(Observable<EffectLayer> value);
	
	/// An event triggered when the efffect layer changes its size.
	external Observable<EffectLayer> get onSizeChangedObservable;
	external set onSizeChangedObservable(Observable<EffectLayer> value);
	
	/// Get the effect name of the layer.
	/// @return The effect name
	external String getEffectName();
	
	/// Checks for the readiness of the element composing the layer.
	/// @param subMesh the mesh to check for
	/// @param useInstances specify whether or not to use instances to render the mesh
	/// @return true if ready otherwise, false
	external bool isReady(SubMesh subMesh, bool useInstances);
	
	/// Returns whether or nood the layer needs stencil enabled during the mesh rendering.
	/// @returns true if the effect requires stencil during the main canvas render pass.
	external bool needStencil();
	
	/// Serializes this layer (Glow or Highlight for example)
	/// @returns a serialized layer object
	external dynamic serialize();
	
	/// Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
	external void render();
	
	/// Determine if a given mesh will be used in the current effect.
	/// @param mesh mesh to test
	/// @returns true if the mesh will be used
	external bool hasMesh(AbstractMesh mesh);
	
	/// Returns true if the layer contains information to display, otherwise false.
	/// @returns true if the glow layer should be rendered
	external bool shouldRender();
	
	/// Dispose the highlight layer and free resources.
	external void dispose();
	
	/// Gets the class name of the effect layer
	/// @returns the string with the class name of the effect layer
	external String getClassName();
	
	/// Creates an effect layer from parsed effect layer data
	/// @param parsedEffectLayer defines effect layer data
	/// @param scene defines the current scene
	/// @param rootUrl defines the root URL containing the effect layer information
	/// @returns a parsed effect Layer
	external static EffectLayer Parse(dynamic parsedEffectLayer, Scene scene, String rootUrl);
}

/// Defines the layer scene component responsible to manage any effect layers
/// in a given scene.
@JS()
class EffectLayerSceneComponent implements ISceneSerializableComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory EffectLayerSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Serializes the component data to the specified json object
	/// @param serializationObject The object to serialize to
	@override
	external void serialize(dynamic serializationObject);
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	@override
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	@override
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get glowMapMergePixelShader;

/* var */
/// @hidden
@JS()
external dynamic get glowMapMergeVertexShader;

/// Glow layer options. This helps customizing the behaviour
/// of the glow layer.
@JS()
@anonymous
class IGlowLayerOptions {
	
	external factory IGlowLayerOptions({num mainTextureRatio, num mainTextureFixedSize, num blurKernelSize, Camera? camera, num mainTextureSamples, num renderingGroupId});
	
	/// Multiplication factor apply to the canvas size to compute the render target size
	/// used to generated the glowing objects (the smaller the faster).
	external num get mainTextureRatio;
	external set mainTextureRatio( num value );
	
	/// Enforces a fixed size texture to ensure resize independant blur.
	external num get mainTextureFixedSize;
	external set mainTextureFixedSize( num value );
	
	/// How big is the kernel of the blur texture.
	external num get blurKernelSize;
	external set blurKernelSize( num value );
	
	/// The camera attached to the layer.
	external Camera? get camera;
	external set camera( Camera? value );
	
	/// Enable MSAA by chosing the number of samples.
	external num get mainTextureSamples;
	external set mainTextureSamples( num value );
	
	/// The rendering group to draw the layer in.
	external num get renderingGroupId;
	external set renderingGroupId( num value );
}

/// The glow layer Helps adding a glow effect around the emissive parts of a mesh.
/// 
/// Once instantiated in a scene, by default, all the emissive meshes will glow.
/// 
/// Documentation: https://doc.babylonjs.com/how_to/glow_layer
@JS()
class GlowLayer extends EffectLayer {
	
	/// Instantiates a new glow Layer and references it to the scene.
	/// @param name The name of the layer
	/// @param scene The scene to use the layer in
	/// @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)
	external factory GlowLayer(String name, Scene scene, [IGlowLayerOptions? options]);
	
	/// Effect Name of the layer.
	external static String get EffectName;
	
	/// The default blur kernel size used for the glow.
	external static num get DefaultBlurKernelSize;
	external static set DefaultBlurKernelSize(num value);
	
	/// The default texture size ratio used for the glow.
	external static num get DefaultTextureRatio;
	external static set DefaultTextureRatio(num value);
	
	/// Sets the kernel size of the blur.
	external set blurKernelSize(num value);
	
	/// Gets the kernel size of the blur.
	external num get blurKernelSize;
	
	/// Sets the glow intensity.
	external set intensity(num value);
	
	/// Gets the glow intensity.
	external num get intensity;
	
	/// Callback used to let the user override the color selection on a per mesh basis
	external void Function(Mesh mesh, SubMesh subMesh, Material material, Color4 result) get customEmissiveColorSelector;
	external set customEmissiveColorSelector(void Function(Mesh mesh, SubMesh subMesh, Material material, Color4 result) value);
	
	/// Callback used to let the user override the texture selection on a per mesh basis
	external Texture Function(Mesh mesh, SubMesh subMesh, Material material) get customEmissiveTextureSelector;
	external set customEmissiveTextureSelector(Texture Function(Mesh mesh, SubMesh subMesh, Material material) value);
	
	/// Get the effect name of the layer.
	/// @return The effect name
	@override
	external String getEffectName();
	
	/// Checks for the readiness of the element composing the layer.
	/// @param subMesh the mesh to check for
	/// @param useInstances specify wether or not to use instances to render the mesh
	/// @param emissiveTexture the associated emissive texture used to generate the glow
	/// @return true if ready otherwise, false
	@override
	external bool isReady(SubMesh subMesh, bool useInstances);
	
	/// Returns whether or nood the layer needs stencil enabled during the mesh rendering.
	@override
	external bool needStencil();
	
	/// Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
	/// @param mesh The mesh to exclude from the glow layer
	external void addExcludedMesh(Mesh mesh);
	
	/// Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
	/// @param mesh The mesh to remove
	external void removeExcludedMesh(Mesh mesh);
	
	/// Add a mesh in the inclusion list to impact or being impacted by the glow layer.
	/// @param mesh The mesh to include in the glow layer
	external void addIncludedOnlyMesh(Mesh mesh);
	
	/// Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
	/// @param mesh The mesh to remove
	external void removeIncludedOnlyMesh(Mesh mesh);
	
	/// Determine if a given mesh will be used in the glow layer
	/// @param mesh The mesh to test
	/// @returns true if the mesh will be highlighted by the current glow layer
	@override
	external bool hasMesh(AbstractMesh mesh);
	
	/// Add a mesh to be rendered through its own material and not with emissive only.
	/// @param mesh The mesh for which we need to use its material
	external void referenceMeshToUseItsOwnMaterial(AbstractMesh mesh);
	
	/// Remove a mesh from being rendered through its own material and not with emissive only.
	/// @param mesh The mesh for which we need to not use its material
	external void unReferenceMeshFromUsingItsOwnMaterial(AbstractMesh mesh);
	
	/// Gets the class name of the effect layer
	/// @returns the string with the class name of the effect layer
	@override
	external String getClassName();
	
	/// Serializes this glow layer
	/// @returns a serialized glow layer object
	@override
	external dynamic serialize();
	
	/// Creates a Glow Layer from parsed glow layer data
	/// @param parsedGlowLayer defines glow layer data
	/// @param scene defines the current scene
	/// @param rootUrl defines the root URL containing the glow layer information
	/// @returns a parsed Glow Layer
	@override
	external static GlowLayer Parse(dynamic parsedGlowLayer, Scene scene, String rootUrl);
}

/* var */
/// @hidden
@JS()
external dynamic get glowBlurPostProcessPixelShader;

/// Highlight layer options. This helps customizing the behaviour
/// of the highlight layer.
@JS()
@anonymous
class IHighlightLayerOptions {
	
	external factory IHighlightLayerOptions({num mainTextureRatio, num mainTextureFixedSize, num blurTextureSizeRatio, num blurVerticalSize, num blurHorizontalSize, num alphaBlendingMode, Camera? camera, bool isStroke, num renderingGroupId});
	
	/// Multiplication factor apply to the canvas size to compute the render target size
	/// used to generated the glowing objects (the smaller the faster).
	external num get mainTextureRatio;
	external set mainTextureRatio( num value );
	
	/// Enforces a fixed size texture to ensure resize independant blur.
	external num get mainTextureFixedSize;
	external set mainTextureFixedSize( num value );
	
	/// Multiplication factor apply to the main texture size in the first step of the blur to reduce the size
	/// of the picture to blur (the smaller the faster).
	external num get blurTextureSizeRatio;
	external set blurTextureSizeRatio( num value );
	
	/// How big in texel of the blur texture is the vertical blur.
	external num get blurVerticalSize;
	external set blurVerticalSize( num value );
	
	/// How big in texel of the blur texture is the horizontal blur.
	external num get blurHorizontalSize;
	external set blurHorizontalSize( num value );
	
	/// Alpha blending mode used to apply the blur. Default is combine.
	external num get alphaBlendingMode;
	external set alphaBlendingMode( num value );
	
	/// The camera attached to the layer.
	external Camera? get camera;
	external set camera( Camera? value );
	
	/// Should we display highlight as a solid stroke?
	external bool get isStroke;
	external set isStroke( bool value );
	
	/// The rendering group to draw the layer in.
	external num get renderingGroupId;
	external set renderingGroupId( num value );
}

/// The highlight layer Helps adding a glow effect around a mesh.
/// 
/// Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove
/// glowy meshes to your scene.
/// 
/// !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
@JS()
class HighlightLayer extends EffectLayer {
	
	/// Instantiates a new highlight Layer and references it to the scene..
	/// @param name The name of the layer
	/// @param scene The scene to use the layer in
	/// @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)
	external factory HighlightLayer(String name, Scene scene, [IHighlightLayerOptions? options]);
	
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Effect Name of the highlight layer.
	external static String get EffectName;
	
	/// The neutral color used during the preparation of the glow effect.
	/// This is black by default as the blend operation is a blend operation.
	external static Color4 get NeutralColor;
	external static set NeutralColor(Color4 value);
	
	/// Stencil value used for glowing meshes.
	external static num get GlowingMeshStencilReference;
	external static set GlowingMeshStencilReference(num value);
	
	/// Stencil value used for the other meshes in the scene.
	external static num get NormalMeshStencilReference;
	external static set NormalMeshStencilReference(num value);
	
	/// Specifies whether or not the inner glow is ACTIVE in the layer.
	external bool get innerGlow;
	external set innerGlow(bool value);
	
	/// Specifies whether or not the outer glow is ACTIVE in the layer.
	external bool get outerGlow;
	external set outerGlow(bool value);
	
	/// Specifies the horizontal size of the blur.
	external set blurHorizontalSize(num value);
	
	/// Specifies the vertical size of the blur.
	external set blurVerticalSize(num value);
	
	/// Gets the horizontal size of the blur.
	external num get blurHorizontalSize;
	
	/// Gets the vertical size of the blur.
	external num get blurVerticalSize;
	
	/// An event triggered when the highlight layer is being blurred.
	external Observable<HighlightLayer> get onBeforeBlurObservable;
	external set onBeforeBlurObservable(Observable<HighlightLayer> value);
	
	/// An event triggered when the highlight layer has been blurred.
	external Observable<HighlightLayer> get onAfterBlurObservable;
	external set onAfterBlurObservable(Observable<HighlightLayer> value);
	
	/// Get the effect name of the layer.
	/// @return The effect name
	@override
	external String getEffectName();
	
	/// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
	@override
	external bool needStencil();
	
	/// Checks for the readiness of the element composing the layer.
	/// @param subMesh the mesh to check for
	/// @param useInstances specify wether or not to use instances to render the mesh
	/// @param emissiveTexture the associated emissive texture used to generate the glow
	/// @return true if ready otherwise, false
	@override
	external bool isReady(SubMesh subMesh, bool useInstances);
	
	/// Returns true if the layer contains information to display, otherwise false.
	@override
	external bool shouldRender();
	
	/// Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.
	/// @param mesh The mesh to exclude from the highlight layer
	external void addExcludedMesh(Mesh mesh);
	
	/// Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.
	/// @param mesh The mesh to highlight
	external void removeExcludedMesh(Mesh mesh);
	
	/// Determine if a given mesh will be highlighted by the current HighlightLayer
	/// @param mesh mesh to test
	/// @returns true if the mesh will be highlighted by the current HighlightLayer
	@override
	external bool hasMesh(AbstractMesh mesh);
	
	/// Add a mesh in the highlight layer in order to make it glow with the chosen color.
	/// @param mesh The mesh to highlight
	/// @param color The color of the highlight
	/// @param glowEmissiveOnly Extract the glow from the emissive texture
	external void addMesh(Mesh mesh, Color3 color, [bool? glowEmissiveOnly]);
	
	/// Remove a mesh from the highlight layer in order to make it stop glowing.
	/// @param mesh The mesh to highlight
	external void removeMesh(Mesh mesh);
	
	/// Remove all the meshes currently referenced in the highlight layer
	external void removeAllMeshes();
	
	/// Dispose the highlight layer and free resources.
	@override
	external void dispose();
	
	/// Gets the class name of the effect layer
	/// @returns the string with the class name of the effect layer
	@override
	external String getClassName();
	
	/// Serializes this Highlight layer
	/// @returns a serialized Highlight layer object
	@override
	external dynamic serialize();
	
	/// Creates a Highlight layer from parsed Highlight layer data
	/// @param parsedHightlightLayer defines the Highlight layer data
	/// @param scene defines the current scene
	/// @param rootUrl defines the root URL containing the Highlight layer information
	/// @returns a parsed Highlight layer
	@override
	external static HighlightLayer Parse(dynamic parsedHightlightLayer, Scene scene, String rootUrl);
}

/// Defines the layer scene component responsible to manage any layers
/// in a given scene.
@JS()
class LayerSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory LayerSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
}

/* var */
/// @hidden
@JS()
external dynamic get layerPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get layerVertexShader;

/// This represents a full screen 2d layer.
/// This can be useful to display a picture in the  background of your scene for instance.
/// @see https://www.babylonjs-playground.com/#08A2BS#1
@JS()
class Layer {
	
	/// Instantiates a new layer.
	/// This represents a full screen 2d layer.
	/// This can be useful to display a picture in the  background of your scene for instance.
	/// @see https://www.babylonjs-playground.com/#08A2BS#1
	/// @param name Define the name of the layer in the scene
	/// @param imgUrl Define the url of the texture to display in the layer
	/// @param scene Define the scene the layer belongs to
	/// @param isBackground Defines whether the layer is displayed in front or behind the scene
	/// @param color Defines a color for the layer
	external factory Layer(String name, String? imgUrl, Scene? scene, [bool? isBackground, Color4? color]);
	
	/// Define the name of the layer.
	external String get name;
	external set name(String value);
	
	/// Define the texture the layer should display.
	external Texture? get texture;
	external set texture(Texture? value);
	
	/// Is the layer in background or foreground.
	external bool get isBackground;
	external set isBackground(bool value);
	
	/// Define the color of the layer (instead of texture).
	external Color4 get color;
	external set color(Color4 value);
	
	/// Define the scale of the layer in order to zoom in out of the texture.
	external Vector2 get scale;
	external set scale(Vector2 value);
	
	/// Define an offset for the layer in order to shift the texture.
	external Vector2 get offset;
	external set offset(Vector2 value);
	
	/// Define the alpha blending mode used in the layer in case the texture or color has an alpha.
	external num get alphaBlendingMode;
	external set alphaBlendingMode(num value);
	
	/// Define if the layer should alpha test or alpha blend with the rest of the scene.
	/// Alpha test will not mix with the background color in case of transparency.
	/// It will either use the texture color or the background depending on the alpha value of the current pixel.
	external bool get alphaTest;
	external set alphaTest(bool value);
	
	/// Define a mask to restrict the layer to only some of the scene cameras.
	external num get layerMask;
	external set layerMask(num value);
	
	/// Define the list of render target the layer is visible into.
	external List<RenderTargetTexture> get renderTargetTextures;
	external set renderTargetTextures(List<RenderTargetTexture> value);
	
	/// Define if the layer is only used in renderTarget or if it also
	/// renders in the main frame buffer of the canvas.
	external bool get renderOnlyInRenderTargetTextures;
	external set renderOnlyInRenderTargetTextures(bool value);
	
	/// An event triggered when the layer is disposed.
	external Observable<Layer> get onDisposeObservable;
	external set onDisposeObservable(Observable<Layer> value);
	
	/// Back compatibility with callback before the onDisposeObservable existed.
	/// The set callback will be triggered when the layer has been disposed.
	external set onDispose(void Function() value);
	
	/// An event triggered before rendering the scene
	external Observable<Layer> get onBeforeRenderObservable;
	external set onBeforeRenderObservable(Observable<Layer> value);
	
	/// Back compatibility with callback before the onBeforeRenderObservable existed.
	/// The set callback will be triggered just before rendering the layer.
	external set onBeforeRender(void Function() value);
	
	/// An event triggered after rendering the scene
	external Observable<Layer> get onAfterRenderObservable;
	external set onAfterRenderObservable(Observable<Layer> value);
	
	/// Back compatibility with callback before the onAfterRenderObservable existed.
	/// The set callback will be triggered just after rendering the layer.
	external set onAfterRender(void Function() value);
	
	/// Renders the layer in the scene.
	external void render();
	
	/// Disposes and releases the associated ressources.
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get lensFlarePixelShader;

/* var */
/// @hidden
@JS()
external dynamic get lensFlareVertexShader;

/// This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
/// It is usually composed of several `lensFlare`.
/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
@JS()
class LensFlareSystem {
	
	/// Instantiates a lens flare system.
	/// This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
	/// It is usually composed of several `lensFlare`.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
	/// @param name Define the name of the lens flare system in the scene
	/// @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).
	/// @param scene Define the scene the lens flare system belongs to
	external factory LensFlareSystem(String name, dynamic emitter, Scene scene);
	
	/// Define the name of the lens flare system
	external String get name;
	external set name(String value);
	
	/// List of lens flares used in this system.
	external List<LensFlare> get lensFlares;
	external set lensFlares(List<LensFlare> value);
	
	/// Define a limit from the border the lens flare can be visible.
	external num get borderLimit;
	external set borderLimit(num value);
	
	/// Define a viewport border we do not want to see the lens flare in.
	external num get viewportBorder;
	external set viewportBorder(num value);
	
	/// Define a predicate which could limit the list of meshes able to occlude the effect.
	external bool Function(AbstractMesh mesh) get meshesSelectionPredicate;
	external set meshesSelectionPredicate(bool Function(AbstractMesh mesh) value);
	
	/// Restricts the rendering of the effect to only the camera rendering this layer mask.
	external num get layerMask;
	external set layerMask(num value);
	
	/// Define the id of the lens flare system in the scene.
	/// (equal to name by default)
	external String get id;
	external set id(String value);
	
	/// Define if the lens flare system is enabled.
	external bool get isEnabled;
	
	external set isEnabled(bool value);
	
	/// Get the scene the effects belongs to.
	/// @returns the scene holding the lens flare system
	external Scene getScene();
	
	/// Get the emitter of the lens flare system.
	/// It defines the source of the lens flares (it can be a camera, a light or a mesh).
	/// @returns the emitter of the lens flare system
	external dynamic getEmitter();
	
	/// Set the emitter of the lens flare system.
	/// It defines the source of the lens flares (it can be a camera, a light or a mesh).
	/// @param newEmitter Define the new emitter of the system
	external void setEmitter(dynamic newEmitter);
	
	/// Get the lens flare system emitter position.
	/// The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).
	/// @returns the position
	external Vector3 getEmitterPosition();
	
	/// @hidden
	external bool computeEffectivePosition(Viewport globalViewport);
	
	/// @hidden
	external bool render();
	
	/// Dispose and release the lens flare with its associated resources.
	external void dispose();
	
	/// Parse a lens flare system from a JSON repressentation
	/// @param parsedLensFlareSystem Define the JSON to parse
	/// @param scene Define the scene the parsed system should be instantiated in
	/// @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures
	/// @returns the parsed system
	external static LensFlareSystem Parse(dynamic parsedLensFlareSystem, Scene scene, String rootUrl);
	
	/// Serialize the current Lens Flare System into a JSON representation.
	/// @returns the serialized JSON
	external dynamic serialize();
}

/// This represents one of the lens effect in a `lensFlareSystem`.
/// It controls one of the indiviual texture used in the effect.
/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
@JS()
class LensFlare {
	
	/// Instantiates a new Lens Flare.
	/// This represents one of the lens effect in a `lensFlareSystem`.
	/// It controls one of the indiviual texture used in the effect.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
	/// @param size Define the size of the lens flare in the system (a floating value between 0 and 1)
	/// @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
	/// @param color Define the lens color
	/// @param imgUrl Define the lens texture url
	/// @param system Define the `lensFlareSystem` this flare is part of
	external factory LensFlare(num size, num position, Color3 color, String imgUrl, LensFlareSystem system);
	
	/// Define the size of the lens flare in the system (a floating value between 0 and 1)
	external num get size;
	external set size(num value);
	
	/// Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
	external num get position;
	external set position(num value);
	
	/// Define the lens color.
	external Color3 get color;
	external set color(Color3 value);
	
	/// Define the lens texture.
	external Texture? get texture;
	external set texture(Texture? value);
	
	/// Define the alpha mode to render this particular lens.
	external num get alphaMode;
	external set alphaMode(num value);
	
	/// Creates a new Lens Flare.
	/// This represents one of the lens effect in a `lensFlareSystem`.
	/// It controls one of the indiviual texture used in the effect.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
	/// @param size Define the size of the lens flare (a floating value between 0 and 1)
	/// @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
	/// @param color Define the lens color
	/// @param imgUrl Define the lens texture url
	/// @param system Define the `lensFlareSystem` this flare is part of
	/// @returns The newly created Lens Flare
	external static LensFlare AddFlare(num size, num position, Color3 color, String imgUrl, LensFlareSystem system);
	
	/// Dispose and release the lens flare with its associated resources.
	external void dispose();
}

/// Defines the lens flare scene component responsible to manage any lens flares
/// in a given scene.
@JS()
class LensFlareSystemSceneComponent implements ISceneSerializableComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory LensFlareSystemSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	@override
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	@override
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
	
	/// Serializes the component data to the specified json object
	/// @param serializationObject The object to serialize to
	@override
	external void serialize(dynamic serializationObject);
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get depthPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get depthVertexShader;

/// This represents a depth renderer in Babylon.
/// A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
@JS()
class DepthRenderer {
	
	/// Instantiates a depth renderer
	/// @param scene The scene the renderer belongs to
	/// @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
	/// @param camera The camera to be used to render the depth map (default: scene's active camera)
	/// @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
	external factory DepthRenderer(Scene scene, [num? type, Camera? camera, bool? storeNonLinearDepth]);
	
	/// Get if the depth renderer is using packed depth or not
	external bool get isPacked;
	
	/// Enable or disable the depth renderer. When disabled, the depth texture is not updated
	external bool get enabled;
	external set enabled(bool value);
	
	/// Specifiess that the depth renderer will only be used within
	/// the camera it is created for.
	/// This can help forcing its rendering during the camera processing.
	external bool get useOnlyInActiveCamera;
	external set useOnlyInActiveCamera(bool value);
	
	/// Creates the depth rendering effect and checks if the effect is ready.
	/// @param subMesh The submesh to be used to render the depth map of
	/// @param useInstances If multiple world instances should be used
	/// @returns if the depth renderer is ready to render the depth map
	external bool isReady(SubMesh subMesh, bool useInstances);
	
	/// Gets the texture which the depth map will be written to.
	/// @returns The depth map texture
	external RenderTargetTexture getDepthMap();
	
	/// Disposes of the depth renderer.
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get minmaxReduxPixelShader;

/// This class computes a min/max reduction from a texture: it means it computes the minimum
/// and maximum values from all values of the texture.
/// It is performed on the GPU for better performances, thanks to a succession of post processes.
/// The source values are read from the red channel of the texture.
@JS()
class MinMaxReducer {
	
	/// Creates a min/max reducer
	/// @param camera The camera to use for the post processes
	external factory MinMaxReducer(Camera camera);
	
	/// Observable triggered when the computation has been performed
	external Observable<MinMaxReducerOnAfterReductionPerformed> get onAfterReductionPerformed;
	external set onAfterReductionPerformed(Observable<MinMaxReducerOnAfterReductionPerformed> value);
	
	/// Gets the texture used to read the values from.
	external RenderTargetTexture? get sourceTexture;
	
	/// Sets the source texture to read the values from.
	/// One must indicate if the texture is a depth texture or not through the depthRedux parameter
	/// because in such textures '1' value must not be taken into account to compute the maximum
	/// as this value is used to clear the texture.
	/// Note that the computation is not activated by calling this function, you must call activate() for that!
	/// @param sourceTexture The texture to read the values from. The values should be in the red channel.
	/// @param depthRedux Indicates if the texture is a depth texture or not
	/// @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
	/// @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
	external void setSourceTexture(RenderTargetTexture sourceTexture, bool depthRedux, [num? type, bool? forceFullscreenViewport]);
	
	/// Defines the refresh rate of the computation.
	/// Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
	external num get refreshRate;
	
	external set refreshRate(num value);
	
	/// Gets the activation status of the reducer
	external bool get activated;
	
	/// Activates the reduction computation.
	/// When activated, the observers registered in onAfterReductionPerformed are
	/// called after the compuation is performed
	external void activate();
	
	/// Deactivates the reduction computation.
	external void deactivate();
	
	/// Disposes the min/max reducer
	/// @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
	external void dispose([bool? disposeAll]);
}

/// This class is a small wrapper around the MinMaxReducer class to compute the min/max values of a depth texture
@JS()
class DepthReducer extends MinMaxReducer {
	
	/// Creates a depth reducer
	/// @param camera The camera used to render the depth texture
	external factory DepthReducer(Camera camera);
	
	/// Gets the depth renderer used for the computation.
	/// Note that the result is null if you provide your own renderer when calling setDepthRenderer.
	external DepthRenderer? get depthRenderer;
	
	/// Sets the depth renderer to use to generate the depth map
	/// @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
	/// @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
	/// @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
	external void setDepthRenderer([DepthRenderer? depthRenderer, num? type, bool? forceFullscreenViewport]);
	
	/// @hidden
	@override
	external void setSourceTexture(RenderTargetTexture sourceTexture, bool depthRedux, [num? type, bool? forceFullscreenViewport]);
	
	/// Activates the reduction computation.
	/// When activated, the observers registered in onAfterReductionPerformed are
	/// called after the compuation is performed
	@override
	external void activate();
	
	/// Deactivates the reduction computation.
	@override
	external void deactivate();
	
	/// Disposes the depth reducer
	/// @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
	@override
	external void dispose([bool? disposeAll]);
}

/// A CSM implementation allowing casting shadows on large scenes.
/// Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
/// Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/
@JS()
class CascadedShadowGenerator extends ShadowGenerator {
	
	/// Creates a Cascaded Shadow Generator object.
	/// A ShadowGenerator is the required tool to use the shadows.
	/// Each directional light casting shadows needs to use its own ShadowGenerator.
	/// Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
	/// @param mapSize The size of the texture what stores the shadows. Example : 1024.
	/// @param light The directional light object generating the shadows.
	/// @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
	external factory CascadedShadowGenerator(num mapSize, DirectionalLight light, [bool? usefulFloatFirst]);
	
	/// Name of the CSM class
	@override
	external static String get CLASSNAME;
	@override
	external static set CLASSNAME(String value);
	
	/// Defines the default number of cascades used by the CSM.
	external static num get DEFAULT_CASCADES_COUNT;
	
	/// Defines the minimum number of cascades used by the CSM.
	external static num get MIN_CASCADES_COUNT;
	
	/// Defines the maximum number of cascades used by the CSM.
	external static num get MAX_CASCADES_COUNT;
	
	/// Gets or sets the actual darkness of the soft shadows while using PCSS filtering (value between 0. and 1.)
	external num get penumbraDarkness;
	external set penumbraDarkness(num value);
	
	/// Gets or set the number of cascades used by the CSM.
	external num get numCascades;
	
	external set numCascades(num value);
	
	/// Sets this to true if you want that the edges of the shadows don't "swimm" / "shimmer" when rotating the camera.
	/// The trade off is that you lose some precision in the shadow rendering when enabling this setting.
	external bool get stabilizeCascades;
	external set stabilizeCascades(bool value);
	
	/// Enables or disables the shadow casters bounding info computation.
	/// If your shadow casters don't move, you can disable this feature.
	/// If it is enabled, the bounding box computation is done every frame.
	external bool get freezeShadowCastersBoundingInfo;
	
	external set freezeShadowCastersBoundingInfo(bool value);
	
	/// Gets or sets the shadow casters bounding info.
	/// If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo
	/// so that the system won't overwrite the bounds you provide
	external BoundingInfo get shadowCastersBoundingInfo;
	
	external set shadowCastersBoundingInfo(BoundingInfo value);
	
	/// Sets the minimal and maximal distances to use when computing the cascade breaks.
	/// 
	/// The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.
	/// If you don't know these values, simply leave them to their defaults and don't call this function.
	/// @param min minimal distance for the breaks (default to 0.)
	/// @param max maximal distance for the breaks (default to 1.)
	external void setMinMaxDistance(num min, num max);
	
	/// Gets the minimal distance used in the cascade break computation
	external num get minDistance;
	
	/// Gets the maximal distance used in the cascade break computation
	external num get maxDistance;
	
	/// Gets the class name of that object
	/// @returns "CascadedShadowGenerator"
	@override
	external String getClassName();
	
	/// Gets a cascade minimum extents
	/// @param cascadeIndex index of the cascade
	/// @returns the minimum cascade extents
	external Vector3? getCascadeMinExtents(num cascadeIndex);
	
	/// Gets a cascade maximum extents
	/// @param cascadeIndex index of the cascade
	/// @returns the maximum cascade extents
	external Vector3? getCascadeMaxExtents(num cascadeIndex);
	
	/// Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.
	/// It defaults to camera.maxZ
	external num get shadowMaxZ;
	
	/// Sets the shadow max z distance.
	external set shadowMaxZ(num value);
	
	/// Gets or sets the debug flag.
	/// When enabled, the cascades are materialized by different colors on the screen.
	external bool get debug;
	
	external set debug(bool value);
	
	/// Gets or sets the depth clamping value.
	/// 
	/// When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted
	/// to account for the shadow casters far away.
	/// 
	/// Note that this property is incompatible with PCSS filtering, so it won't be used in that case.
	external bool get depthClamp;
	
	external set depthClamp(bool value);
	
	/// Gets or sets the percentage of blending between two cascades (value between 0. and 1.).
	/// It defaults to 0.1 (10% blending).
	external num get cascadeBlendPercentage;
	
	external set cascadeBlendPercentage(num value);
	
	/// Gets or set the lambda parameter.
	/// This parameter is used to split the camera frustum and create the cascades.
	/// It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.
	/// For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.
	external num get lambda;
	
	external set lambda(num value);
	
	/// Gets the view matrix corresponding to a given cascade
	/// @param cascadeNum cascade to retrieve the view matrix from
	/// @returns the cascade view matrix
	external Matrix? getCascadeViewMatrix(num cascadeNum);
	
	/// Gets the projection matrix corresponding to a given cascade
	/// @param cascadeNum cascade to retrieve the projection matrix from
	/// @returns the cascade projection matrix
	external Matrix? getCascadeProjectionMatrix(num cascadeNum);
	
	/// Gets the transformation matrix corresponding to a given cascade
	/// @param cascadeNum cascade to retrieve the transformation matrix from
	/// @returns the cascade transformation matrix
	external Matrix? getCascadeTransformMatrix(num cascadeNum);
	
	/// Sets the depth renderer to use when autoCalcDepthBounds is enabled.
	/// 
	/// Note that if no depth renderer is set, a new one will be automatically created internally when necessary.
	/// 
	/// You should call this function if you already have a depth renderer enabled in your scene, to avoid
	/// doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!
	/// @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created
	external void setDepthRenderer(DepthRenderer? depthRenderer);
	
	/// Gets or sets the autoCalcDepthBounds property.
	/// 
	/// When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one
	/// you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the
	/// minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.
	/// It can greatly enhance the shadow quality, at the expense of more GPU works.
	/// When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.
	external bool get autoCalcDepthBounds;
	
	external set autoCalcDepthBounds(bool value);
	
	/// Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
	/// Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
	/// Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible
	/// for setting the refresh rate on the renderer yourself!
	external num get autoCalcDepthBoundsRefreshRate;
	
	external set autoCalcDepthBoundsRefreshRate(num value);
	
	/// Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.
	/// This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if
	/// you change the camera near/far planes!
	external void splitFrustum();
	
	/// Support test.
	external static bool get IsSupported;
	
	/// Prepare all the defines in a material relying on a shadow map at the specified light index.
	/// @param defines Defines of the material we want to update
	/// @param lightIndex Index of the light in the enabled light list of the material
	@override
	external void prepareDefines(dynamic defines, num lightIndex);
	
	/// Binds the shadow related information inside of an effect (information like near, far, darkness...
	/// defined in the generator but impacting the effect).
	/// @param lightIndex Index of the light in the enabled light list of the material owning the effect
	/// @param effect The effect we are binfing the information for
	@override
	external void bindShadowLight(String lightIndex, Effect effect);
	
	/// Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.
	/// (eq to view projection * shadow projection matrices)
	/// @returns The transform matrix used to create the shadow map
	@override
	external Matrix getTransformMatrix();
	
	/// Disposes the ShadowGenerator.
	/// Returns nothing.
	@override
	external void dispose();
	
	/// Serializes the shadow generator setup to a json object.
	/// @returns The serialized JSON object
	@override
	external dynamic serialize();
	
	/// Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
	/// @param parsedShadowGenerator The JSON object to parse
	/// @param scene The scene to create the shadow map for
	/// @returns The parsed shadow generator
	@override
	external static ShadowGenerator Parse(dynamic parsedShadowGenerator, Scene scene, [ShadowGenerator Function(num mapSize, IShadowLight light)? constr]);
}

/// Defines the shadow generator component responsible to manage any shadow generators
/// in a given scene.
@JS()
class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory ShadowGeneratorSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Serializes the component data to the specified json object
	/// @param serializationObject The object to serialize to
	@override
	external void serialize(dynamic serializationObject);
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	@override
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	@override
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void dispose();
}

/// A point light is a light defined by an unique point in world space.
/// The light is emitted in every direction from this point.
/// A good example of a point light is a standard light bulb.
/// Documentation: https://doc.babylonjs.com/babylon101/lights
@JS()
class PointLight extends ShadowLight {
	
	/// Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
	/// A PointLight emits the light in every direction.
	/// It can cast shadows.
	/// If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
	/// ```javascript
	/// var pointLight = new PointLight("pl", camera.position, scene);
	/// ```
	/// Documentation : https://doc.babylonjs.com/babylon101/lights
	/// @param name The light friendly name
	/// @param position The position of the point light in the scene
	/// @param scene The scene the lights belongs to
	external factory PointLight(String name, Vector3 position, Scene scene);
	
	/// Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
	/// This specifies what angle the shadow will use to be created.
	/// 
	/// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
	external num get shadowAngle;
	
	/// Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
	/// This specifies what angle the shadow will use to be created.
	/// 
	/// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
	external set shadowAngle(num value);
	
	/// Returns the string "PointLight"
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Returns the integer 0.
	/// @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
	@override
	external num getTypeID();
	
	/// Specifies wether or not the shadowmap should be a cube texture.
	/// @returns true if the shadowmap needs to be a cube texture.
	@override
	external bool needCube();
	
	/// Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
	/// @param faceIndex The index of the face we are computed the direction to generate shadow
	/// @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
	@override
	external Vector3 getShadowDirection([num? faceIndex]);
	
	/// Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
	/// @param effect The effect to update
	/// @param lightIndex The index of the light in the effect to update
	/// @returns The point light
	@override
	external PointLight transferToEffect(Effect effect, String lightIndex);
	
	/* Manual Fix 10 */
	
	@override
	external Light transferToNodeMaterialEffect(Effect effect, String lightDataUniformName);
	
	/// Prepares the list of defines specific to the light type.
	/// @param defines the list of defines
	/// @param lightIndex defines the index of the light for the effect
	@override
	external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
	
	/// The light id in the scene (used in scene.findLighById for instance)
	@override
	external String get id;
	@override
	external set id(String value);
	
	/// The position the shdow will be casted from.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// In 2d mode (needCube being false), the direction used to cast the shadow.
	external Vector3 get direction;
	external set direction(Vector3 value);
	
	/// The friendly name of the light in the scene.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the shadow projection clipping minimum z value.
	external num get shadowMinZ;
	external set shadowMinZ(num value);
	
	/// Defines the shadow projection clipping maximum z value.
	external num get shadowMaxZ;
	external set shadowMaxZ(num value);
	
	/// Gets the scene the light belongs to.
	/// @returns The scene
	@override
	external Scene getScene();
}

/// Header information of HDR texture files.
@JS()
@anonymous
class HDRInfo {
	
	external factory HDRInfo({num height, num width, num dataPosition});
	
	/// The height of the texture in pixels.
	external num get height;
	external set height( num value );
	
	/// The width of the texture in pixels.
	external num get width;
	external set width( num value );
	
	/// The index of the beginning of the data in the binary file.
	external num get dataPosition;
	external set dataPosition( num value );
}

/// This groups tools to convert HDR texture to native colors array.
@JS()
class HDRTools {
	external factory HDRTools();
	
	/// Reads header information from an RGBE texture stored in a native array.
	/// More information on this format are available here:
	/// https://en.wikipedia.org/wiki/RGBE_image_format
	/// 
	/// @param uint8array The binary file stored in  native array.
	/// @return The header information.
	external static HDRInfo RGBE_ReadHeader(Uint8List uint8array);
	
	/// Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
	/// This RGBE texture needs to store the information as a panorama.
	/// 
	/// More information on this format are available here:
	/// https://en.wikipedia.org/wiki/RGBE_image_format
	/// 
	/// @param buffer The binary file stored in an array buffer.
	/// @param size The expected size of the extracted cubemap.
	/// @return The Cube Map information.
	external static CubeMapInfo GetCubeMapTextureData(ByteBuffer buffer, num size);
	
	/// Returns the pixels data extracted from an RGBE texture.
	/// This pixels will be stored left to right up to down in the R G B order in one array.
	/// 
	/// More information on this format are available here:
	/// https://en.wikipedia.org/wiki/RGBE_image_format
	/// 
	/// @param uint8array The binary file stored in an array buffer.
	/// @param hdrInfo The header information of the file.
	/// @return The pixels data in RGB right to left up to down order.
	external static Float32List RGBE_ReadPixels(Uint8List uint8array, HDRInfo hdrInfo);
}

/// Effect Render Options
@JS()
@anonymous
class IEffectRendererOptions {
	
	external factory IEffectRendererOptions({List<num> positions, List<num> indices});
	
	/// Defines the vertices positions.
	external List<num> get positions;
	external set positions( List<num> value );
	
	/// Defines the indices.
	external List<num> get indices;
	external set indices( List<num> value );
}

/// Helper class to render one or more effects.
/// You can access the previous rendering in your shader by declaring a sampler named textureSampler
@JS()
class EffectRenderer {
	
	/// Creates an effect renderer
	/// @param engine the engine to use for rendering
	/// @param options defines the options of the effect renderer
	external factory EffectRenderer(ThinEngine engine, [IEffectRendererOptions? options]);
	
	/// Sets the current viewport in normalized coordinates 0-1
	/// @param viewport Defines the viewport to set (defaults to 0 0 1 1)
	external void setViewport([Viewport? viewport]);
	
	/// Binds the embedded attributes buffer to the effect.
	/// @param effect Defines the effect to bind the attributes for
	external void bindBuffers(Effect effect);
	
	/// Sets the current effect wrapper to use during draw.
	/// The effect needs to be ready before calling this api.
	/// This also sets the default full screen position attribute.
	/// @param effectWrapper Defines the effect to draw with
	external void applyEffectWrapper(EffectWrapper effectWrapper);
	
	/// Restores engine states
	external void restoreStates();
	
	/// Draws a full screen quad.
	external void draw();
	
	/// renders one or more effects to a specified texture
	/// @param effectWrapper the effect to renderer
	/// @param outputTexture texture to draw to, if null it will render to the screen.
	external void render(EffectWrapper effectWrapper, [dynamic? outputTexture]);
	
	/// Disposes of the effect renderer
	external void dispose();
}

/// Options to create an EffectWrapper
@JS()
@anonymous
class EffectWrapperCreationOptions {
	
	external factory EffectWrapperCreationOptions({ThinEngine engine, String fragmentShader, bool useShaderStore, String vertexShader, List<String> attributeNames, List<String> uniformNames, List<String> samplerNames, List<String> defines, void Function(Effect effect)? onCompiled, String name});
	
	/// Engine to use to create the effect
	external ThinEngine get engine;
	external set engine( ThinEngine value );
	
	/// Fragment shader for the effect
	external String get fragmentShader;
	external set fragmentShader( String value );
	
	/// Use the shader store instead of direct source code
	external bool get useShaderStore;
	external set useShaderStore( bool value );
	
	/// Vertex shader for the effect
	external String get vertexShader;
	external set vertexShader( String value );
	
	/// Attributes to use in the shader
	external List<String> get attributeNames;
	external set attributeNames( List<String> value );
	
	/// Uniforms to use in the shader
	external List<String> get uniformNames;
	external set uniformNames( List<String> value );
	
	/// Texture sampler names to use in the shader
	external List<String> get samplerNames;
	external set samplerNames( List<String> value );
	
	/// Defines to use in the shader
	external List<String> get defines;
	external set defines( List<String> value );
	
	/// Callback when effect is compiled
	external void Function(Effect effect)? get onCompiled;
	external set onCompiled( void Function(Effect effect)? value );
	
	/// The friendly name of the effect displayed in Spector.
	external String get name;
	external set name( String value );
}

/// Wraps an effect to be used for rendering
@JS()
class EffectWrapper {
	
	/// Creates an effect to be renderer
	/// @param creationOptions options to create the effect
	external factory EffectWrapper(EffectWrapperCreationOptions creationOptions);
	
	/// Event that is fired right before the effect is drawn (should be used to update uniforms)
	external Observable<dynamic /* object */> get onApplyObservable;
	external set onApplyObservable(Observable<dynamic /* object */> value);
	
	/// The underlying effect
	external Effect get effect;
	external set effect(Effect value);
	
	/// Disposes of the effect wrapper
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get hdrFilteringVertexShader;

/* var */
/// @hidden
@JS()
external dynamic get hdrFilteringPixelShader;

/// Options for texture filtering
@JS()
@anonymous
class IHDRFilteringOptions {
	
	external factory IHDRFilteringOptions({num hdrScale, num quality});
	
	/// Scales pixel intensity for the input HDR map.
	external num get hdrScale;
	external set hdrScale( num value );
	
	/// Quality of the filter. Should be `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` for prefiltering
	external num get quality;
	external set quality( num value );
}

/// Filters HDR maps to get correct renderings of PBR reflections
@JS()
class HDRFiltering {
	
	/// Instantiates HDR filter for reflection maps
	/// 
	/// @param engine Thin engine
	/// @param options Options
	external factory HDRFiltering(ThinEngine engine, [IHDRFilteringOptions? options]);
	
	/// Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless
	/// you care about baking speed.
	external num get quality;
	external set quality(num value);
	
	/// Scales pixel intensity for the input HDR map.
	external num get hdrScale;
	external set hdrScale(num value);
	
	/// Get a value indicating if the filter is ready to be used
	/// @param texture Texture to filter
	/// @returns true if the filter is ready
	external bool isReady(BaseTexture texture);
	
	/// Prefilters a cube texture to have mipmap levels representing roughness values.
	/// Prefiltering will be invoked at the end of next rendering pass.
	/// This has to be done once the map is loaded, and has not been prefiltered by a third party software.
	/// See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information
	/// @param texture Texture to filter
	/// @param onFinished Callback when filtering is done
	/// @return Promise called when prefiltering is done
	external Promise<dynamic>? prefilter(BaseTexture texture, [void Function()? onFinished]);
}

/// This represents a texture coming from an HDR input.
/// 
/// The only supported format is currently panorama picture stored in RGBE format.
/// Example of such files can be found on HDRLib: http://hdrlib.com/
@JS()
class HDRCubeTexture extends BaseTexture {
	
	/// Instantiates an HDRTexture from the following parameters.
	/// 
	/// @param url The location of the HDR raw data (Panorama stored in RGBE format)
	/// @param sceneOrEngine The scene or engine the texture will be used in
	/// @param size The cubemap desired size (the more it increases the longer the generation will be)
	/// @param noMipmap Forces to not generate the mipmap if true
	/// @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process
	/// @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
	/// @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.
	external factory HDRCubeTexture(String url, dynamic sceneOrEngine, num size, [bool? noMipmap, bool? generateHarmonics, bool? gammaSpace, bool? prefilterOnLoad, void Function()? onLoad, void Function([String? message, dynamic? exception])? onError]);
	
	/// The texture URL.
	external String get url;
	external set url(String value);
	
	/// Sets wether or not the texture is blocking during loading.
	external set isBlocking(bool value);
	
	/// Gets wether or not the texture is blocking during loading.
	@override
	external bool get isBlocking;
	
	/// Sets texture matrix rotation angle around Y axis in radians.
	external set rotationY(num value);
	
	/// Gets texture matrix rotation angle around Y axis radians.
	external num get rotationY;
	
	/// Gets or sets the center of the bounding box associated with the cube texture
	/// It must define where the camera used to render the texture was set
	external Vector3 get boundingBoxPosition;
	external set boundingBoxPosition(Vector3 value);
	
	/// Gets or sets the size of the bounding box associated with the cube texture
	/// When defined, the cubemap will switch to local mode
	/// @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
	/// @example https://www.babylonjs-playground.com/#RNASML
	external set boundingBoxSize(Vector3 value);
	
	external Vector3 get boundingBoxSize;
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "HDRCubeTexture"
	@override
	external String getClassName();
	
	@override
	external HDRCubeTexture? clone();
	
	@override
	external void delayLoad();
	
	/// Get the texture reflection matrix used to rotate/transform the reflection.
	/// @returns the reflection matrix
	@override
	external Matrix getReflectionTextureMatrix();
	
	/// Set the texture reflection matrix used to rotate/transform the reflection.
	/// @param value Define the reflection matrix to set
	external void setReflectionTextureMatrix(Matrix value);
	
	/// Parses a JSON representation of an HDR Texture in order to create the texture
	/// @param parsedTexture Define the JSON representation
	/// @param scene Define the scene the texture should be created in
	/// @param rootUrl Define the root url in case we need to load relative dependencies
	/// @returns the newly created texture after parsing
	external static HDRCubeTexture? Parse(dynamic parsedTexture, Scene scene, String rootUrl);
	
	@override
	external dynamic serialize();
}

/// Class used to control physics engine
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
@JS()
class PhysicsEngine implements IPhysicsEngine {
	
	/// Creates a new Physics Engine
	/// @param gravity defines the gravity vector used by the simulation
	/// @param _physicsPlugin defines the plugin to use (CannonJS by default)
	external factory PhysicsEngine(Vector3? gravity, [IPhysicsEnginePlugin? _physicsPlugin]);
	
	/// Global value used to control the smallest number supported by the simulation
	external static num get Epsilon;
	external static set Epsilon(num value);
	
	/// Gets the gravity vector used by the simulation
	@override
	external Vector3 get gravity;
	@override
	external set gravity(Vector3 value);
	
	/// Factory used to create the default physics plugin.
	/// @returns The default physics plugin
	external static IPhysicsEnginePlugin DefaultPluginFactory();
	
	/// Sets the gravity vector used by the simulation
	/// @param gravity defines the gravity vector to use
	@override
	external void setGravity(Vector3 gravity);
	
	/// Set the time step of the physics engine.
	/// Default is 1/60.
	/// To slow it down, enter 1/600 for example.
	/// To speed it up, 1/30
	/// @param newTimeStep defines the new timestep to apply to this world.
	@override
	external void setTimeStep([num? newTimeStep]);
	
	/// Get the time step of the physics engine.
	/// @returns the current time step
	@override
	external num getTimeStep();
	
	/// Set the sub time step of the physics engine.
	/// Default is 0 meaning there is no sub steps
	/// To increase physics resolution precision, set a small value (like 1 ms)
	/// @param subTimeStep defines the new sub timestep used for physics resolution.
	@override
	external void setSubTimeStep([num? subTimeStep]);
	
	/// Get the sub time step of the physics engine.
	/// @returns the current sub time step
	@override
	external num getSubTimeStep();
	
	/// Release all resources
	@override
	external void dispose();
	
	/// Gets the name of the current physics plugin
	/// @returns the name of the plugin
	@override
	external String getPhysicsPluginName();
	
	/// Adding a new impostor for the impostor tracking.
	/// This will be done by the impostor itself.
	/// @param impostor the impostor to add
	@override
	external void addImpostor(PhysicsImpostor impostor);
	
	/// Remove an impostor from the engine.
	/// This impostor and its mesh will not longer be updated by the physics engine.
	/// @param impostor the impostor to remove
	@override
	external void removeImpostor(PhysicsImpostor impostor);
	
	/// Add a joint to the physics engine
	/// @param mainImpostor defines the main impostor to which the joint is added.
	/// @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
	/// @param joint defines the joint that will connect both impostors.
	@override
	external void addJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);
	
	/// Removes a joint from the simulation
	/// @param mainImpostor defines the impostor used with the joint
	/// @param connectedImpostor defines the other impostor connected to the main one by the joint
	/// @param joint defines the joint to remove
	@override
	external void removeJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);
	
	/// Gets the current plugin used to run the simulation
	/// @returns current plugin
	@override
	external IPhysicsEnginePlugin getPhysicsPlugin();
	
	/// Gets the list of physic impostors
	/// @returns an array of PhysicsImpostor
	@override
	external List<PhysicsImpostor> getImpostors();
	
	/// Gets the impostor for a physics enabled object
	/// @param object defines the object impersonated by the impostor
	/// @returns the PhysicsImpostor or null if not found
	@override
	external PhysicsImpostor? getImpostorForPhysicsObject(IPhysicsEnabledObject object);
	
	/// Gets the impostor for a physics body object
	/// @param body defines physics body used by the impostor
	/// @returns the PhysicsImpostor or null if not found
	@override
	external PhysicsImpostor? getImpostorWithPhysicsBody(dynamic body);
	
	/// Does a raycast in the physics world
	/// @param from when should the ray start?
	/// @param to when should the ray end?
	/// @returns PhysicsRaycastResult
	@override
	external PhysicsRaycastResult raycast(Vector3 from, Vector3 to);
}

/// @hidden
@JS()
class CannonJSPlugin implements IPhysicsEnginePlugin {
	
	external factory CannonJSPlugin([bool? _useDeltaForWorldStep, num? iterations, dynamic? cannonInjection]);
	
	@override
	external dynamic get world;
	@override
	external set world(dynamic value);
	
	@override
	external String get name;
	@override
	external set name(String value);
	
	external dynamic get BJSCANNON;
	external set BJSCANNON(dynamic value);
	
	@override
	external void setGravity(Vector3 gravity);
	
	@override
	external void setTimeStep(num timeStep);
	
	@override
	external num getTimeStep();
	
	@override
	external void executeStep(num delta, List<PhysicsImpostor> impostors);
	
	@override
	external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	@override
	external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	@override
	external void generatePhysicsBody(PhysicsImpostor impostor);
	
	@override
	external void removePhysicsBody(PhysicsImpostor impostor);
	
	@override
	external void generateJoint(PhysicsImpostorJoint impostorJoint);
	
	@override
	external void removeJoint(PhysicsImpostorJoint impostorJoint);
	
	@override
	external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);
	
	@override
	external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);
	
	@override
	external bool isSupported();
	
	@override
	external void setLinearVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	@override
	external void setAngularVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	@override
	external Vector3? getLinearVelocity(PhysicsImpostor impostor);
	
	@override
	external Vector3? getAngularVelocity(PhysicsImpostor impostor);
	
	@override
	external void setBodyMass(PhysicsImpostor impostor, num mass);
	
	@override
	external num getBodyMass(PhysicsImpostor impostor);
	
	@override
	external num getBodyFriction(PhysicsImpostor impostor);
	
	@override
	external void setBodyFriction(PhysicsImpostor impostor, num friction);
	
	@override
	external num getBodyRestitution(PhysicsImpostor impostor);
	
	@override
	external void setBodyRestitution(PhysicsImpostor impostor, num restitution);
	
	@override
	external void sleepBody(PhysicsImpostor impostor);
	
	@override
	external void wakeUpBody(PhysicsImpostor impostor);
	
	@override
	external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num? minDistance]);
	
	@override
	external void setMotor(IMotorEnabledJoint joint, [num? speed, num? maxForce, num? motorIndex]);
	
	@override
	external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num? lowerLimit, num? motorIndex]);
	
	@override
	external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);
	
	@override
	external num getRadius(PhysicsImpostor impostor);
	
	@override
	external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);
	
	@override
	external void dispose();
	
	/// Does a raycast in the physics world
	/// @param from when should the ray start?
	/// @param to when should the ray end?
	/// @returns PhysicsRaycastResult
	@override
	external PhysicsRaycastResult raycast(Vector3 from, Vector3 to);
	
	external num getBodyPressure(PhysicsImpostor impostor);
	
	external void setBodyPressure(PhysicsImpostor impostor, num pressure);
	
	external num getBodyStiffness(PhysicsImpostor impostor);
	
	external void setBodyStiffness(PhysicsImpostor impostor, num stiffness);
	
	external num getBodyVelocityIterations(PhysicsImpostor impostor);
	
	external void setBodyVelocityIterations(PhysicsImpostor impostor, num velocityIterations);
	
	external num getBodyPositionIterations(PhysicsImpostor impostor);
	
	external void setBodyPositionIterations(PhysicsImpostor impostor, num positionIterations);
	
	external void appendAnchor(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num width, num height, num influence, bool noCollisionBetweenLinkedBodies);
	
	external void appendHook(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num length, num influence, bool noCollisionBetweenLinkedBodies);
}

/// @hidden
@JS()
class OimoJSPlugin implements IPhysicsEnginePlugin {
	
	external factory OimoJSPlugin([bool? _useDeltaForWorldStep, num? iterations, dynamic? oimoInjection]);
	
	@override
	external dynamic get world;
	@override
	external set world(dynamic value);
	
	@override
	external String get name;
	@override
	external set name(String value);
	
	external dynamic get BJSOIMO;
	external set BJSOIMO(dynamic value);
	
	@override
	external void setGravity(Vector3 gravity);
	
	@override
	external void setTimeStep(num timeStep);
	
	@override
	external num getTimeStep();
	
	@override
	external void executeStep(num delta, List<PhysicsImpostor> impostors);
	
	@override
	external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	@override
	external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	@override
	external void generatePhysicsBody(PhysicsImpostor impostor);
	
	@override
	external void removePhysicsBody(PhysicsImpostor impostor);
	
	@override
	external void generateJoint(PhysicsImpostorJoint impostorJoint);
	
	@override
	external void removeJoint(PhysicsImpostorJoint impostorJoint);
	
	@override
	external bool isSupported();
	
	@override
	external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);
	
	@override
	external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);
	
	@override
	external void setLinearVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	@override
	external void setAngularVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	@override
	external Vector3? getLinearVelocity(PhysicsImpostor impostor);
	
	@override
	external Vector3? getAngularVelocity(PhysicsImpostor impostor);
	
	@override
	external void setBodyMass(PhysicsImpostor impostor, num mass);
	
	@override
	external num getBodyMass(PhysicsImpostor impostor);
	
	@override
	external num getBodyFriction(PhysicsImpostor impostor);
	
	@override
	external void setBodyFriction(PhysicsImpostor impostor, num friction);
	
	@override
	external num getBodyRestitution(PhysicsImpostor impostor);
	
	@override
	external void setBodyRestitution(PhysicsImpostor impostor, num restitution);
	
	@override
	external void sleepBody(PhysicsImpostor impostor);
	
	@override
	external void wakeUpBody(PhysicsImpostor impostor);
	
	@override
	external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num? minDistance]);
	
	@override
	external void setMotor(IMotorEnabledJoint joint, num speed, [num? force, num? motorIndex]);
	
	@override
	external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num? lowerLimit, num? motorIndex]);
	
	@override
	external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);
	
	@override
	external num getRadius(PhysicsImpostor impostor);
	
	@override
	external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);
	
	@override
	external void dispose();
	
	/// Does a raycast in the physics world
	/// @param from when should the ray start?
	/// @param to when should the ray end?
	/// @returns PhysicsRaycastResult
	@override
	external PhysicsRaycastResult raycast(Vector3 from, Vector3 to);
	
	external num getBodyPressure(PhysicsImpostor impostor);
	
	external void setBodyPressure(PhysicsImpostor impostor, num pressure);
	
	external num getBodyStiffness(PhysicsImpostor impostor);
	
	external void setBodyStiffness(PhysicsImpostor impostor, num stiffness);
	
	external num getBodyVelocityIterations(PhysicsImpostor impostor);
	
	external void setBodyVelocityIterations(PhysicsImpostor impostor, num velocityIterations);
	
	external num getBodyPositionIterations(PhysicsImpostor impostor);
	
	external void setBodyPositionIterations(PhysicsImpostor impostor, num positionIterations);
	
	external void appendAnchor(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num width, num height, num influence, bool noCollisionBetweenLinkedBodies);
	
	external void appendHook(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num length, num influence, bool noCollisionBetweenLinkedBodies);
}

/// AmmoJS Physics plugin
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine
/// @see https://github.com/kripken/ammo.js/
@JS()
class AmmoJSPlugin implements IPhysicsEnginePlugin {
	
	/// Initializes the ammoJS plugin
	/// @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)
	/// @param ammoInjection can be used to inject your own ammo reference
	/// @param overlappingPairCache can be used to specify your own overlapping pair cache
	external factory AmmoJSPlugin([bool? _useDeltaForWorldStep, dynamic? ammoInjection, dynamic? overlappingPairCache]);
	
	/// Reference to the Ammo library
	external dynamic get bjsAMMO;
	external set bjsAMMO(dynamic value);
	
	/// Created ammoJS world which physics bodies are added to
	@override
	external dynamic get world;
	@override
	external set world(dynamic value);
	
	/// Name of the plugin
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Sets the gravity of the physics world (m/(s^2))
	/// @param gravity Gravity to set
	@override
	external void setGravity(Vector3 gravity);
	
	/// Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)
	/// @param timeStep timestep to use in seconds
	@override
	external void setTimeStep(num timeStep);
	
	/// Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)
	/// @param fixedTimeStep fixedTimeStep to use in seconds
	external void setFixedTimeStep(num fixedTimeStep);
	
	/// Sets the maximum number of steps by the physics engine per frame (Default: 5)
	/// @param maxSteps the maximum number of steps by the physics engine per frame
	external void setMaxSteps(num maxSteps);
	
	/// Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)
	/// @returns the current timestep in seconds
	@override
	external num getTimeStep();
	
	/// The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor
	external dynamic Function(PhysicsImpostor impostor) get onCreateCustomShape;
	external set onCreateCustomShape(dynamic Function(PhysicsImpostor impostor) value);
	
	/// Moves the physics simulation forward delta seconds and updates the given physics imposters
	/// Prior to the step the imposters physics location is set to the position of the babylon meshes
	/// After the step the babylon meshes are set to the position of the physics imposters
	/// @param delta amount of time to step forward
	/// @param impostors array of imposters to update before/after the step
	@override
	external void executeStep(num delta, List<PhysicsImpostor> impostors);
	
	/// Applies an impulse on the imposter
	/// @param impostor imposter to apply impulse to
	/// @param force amount of force to be applied to the imposter
	/// @param contactPoint the location to apply the impulse on the imposter
	@override
	external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	/// Applies a force on the imposter
	/// @param impostor imposter to apply force
	/// @param force amount of force to be applied to the imposter
	/// @param contactPoint the location to apply the force on the imposter
	@override
	external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);
	
	/// Creates a physics body using the plugin
	/// @param impostor the imposter to create the physics body on
	@override
	external void generatePhysicsBody(PhysicsImpostor impostor);
	
	/// Removes the physics body from the imposter and disposes of the body's memory
	/// @param impostor imposter to remove the physics body from
	@override
	external void removePhysicsBody(PhysicsImpostor impostor);
	
	/// Generates a joint
	/// @param impostorJoint the imposter joint to create the joint with
	@override
	external void generateJoint(PhysicsImpostorJoint impostorJoint);
	
	/// Removes a joint
	/// @param impostorJoint the imposter joint to remove the joint from
	@override
	external void removeJoint(PhysicsImpostorJoint impostorJoint);
	
	/// Sets the physics body position/rotation from the babylon mesh's position/rotation
	/// @param impostor imposter containing the physics body and babylon object
	@override
	external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);
	
	/// Sets the babylon object's position/rotation from the physics body's position/rotation
	/// @param impostor imposter containing the physics body and babylon object
	/// @param newPosition new position
	/// @param newRotation new rotation
	@override
	external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);
	
	/// If this plugin is supported
	/// @returns true if its supported
	@override
	external bool isSupported();
	
	/// Sets the linear velocity of the physics body
	/// @param impostor imposter to set the velocity on
	/// @param velocity velocity to set
	@override
	external void setLinearVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	/// Sets the angular velocity of the physics body
	/// @param impostor imposter to set the velocity on
	/// @param velocity velocity to set
	@override
	external void setAngularVelocity(PhysicsImpostor impostor, Vector3? velocity);
	
	/// gets the linear velocity
	/// @param impostor imposter to get linear velocity from
	/// @returns linear velocity
	@override
	external Vector3? getLinearVelocity(PhysicsImpostor impostor);
	
	/// gets the angular velocity
	/// @param impostor imposter to get angular velocity from
	/// @returns angular velocity
	@override
	external Vector3? getAngularVelocity(PhysicsImpostor impostor);
	
	/// Sets the mass of physics body
	/// @param impostor imposter to set the mass on
	/// @param mass mass to set
	@override
	external void setBodyMass(PhysicsImpostor impostor, num mass);
	
	/// Gets the mass of the physics body
	/// @param impostor imposter to get the mass from
	/// @returns mass
	@override
	external num getBodyMass(PhysicsImpostor impostor);
	
	/// Gets friction of the impostor
	/// @param impostor impostor to get friction from
	/// @returns friction value
	@override
	external num getBodyFriction(PhysicsImpostor impostor);
	
	/// Sets friction of the impostor
	/// @param impostor impostor to set friction on
	/// @param friction friction value
	@override
	external void setBodyFriction(PhysicsImpostor impostor, num friction);
	
	/// Gets restitution of the impostor
	/// @param impostor impostor to get restitution from
	/// @returns restitution value
	@override
	external num getBodyRestitution(PhysicsImpostor impostor);
	
	/// Sets resitution of the impostor
	/// @param impostor impostor to set resitution on
	/// @param restitution resitution value
	@override
	external void setBodyRestitution(PhysicsImpostor impostor, num restitution);
	
	/// Gets pressure inside the impostor
	/// @param impostor impostor to get pressure from
	/// @returns pressure value
	@override
	external num getBodyPressure(PhysicsImpostor impostor);
	
	/// Sets pressure inside a soft body impostor
	/// Cloth and rope must remain 0 pressure
	/// @param impostor impostor to set pressure on
	/// @param pressure pressure value
	@override
	external void setBodyPressure(PhysicsImpostor impostor, num pressure);
	
	/// Gets stiffness of the impostor
	/// @param impostor impostor to get stiffness from
	/// @returns pressure value
	@override
	external num getBodyStiffness(PhysicsImpostor impostor);
	
	/// Sets stiffness of the impostor
	/// @param impostor impostor to set stiffness on
	/// @param stiffness stiffness value from 0 to 1
	@override
	external void setBodyStiffness(PhysicsImpostor impostor, num stiffness);
	
	/// Gets velocityIterations of the impostor
	/// @param impostor impostor to get velocity iterations from
	/// @returns velocityIterations value
	@override
	external num getBodyVelocityIterations(PhysicsImpostor impostor);
	
	/// Sets velocityIterations of the impostor
	/// @param impostor impostor to set velocity iterations on
	/// @param velocityIterations velocityIterations value
	@override
	external void setBodyVelocityIterations(PhysicsImpostor impostor, num velocityIterations);
	
	/// Gets positionIterations of the impostor
	/// @param impostor impostor to get position iterations from
	/// @returns positionIterations value
	@override
	external num getBodyPositionIterations(PhysicsImpostor impostor);
	
	/// Sets positionIterations of the impostor
	/// @param impostor impostor to set position on
	/// @param positionIterations positionIterations value
	@override
	external void setBodyPositionIterations(PhysicsImpostor impostor, num positionIterations);
	
	/// Append an anchor to a cloth object
	/// @param impostor is the cloth impostor to add anchor to
	/// @param otherImpostor is the rigid impostor to anchor to
	/// @param width ratio across width from 0 to 1
	/// @param height ratio up height from 0 to 1
	/// @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech
	/// @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
	@override
	external void appendAnchor(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num width, num height, [num? influence, bool? noCollisionBetweenLinkedBodies]);
	
	/// Append an hook to a rope object
	/// @param impostor is the rope impostor to add hook to
	/// @param otherImpostor is the rigid impostor to hook to
	/// @param length ratio along the rope from 0 to 1
	/// @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little strech
	/// @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
	@override
	external void appendHook(PhysicsImpostor impostor, PhysicsImpostor otherImpostor, num length, [num? influence, bool? noCollisionBetweenLinkedBodies]);
	
	/// Sleeps the physics body and stops it from being active
	/// @param impostor impostor to sleep
	@override
	external void sleepBody(PhysicsImpostor impostor);
	
	/// Activates the physics body
	/// @param impostor impostor to activate
	@override
	external void wakeUpBody(PhysicsImpostor impostor);
	
	/// Updates the distance parameters of the joint
	/// @param joint joint to update
	/// @param maxDistance maximum distance of the joint
	/// @param minDistance minimum distance of the joint
	@override
	external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num? minDistance]);
	
	/// Sets a motor on the joint
	/// @param joint joint to set motor on
	/// @param speed speed of the motor
	/// @param maxForce maximum force of the motor
	/// @param motorIndex index of the motor
	@override
	external void setMotor(IMotorEnabledJoint joint, [num? speed, num? maxForce, num? motorIndex]);
	
	/// Sets the motors limit
	/// @param joint joint to set limit on
	/// @param upperLimit upper limit
	/// @param lowerLimit lower limit
	@override
	external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num? lowerLimit, num? motorIndex]);
	
	/// Syncs the position and rotation of a mesh with the impostor
	/// @param mesh mesh to sync
	/// @param impostor impostor to update the mesh with
	@override
	external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);
	
	/// Gets the radius of the impostor
	/// @param impostor impostor to get radius from
	/// @returns the radius
	@override
	external num getRadius(PhysicsImpostor impostor);
	
	/// Gets the box size of the impostor
	/// @param impostor impostor to get box size from
	/// @param result the resulting box size
	@override
	external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);
	
	/// Disposes of the impostor
	@override
	external void dispose();
	
	/// Does a raycast in the physics world
	/// @param from when should the ray start?
	/// @param to when should the ray end?
	/// @returns PhysicsRaycastResult
	@override
	external PhysicsRaycastResult raycast(Vector3 from, Vector3 to);
}

/// Class used to generate realtime reflection / refraction cube textures
/// @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes
@JS()
class ReflectionProbe {
	
	/// Creates a new reflection probe
	/// @param name defines the name of the probe
	/// @param size defines the texture resolution (for each face)
	/// @param scene defines the hosting scene
	/// @param generateMipMaps defines if mip maps should be generated automatically (true by default)
	/// @param useFloat defines if HDR data (flaot data) should be used to store colors (false by default)
	external factory ReflectionProbe(String name, num size, Scene scene, [bool? generateMipMaps, bool? useFloat]);
	
	/// defines the name of the probe
	external String get name;
	external set name(String value);
	
	/// Gets or sets probe position (center of the cube map)
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2
	external num get samples;
	
	external set samples(num value);
	
	/// Gets or sets the refresh rate to use (on every frame by default)
	external num get refreshRate;
	
	external set refreshRate(num value);
	
	/// Gets the hosting scene
	/// @returns a Scene
	external Scene getScene();
	
	/// Gets the internal CubeTexture used to render to
	external RenderTargetTexture get cubeTexture;
	
	/// Gets the list of meshes to render
	external List<AbstractMesh>? get renderList;
	
	/// Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)
	/// @param mesh defines the mesh to attach to
	external void attachToMesh(AbstractMesh? mesh);
	
	/// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups
	/// @param renderingGroupId The rendering group id corresponding to its index
	/// @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
	external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil);
	
	/// Clean all associated resources
	external void dispose();
	
	/// Converts the reflection probe information to a readable string for debug purpose.
	/// @param fullDetails Supports for multiple levels of logging within scene loading
	/// @returns the human readable reflection probe info
	external String toString([bool? fullDetails]);
	
	/// Get the class name of the relfection probe.
	/// @returns "ReflectionProbe"
	external String getClassName();
	
	/// Serialize the reflection probe to a JSON representation we can easily use in the resepective Parse function.
	/// @returns The JSON representation of the texture
	external dynamic serialize();
	
	/// Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.
	/// @param parsedReflectionProbe Define the JSON representation of the reflection probe
	/// @param scene Define the scene the parsed reflection probe should be instantiated in
	/// @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
	/// @returns The parsed reflection probe if successful
	external static ReflectionProbe? Parse(dynamic parsedReflectionProbe, Scene scene, String rootUrl);
}

/// Helps setting up some configuration for the babylon file loader.
@JS()
class BabylonFileLoaderConfiguration {
	external factory BabylonFileLoaderConfiguration();
	
	/// The loader does not allow injecting custom physix engine into the plugins.
	/// Unfortunately in ES6, we need to manually inject them into the plugin.
	/// So you could set this variable to your engine import to make it work.
	external static dynamic get LoaderInjectedPhysicsEngine;
	external static set LoaderInjectedPhysicsEngine(dynamic value);
}

/// The Physically based simple base material of BJS.
/// 
/// This enables better naming and convention enforcements on top of the pbrMaterial.
/// It is used as the base class for both the specGloss and metalRough conventions.
@JS()
abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial {
	
	/// Instantiates a new PBRMaterial instance.
	/// 
	/// @param name The material name
	/// @param scene The scene the material will be use in.
	external factory PBRBaseSimpleMaterial(String name, Scene scene);
	
	/// Number of Simultaneous lights allowed on the material.
	external num get maxSimultaneousLights;
	external set maxSimultaneousLights(num value);
	
	/// If sets to true, disables all the lights affecting the material.
	external bool get disableLighting;
	external set disableLighting(bool value);
	
	/// Environment Texture used in the material (this is use for both reflection and environment lighting).
	external BaseTexture get environmentTexture;
	external set environmentTexture(BaseTexture value);
	
	/// If sets to true, x component of normal map value will invert (x = 1.0 - x).
	external bool get invertNormalMapX;
	external set invertNormalMapX(bool value);
	
	/// If sets to true, y component of normal map value will invert (y = 1.0 - y).
	external bool get invertNormalMapY;
	external set invertNormalMapY(bool value);
	
	/// Normal map used in the model.
	external BaseTexture get normalTexture;
	external set normalTexture(BaseTexture value);
	
	/// Emissivie color used to self-illuminate the model.
	external Color3 get emissiveColor;
	external set emissiveColor(Color3 value);
	
	/// Emissivie texture used to self-illuminate the model.
	external BaseTexture get emissiveTexture;
	external set emissiveTexture(BaseTexture value);
	
	/// Occlusion Channel Strenght.
	external num get occlusionStrength;
	external set occlusionStrength(num value);
	
	/// Occlusion Texture of the material (adding extra occlusion effects).
	external BaseTexture get occlusionTexture;
	external set occlusionTexture(BaseTexture value);
	
	/// Defines the alpha limits in alpha test mode.
	external num get alphaCutOff;
	external set alphaCutOff(num value);
	
	/// Gets the current double sided mode.
	external bool get doubleSided;
	
	/// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
	external set doubleSided(bool value);
	
	/// Stores the pre-calculated light information of a mesh in a texture.
	external BaseTexture get lightmapTexture;
	external set lightmapTexture(BaseTexture value);
	
	/// If true, the light map contains occlusion information instead of lighting info.
	external bool get useLightmapAsShadowmap;
	external set useLightmapAsShadowmap(bool value);
	
	@override
	external String getClassName();
}

/// The PBR material of BJS following the metal roughness convention.
/// 
/// This fits to the PBR convention in the GLTF definition:
/// https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
@JS()
class PBRMetallicRoughnessMaterial extends PBRBaseSimpleMaterial {
	
	/// Instantiates a new PBRMetalRoughnessMaterial instance.
	/// 
	/// @param name The material name
	/// @param scene The scene the material will be use in.
	external factory PBRMetallicRoughnessMaterial(String name, Scene scene);
	
	/// The base color has two different interpretations depending on the value of metalness.
	/// When the material is a metal, the base color is the specific measured reflectance value
	/// at normal incidence (F0). For a non-metal the base color represents the reflected diffuse color
	/// of the material.
	external Color3 get baseColor;
	external set baseColor(Color3 value);
	
	/// Base texture of the metallic workflow. It contains both the baseColor information in RGB as
	/// well as opacity information in the alpha channel.
	external BaseTexture get baseTexture;
	external set baseTexture(BaseTexture value);
	
	/// Specifies the metallic scalar value of the material.
	/// Can also be used to scale the metalness values of the metallic texture.
	external num get metallic;
	external set metallic(num value);
	
	/// Specifies the roughness scalar value of the material.
	/// Can also be used to scale the roughness values of the metallic texture.
	external num get roughness;
	external set roughness(num value);
	
	/// Texture containing both the metallic value in the B channel and the
	/// roughness value in the G channel to keep better precision.
	external BaseTexture get metallicRoughnessTexture;
	external set metallicRoughnessTexture(BaseTexture value);
	
	/// Return the currrent class name of the material.
	@override
	external String getClassName();
	
	/// Makes a duplicate of the current material.
	/// @param name - name to use for the new material.
	@override
	external PBRMetallicRoughnessMaterial? clone(String name);
	
	/// Serialize the material to a parsable JSON object.
	@override
	external dynamic serialize();
	
	/// Parses a JSON object correponding to the serialize function.
	@override
	external static PBRMetallicRoughnessMaterial? Parse(dynamic source, Scene scene, String rootUrl);
}

/// The PBR material of BJS following the specular glossiness convention.
/// 
/// This fits to the PBR convention in the GLTF definition:
/// https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
@JS()
class PBRSpecularGlossinessMaterial extends PBRBaseSimpleMaterial {
	
	/// Instantiates a new PBRSpecularGlossinessMaterial instance.
	/// 
	/// @param name The material name
	/// @param scene The scene the material will be use in.
	external factory PBRSpecularGlossinessMaterial(String name, Scene scene);
	
	/// Specifies the diffuse color of the material.
	external Color3 get diffuseColor;
	external set diffuseColor(Color3 value);
	
	/// Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha
	/// channel.
	external BaseTexture get diffuseTexture;
	external set diffuseTexture(BaseTexture value);
	
	/// Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).
	external Color3 get specularColor;
	external set specularColor(Color3 value);
	
	/// Specifies the glossiness of the material. This indicates "how sharp is the reflection".
	external num get glossiness;
	external set glossiness(num value);
	
	/// Specifies both the specular color RGB and the glossiness A of the material per pixels.
	external BaseTexture get specularGlossinessTexture;
	external set specularGlossinessTexture(BaseTexture value);
	
	/// Return the currrent class name of the material.
	@override
	external String getClassName();
	
	/// Makes a duplicate of the current material.
	/// @param name - name to use for the new material.
	@override
	external PBRSpecularGlossinessMaterial? clone(String name);
	
	/// Serialize the material to a parsable JSON object.
	@override
	external dynamic serialize();
	
	/// Parses a JSON object correponding to the serialize function.
	@override
	external static PBRSpecularGlossinessMaterial? Parse(dynamic source, Scene scene, String rootUrl);
}

/// This represents a color grading texture. This acts as a lookup table LUT, useful during post process
/// It can help converting any input color in a desired output one. This can then be used to create effects
/// from sepia, black and white to sixties or futuristic rendering...
/// 
/// The only supported format is currently 3dl.
/// More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table
@JS()
class ColorGradingTexture extends BaseTexture {
	
	/// Instantiates a ColorGradingTexture from the following parameters.
	/// 
	/// @param url The location of the color gradind data (currently only supporting 3dl)
	/// @param sceneOrEngine The scene or engine the texture will be used in
	/// @param onLoad defines a callback triggered when the texture has been loaded
	external factory ColorGradingTexture(String url, dynamic sceneOrEngine, [void Function()? onLoad]);
	
	/// The texture URL.
	external String get url;
	external set url(String value);
	
	/// Returns the texture matrix used in most of the material.
	/// This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
	@override
	external Matrix getTextureMatrix();
	
	/// Clones the color gradind texture.
	@override
	external ColorGradingTexture? clone();
	
	/// Called during delayed load for textures.
	@override
	external void delayLoad();
	
	/// Parses a color grading texture serialized by Babylon.
	/// @param parsedTexture The texture information being parsedTexture
	/// @param scene The scene to load the texture in
	/// @param rootUrl The root url of the data assets to load
	/// @return A color gradind texture
	external static ColorGradingTexture? Parse(dynamic parsedTexture, Scene scene);
	
	/// Serializes the LUT texture to json format.
	@override
	external dynamic serialize();
}

/// This represents a texture coming from an equirectangular image supported by the web browser canvas.
@JS()
class EquiRectangularCubeTexture extends BaseTexture {
	
	/// Instantiates an EquiRectangularCubeTexture from the following parameters.
	/// @param url The location of the image
	/// @param scene The scene the texture will be used in
	/// @param size The cubemap desired size (the more it increases the longer the generation will be)
	/// @param noMipmap Forces to not generate the mipmap if true
	/// @param gammaSpace Specifies if the texture will be used in gamma or linear space
	/// (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
	/// @param onLoad — defines a callback called when texture is loaded
	/// @param onError — defines a callback called if there is an error
	external factory EquiRectangularCubeTexture(String url, Scene scene, num size, [bool? noMipmap, bool? gammaSpace, void Function()? onLoad, void Function([String? message, dynamic? exception])? onError]);
	
	/// The URL to the image.
	external String get url;
	external set url(String value);
	
	/// Get the current class name of the texture useful for serialization or dynamic coding.
	/// @returns "EquiRectangularCubeTexture"
	@override
	external String getClassName();
	
	/// Create a clone of the current EquiRectangularCubeTexture and return it.
	/// @returns A clone of the current EquiRectangularCubeTexture.
	@override
	external EquiRectangularCubeTexture? clone();
}

/// Defines the options related to the creation of an HtmlElementTexture
@JS()
@anonymous
class IHtmlElementTextureOptions {
	
	external factory IHtmlElementTextureOptions({bool generateMipMaps, num samplingMode, ThinEngine? engine, Scene? scene});
	
	/// Defines wether mip maps should be created or not.
	external bool get generateMipMaps;
	external set generateMipMaps( bool value );
	
	/// Defines the sampling mode of the texture.
	external num get samplingMode;
	external set samplingMode( num value );
	
	/// Defines the engine instance to use the texture with. It is not mandatory if you define a scene.
	external ThinEngine? get engine;
	external set engine( ThinEngine? value );
	
	/// Defines the scene the texture belongs to. It is not mandatory if you define an engine.
	external Scene? get scene;
	external set scene( Scene? value );
}

/// This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.
/// To be as efficient as possible depending on your constraints nothing aside the first upload
/// is automatically managed.
/// It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements
/// in your application.
/// 
/// As the update is not automatic, you need to call them manually.
@JS()
class HtmlElementTexture extends BaseTexture {
	
	/// Instantiates a HtmlElementTexture from the following parameters.
	/// 
	/// @param name Defines the name of the texture
	/// @param element Defines the video or canvas the texture is filled with
	/// @param options Defines the other none mandatory texture creation options
	external factory HtmlElementTexture(String name, dynamic element, IHtmlElementTextureOptions options);
	
	/// The texture URL.
	external dynamic get element;
	external set element(dynamic value);
	
	/// Returns the texture matrix used in most of the material.
	@override
	external Matrix getTextureMatrix();
	
	/// Updates the content of the texture.
	/// @param invertY Defines wether the texture should be inverted on Y (false by default on video and true on canvas)
	external void update([bool? invertY]);
}

/// Based on jsTGALoader - Javascript loader for TGA file
/// By Vincent Thibault
/// @see http://blog.robrowser.com/javascript-tga-loader.html
@JS()
class TGATools {
	external factory TGATools();
	
	/// Gets the header of a TGA file
	/// @param data defines the TGA data
	/// @returns the header
	external static dynamic GetTGAHeader(Uint8List data);
	
	/// Uploads TGA content to a Babylon Texture
	/// @hidden
	external static void UploadContent(InternalTexture texture, Uint8List data);
}

/// Info about the .basis files
@JS()
class BasisFileInfo {
	external factory BasisFileInfo();
	
	/// If the file has alpha
	external bool get hasAlpha;
	external set hasAlpha(bool value);
	
	/// Info about each image of the basis file
	external List<BasisFileInfoImages> get images;
	external set images(List<BasisFileInfoImages> value);
}

/// Result of transcoding a basis file
@JS()
class TranscodeResult {
	external factory TranscodeResult();
	
	/// Info about the .basis file
	external BasisFileInfo get fileInfo;
	external set fileInfo(BasisFileInfo value);
	
	/// Format to use when loading the file
	external num get format;
	external set format(num value);
}

/// Configuration options for the Basis transcoder
@JS()
class BasisTranscodeConfiguration {
	external factory BasisTranscodeConfiguration();
	
	/// Supported compression formats used to determine the supported output format of the transcoder
	external BasisTranscodeConfigurationSupportedCompressionFormats get supportedCompressionFormats;
	external set supportedCompressionFormats(BasisTranscodeConfigurationSupportedCompressionFormats value);
	
	/// If mipmap levels should be loaded for transcoded images (Default: true)
	external bool get loadMipmapLevels;
	external set loadMipmapLevels(bool value);
	
	/// Index of a single image to load (Default: all images)
	external num get loadSingleImage;
	external set loadSingleImage(num value);
}

/// Used to load .Basis files
/// See https://github.com/BinomialLLC/basis_universal/tree/master/webgl
@JS()
class BasisTools {
	external factory BasisTools();
	
	/// URL to use when loading the basis transcoder
	external static String get JSModuleURL;
	external static set JSModuleURL(String value);
	
	/// URL to use when loading the wasm module for the transcoder
	external static String get WasmModuleURL;
	external static set WasmModuleURL(String value);
	
	/// Get the internal format to be passed to texImage2D corresponding to the .basis format value
	/// @param basisFormat format chosen from GetSupportedTranscodeFormat
	/// @returns internal format corresponding to the Basis format
	external static num GetInternalFormatFromBasisFormat(num basisFormat);
	
	/// Transcodes a loaded image file to compressed pixel data
	/// @param data image data to transcode
	/// @param config configuration options for the transcoding
	/// @returns a promise resulting in the transcoded image
	external static Promise<TranscodeResult> TranscodeAsync(dynamic data, BasisTranscodeConfiguration config);
	
	/// Loads a texture from the transcode result
	/// @param texture texture load to
	/// @param transcodeResult the result of transcoding the basis file to load from
	external static void LoadTextureFromTranscodeResult(InternalTexture texture, TranscodeResult transcodeResult);
}

/// Defines the basic options interface of a TexturePacker Frame
@JS()
abstract class ITexturePackerFrame {
	
	/// The frame ID
	external num get id;
	external set id(num value);
	
	/// The frames Scale
	external Vector2 get scale;
	external set scale(Vector2 value);
	
	/// The Frames offset
	external Vector2 get offset;
	external set offset(Vector2 value);
}

/// This is a support class for frame Data on texture packer sets.
@JS()
class TexturePackerFrame implements ITexturePackerFrame {
	
	/// Initializes a texture package frame.
	/// @param id The numerical frame identifier
	/// @param scale Scalar Vector2 for UV frame
	/// @param offset Vector2 for the frame position in UV units.
	/// @returns TexturePackerFrame
	external factory TexturePackerFrame(num id, Vector2 scale, Vector2 offset);
	
	/// The frame ID
	@override
	external num get id;
	@override
	external set id(num value);
	
	/// The frames Scale
	@override
	external Vector2 get scale;
	@override
	external set scale(Vector2 value);
	
	/// The Frames offset
	@override
	external Vector2 get offset;
	@override
	external set offset(Vector2 value);
}

/// Defines the basic options interface of a TexturePacker
@JS()
@anonymous
class ITexturePackerOptions {
	
	external factory ITexturePackerOptions({List<String> map, String uvsIn, String uvsOut, num layout, num colnum, bool updateInputMeshes, bool disposeSources, bool fillBlanks, String customFillColor, num frameSize, num paddingRatio, num paddingMode, dynamic paddingColor});
	
	/// Custom targets for the channels of a texture packer.  Default is all the channels of the Standard Material
	external List<String> get map;
	external set map( List<String> value );
	
	/// the UV input targets, as a single value for all meshes. Defaults to VertexBuffer.UVKind
	external String get uvsIn;
	external set uvsIn( String value );
	
	/// the UV output targets, as a single value for all meshes.  Defaults to VertexBuffer.UVKind
	external String get uvsOut;
	external set uvsOut( String value );
	
	/// number representing the layout style. Defaults to LAYOUT_STRIP
	external num get layout;
	external set layout( num value );
	
	/// number of columns if using custom column count layout(2).  This defaults to 4.
	external num get colnum;
	external set colnum( num value );
	
	/// flag to update the input meshes to the new packed texture after compilation. Defaults to true.
	external bool get updateInputMeshes;
	external set updateInputMeshes( bool value );
	
	/// boolean flag to dispose all the source textures.  Defaults to true.
	external bool get disposeSources;
	external set disposeSources( bool value );
	
	/// Fills the blank cells in a set to the customFillColor.  Defaults to true.
	external bool get fillBlanks;
	external set fillBlanks( bool value );
	
	/// string value representing the context fill style color.  Defaults to 'black'.
	external String get customFillColor;
	external set customFillColor( String value );
	
	/// Width and Height Value of each Frame in the TexturePacker Sets
	external num get frameSize;
	external set frameSize( num value );
	
	/// Ratio of the value to add padding wise to each cell.  Defaults to 0.0115
	external num get paddingRatio;
	external set paddingRatio( num value );
	
	/// Number that declares the fill method for the padding gutter.
	external num get paddingMode;
	external set paddingMode( num value );
	
	/// If in SUBUV_COLOR padding mode what color to use.
	external dynamic get paddingColor;
	external set paddingColor( dynamic value );
}

/// Defines the basic interface of a TexturePacker JSON File
@JS()
@anonymous
class ITexturePackerJSON {
	
	external factory ITexturePackerJSON({String name, dynamic sets, ITexturePackerOptions options, List<num> frames});
	
	/// The frame ID
	external String get name;
	external set name( String value );
	
	/// The base64 channel data
	external dynamic get sets;
	external set sets( dynamic value );
	
	/// The options of the Packer
	external ITexturePackerOptions get options;
	external set options( ITexturePackerOptions value );
	
	/// The frame data of the Packer
	external List<num> get frames;
	external set frames( List<num> value );
}

/// This is a support class that generates a series of packed texture sets.
/// @see https://doc.babylonjs.com/babylon101/materials
@JS()
class TexturePacker {
	
	/// Initializes a texture package series from an array of meshes or a single mesh.
	/// @param name The name of the package
	/// @param meshes The target meshes to compose the package from
	/// @param options The arguments that texture packer should follow while building.
	/// @param scene The scene which the textures are scoped to.
	/// @returns TexturePacker
	external factory TexturePacker(String name, List<AbstractMesh> meshes, ITexturePackerOptions options, Scene scene);
	
	/// Packer Layout Constant 0
	external static num get LAYOUT_STRIP;
	
	/// Packer Layout Constant 1
	external static num get LAYOUT_POWER2;
	
	/// Packer Layout Constant 2
	external static num get LAYOUT_COLNUM;
	
	/// Packer Layout Constant 0
	external static num get SUBUV_WRAP;
	
	/// Packer Layout Constant 1
	external static num get SUBUV_EXTEND;
	
	/// Packer Layout Constant 2
	external static num get SUBUV_COLOR;
	
	/// The Name of the Texture Package
	external String get name;
	external set name(String value);
	
	/// The scene scope of the TexturePacker
	external Scene get scene;
	external set scene(Scene value);
	
	/// The Meshes to target
	external List<AbstractMesh> get meshes;
	external set meshes(List<AbstractMesh> value);
	
	/// Arguments passed with the Constructor
	external ITexturePackerOptions get options;
	external set options(ITexturePackerOptions value);
	
	/// The promise that is started upon initialization
	external Promise<dynamic>? get promise;
	external set promise(Promise<dynamic>? value);
	
	/// The Container object for the channel sets that are generated
	external dynamic get sets;
	external set sets(dynamic value);
	
	/// The Container array for the frames that are generated
	external List<TexturePackerFrame> get frames;
	external set frames(List<TexturePackerFrame> value);
	
	/// Public method to set a Mesh to a frame
	/// @param m that is the target
	/// @param frameID or the frame index
	/// @param updateMaterial trigger for if the Meshes attached Material be updated?
	external void setMeshToFrame(AbstractMesh m, num frameID, [bool? updateMaterial]);
	
	/// Starts the async promise to compile the texture packer.
	/// @returns Promise<void>
	external Promise<void> processAsync();
	
	/// Disposes all textures associated with this packer
	external void dispose();
	
	/// Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.
	/// @param imageType is the image type to use.
	/// @param quality of the image if downloading as jpeg, Ranges from >0 to 1.
	external void download([String? imageType, num? quality]);
	
	/// Public method to load a texturePacker JSON file.
	/// @param data of the JSON file in string format.
	external void updateFromJSON(String data);
}

/// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
/// Custom Procedural textures are the easiest way to create your own procedural in your application.
/// @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures#creating-custom-procedural-textures
@JS()
class CustomProceduralTexture extends ProceduralTexture {
	
	/// Instantiates a new Custom Procedural Texture.
	/// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
	/// Custom Procedural textures are the easiest way to create your own procedural in your application.
	/// @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures#creating-custom-procedural-textures
	/// @param name Define the name of the texture
	/// @param texturePath Define the folder path containing all the cutom texture related files (config, shaders...)
	/// @param size Define the size of the texture to create
	/// @param scene Define the scene the texture belongs to
	/// @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
	/// @param generateMipMaps Define if the texture should creates mip maps or not
	external factory CustomProceduralTexture(String name, String texturePath, num size, Scene scene, [Texture? fallbackTexture, bool? generateMipMaps]);
	
	/// Is the texture ready to be used ? (rendered at least once)
	/// @returns true if ready, otherwise, false.
	@override
	external bool isReady();
	
	/// Render the texture to its associated render target.
	/// @param useCameraPostProcess Define if camera post process should be applied to the texture
	@override
	external void render([bool? useCameraPostProcess]);
	
	/// Update the list of dependant textures samplers in the shader.
	external void updateTextures();
	
	/// Update the uniform values of the procedural texture in the shader.
	external void updateShaderUniforms();
	
	/// Define if the texture animates or not.
	external bool get animate;
	
	external set animate(bool value);
}

/* var */
/// @hidden
@JS()
external dynamic get noisePixelShader;

/// Class used to generate noise procedural textures
@JS()
class NoiseProceduralTexture extends ProceduralTexture {
	
	/// Creates a new NoiseProceduralTexture
	/// @param name defines the name fo the texture
	/// @param size defines the size of the texture (default is 256)
	/// @param scene defines the hosting scene
	/// @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created
	/// @param generateMipMaps defines if mipmaps must be generated (true by default)
	external factory NoiseProceduralTexture(String name, [num? size, Scene? scene, Texture? fallbackTexture, bool? generateMipMaps]);
	
	/// Gets or sets the start time (default is 0)
	external num get time;
	external set time(num value);
	
	/// Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2)
	external num get brightness;
	external set brightness(num value);
	
	/// Defines the number of octaves to process
	external num get octaves;
	external set octaves(num value);
	
	/// Defines the level of persistence (0.8 by default)
	external num get persistence;
	external set persistence(num value);
	
	/// Gets or sets animation speed factor (default is 1)
	external num get animationSpeedFactor;
	external set animationSpeedFactor(num value);
	
	/// Generate the current state of the procedural texture
	@override
	external void render([bool? useCameraPostProcess]);
	
	/// Serializes this noise procedural texture
	/// @returns a serialized noise procedural texture object
	@override
	external dynamic serialize();
	
	/// Clone the texture.
	/// @returns the cloned texture
	@override
	external NoiseProceduralTexture? clone();
	
	/// Creates a NoiseProceduralTexture from parsed noise procedural texture data
	/// @param parsedTexture defines parsed texture data
	/// @param scene defines the current scene
	/// @param rootUrl defines the root URL containing noise procedural texture information
	/// @returns a parsed NoiseProceduralTexture
	@override
	external static NoiseProceduralTexture? Parse(dynamic parsedTexture, Scene scene, [String? rootUrl]);
}

/// Raw cube texture where the raw buffers are passed in
@JS()
class RawCubeTexture extends CubeTexture {
	
	/// Creates a cube texture where the raw buffers are passed in.
	/// @param scene defines the scene the texture is attached to
	/// @param data defines the array of data to use to create each face
	/// @param size defines the size of the textures
	/// @param format defines the format of the data
	/// @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
	/// @param generateMipMaps  defines if the engine should generate the mip levels
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
	/// @param compression defines the compression used (null by default)
	external factory RawCubeTexture(Scene scene, List<dynamic>? data, num size, [num? format, num? type, bool? generateMipMaps, bool? invertY, num? samplingMode, String? compression]);
	
	/// Updates the raw cube texture.
	/// @param data defines the data to store
	/// @param format defines the data format
	/// @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
	/// @param invertY defines if data must be stored with Y axis inverted
	/// @param compression defines the compression used (null by default)
	/// @param level defines which level of the texture to update
	external void update(List<dynamic> data, num format, num type, bool invertY, [String? compression]);
	
	/// Updates a raw cube texture with RGBD encoded data.
	/// @param data defines the array of data [mipmap][face] to use to create each face
	/// @param sphericalPolynomial defines the spherical polynomial for irradiance
	/// @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
	/// @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
	/// @returns a promsie that resolves when the operation is complete
	external Promise<void> updateRGBDAsync(List<List<dynamic>> data, [SphericalPolynomial? sphericalPolynomial, num? lodScale, num? lodOffset]);
	
	/// Clones the raw cube texture.
	/// @return a new cube texture
	@override
	external CubeTexture? clone();
}

/// Class used to store 2D array textures containing user data
@JS()
class RawTexture2DArray extends Texture {
	
	/// Create a new RawTexture2DArray
	/// @param data defines the data of the texture
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @param depth defines the number of layers of the texture
	/// @param format defines the texture format to use
	/// @param scene defines the hosting scene
	/// @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
	/// @param invertY defines if texture must be stored with Y axis inverted
	/// @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
	/// @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
	external factory RawTexture2DArray(dynamic data, num width, num height, num depth, num format, Scene scene, [bool? generateMipMaps, bool? invertY, num? samplingMode, num? textureType]);
	
	/// Gets or sets the texture format to use
	external num get format;
	external set format(num value);
	
	/// Update the texture with new data
	/// @param data defines the data to store in the texture
	external void update(dynamic data);
}

/// Class used to store 3D textures containing user data
@JS()
class RawTexture3D extends Texture {
	
	/// Create a new RawTexture3D
	/// @param data defines the data of the texture
	/// @param width defines the width of the texture
	/// @param height defines the height of the texture
	/// @param depth defines the depth of the texture
	/// @param format defines the texture format to use
	/// @param scene defines the hosting scene
	/// @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
	/// @param invertY defines if texture must be stored with Y axis inverted
	/// @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
	/// @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
	external factory RawTexture3D(dynamic data, num width, num height, num depth, num format, Scene scene, [bool? generateMipMaps, bool? invertY, num? samplingMode, num? textureType]);
	
	/// Gets or sets the texture format to use
	external num get format;
	external set format(num value);
	
	/// Update the texture with new data
	/// @param data defines the data to store in the texture
	external void update(dynamic data);
}

/// Creates a refraction texture used by refraction channel of the standard material.
/// It is like a mirror but to see through a material.
/// @see https://doc.babylonjs.com/how_to/reflect#refraction
@JS()
class RefractionTexture extends RenderTargetTexture {
	
	/// Creates a refraction texture used by refraction channel of the standard material.
	/// It is like a mirror but to see through a material.
	/// @see https://doc.babylonjs.com/how_to/reflect#refraction
	/// @param name Define the texture name
	/// @param size Define the size of the underlying texture
	/// @param scene Define the scene the refraction belongs to
	/// @param generateMipMaps Define if we need to generate mips level for the refraction
	external factory RefractionTexture(String name, num size, Scene scene, [bool? generateMipMaps]);
	
	/// Define the reflection plane we want to use. The refractionPlane is usually set to the constructed refractor.
	/// It is possible to directly set the refractionPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the refractionPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the refractor as stated in the doc.
	/// @see https://doc.babylonjs.com/how_to/reflect#refraction
	external Plane get refractionPlane;
	external set refractionPlane(Plane value);
	
	/// Define how deep under the surface we should see.
	external num get depth;
	external set depth(num value);
	
	/// Clone the refraction texture.
	/// @returns the cloned texture
	@override
	external RefractionTexture? clone();
	
	/// Serialize the texture to a JSON representation you could use in Parse later on
	/// @returns the serialized JSON representation
	@override
	external dynamic serialize();
}

/// Block used to add support for vertex skinning (bones)
@JS()
class BonesBlock extends NodeMaterialBlock {
	
	/// Creates a new BonesBlock
	/// @param name defines the block name
	external factory BonesBlock(String name);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the matrix indices input component
	external NodeMaterialConnectionPoint get matricesIndices;
	
	/// Gets the matrix weights input component
	external NodeMaterialConnectionPoint get matricesWeights;
	
	/// Gets the extra matrix indices input component
	external NodeMaterialConnectionPoint get matricesIndicesExtra;
	
	/// Gets the extra matrix weights input component
	external NodeMaterialConnectionPoint get matricesWeightsExtra;
	
	/// Gets the world input component
	external NodeMaterialConnectionPoint get world;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void provideFallbacks(AbstractMesh mesh, EffectFallbacks fallbacks);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
}

/// Block used to add support for instances
/// @see https://doc.babylonjs.com/how_to/how_to_use_instances
@JS()
class InstancesBlock extends NodeMaterialBlock {
	
	/// Creates a new InstancesBlock
	/// @param name defines the block name
	external factory InstancesBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the first world row input component
	external NodeMaterialConnectionPoint get world0;
	
	/// Gets the second world row input component
	external NodeMaterialConnectionPoint get world1;
	
	/// Gets the third world row input component
	external NodeMaterialConnectionPoint get world2;
	
	/// Gets the forth world row input component
	external NodeMaterialConnectionPoint get world3;
	
	/// Gets the world input component
	external NodeMaterialConnectionPoint get world;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	/// Gets the isntanceID component
	external NodeMaterialConnectionPoint get instanceID;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
}

/// Block used to add morph targets support to vertex shader
@JS()
class MorphTargetsBlock extends NodeMaterialBlock {
	
	/// Create a new MorphTargetsBlock
	/// @param name defines the block name
	external factory MorphTargetsBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the position input component
	external NodeMaterialConnectionPoint get position;
	
	/// Gets the normal input component
	external NodeMaterialConnectionPoint get normal;
	
	/// Gets the tangent input component
	external NodeMaterialConnectionPoint get tangent;
	
	/// Gets the tangent input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the position output component
	external NodeMaterialConnectionPoint get positionOutput;
	
	/// Gets the normal output component
	external NodeMaterialConnectionPoint get normalOutput;
	
	/// Gets the tangent output component
	external NodeMaterialConnectionPoint get tangentOutput;
	
	/// Gets the tangent output component
	external NodeMaterialConnectionPoint get uvOutput;
	
	@override
	external void initialize(NodeMaterialBuildState state);
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external void replaceRepeatableContent(NodeMaterialBuildState vertexShaderState, NodeMaterialBuildState fragmentShaderState, AbstractMesh mesh, NodeMaterialDefines defines);
}

/// Block used to get data information from a light
@JS()
class LightInformationBlock extends NodeMaterialBlock {
	
	/// Creates a new LightInformationBlock
	/// @param name defines the block name
	external factory LightInformationBlock(String name);
	
	/// Gets or sets the light associated with this block
	external Light? get light;
	external set light(Light? value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the direction output component
	external NodeMaterialConnectionPoint get direction;
	
	/// Gets the direction output component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the direction output component
	external NodeMaterialConnectionPoint get intensity;
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external dynamic serialize();
}

/// Block used to add image processing support to fragment shader
@JS()
class ImageProcessingBlock extends NodeMaterialBlock {
	
	/// Create a new ImageProcessingBlock
	/// @param name defines the block name
	external factory ImageProcessingBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	@override
	external bool isReady(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances]);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
}

/// Block used to pertub normals based on a normal map
@JS()
class PerturbNormalBlock extends NodeMaterialBlock {
	
	/// Create a new PerturbNormalBlock
	/// @param name defines the block name
	external factory PerturbNormalBlock(String name);
	
	/// Gets or sets a boolean indicating that normal should be inverted on X axis
	external bool get invertX;
	external set invertX(bool value);
	
	/// Gets or sets a boolean indicating that normal should be inverted on Y axis
	external bool get invertY;
	external set invertY(bool value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the world normal input component
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the world tangent input component
	external NodeMaterialConnectionPoint get worldTangent;
	
	/// Gets the uv input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the normal map color input component
	external NodeMaterialConnectionPoint get normalMapColor;
	
	/// Gets the strength input component
	external NodeMaterialConnectionPoint get strength;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external dynamic serialize();
}

/// Block used to discard a pixel if a value is smaller than a cutoff
@JS()
class DiscardBlock extends NodeMaterialBlock {
	
	/// Create a new DiscardBlock
	/// @param name defines the block name
	external factory DiscardBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the cutoff input component
	external NodeMaterialConnectionPoint get cutoff;
}

/// Block used to test if the fragment shader is front facing
@JS()
class FrontFacingBlock extends NodeMaterialBlock {
	
	/// Creates a new FrontFacingBlock
	/// @param name defines the block name
	external factory FrontFacingBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the derivative value on x and y of a given input
@JS()
class DerivativeBlock extends NodeMaterialBlock {
	
	/// Create a new DerivativeBlock
	/// @param name defines the block name
	external factory DerivativeBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the derivative output on x
	external NodeMaterialConnectionPoint get dx;
	
	/// Gets the derivative output on y
	external NodeMaterialConnectionPoint get dy;
}

/// Block used to make gl_FragCoord available
@JS()
class FragCoordBlock extends NodeMaterialBlock {
	
	/// Creates a new FragCoordBlock
	/// @param name defines the block name
	external factory FragCoordBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the xy component
	external NodeMaterialConnectionPoint get xy;
	
	/// Gets the xyz component
	external NodeMaterialConnectionPoint get xyz;
	
	/// Gets the xyzw component
	external NodeMaterialConnectionPoint get xyzw;
	
	/// Gets the x component
	external NodeMaterialConnectionPoint get x;
	
	/// Gets the y component
	external NodeMaterialConnectionPoint get y;
	
	/// Gets the z component
	external NodeMaterialConnectionPoint get z;
	
	/// Gets the w component
	external NodeMaterialConnectionPoint get output;
	
	external String writeOutputs(NodeMaterialBuildState state);
}

/// Block used to get the screen sizes
@JS()
class ScreenSizeBlock extends NodeMaterialBlock {
	
	/// Creates a new ScreenSizeBlock
	/// @param name defines the block name
	external factory ScreenSizeBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the xy component
	external NodeMaterialConnectionPoint get xy;
	
	/// Gets the x component
	external NodeMaterialConnectionPoint get x;
	
	/// Gets the y component
	external NodeMaterialConnectionPoint get y;
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	external String writeOutputs(NodeMaterialBuildState state, String varName);
}

/// Block used to add support for scene fog
@JS()
class FogBlock extends NodeMaterialBlock {
	
	/// Create a new FogBlock
	/// @param name defines the block name
	external factory FogBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the view input component
	external NodeMaterialConnectionPoint get view;
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the fog color input component
	external NodeMaterialConnectionPoint get fogColor;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
}

/// Block used to add light in the fragment shader
@JS()
class LightBlock extends NodeMaterialBlock {
	
	/// Create a new LightBlock
	/// @param name defines the block name
	external factory LightBlock(String name);
	
	/// Gets or sets the light associated with this block
	external Light? get light;
	external set light(Light? value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the world normal input component
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the camera (or eye) position component
	external NodeMaterialConnectionPoint get cameraPosition;
	
	/// Gets the glossiness component
	external NodeMaterialConnectionPoint get glossiness;
	
	/// Gets the glossinness power component
	external NodeMaterialConnectionPoint get glossPower;
	
	/// Gets the diffuse color component
	external NodeMaterialConnectionPoint get diffuseColor;
	
	/// Gets the specular color component
	external NodeMaterialConnectionPoint get specularColor;
	
	/// Gets the view matrix component
	external NodeMaterialConnectionPoint get view;
	
	/// Gets the diffuse output component
	external NodeMaterialConnectionPoint get diffuseOutput;
	
	/// Gets the specular output component
	external NodeMaterialConnectionPoint get specularOutput;
	
	/// Gets the shadow output component
	external NodeMaterialConnectionPoint get shadow;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void updateUniformsAndSamples(NodeMaterialBuildState state, NodeMaterial nodeMaterial, NodeMaterialDefines defines, List<String> uniformBuffers);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external dynamic serialize();
}

/// Block used to read a reflection texture from a sampler
@JS()
class ReflectionTextureBlock extends ReflectionTextureBaseBlock {
	
	/// Create a new ReflectionTextureBlock
	/// @param name defines the block name
	external factory ReflectionTextureBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	@override
	external NodeMaterialConnectionPoint get position;
	
	/// Gets the world position input component
	@override
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the world normal input component
	@override
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the world input component
	@override
	external NodeMaterialConnectionPoint get world;
	
	/// Gets the camera (or eye) position component
	@override
	external NodeMaterialConnectionPoint get cameraPosition;
	
	/// Gets the view input component
	@override
	external NodeMaterialConnectionPoint get view;
	
	/// Gets the rgb output component
	external NodeMaterialConnectionPoint get rgb;
	
	/// Gets the rgba output component
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the r output component
	external NodeMaterialConnectionPoint get r;
	
	/// Gets the g output component
	external NodeMaterialConnectionPoint get g;
	
	/// Gets the b output component
	external NodeMaterialConnectionPoint get b;
	
	/// Gets the a output component
	external NodeMaterialConnectionPoint get a;
	
	@override
	external void autoConfigure(NodeMaterial material);
}

/// Block used to add 2 vectors
@JS()
class AddBlock extends NodeMaterialBlock {
	
	/// Creates a new AddBlock
	/// @param name defines the block name
	external factory AddBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to scale a vector by a float
@JS()
class ScaleBlock extends NodeMaterialBlock {
	
	/// Creates a new ScaleBlock
	/// @param name defines the block name
	external factory ScaleBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the factor input component
	external NodeMaterialConnectionPoint get factor;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to clamp a float
@JS()
class ClampBlock extends NodeMaterialBlock {
	
	/// Creates a new ClampBlock
	/// @param name defines the block name
	external factory ClampBlock(String name);
	
	/// Gets or sets the minimum range
	external num get minimum;
	external set minimum(num value);
	
	/// Gets or sets the maximum range
	external num get maximum;
	external set maximum(num value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external dynamic serialize();
}

/// Block used to apply a cross product between 2 vectors
@JS()
class CrossBlock extends NodeMaterialBlock {
	
	/// Creates a new CrossBlock
	/// @param name defines the block name
	external factory CrossBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to apply a dot product between 2 vectors
@JS()
class DotBlock extends NodeMaterialBlock {
	
	/// Creates a new DotBlock
	/// @param name defines the block name
	external factory DotBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to normalize a vector
@JS()
class NormalizeBlock extends NodeMaterialBlock {
	
	/// Creates a new NormalizeBlock
	/// @param name defines the block name
	external factory NormalizeBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to create a Color3/4 out of individual inputs (one for each component)
@JS()
class ColorMergerBlock extends NodeMaterialBlock {
	
	/// Create a new ColorMergerBlock
	/// @param name defines the block name
	external factory ColorMergerBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the rgb component (input)
	external NodeMaterialConnectionPoint get rgbIn;
	
	/// Gets the r component (input)
	external NodeMaterialConnectionPoint get r;
	
	/// Gets the g component (input)
	external NodeMaterialConnectionPoint get g;
	
	/// Gets the b component (input)
	external NodeMaterialConnectionPoint get b;
	
	/// Gets the a component (input)
	external NodeMaterialConnectionPoint get a;
	
	/// Gets the rgba component (output)
	external NodeMaterialConnectionPoint get rgba;
	
	/// Gets the rgb component (output)
	external NodeMaterialConnectionPoint get rgbOut;
	
	/// Gets the rgb component (output)
	/// @deprecated Please use rgbOut instead.
	external NodeMaterialConnectionPoint get rgb;
}

/// Block used to expand a Vector3/4 into 4 outputs (one for each component)
@JS()
class VectorSplitterBlock extends NodeMaterialBlock {
	
	/// Create a new VectorSplitterBlock
	/// @param name defines the block name
	external factory VectorSplitterBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the xyzw component (input)
	external NodeMaterialConnectionPoint get xyzw;
	
	/// Gets the xyz component (input)
	external NodeMaterialConnectionPoint get xyzIn;
	
	/// Gets the xy component (input)
	external NodeMaterialConnectionPoint get xyIn;
	
	/// Gets the xyz component (output)
	external NodeMaterialConnectionPoint get xyzOut;
	
	/// Gets the xy component (output)
	external NodeMaterialConnectionPoint get xyOut;
	
	/// Gets the x component (output)
	external NodeMaterialConnectionPoint get x;
	
	/// Gets the y component (output)
	external NodeMaterialConnectionPoint get y;
	
	/// Gets the z component (output)
	external NodeMaterialConnectionPoint get z;
	
	/// Gets the w component (output)
	external NodeMaterialConnectionPoint get w;
}

/// Block used to lerp between 2 values
@JS()
class LerpBlock extends NodeMaterialBlock {
	
	/// Creates a new LerpBlock
	/// @param name defines the block name
	external factory LerpBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the gradient operand input component
	external NodeMaterialConnectionPoint get gradient;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to divide 2 vectors
@JS()
class DivideBlock extends NodeMaterialBlock {
	
	/// Creates a new DivideBlock
	/// @param name defines the block name
	external factory DivideBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to subtract 2 vectors
@JS()
class SubtractBlock extends NodeMaterialBlock {
	
	/// Creates a new SubtractBlock
	/// @param name defines the block name
	external factory SubtractBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to step a value
@JS()
class StepBlock extends NodeMaterialBlock {
	
	/// Creates a new StepBlock
	/// @param name defines the block name
	external factory StepBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value operand input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the edge operand input component
	external NodeMaterialConnectionPoint get edge;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the opposite (1 - x) of a value
@JS()
class OneMinusBlock extends NodeMaterialBlock {
	
	/// Creates a new OneMinusBlock
	/// @param name defines the block name
	external factory OneMinusBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the view direction
@JS()
class ViewDirectionBlock extends NodeMaterialBlock {
	
	/// Creates a new ViewDirectionBlock
	/// @param name defines the block name
	external factory ViewDirectionBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the camera position component
	external NodeMaterialConnectionPoint get cameraPosition;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external void autoConfigure(NodeMaterial material);
}

/// Block used to compute fresnel value
@JS()
class FresnelBlock extends NodeMaterialBlock {
	
	/// Create a new FresnelBlock
	/// @param name defines the block name
	external factory FresnelBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world normal input component
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the view direction input component
	external NodeMaterialConnectionPoint get viewDirection;
	
	/// Gets the bias input component
	external NodeMaterialConnectionPoint get bias;
	
	/// Gets the camera (or eye) position component
	external NodeMaterialConnectionPoint get power;
	
	/// Gets the fresnel output component
	external NodeMaterialConnectionPoint get fresnel;
	
	@override
	external void autoConfigure(NodeMaterial material);
}

/// Block used to get the max of 2 values
@JS()
class MaxBlock extends NodeMaterialBlock {
	
	/// Creates a new MaxBlock
	/// @param name defines the block name
	external factory MaxBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the min of 2 values
@JS()
class MinBlock extends NodeMaterialBlock {
	
	/// Creates a new MinBlock
	/// @param name defines the block name
	external factory MinBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the distance between 2 values
@JS()
class DistanceBlock extends NodeMaterialBlock {
	
	/// Creates a new DistanceBlock
	/// @param name defines the block name
	external factory DistanceBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the length of a vector
@JS()
class LengthBlock extends NodeMaterialBlock {
	
	/// Creates a new LengthBlock
	/// @param name defines the block name
	external factory LengthBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get negative version of a value (i.e. x * -1)
@JS()
class NegateBlock extends NodeMaterialBlock {
	
	/// Creates a new NegateBlock
	/// @param name defines the block name
	external factory NegateBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the value of the first parameter raised to the power of the second
@JS()
class PowBlock extends NodeMaterialBlock {
	
	/// Creates a new PowBlock
	/// @param name defines the block name
	external factory PowBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value operand input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the power operand input component
	external NodeMaterialConnectionPoint get power;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get a random number
@JS()
class RandomNumberBlock extends NodeMaterialBlock {
	
	/// Creates a new RandomNumberBlock
	/// @param name defines the block name
	external factory RandomNumberBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the seed input component
	external NodeMaterialConnectionPoint get seed;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to compute arc tangent of 2 values
@JS()
class ArcTan2Block extends NodeMaterialBlock {
	
	/// Creates a new ArcTan2Block
	/// @param name defines the block name
	external factory ArcTan2Block(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the x operand input component
	external NodeMaterialConnectionPoint get x;
	
	/// Gets the y operand input component
	external NodeMaterialConnectionPoint get y;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to smooth step a value
@JS()
class SmoothStepBlock extends NodeMaterialBlock {
	
	/// Creates a new SmoothStepBlock
	/// @param name defines the block name
	external factory SmoothStepBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value operand input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the first edge operand input component
	external NodeMaterialConnectionPoint get edge0;
	
	/// Gets the second edge operand input component
	external NodeMaterialConnectionPoint get edge1;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the reciprocal (1 / x) of a value
@JS()
class ReciprocalBlock extends NodeMaterialBlock {
	
	/// Creates a new ReciprocalBlock
	/// @param name defines the block name
	external factory ReciprocalBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to replace a color by another one
@JS()
class ReplaceColorBlock extends NodeMaterialBlock {
	
	/// Creates a new ReplaceColorBlock
	/// @param name defines the block name
	external factory ReplaceColorBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the reference input component
	external NodeMaterialConnectionPoint get reference;
	
	/// Gets the distance input component
	external NodeMaterialConnectionPoint get distance;
	
	/// Gets the replacement input component
	external NodeMaterialConnectionPoint get replacement;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to posterize a value
/// @see https://en.wikipedia.org/wiki/Posterization
@JS()
class PosterizeBlock extends NodeMaterialBlock {
	
	/// Creates a new PosterizeBlock
	/// @param name defines the block name
	external factory PosterizeBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the value input component
	external NodeMaterialConnectionPoint get value;
	
	/// Gets the steps input component
	external NodeMaterialConnectionPoint get steps;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/* enum */
abstract class WaveBlockKind {
	
	/// SawTooth
	static const int SawTooth = 1;
	
	/// Square
	static const int Square = 2;
	
	/// Triangle
	static const int Triangle = 3;
}

/// Block used to apply wave operation to floats
@JS()
class WaveBlock extends NodeMaterialBlock {
	
	/// Creates a new WaveBlock
	/// @param name defines the block name
	external factory WaveBlock(String name);
	
	/// Gets or sets the kibnd of wave to be applied by the block
	external int get kind;
	external set kind(int value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input component
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external dynamic serialize();
}

/// Class used to store a color step for the GradientBlock
@JS()
class GradientBlockColorStep {
	
	/// Creates a new GradientBlockColorStep
	/// @param step defines a value indicating which step this color is associated with (between 0 and 1)
	/// @param color defines the color associated with this step
	external factory GradientBlockColorStep(num step, Color3 color);
	
	/// Gets value indicating which step this color is associated with (between 0 and 1)
	external num get step;
	
	/// Sets a value indicating which step this color is associated with (between 0 and 1)
	external set step(num value);
	
	/// Gets the color associated with this step
	external Color3 get color;
	
	/// Sets the color associated with this step
	external set color(Color3 value);
}

/// Block used to return a color from a gradient based on an input value between 0 and 1
@JS()
class GradientBlock extends NodeMaterialBlock {
	
	/// Creates a new GradientBlock
	/// @param name defines the block name
	external factory GradientBlock(String name);
	
	/// Gets or sets the list of color steps
	external List<GradientBlockColorStep> get colorSteps;
	external set colorSteps(List<GradientBlockColorStep> value);
	
	/// Gets an observable raised when the value is changed
	external Observable<GradientBlock> get onValueChangedObservable;
	external set onValueChangedObservable(Observable<GradientBlock> value);
	
	/// calls observable when the value is changed
	external void colorStepsUpdated();
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the gradient input component
	external NodeMaterialConnectionPoint get gradient;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external dynamic serialize();
}

/// Block used to normalize lerp between 2 values
@JS()
class NLerpBlock extends NodeMaterialBlock {
	
	/// Creates a new NLerpBlock
	/// @param name defines the block name
	external factory NLerpBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the gradient operand input component
	external NodeMaterialConnectionPoint get gradient;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// block used to Generate a Worley Noise 3D Noise Pattern
@JS()
class WorleyNoise3DBlock extends NodeMaterialBlock {
	
	/// Creates a new WorleyNoise3DBlock
	/// @param name defines the block name
	external factory WorleyNoise3DBlock(String name);
	
	/// Gets or sets a boolean indicating that normal should be inverted on X axis
	external bool get manhattanDistance;
	external set manhattanDistance(bool value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the seed input component
	external NodeMaterialConnectionPoint get seed;
	
	/// Gets the jitter input component
	external NodeMaterialConnectionPoint get jitter;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	/// Exposes the properties to the Seralize?
	@override
	external dynamic serialize();
}

/// block used to Generate a Simplex Perlin 3d Noise Pattern
@JS()
class SimplexPerlin3DBlock extends NodeMaterialBlock {
	
	/// Creates a new SimplexPerlin3DBlock
	/// @param name defines the block name
	external factory SimplexPerlin3DBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the seed operand input component
	external NodeMaterialConnectionPoint get seed;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to blend normals
@JS()
class NormalBlendBlock extends NodeMaterialBlock {
	
	/// Creates a new NormalBlendBlock
	/// @param name defines the block name
	external factory NormalBlendBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the first input component
	external NodeMaterialConnectionPoint get normalMap0;
	
	/// Gets the second input component
	external NodeMaterialConnectionPoint get normalMap1;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to rotate a 2d vector by a given angle
@JS()
class Rotate2dBlock extends NodeMaterialBlock {
	
	/// Creates a new Rotate2dBlock
	/// @param name defines the block name
	external factory Rotate2dBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the input vector
	external NodeMaterialConnectionPoint get input;
	
	/// Gets the input angle
	external NodeMaterialConnectionPoint get angle;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
	
	@override
	external void autoConfigure(NodeMaterial material);
}

/// Block used to get the reflected vector from a direction and a normal
@JS()
class ReflectBlock extends NodeMaterialBlock {
	
	/// Creates a new ReflectBlock
	/// @param name defines the block name
	external factory ReflectBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the incident component
	external NodeMaterialConnectionPoint get incident;
	
	/// Gets the normal component
	external NodeMaterialConnectionPoint get normal;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to get the refracted vector from a direction and a normal
@JS()
class RefractBlock extends NodeMaterialBlock {
	
	/// Creates a new RefractBlock
	/// @param name defines the block name
	external factory RefractBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the incident component
	external NodeMaterialConnectionPoint get incident;
	
	/// Gets the normal component
	external NodeMaterialConnectionPoint get normal;
	
	/// Gets the index of refraction component
	external NodeMaterialConnectionPoint get ior;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to desaturate a color
@JS()
class DesaturateBlock extends NodeMaterialBlock {
	
	/// Creates a new DesaturateBlock
	/// @param name defines the block name
	external factory DesaturateBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the color operand input component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the level operand input component
	external NodeMaterialConnectionPoint get level;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Block used to implement the reflection module of the PBR material
@JS()
class ReflectionBlock extends ReflectionTextureBaseBlock {
	
	/// Create a new ReflectionBlock
	/// @param name defines the block name
	external factory ReflectionBlock(String name);
	
	/// @hidden
	external NodeMaterialConnectionPoint get worldPositionConnectionPoint;
	external set worldPositionConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// @hidden
	external NodeMaterialConnectionPoint get worldNormalConnectionPoint;
	external set worldNormalConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// @hidden
	external NodeMaterialConnectionPoint get cameraPositionConnectionPoint;
	external set cameraPositionConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// @hidden
	external NodeMaterialConnectionPoint get viewConnectionPoint;
	external set viewConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// Defines if the material uses spherical harmonics vs spherical polynomials for the
	/// diffuse part of the IBL.
	external bool get useSphericalHarmonics;
	external set useSphericalHarmonics(bool value);
	
	/// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
	external bool get forceIrradianceInFragment;
	external set forceIrradianceInFragment(bool value);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the position input component
	@override
	external NodeMaterialConnectionPoint get position;
	
	/// Gets the world position input component
	@override
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the world normal input component
	@override
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the world input component
	@override
	external NodeMaterialConnectionPoint get world;
	
	/// Gets the camera (or eye) position component
	@override
	external NodeMaterialConnectionPoint get cameraPosition;
	
	/// Gets the view input component
	@override
	external NodeMaterialConnectionPoint get view;
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the reflection object output component
	external NodeMaterialConnectionPoint get reflection;
	
	/// Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)
	external bool get hasTexture;
	
	/// Gets the reflection color (either the name of the variable if the color input is connected, else a default value)
	external String get reflectionColor;
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	/// Gets the code to inject in the vertex shader
	/// @param state current state of the node material building
	/// @returns the shader code
	@override
	external String handleVertexSide(NodeMaterialBuildState state);
	
	/// Gets the main code of the block (fragment side)
	/// @param state current state of the node material building
	/// @param normalVarName name of the existing variable corresponding to the normal
	/// @returns the shader code
	external String getCode(NodeMaterialBuildState state, String normalVarName);
	
	@override
	external dynamic serialize();
}

/// Block used to implement the sheen module of the PBR material
@JS()
class SheenBlock extends NodeMaterialBlock {
	
	/// Create a new SheenBlock
	/// @param name defines the block name
	external factory SheenBlock(String name);
	
	/// If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.
	/// It allows the strength of the sheen effect to not depend on the base color of the material,
	/// making it easier to setup and tweak the effect
	external bool get albedoScaling;
	external set albedoScaling(bool value);
	
	/// Defines if the sheen is linked to the sheen color.
	external bool get linkSheenWithAlbedo;
	external set linkSheenWithAlbedo(bool value);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the intensity input component
	external NodeMaterialConnectionPoint get intensity;
	
	/// Gets the color input component
	external NodeMaterialConnectionPoint get color;
	
	/// Gets the roughness input component
	external NodeMaterialConnectionPoint get roughness;
	
	/// Gets the sheen object output component
	external NodeMaterialConnectionPoint get sheen;
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	/// Gets the main code of the block (fragment side)
	/// @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
	/// @returns the shader code
	external String getCode(ReflectionBlock? reflectionBlock);
	
	@override
	external dynamic serialize();
}

/// Block used to implement the anisotropy module of the PBR material
@JS()
class AnisotropyBlock extends NodeMaterialBlock {
	
	/// Create a new AnisotropyBlock
	/// @param name defines the block name
	external factory AnisotropyBlock(String name);
	
	/// @hidden
	external NodeMaterialConnectionPoint get worldPositionConnectionPoint;
	external set worldPositionConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// @hidden
	external NodeMaterialConnectionPoint get worldNormalConnectionPoint;
	external set worldNormalConnectionPoint(NodeMaterialConnectionPoint value);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the intensity input component
	external NodeMaterialConnectionPoint get intensity;
	
	/// Gets the direction input component
	external NodeMaterialConnectionPoint get direction;
	
	/// Gets the uv input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the worldTangent input component
	external NodeMaterialConnectionPoint get worldTangent;
	
	/// Gets the anisotropy object output component
	external NodeMaterialConnectionPoint get anisotropy;
	
	/// Gets the main code of the block (fragment side)
	/// @param state current state of the node material building
	/// @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated
	/// @returns the shader code
	external String getCode(NodeMaterialBuildState state, [bool? generateTBNSpace]);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
}

/// Block used to implement the clear coat module of the PBR material
@JS()
class ClearCoatBlock extends NodeMaterialBlock {
	
	/// Create a new ClearCoatBlock
	/// @param name defines the block name
	external factory ClearCoatBlock(String name);
	
	/// Defines if the F0 value should be remapped to account for the interface change in the material.
	external bool get remapF0OnInterfaceChange;
	external set remapF0OnInterfaceChange(bool value);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the intensity input component
	external NodeMaterialConnectionPoint get intensity;
	
	/// Gets the roughness input component
	external NodeMaterialConnectionPoint get roughness;
	
	/// Gets the ior input component
	external NodeMaterialConnectionPoint get indexOfRefraction;
	
	/// Gets the bump texture input component
	external NodeMaterialConnectionPoint get normalMapColor;
	
	/// Gets the uv input component
	external NodeMaterialConnectionPoint get uv;
	
	/// Gets the tint color input component
	external NodeMaterialConnectionPoint get tintColor;
	
	/// Gets the tint "at distance" input component
	external NodeMaterialConnectionPoint get tintAtDistance;
	
	/// Gets the tint thickness input component
	external NodeMaterialConnectionPoint get tintThickness;
	
	/// Gets the world tangent input component
	external NodeMaterialConnectionPoint get worldTangent;
	
	/// Gets the clear coat object output component
	external NodeMaterialConnectionPoint get clearcoat;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	/// Gets the main code of the block (fragment side)
	/// @param state current state of the node material building
	/// @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module
	/// @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
	/// @param worldPosVarName name of the variable holding the world position
	/// @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated
	/// @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)
	/// @param worldNormalVarName name of the variable holding the world normal
	/// @returns the shader code
	external static String GetCode(NodeMaterialBuildState state, ClearCoatBlock? ccBlock, ReflectionBlock? reflectionBlock, String worldPosVarName, bool generateTBNSpace, bool vTBNAvailable, String worldNormalVarName);
	
	@override
	external dynamic serialize();
}

/// Block used to implement the sub surface module of the PBR material
@JS()
class SubSurfaceBlock extends NodeMaterialBlock {
	
	/// Create a new SubSurfaceBlock
	/// @param name defines the block name
	external factory SubSurfaceBlock(String name);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the thickness component
	external NodeMaterialConnectionPoint get thickness;
	
	/// Gets the tint color input component
	external NodeMaterialConnectionPoint get tintColor;
	
	/// Gets the translucency intensity input component
	external NodeMaterialConnectionPoint get translucencyIntensity;
	
	/// Gets the translucency diffusion distance input component
	external NodeMaterialConnectionPoint get translucencyDiffusionDist;
	
	/// Gets the refraction object parameters
	external NodeMaterialConnectionPoint get refraction;
	
	/// Gets the sub surface object output component
	external NodeMaterialConnectionPoint get subsurface;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	/// Gets the main code of the block (fragment side)
	/// @param state current state of the node material building
	/// @param ssBlock instance of a SubSurfaceBlock or null if the code must be generated without an active sub surface module
	/// @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
	/// @param worldPosVarName name of the variable holding the world position
	/// @returns the shader code
	external static String GetCode(NodeMaterialBuildState state, SubSurfaceBlock? ssBlock, ReflectionBlock? reflectionBlock, String worldPosVarName);
}

/// Block used to implement the PBR metallic/roughness model
@JS()
class PBRMetallicRoughnessBlock extends NodeMaterialBlock {
	
	/// Create a new ReflectionBlock
	/// @param name defines the block name
	external factory PBRMetallicRoughnessBlock(String name);
	
	/// Gets or sets the light associated with this block
	external Light? get light;
	external set light(Light? value);
	
	/// Intensity of the direct lights e.g. the four lights available in your scene.
	/// This impacts both the direct diffuse and specular highlights.
	external num get directIntensity;
	external set directIntensity(num value);
	
	/// Intensity of the environment e.g. how much the environment will light the object
	/// either through harmonics for rough material or through the refelction for shiny ones.
	external num get environmentIntensity;
	external set environmentIntensity(num value);
	
	/// This is a special control allowing the reduction of the specular highlights coming from the
	/// four lights of the scene. Those highlights may not be needed in full environment lighting.
	external num get specularIntensity;
	external set specularIntensity(num value);
	
	/// Defines the  falloff type used in this material.
	/// It by default is Physical.
	external num get lightFalloff;
	external set lightFalloff(num value);
	
	/// Specifies that alpha test should be used
	external bool get useAlphaTest;
	external set useAlphaTest(bool value);
	
	/// Defines the alpha limits in alpha test mode.
	external num get alphaTestCutoff;
	external set alphaTestCutoff(num value);
	
	/// Specifies that alpha blending should be used
	external bool get useAlphaBlending;
	external set useAlphaBlending(bool value);
	
	/// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).
	/// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
	external bool get useRadianceOverAlpha;
	external set useRadianceOverAlpha(bool value);
	
	/// Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).
	/// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
	external bool get useSpecularOverAlpha;
	external set useSpecularOverAlpha(bool value);
	
	/// Enables specular anti aliasing in the PBR shader.
	/// It will both interacts on the Geometry for analytical and IBL lighting.
	/// It also prefilter the roughness map based on the bump values.
	external bool get enableSpecularAntiAliasing;
	external set enableSpecularAntiAliasing(bool value);
	
	/// Enables realtime filtering on the texture.
	external bool get realTimeFiltering;
	external set realTimeFiltering(bool value);
	
	/// Quality switch for realtime filtering
	external num get realTimeFilteringQuality;
	external set realTimeFilteringQuality(num value);
	
	/// Defines if the material uses energy conservation.
	external bool get useEnergyConservation;
	external set useEnergyConservation(bool value);
	
	/// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
	/// too much the area relying on ambient texture to define their ambient occlusion.
	external bool get useRadianceOcclusion;
	external set useRadianceOcclusion(bool value);
	
	/// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
	/// makes the reflect vector face the model (under horizon).
	external bool get useHorizonOcclusion;
	external set useHorizonOcclusion(bool value);
	
	/// If set to true, no lighting calculations will be applied.
	external bool get unlit;
	external set unlit(bool value);
	
	/// Force normal to face away from face.
	external bool get forceNormalForward;
	external set forceNormalForward(bool value);
	
	/// Defines the material debug mode.
	/// It helps seeing only some components of the material while troubleshooting.
	external num get debugMode;
	external set debugMode(num value);
	
	/// Specify from where on screen the debug mode should start.
	/// The value goes from -1 (full screen) to 1 (not visible)
	/// It helps with side by side comparison against the final render
	/// This defaults to 0
	external num get debugLimit;
	external set debugLimit(num value);
	
	/// As the default viewing range might not be enough (if the ambient is really small for instance)
	/// You can use the factor to better multiply the final value.
	external num get debugFactor;
	external set debugFactor(num value);
	
	/// Initialize the block and prepare the context for build
	/// @param state defines the state that will be used for the build
	@override
	external void initialize(NodeMaterialBuildState state);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the world position input component
	external NodeMaterialConnectionPoint get worldPosition;
	
	/// Gets the world normal input component
	external NodeMaterialConnectionPoint get worldNormal;
	
	/// Gets the view matrix parameter
	external NodeMaterialConnectionPoint get view;
	
	/// Gets the camera position input component
	external NodeMaterialConnectionPoint get cameraPosition;
	
	/// Gets the perturbed normal input component
	external NodeMaterialConnectionPoint get perturbedNormal;
	
	/// Gets the base color input component
	external NodeMaterialConnectionPoint get baseColor;
	
	/// Gets the metallic input component
	external NodeMaterialConnectionPoint get metallic;
	
	/// Gets the roughness input component
	external NodeMaterialConnectionPoint get roughness;
	
	/// Gets the ambient occlusion input component
	external NodeMaterialConnectionPoint get ambientOcc;
	
	/// Gets the opacity input component
	external NodeMaterialConnectionPoint get opacity;
	
	/// Gets the index of refraction input component
	external NodeMaterialConnectionPoint get indexOfRefraction;
	
	/// Gets the ambient color input component
	external NodeMaterialConnectionPoint get ambientColor;
	
	/// Gets the reflection object parameters
	external NodeMaterialConnectionPoint get reflection;
	
	/// Gets the clear coat object parameters
	external NodeMaterialConnectionPoint get clearcoat;
	
	/// Gets the sheen object parameters
	external NodeMaterialConnectionPoint get sheen;
	
	/// Gets the sub surface object parameters
	external NodeMaterialConnectionPoint get subsurface;
	
	/// Gets the anisotropy object parameters
	external NodeMaterialConnectionPoint get anisotropy;
	
	/// Gets the ambient output component
	external NodeMaterialConnectionPoint get ambientClr;
	
	/// Gets the diffuse output component
	external NodeMaterialConnectionPoint get diffuseDir;
	
	/// Gets the specular output component
	external NodeMaterialConnectionPoint get specularDir;
	
	/// Gets the clear coat output component
	external NodeMaterialConnectionPoint get clearcoatDir;
	
	/// Gets the sheen output component
	external NodeMaterialConnectionPoint get sheenDir;
	
	/// Gets the indirect diffuse output component
	external NodeMaterialConnectionPoint get diffuseIndirect;
	
	/// Gets the indirect specular output component
	external NodeMaterialConnectionPoint get specularIndirect;
	
	/// Gets the indirect clear coat output component
	external NodeMaterialConnectionPoint get clearcoatIndirect;
	
	/// Gets the indirect sheen output component
	external NodeMaterialConnectionPoint get sheenIndirect;
	
	/// Gets the refraction output component
	external NodeMaterialConnectionPoint get refraction;
	
	/// Gets the global lighting output component
	external NodeMaterialConnectionPoint get lighting;
	
	/// Gets the shadow output component
	external NodeMaterialConnectionPoint get shadow;
	
	/// Gets the alpha output component
	external NodeMaterialConnectionPoint get alpha;
	
	@override
	external void autoConfigure(NodeMaterial material);
	
	@override
	external void prepareDefines(AbstractMesh mesh, NodeMaterial nodeMaterial, NodeMaterialDefines defines, [bool? useInstances, SubMesh? subMesh]);
	
	@override
	external void updateUniformsAndSamples(NodeMaterialBuildState state, NodeMaterial nodeMaterial, NodeMaterialDefines defines, List<String> uniformBuffers);
	
	@override
	external void bind(Effect effect, NodeMaterial nodeMaterial, [Mesh? mesh, SubMesh? subMesh]);
	
	@override
	external dynamic serialize();
}

/// Block used to compute value of one parameter modulo another
@JS()
class ModBlock extends NodeMaterialBlock {
	
	/// Creates a new ModBlock
	/// @param name defines the block name
	external factory ModBlock(String name);
	
	/// Gets the current class name
	/// @returns the class name
	@override
	external String getClassName();
	
	/// Gets the left operand input component
	external NodeMaterialConnectionPoint get left;
	
	/// Gets the right operand input component
	external NodeMaterialConnectionPoint get right;
	
	/// Gets the output component
	external NodeMaterialConnectionPoint get output;
}

/// Configuration for Draco compression
@JS()
@anonymous
class IDracoCompressionConfiguration {
	
	external factory IDracoCompressionConfiguration({IDracoCompressionConfigurationDecoder decoder});
	
	/// Configuration for the decoder.
	external IDracoCompressionConfigurationDecoder get decoder;
	external set decoder( IDracoCompressionConfigurationDecoder value );
}

/// Draco compression (https://google.github.io/draco/)
/// 
/// This class wraps the Draco module.
/// 
/// **Encoder**
/// 
/// The encoder is not currently implemented.
/// 
/// **Decoder**
/// 
/// By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.
/// 
/// To update the configuration, use the following code:
/// ```javascript
/// DracoCompression.Configuration = {
/// decoder: {
/// wasmUrl: "<url to the WebAssembly library>",
/// wasmBinaryUrl: "<url to the WebAssembly binary>",
/// fallbackUrl: "<url to the fallback JavaScript library>",
/// }
/// };
/// ```
/// 
/// Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.
/// Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.
/// Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.
/// 
/// To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:
/// ```javascript
/// var vertexData = await DracoCompression.Default.decodeMeshAsync(data);
/// ```
/// 
/// @see https://www.babylonjs-playground.com/#N3EK4B#0
@JS()
class DracoCompression implements IDisposable {
	
	/// Constructor
	/// @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
	external factory DracoCompression([num? numWorkers]);
	
	/// The configuration. Defaults to the following urls:
	/// - wasmUrl: "https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js"
	/// - wasmBinaryUrl: "https://preview.babylonjs.com/draco_decoder_gltf.wasm"
	/// - fallbackUrl: "https://preview.babylonjs.com/draco_decoder_gltf.js"
	external static IDracoCompressionConfiguration get Configuration;
	external static set Configuration(IDracoCompressionConfiguration value);
	
	/// Returns true if the decoder configuration is available.
	external static bool get DecoderAvailable;
	
	/// Default number of workers to create when creating the draco compression object.
	external static num get DefaultNumWorkers;
	external static set DefaultNumWorkers(num value);
	
	/// Default instance for the draco compression object.
	external static DracoCompression get Default;
	
	/// Stop all async operations and release resources.
	@override
	external void dispose();
	
	/// Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.
	/// @returns a promise that resolves when ready
	external Promise<void> whenReadyAsync();
	
	/// Decode Draco compressed mesh data to vertex data.
	/// @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
	/// @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
	/// @returns A promise that resolves with the decoded vertex data
	external Promise<VertexData> decodeMeshAsync(dynamic data, [dynamic /* object */? attributes]);
}

/// Class for building Constructive Solid Geometry
@JS()
class CSG {
	external factory CSG();
	
	/// The world matrix
	external Matrix get matrix;
	external set matrix(Matrix value);
	
	/// Stores the position
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// Stores the rotation
	external Vector3 get rotation;
	external set rotation(Vector3 value);
	
	/// Stores the rotation quaternion
	external Quaternion? get rotationQuaternion;
	external set rotationQuaternion(Quaternion? value);
	
	/// Stores the scaling vector
	external Vector3 get scaling;
	external set scaling(Vector3 value);
	
	/// Convert the Mesh to CSG
	/// @param mesh The Mesh to convert to CSG
	/// @returns A new CSG from the Mesh
	external static CSG FromMesh(Mesh mesh);
	
	/// Clones, or makes a deep copy, of the CSG
	/// @returns A new CSG
	external CSG clone();
	
	/// Unions this CSG with another CSG
	/// @param csg The CSG to union against this CSG
	/// @returns The unioned CSG
	external CSG union(CSG csg);
	
	/// Unions this CSG with another CSG in place
	/// @param csg The CSG to union against this CSG
	external void unionInPlace(CSG csg);
	
	/// Subtracts this CSG with another CSG
	/// @param csg The CSG to subtract against this CSG
	/// @returns A new CSG
	external CSG subtract(CSG csg);
	
	/// Subtracts this CSG with another CSG in place
	/// @param csg The CSG to subtact against this CSG
	external void subtractInPlace(CSG csg);
	
	/// Intersect this CSG with another CSG
	/// @param csg The CSG to intersect against this CSG
	/// @returns A new CSG
	external CSG intersect(CSG csg);
	
	/// Intersects this CSG with another CSG in place
	/// @param csg The CSG to intersect against this CSG
	external void intersectInPlace(CSG csg);
	
	/// Return a new CSG solid with solid and empty space switched. This solid is
	/// not modified.
	/// @returns A new CSG solid with solid and empty space switched
	external CSG inverse();
	
	/// Inverses the CSG in place
	external void inverseInPlace();
	
	/// This is used to keep meshes transformations so they can be restored
	/// when we build back a Babylon Mesh
	/// NB : All CSG operations are performed in world coordinates
	/// @param csg The CSG to copy the transform attributes from
	/// @returns This CSG
	external CSG copyTransformAttributes(CSG csg);
	
	/// Build Raw mesh from CSG
	/// Coordinates here are in world space
	/// @param name The name of the mesh geometry
	/// @param scene The Scene
	/// @param keepSubMeshes Specifies if the submeshes should be kept
	/// @returns A new Mesh
	external Mesh buildMeshGeometry(String name, [Scene? scene, bool? keepSubMeshes]);
	
	/// Build Mesh from CSG taking material and transforms into account
	/// @param name The name of the Mesh
	/// @param material The material of the Mesh
	/// @param scene The Scene
	/// @param keepSubMeshes Specifies if submeshes should be kept
	/// @returns The new Mesh
	external Mesh toMesh(String name, [Material? material, Scene? scene, bool? keepSubMeshes]);
}

/// Class used to create a trail following a mesh
@JS()
class TrailMesh extends Mesh {
	
	/// @constructor
	/// @param name The value used by scene.getMeshByName() to do a lookup.
	/// @param generator The mesh or transform node to generate a trail.
	/// @param scene The scene to add this mesh to.
	/// @param diameter Diameter of trailing mesh. Default is 1.
	/// @param length Length of trailing mesh. Default is 60.
	/// @param autoStart Automatically start trailing mesh. Default true.
	external factory TrailMesh(String name, TransformNode generator, Scene scene, [num? diameter, num? length, bool? autoStart]);
	
	/// "TrailMesh"
	/// @returns "TrailMesh"
	@override
	external String getClassName();
	
	/// Start trailing mesh.
	external void start();
	
	/// Stop trailing mesh.
	external void stop();
	
	/// Update trailing mesh geometry.
	external void update();
	
	/// Returns a new TrailMesh object.
	/// @param name is a string, the name given to the new mesh
	/// @param newGenerator use new generator object for cloned trail mesh
	/// @returns a new mesh
	@override
	/* Manual Fix 22 */
	external TrailMesh? clone([String? name, Node? newGenerator, bool? doNotCloneChildren, bool? clonePhysicsImpostor]);
	
	/// Serializes this trail mesh
	/// @param serializationObject object to write serialization to
	@override
	external void serialize([dynamic? serializationObject]);
	
	/// Parses a serialized trail mesh
	/// @param parsedMesh the serialized mesh
	/// @param scene the scene to create the trail mesh in
	/// @returns the created trail mesh
	@override
	external static TrailMesh Parse(dynamic parsedMesh, Scene scene, [String? rootUrl]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class TiledBoxBuilder {
	external factory TiledBoxBuilder();
	
	/// Creates a box mesh
	/// faceTiles sets the pattern, tile size and number of tiles for a face     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
	/// * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the box mesh
	external static Mesh CreateTiledBox(String name, TiledBoxBuilderCreateTiledBoxOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class TorusKnotBuilder {
	external factory TorusKnotBuilder();
	
	/// Creates a torus knot mesh
	/// * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
	/// * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
	/// * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
	/// * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the torus knot mesh
	/// @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot
	external static Mesh CreateTorusKnot(String name, TorusKnotBuilderCreateTorusKnotOptions options, dynamic scene);
}

/// Polygon
/// @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon
@JS()
class Polygon {
	external factory Polygon();
	
	/// Creates a rectangle
	/// @param xmin bottom X coord
	/// @param ymin bottom Y coord
	/// @param xmax top X coord
	/// @param ymax top Y coord
	/// @returns points that make the resulting rectation
	external static List<Vector2> Rectangle(num xmin, num ymin, num xmax, num ymax);
	
	/// Creates a circle
	/// @param radius radius of circle
	/// @param cx scale in x
	/// @param cy scale in y
	/// @param numberOfSides number of sides that make up the circle
	/// @returns points that make the resulting circle
	external static List<Vector2> Circle(num radius, [num? cx, num? cy, num? numberOfSides]);
	
	/// Creates a polygon from input string
	/// @param input Input polygon data
	/// @returns the parsed points
	external static List<Vector2> Parse(String input);
	
	/// Starts building a polygon from x and y coordinates
	/// @param x x coordinate
	/// @param y y coordinate
	/// @returns the started path2
	external static Path2 StartingAt(num x, num y);
}

/// Builds a polygon
/// @see https://doc.babylonjs.com/how_to/polygonmeshbuilder
@JS()
class PolygonMeshBuilder {
	
	/// Creates a PolygonMeshBuilder
	/// @param name name of the builder
	/// @param contours Path of the polygon
	/// @param scene scene to add to when creating the mesh
	/// @param earcutInjection can be used to inject your own earcut reference
	external factory PolygonMeshBuilder(String name, dynamic contours, [Scene? scene, dynamic? earcutInjection]);
	
	/// Babylon reference to the earcut plugin.
	external dynamic get bjsEarcut;
	external set bjsEarcut(dynamic value);
	
	/// Adds a whole within the polygon
	/// @param hole Array of points defining the hole
	/// @returns this
	external PolygonMeshBuilder addHole(List<Vector2> hole);
	
	/// Creates the polygon
	/// @param updatable If the mesh should be updatable
	/// @param depth The depth of the mesh created
	/// @returns the created mesh
	external Mesh build([bool? updatable, num? depth]);
	
	/// Creates the polygon
	/// @param depth The depth of the mesh created
	/// @returns the created VertexData
	external VertexData buildVertexData([num? depth]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class PolygonBuilder {
	external factory PolygonBuilder();
	
	/// Creates a polygon mesh
	/// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
	/// * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
	/// * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
	/// * Remember you can only change the shape positions, not their number when updating a polygon
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @param earcutInjection can be used to inject your own earcut reference
	/// @returns the polygon mesh
	external static Mesh CreatePolygon(String name, PolygonBuilderCreatePolygonOptions options, [Scene? scene, dynamic? earcutInjection]);
	
	/// Creates an extruded polygon mesh, with depth in the Y direction.
	/// * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
	/// @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @param earcutInjection can be used to inject your own earcut reference
	/// @returns the polygon mesh
	external static Mesh ExtrudePolygon(String name, PolygonBuilderExtrudePolygonOptions options, [Scene? scene, dynamic? earcutInjection]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class LatheBuilder {
	external factory LatheBuilder();
	
	/// Creates lathe mesh.
	/// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
	/// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
	/// * The parameter `radius` (positive float, default 1) is the radius value of the lathe
	/// * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
	/// * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
	/// * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
	/// * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the lathe mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe
	external static Mesh CreateLathe(String name, LatheBuilderCreateLatheOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class TiledPlaneBuilder {
	external factory TiledPlaneBuilder();
	
	/// Creates a tiled plane mesh
	/// * The parameter `pattern` will, depending on value, do nothing or
	/// * * flip (reflect about central vertical) alternate tiles across and up
	/// * * flip every tile on alternate rows
	/// * * rotate (180 degs) alternate tiles across and up
	/// * * rotate every tile on alternate rows
	/// * * flip and rotate alternate tiles across and up
	/// * * flip and rotate every tile on alternate rows
	/// * The parameter `tileSize` sets the size (float) of each tile side (default 1)
	/// * You can set some different tile dimensions by using the parameters `tileWidth` and `tileHeight` (both by default have the same value of `tileSize`)
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
	/// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
	/// @see https://doc.babylonjs.com/how_to/set_shapes#box
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the box mesh
	external static Mesh CreateTiledPlane(String name, TiledPlaneBuilderCreateTiledPlaneOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class TubeBuilder {
	external factory TubeBuilder();
	
	/// Creates a tube mesh.
	/// The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
	/// * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
	/// * The parameter `radius` (positive float, default 1) sets the tube radius size
	/// * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
	/// * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
	/// * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
	/// * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the tube mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/set_shapes#tube
	external static Mesh CreateTube(String name, TubeBuilderCreateTubeOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class IcoSphereBuilder {
	external factory IcoSphereBuilder();
	
	/// Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
	/// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
	/// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
	/// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
	/// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the icosahedron mesh
	/// @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
	external static Mesh CreateIcoSphere(String name, IcoSphereBuilderCreateIcoSphereOptions options, [Scene? scene]);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class DecalBuilder {
	external factory DecalBuilder();
	
	/// Creates a decal mesh.
	/// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
	/// * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
	/// * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
	/// * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
	/// * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
	/// @param name defines the name of the mesh
	/// @param sourceMesh defines the mesh where the decal must be applied
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the decal mesh
	/// @see https://doc.babylonjs.com/how_to/decals
	external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, DecalBuilderCreateDecalOptions options);
}

/// Class containing static functions to help procedurally build meshes
@JS()
class MeshBuilder {
	external factory MeshBuilder();
	
	/// Creates a box mesh
	/// * The parameter `size` sets the size (float) of each box side (default 1)
	/// * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
	/// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
	/// * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @see https://doc.babylonjs.com/how_to/set_shapes#box
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the box mesh
	external static Mesh CreateBox(String name, MeshBuilderCreateBoxOptions options, [Scene? scene]);
	
	/// Creates a tiled box mesh
	/// * faceTiles sets the pattern, tile size and number of tiles for a face
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the tiled box mesh
	external static Mesh CreateTiledBox(String name, MeshBuilderCreateTiledBoxOptions options, [Scene? scene]);
	
	/// Creates a sphere mesh
	/// * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
	/// * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
	/// * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
	/// * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
	/// * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the sphere mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#sphere
	external static Mesh CreateSphere(String name, MeshBuilderCreateSphereOptions options, [Scene? scene]);
	
	/// Creates a plane polygonal mesh.  By default, this is a disc
	/// * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
	/// * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
	/// * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the plane polygonal mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
	external static Mesh CreateDisc(String name, MeshBuilderCreateDiscOptions options, [Scene? scene]);
	
	/// Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
	/// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
	/// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
	/// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
	/// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the icosahedron mesh
	/// @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
	external static Mesh CreateIcoSphere(String name, MeshBuilderCreateIcoSphereOptions options, [Scene? scene]);
	
	/// Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
	/// * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
	/// * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
	/// * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
	/// * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
	/// * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
	/// * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
	/// * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
	/// * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
	/// * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the ribbon mesh
	/// @see https://doc.babylonjs.com/how_to/ribbon_tutorial
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	external static Mesh CreateRibbon(String name, MeshBuilderCreateRibbonOptions options, [Scene? scene]);
	
	/// Creates a cylinder or a cone mesh
	/// * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
	/// * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
	/// * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
	/// * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
	/// * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
	/// * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
	/// * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
	/// * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).
	/// * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
	/// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
	/// * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
	/// * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
	/// * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
	/// * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
	/// * If `enclose` is false, a ring surface is one element.
	/// * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
	/// * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the cylinder mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
	external static Mesh CreateCylinder(String name, MeshBuilderCreateCylinderOptions options, [Scene? scene]);
	
	/// Creates a torus mesh
	/// * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
	/// * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
	/// * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the torus mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#torus
	external static Mesh CreateTorus(String name, MeshBuilderCreateTorusOptions options, [Scene? scene]);
	
	/// Creates a torus knot mesh
	/// * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
	/// * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
	/// * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
	/// * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the torus knot mesh
	/// @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot
	external static Mesh CreateTorusKnot(String name, MeshBuilderCreateTorusKnotOptions options, [Scene? scene]);
	
	/// Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
	/// * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
	/// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
	/// * The parameter `lines` is an array of lines, each line being an array of successive Vector3
	/// * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
	/// * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
	/// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
	/// * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
	/// * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system
	/// @param name defines the name of the new line system
	/// @param options defines the options used to create the line system
	/// @param scene defines the hosting scene
	/// @returns a new line system mesh
	external static LinesMesh CreateLineSystem(String name, MeshBuilderCreateLineSystemOptions options, Scene? scene);
	
	/// Creates a line mesh
	/// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
	/// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
	/// * The parameter `points` is an array successive Vector3
	/// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
	/// * The optional parameter `colors` is an array of successive Color4, one per line point
	/// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
	/// * When updating an instance, remember that only point positions can change, not the number of points
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#lines
	/// @param name defines the name of the new line system
	/// @param options defines the options used to create the line system
	/// @param scene defines the hosting scene
	/// @returns a new line mesh
	external static LinesMesh CreateLines(String name, MeshBuilderCreateLinesOptions options, [Scene? scene]);
	
	/// Creates a dashed line mesh
	/// * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
	/// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
	/// * The parameter `points` is an array successive Vector3
	/// * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
	/// * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
	/// * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
	/// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
	/// * When updating an instance, remember that only point positions can change, not the number of points
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the dashed line mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
	external static LinesMesh CreateDashedLines(String name, MeshBuilderCreateDashedLinesOptions options, [Scene? scene]);
	
	/// Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
	/// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
	/// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
	/// * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
	/// * The parameter `scale` (float, default 1) is the value to scale the shape.
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
	/// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the extruded shape mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
	external static Mesh ExtrudeShape(String name, MeshBuilderExtrudeShapeOptions options, [Scene? scene]);
	
	/// Creates an custom extruded shape mesh.
	/// The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
	/// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
	/// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
	/// * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
	/// * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
	/// * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
	/// * It must returns a float value that will be the scale value applied to the shape on each path point
	/// * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
	/// * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
	/// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the custom extruded shape mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
	external static Mesh ExtrudeShapeCustom(String name, MeshBuilderExtrudeShapeCustomOptions options, [Scene? scene]);
	
	/// Creates lathe mesh.
	/// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
	/// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
	/// * The parameter `radius` (positive float, default 1) is the radius value of the lathe
	/// * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
	/// * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
	/// * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
	/// * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the lathe mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe
	external static Mesh CreateLathe(String name, MeshBuilderCreateLatheOptions options, [Scene? scene]);
	
	/// Creates a tiled plane mesh
	/// * You can set a limited pattern arrangement with the tiles
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the plane mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#plane
	external static Mesh CreateTiledPlane(String name, MeshBuilderCreateTiledPlaneOptions options, [Scene? scene]);
	
	/// Creates a plane mesh
	/// * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
	/// * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
	/// * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the plane mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#plane
	external static Mesh CreatePlane(String name, MeshBuilderCreatePlaneOptions options, [Scene? scene]);
	
	/// Creates a ground mesh
	/// * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
	/// * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the ground mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#ground
	external static Mesh CreateGround(String name, MeshBuilderCreateGroundOptions options, [Scene? scene]);
	
	/// Creates a tiled ground mesh
	/// * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
	/// * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
	/// * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
	/// * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the tiled ground mesh
	/// @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground
	external static Mesh CreateTiledGround(String name, MeshBuilderCreateTiledGroundOptions options, [Scene? scene]);
	
	/// Creates a ground mesh from a height map
	/// * The parameter `url` sets the URL of the height map image resource.
	/// * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
	/// * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
	/// * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
	/// * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
	/// * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
	/// * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
	/// * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
	/// @param name defines the name of the mesh
	/// @param url defines the url to the height map
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the ground mesh
	/// @see https://doc.babylonjs.com/babylon101/height_map
	/// @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map
	external static GroundMesh CreateGroundFromHeightMap(String name, String url, MeshBuilderCreateGroundFromHeightMapOptions options, [Scene? scene]);
	
	/// Creates a polygon mesh
	/// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
	/// * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
	/// * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
	/// * Remember you can only change the shape positions, not their number when updating a polygon
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @param earcutInjection can be used to inject your own earcut reference
	/// @returns the polygon mesh
	external static Mesh CreatePolygon(String name, MeshBuilderCreatePolygonOptions options, [Scene? scene, dynamic? earcutInjection]);
	
	/// Creates an extruded polygon mesh, with depth in the Y direction.
	/// * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
	/// @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @param earcutInjection can be used to inject your own earcut reference
	/// @returns the polygon mesh
	external static Mesh ExtrudePolygon(String name, MeshBuilderExtrudePolygonOptions options, [Scene? scene, dynamic? earcutInjection]);
	
	/// Creates a tube mesh.
	/// The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
	/// * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
	/// * The parameter `radius` (positive float, default 1) sets the tube radius size
	/// * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
	/// * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
	/// * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
	/// * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
	/// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
	/// * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the tube mesh
	/// @see https://doc.babylonjs.com/how_to/parametric_shapes
	/// @see https://doc.babylonjs.com/how_to/set_shapes#tube
	external static Mesh CreateTube(String name, MeshBuilderCreateTubeOptions options, [Scene? scene]);
	
	/// Creates a polyhedron mesh
	/// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
	/// * The parameter `size` (positive float, default 1) sets the polygon size
	/// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
	/// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
	/// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
	/// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
	/// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
	/// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
	/// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
	/// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
	/// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
	/// @param name defines the name of the mesh
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the polyhedron mesh
	/// @see https://doc.babylonjs.com/how_to/polyhedra_shapes
	external static Mesh CreatePolyhedron(String name, MeshBuilderCreatePolyhedronOptions options, [Scene? scene]);
	
	/// Creates a decal mesh.
	/// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
	/// * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
	/// * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
	/// * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
	/// * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
	/// @param name defines the name of the mesh
	/// @param sourceMesh defines the mesh where the decal must be applied
	/// @param options defines the options used to create the mesh
	/// @param scene defines the hosting scene
	/// @returns the decal mesh
	/// @see https://doc.babylonjs.com/how_to/decals
	external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, MeshBuilderCreateDecalOptions options);
	
	/// Creates a Capsule Mesh
	/// @param name defines the name of the mesh.
	/// @param options the constructors options used to shape the mesh.
	/// @param scene defines the scene the mesh is scoped to.
	/// @returns the capsule mesh
	/// @see https://doc.babylonjs.com/how_to/capsule_shape
	external static Mesh CreateCapsule(String name, [ICreateCapsuleOptions? options, Scene? scene]);
}

/// A simplifier interface for future simplification implementations
/// @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
@JS()
abstract class ISimplifier {
	
	/// Simplification of a given mesh according to the given settings.
	/// Since this requires computation, it is assumed that the function runs async.
	/// @param settings The settings of the simplification, including quality and distance
	/// @param successCallback A callback that will be called after the mesh was simplified.
	/// @param errorCallback in case of an error, this callback will be called. optional.
	external void simplify(ISimplificationSettings settings, void Function(Mesh simplifiedMeshes) successCallback, [void Function()? errorCallback]);
}

/// Expected simplification settings.
/// Quality should be between 0 and 1 (1 being 100%, 0 being 0%)
/// @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
@JS()
abstract class ISimplificationSettings {
	
	/// Gets or sets the expected quality
	external num get quality;
	external set quality(num value);
	
	/// Gets or sets the distance when this optimized version should be used
	external num get distance;
	external set distance(num value);
	
	/// Gets an already optimized mesh
	external bool? get optimizeMesh;
	external set optimizeMesh(bool? value);
}

/// Class used to specify simplification options
/// @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
@JS()
class SimplificationSettings implements ISimplificationSettings {
	
	/// Creates a SimplificationSettings
	/// @param quality expected quality
	/// @param distance distance when this optimized version should be used
	/// @param optimizeMesh already optimized mesh
	external factory SimplificationSettings(num quality, num distance, [bool? optimizeMesh]);
	
	/// expected quality
	@override
	external num get quality;
	@override
	external set quality(num value);
	
	/// distance when this optimized version should be used
	@override
	external num get distance;
	@override
	external set distance(num value);
	
	/// already optimized mesh
	@override
	external bool? get optimizeMesh;
	@override
	external set optimizeMesh(bool? value);
}

/// Interface used to define a simplification task
@JS()
@anonymous
class ISimplificationTask {
	
	external factory ISimplificationTask({List<ISimplificationSettings> settings, int simplificationType, Mesh mesh, void Function() successCallback, bool parallelProcessing});
	
	/// Array of settings
	external List<ISimplificationSettings> get settings;
	external set settings( List<ISimplificationSettings> value );
	
	/// Simplification type
	external int get simplificationType;
	external set simplificationType( int value );
	
	/// Mesh to simplify
	external Mesh get mesh;
	external set mesh( Mesh value );
	
	/// Callback called on success
	external void Function() get successCallback;
	external set successCallback( void Function() value );
	
	/// Defines if parallel processing can be used
	external bool get parallelProcessing;
	external set parallelProcessing( bool value );
}

/// Queue used to order the simplification tasks
/// @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
@JS()
class SimplificationQueue {
	
	/// Creates a new queue
	external factory SimplificationQueue();
	
	/// Gets a boolean indicating that the process is still running
	external bool get running;
	external set running(bool value);
	
	/// Adds a new simplification task
	/// @param task defines a task to add
	external void addTask(ISimplificationTask task);
	
	/// Execute next task
	external void executeNext();
	
	/// Execute a simplification task
	/// @param task defines the task to run
	external void runSimplification(ISimplificationTask task);
}

/* enum */
abstract class SimplificationType {
	
	/// Quadratic error decimation
	static const int QUADRATIC = 1;
}

/// An implementation of the Quadratic Error simplification algorithm.
/// Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
/// Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
/// @author RaananW
/// @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
@JS()
class QuadraticErrorSimplification implements ISimplifier {
	
	/// Creates a new QuadraticErrorSimplification
	/// @param _mesh defines the target mesh
	external factory QuadraticErrorSimplification(Mesh _mesh);
	
	/// Gets or sets the number pf sync interations
	external num get syncIterations;
	external set syncIterations(num value);
	
	/// Gets or sets the aggressiveness of the simplifier
	external num get aggressiveness;
	external set aggressiveness(num value);
	
	/// Gets or sets the number of allowed iterations for decimation
	external num get decimationIterations;
	external set decimationIterations(num value);
	
	/// Gets or sets the espilon to use for bounding box computation
	external num get boundingBoxEpsilon;
	external set boundingBoxEpsilon(num value);
	
	/// Simplification of a given mesh according to the given settings.
	/// Since this requires computation, it is assumed that the function runs async.
	/// @param settings The settings of the simplification, including quality and distance
	/// @param successCallback A callback that will be called after the mesh was simplified.
	@override
	external void simplify(ISimplificationSettings settings, void Function(Mesh simplifiedMesh) successCallback, [void Function()? errorCallback]);
}

/// Defines the simplification queue scene component responsible to help scheduling the various simplification task
/// created in a scene
@JS()
class SimplicationQueueSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory SimplicationQueueSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/// Navigation plugin interface to add navigation constrained by a navigation mesh
@JS()
abstract class INavigationEnginePlugin {
	
	/// plugin name
	external String get name;
	external set name(String value);
	
	/// Creates a navigation mesh
	/// @param meshes array of all the geometry used to compute the navigatio mesh
	/// @param parameters bunch of parameters used to filter geometry
	external void createNavMesh(List<Mesh> meshes, INavMeshParameters parameters);
	
	/// Create a navigation mesh debug mesh
	/// @param scene is where the mesh will be added
	/// @returns debug display mesh
	external Mesh createDebugNavMesh(Scene scene);
	
	/// Get a navigation mesh constrained position, closest to the parameter position
	/// @param position world position
	/// @returns the closest point to position constrained by the navigation mesh
	external Vector3 getClosestPoint(Vector3 position);
	
	/// Get a navigation mesh constrained position, closest to the parameter position
	/// @param position world position
	/// @param result output the closest point to position constrained by the navigation mesh
	external void getClosestPointToRef(Vector3 position, Vector3 result);
	
	/// Get a navigation mesh constrained position, within a particular radius
	/// @param position world position
	/// @param maxRadius the maximum distance to the constrained world position
	/// @returns the closest point to position constrained by the navigation mesh
	external Vector3 getRandomPointAround(Vector3 position, num maxRadius);
	
	/// Get a navigation mesh constrained position, within a particular radius
	/// @param position world position
	/// @param maxRadius the maximum distance to the constrained world position
	/// @param result output the closest point to position constrained by the navigation mesh
	external void getRandomPointAroundToRef(Vector3 position, num maxRadius, Vector3 result);
	
	/// Compute the final position from a segment made of destination-position
	/// @param position world position
	/// @param destination world position
	/// @returns the resulting point along the navmesh
	external Vector3 moveAlong(Vector3 position, Vector3 destination);
	
	/// Compute the final position from a segment made of destination-position
	/// @param position world position
	/// @param destination world position
	/// @param result output the resulting point along the navmesh
	external void moveAlongToRef(Vector3 position, Vector3 destination, Vector3 result);
	
	/// Compute a navigation path from start to end. Returns an empty array if no path can be computed
	/// @param start world position
	/// @param end world position
	/// @returns array containing world position composing the path
	external List<Vector3> computePath(Vector3 start, Vector3 end);
	
	/// If this plugin is supported
	/// @returns true if plugin is supported
	external bool isSupported();
	
	/// Create a new Crowd so you can add agents
	/// @param maxAgents the maximum agent count in the crowd
	/// @param maxAgentRadius the maximum radius an agent can have
	/// @param scene to attach the crowd to
	/// @returns the crowd you can add agents to
	external ICrowd createCrowd(num maxAgents, num maxAgentRadius, Scene scene);
	
	/// Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
	/// The queries will try to find a solution within those bounds
	/// default is (1,1,1)
	/// @param extent x,y,z value that define the extent around the queries point of reference
	external void setDefaultQueryExtent(Vector3 extent);
	
	/// Get the Bounding box extent specified by setDefaultQueryExtent
	/// @returns the box extent values
	external Vector3 getDefaultQueryExtent();
	
	/// build the navmesh from a previously saved state using getNavmeshData
	/// @param data the Uint8Array returned by getNavmeshData
	external void buildFromNavmeshData(Uint8List data);
	
	/// returns the navmesh data that can be used later. The navmesh must be built before retrieving the data
	/// @returns data the Uint8Array that can be saved and reused
	external Uint8List getNavmeshData();
	
	/// Get the Bounding box extent result specified by setDefaultQueryExtent
	/// @param result output the box extent values
	external void getDefaultQueryExtentToRef(Vector3 result);
	
	/// Set the time step of the navigation tick update.
	/// Default is 1/60.
	/// A value of 0 will disable fixed time update
	/// @param newTimeStep the new timestep to apply to this world.
	external void setTimeStep(num newTimeStep);
	
	/// Get the time step of the navigation tick update.
	/// @returns the current time step
	external num getTimeStep();
	
	/// If delta time in navigation tick update is greater than the time step
	/// a number of sub iterations are done. If more iterations are need to reach deltatime
	/// they will be discarded.
	/// A value of 0 will set to no maximum and update will use as many substeps as needed
	/// @param newStepCount the maximum number of iterations
	external void setMaximumSubStepCount(num newStepCount);
	
	/// Get the maximum number of iterations per navigation tick update
	/// @returns the maximum number of iterations
	external num getMaximumSubStepCount();
	
	/// Release all resources
	external void dispose();
}

/// Crowd Interface. A Crowd is a collection of moving agents constrained by a navigation mesh
@JS()
abstract class ICrowd {
	
	/// Add a new agent to the crowd with the specified parameter a corresponding transformNode.
	/// You can attach anything to that node. The node position is updated in the scene update tick.
	/// @param pos world position that will be constrained by the navigation mesh
	/// @param parameters agent parameters
	/// @param transform hooked to the agent that will be update by the scene
	/// @returns agent index
	external num addAgent(Vector3 pos, IAgentParameters parameters, TransformNode transform);
	
	/// Returns the agent position in world space
	/// @param index agent index returned by addAgent
	/// @returns world space position
	external Vector3 getAgentPosition(num index);
	
	/// Gets the agent position result in world space
	/// @param index agent index returned by addAgent
	/// @param result output world space position
	external void getAgentPositionToRef(num index, Vector3 result);
	
	/// Gets the agent velocity in world space
	/// @param index agent index returned by addAgent
	/// @returns world space velocity
	external Vector3 getAgentVelocity(num index);
	
	/// Gets the agent velocity result in world space
	/// @param index agent index returned by addAgent
	/// @param result output world space velocity
	external void getAgentVelocityToRef(num index, Vector3 result);
	
	/// Gets the agent next target point on the path
	/// @param index agent index returned by addAgent
	/// @returns world space position
	external Vector3 getAgentNextTargetPath(num index);
	
	/// Gets the agent state
	/// @param index agent index returned by addAgent
	/// @returns agent state
	external num getAgentState(num index);
	
	/// returns true if the agent in over an off mesh link connection
	/// @param index agent index returned by addAgent
	/// @returns true if over an off mesh link connection
	external bool overOffmeshConnection(num index);
	
	/// Gets the agent next target point on the path
	/// @param index agent index returned by addAgent
	/// @param result output world space position
	external void getAgentNextTargetPathToRef(num index, Vector3 result);
	
	/// remove a particular agent previously created
	/// @param index agent index returned by addAgent
	external void removeAgent(num index);
	
	/// get the list of all agents attached to this crowd
	/// @returns list of agent indices
	external List<num> getAgents();
	
	/// Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function
	/// @param deltaTime in seconds
	external void update(num deltaTime);
	
	/// Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh
	/// @param index agent index returned by addAgent
	/// @param destination targeted world position
	external void agentGoto(num index, Vector3 destination);
	
	/// Teleport the agent to a new position
	/// @param index agent index returned by addAgent
	/// @param destination targeted world position
	external void agentTeleport(num index, Vector3 destination);
	
	/// Update agent parameters
	/// @param index agent index returned by addAgent
	/// @param parameters agent parameters
	external void updateAgentParameters(num index, IAgentParameters parameters);
	
	/// Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
	/// The queries will try to find a solution within those bounds
	/// default is (1,1,1)
	/// @param extent x,y,z value that define the extent around the queries point of reference
	external void setDefaultQueryExtent(Vector3 extent);
	
	/// Get the Bounding box extent specified by setDefaultQueryExtent
	/// @returns the box extent values
	external Vector3 getDefaultQueryExtent();
	
	/// Get the Bounding box extent result specified by setDefaultQueryExtent
	/// @param result output the box extent values
	external void getDefaultQueryExtentToRef(Vector3 result);
	
	/// Release all resources
	external void dispose();
}

/// Configures an agent
@JS()
@anonymous
class IAgentParameters {
	
	external factory IAgentParameters({num radius, num height, num maxAcceleration, num maxSpeed, num collisionQueryRange, num pathOptimizationRange, num separationWeight});
	
	/// Agent radius. [Limit: >= 0]
	external num get radius;
	external set radius( num value );
	
	/// Agent height. [Limit: > 0]
	external num get height;
	external set height( num value );
	
	/// Maximum allowed acceleration. [Limit: >= 0]
	external num get maxAcceleration;
	external set maxAcceleration( num value );
	
	/// Maximum allowed speed. [Limit: >= 0]
	external num get maxSpeed;
	external set maxSpeed( num value );
	
	/// Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]
	external num get collisionQueryRange;
	external set collisionQueryRange( num value );
	
	/// The path visibility optimization range. [Limit: > 0]
	external num get pathOptimizationRange;
	external set pathOptimizationRange( num value );
	
	/// How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]
	external num get separationWeight;
	external set separationWeight( num value );
}

/// Configures the navigation mesh creation
@JS()
@anonymous
class INavMeshParameters {
	
	external factory INavMeshParameters({num cs, num ch, num walkableSlopeAngle, num walkableHeight, num walkableClimb, num walkableRadius, num maxEdgeLen, num maxSimplificationError, num minRegionArea, num mergeRegionArea, num maxVertsPerPoly, num detailSampleDist, num detailSampleMaxError});
	
	/// The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]
	external num get cs;
	external set cs( num value );
	
	/// The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
	external num get ch;
	external set ch( num value );
	
	/// The maximum slope that is considered walkable. [Limits: 0 <= value < 90] [Units: Degrees]
	external num get walkableSlopeAngle;
	external set walkableSlopeAngle( num value );
	
	/// Minimum floor to 'ceiling' height that will still allow the floor area to
	/// be considered walkable. [Limit: >= 3] [Units: vx]
	external num get walkableHeight;
	external set walkableHeight( num value );
	
	/// Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]
	external num get walkableClimb;
	external set walkableClimb( num value );
	
	/// The distance to erode/shrink the walkable area of the heightfield away from
	/// obstructions.  [Limit: >=0] [Units: vx]
	external num get walkableRadius;
	external set walkableRadius( num value );
	
	/// The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]
	external num get maxEdgeLen;
	external set maxEdgeLen( num value );
	
	/// The maximum distance a simplfied contour's border edges should deviate
	/// the original raw contour. [Limit: >=0] [Units: vx]
	external num get maxSimplificationError;
	external set maxSimplificationError( num value );
	
	/// The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]
	external num get minRegionArea;
	external set minRegionArea( num value );
	
	/// Any regions with a span count smaller than this value will, if possible,
	/// be merged with larger regions. [Limit: >=0] [Units: vx]
	external num get mergeRegionArea;
	external set mergeRegionArea( num value );
	
	/// The maximum number of vertices allowed for polygons generated during the
	/// contour to polygon conversion process. [Limit: >= 3]
	external num get maxVertsPerPoly;
	external set maxVertsPerPoly( num value );
	
	/// Sets the sampling distance to use when generating the detail mesh.
	/// (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]
	external num get detailSampleDist;
	external set detailSampleDist( num value );
	
	/// The maximum distance the detail mesh surface should deviate from heightfield
	/// data. (For height detail only.) [Limit: >=0] [Units: wu]
	external num get detailSampleMaxError;
	external set detailSampleMaxError( num value );
}

/// RecastJS navigation plugin
@JS()
class RecastJSPlugin implements INavigationEnginePlugin {
	
	/// Initializes the recastJS plugin
	/// @param recastInjection can be used to inject your own recast reference
	external factory RecastJSPlugin([dynamic? recastInjection]);
	
	/// Reference to the Recast library
	external dynamic get bjsRECAST;
	external set bjsRECAST(dynamic value);
	
	/// plugin name
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// the first navmesh created. We might extend this to support multiple navmeshes
	external dynamic get navMesh;
	external set navMesh(dynamic value);
	
	/// Set the time step of the navigation tick update.
	/// Default is 1/60.
	/// A value of 0 will disable fixed time update
	/// @param newTimeStep the new timestep to apply to this world.
	@override
	external void setTimeStep([num? newTimeStep]);
	
	/// Get the time step of the navigation tick update.
	/// @returns the current time step
	@override
	external num getTimeStep();
	
	/// If delta time in navigation tick update is greater than the time step
	/// a number of sub iterations are done. If more iterations are need to reach deltatime
	/// they will be discarded.
	/// A value of 0 will set to no maximum and update will use as many substeps as needed
	/// @param newStepCount the maximum number of iterations
	@override
	external void setMaximumSubStepCount([num? newStepCount]);
	
	/// Get the maximum number of iterations per navigation tick update
	/// @returns the maximum number of iterations
	@override
	external num getMaximumSubStepCount();
	
	/// Creates a navigation mesh
	/// @param meshes array of all the geometry used to compute the navigatio mesh
	/// @param parameters bunch of parameters used to filter geometry
	@override
	external void createNavMesh(List<Mesh> meshes, INavMeshParameters parameters);
	
	/// Create a navigation mesh debug mesh
	/// @param scene is where the mesh will be added
	/// @returns debug display mesh
	@override
	external Mesh createDebugNavMesh(Scene scene);
	
	/// Get a navigation mesh constrained position, closest to the parameter position
	/// @param position world position
	/// @returns the closest point to position constrained by the navigation mesh
	@override
	external Vector3 getClosestPoint(Vector3 position);
	
	/// Get a navigation mesh constrained position, closest to the parameter position
	/// @param position world position
	/// @param result output the closest point to position constrained by the navigation mesh
	@override
	external void getClosestPointToRef(Vector3 position, Vector3 result);
	
	/// Get a navigation mesh constrained position, within a particular radius
	/// @param position world position
	/// @param maxRadius the maximum distance to the constrained world position
	/// @returns the closest point to position constrained by the navigation mesh
	@override
	external Vector3 getRandomPointAround(Vector3 position, num maxRadius);
	
	/// Get a navigation mesh constrained position, within a particular radius
	/// @param position world position
	/// @param maxRadius the maximum distance to the constrained world position
	/// @param result output the closest point to position constrained by the navigation mesh
	@override
	external void getRandomPointAroundToRef(Vector3 position, num maxRadius, Vector3 result);
	
	/// Compute the final position from a segment made of destination-position
	/// @param position world position
	/// @param destination world position
	/// @returns the resulting point along the navmesh
	@override
	external Vector3 moveAlong(Vector3 position, Vector3 destination);
	
	/// Compute the final position from a segment made of destination-position
	/// @param position world position
	/// @param destination world position
	/// @param result output the resulting point along the navmesh
	@override
	external void moveAlongToRef(Vector3 position, Vector3 destination, Vector3 result);
	
	/// Compute a navigation path from start to end. Returns an empty array if no path can be computed
	/// @param start world position
	/// @param end world position
	/// @returns array containing world position composing the path
	@override
	external List<Vector3> computePath(Vector3 start, Vector3 end);
	
	/// Create a new Crowd so you can add agents
	/// @param maxAgents the maximum agent count in the crowd
	/// @param maxAgentRadius the maximum radius an agent can have
	/// @param scene to attach the crowd to
	/// @returns the crowd you can add agents to
	@override
	external ICrowd createCrowd(num maxAgents, num maxAgentRadius, Scene scene);
	
	/// Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
	/// The queries will try to find a solution within those bounds
	/// default is (1,1,1)
	/// @param extent x,y,z value that define the extent around the queries point of reference
	@override
	external void setDefaultQueryExtent(Vector3 extent);
	
	/// Get the Bounding box extent specified by setDefaultQueryExtent
	/// @returns the box extent values
	@override
	external Vector3 getDefaultQueryExtent();
	
	/// build the navmesh from a previously saved state using getNavmeshData
	/// @param data the Uint8Array returned by getNavmeshData
	@override
	external void buildFromNavmeshData(Uint8List data);
	
	/// returns the navmesh data that can be used later. The navmesh must be built before retrieving the data
	/// @returns data the Uint8Array that can be saved and reused
	@override
	external Uint8List getNavmeshData();
	
	/// Get the Bounding box extent result specified by setDefaultQueryExtent
	/// @param result output the box extent values
	@override
	external void getDefaultQueryExtentToRef(Vector3 result);
	
	/// Disposes
	@override
	external void dispose();
	
	/// If this plugin is supported
	/// @returns true if plugin is supported
	@override
	external bool isSupported();
}

/// Recast detour crowd implementation
@JS()
class RecastJSCrowd implements ICrowd {
	
	/// Constructor
	/// @param plugin recastJS plugin
	/// @param maxAgents the maximum agent count in the crowd
	/// @param maxAgentRadius the maximum radius an agent can have
	/// @param scene to attach the crowd to
	/// @returns the crowd you can add agents to
	external factory RecastJSCrowd(RecastJSPlugin plugin, num maxAgents, num maxAgentRadius, Scene scene);
	
	/// Recast/detour plugin
	external RecastJSPlugin get bjsRECASTPlugin;
	external set bjsRECASTPlugin(RecastJSPlugin value);
	
	/// Link to the detour crowd
	external dynamic get recastCrowd;
	external set recastCrowd(dynamic value);
	
	/// One transform per agent
	external List<TransformNode> get transforms;
	external set transforms(List<TransformNode> value);
	
	/// All agents created
	external List<num> get agents;
	external set agents(List<num> value);
	
	/// Add a new agent to the crowd with the specified parameter a corresponding transformNode.
	/// You can attach anything to that node. The node position is updated in the scene update tick.
	/// @param pos world position that will be constrained by the navigation mesh
	/// @param parameters agent parameters
	/// @param transform hooked to the agent that will be update by the scene
	/// @returns agent index
	@override
	external num addAgent(Vector3 pos, IAgentParameters parameters, TransformNode transform);
	
	/// Returns the agent position in world space
	/// @param index agent index returned by addAgent
	/// @returns world space position
	@override
	external Vector3 getAgentPosition(num index);
	
	/// Returns the agent position result in world space
	/// @param index agent index returned by addAgent
	/// @param result output world space position
	@override
	external void getAgentPositionToRef(num index, Vector3 result);
	
	/// Returns the agent velocity in world space
	/// @param index agent index returned by addAgent
	/// @returns world space velocity
	@override
	external Vector3 getAgentVelocity(num index);
	
	/// Returns the agent velocity result in world space
	/// @param index agent index returned by addAgent
	/// @param result output world space velocity
	@override
	external void getAgentVelocityToRef(num index, Vector3 result);
	
	/// Returns the agent next target point on the path
	/// @param index agent index returned by addAgent
	/// @returns world space position
	@override
	external Vector3 getAgentNextTargetPath(num index);
	
	/// Returns the agent next target point on the path
	/// @param index agent index returned by addAgent
	/// @param result output world space position
	@override
	external void getAgentNextTargetPathToRef(num index, Vector3 result);
	
	/// Gets the agent state
	/// @param index agent index returned by addAgent
	/// @returns agent state
	@override
	external num getAgentState(num index);
	
	/// returns true if the agent in over an off mesh link connection
	/// @param index agent index returned by addAgent
	/// @returns true if over an off mesh link connection
	@override
	external bool overOffmeshConnection(num index);
	
	/// Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh
	/// @param index agent index returned by addAgent
	/// @param destination targeted world position
	@override
	external void agentGoto(num index, Vector3 destination);
	
	/// Teleport the agent to a new position
	/// @param index agent index returned by addAgent
	/// @param destination targeted world position
	@override
	external void agentTeleport(num index, Vector3 destination);
	
	/// Update agent parameters
	/// @param index agent index returned by addAgent
	/// @param parameters agent parameters
	@override
	external void updateAgentParameters(num index, IAgentParameters parameters);
	
	/// remove a particular agent previously created
	/// @param index agent index returned by addAgent
	@override
	external void removeAgent(num index);
	
	/// get the list of all agents attached to this crowd
	/// @returns list of agent indices
	@override
	external List<num> getAgents();
	
	/// Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function
	/// @param deltaTime in seconds
	@override
	external void update(num deltaTime);
	
	/// Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
	/// The queries will try to find a solution within those bounds
	/// default is (1,1,1)
	/// @param extent x,y,z value that define the extent around the queries point of reference
	@override
	external void setDefaultQueryExtent(Vector3 extent);
	
	/// Get the Bounding box extent specified by setDefaultQueryExtent
	/// @returns the box extent values
	@override
	external Vector3 getDefaultQueryExtent();
	
	/// Get the Bounding box extent result specified by setDefaultQueryExtent
	/// @param result output the box extent values
	@override
	external void getDefaultQueryExtentToRef(Vector3 result);
	
	/// Release all resources
	@override
	external void dispose();
}

/// Class used to enable access to IndexedDB
/// @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
@JS()
class Database implements IOfflineProvider {
	
	/// Creates a new Database
	/// @param urlToScene defines the url to load the scene
	/// @param callbackManifestChecked defines the callback to use when manifest is checked
	/// @param disableManifestCheck defines a boolean indicating that we want to skip the manifest validation (it will be considered validated and up to date)
	external factory Database(String urlToScene, dynamic Function(bool checked) callbackManifestChecked, [bool? disableManifestCheck]);
	
	/// Gets a boolean indicating if Database storate is enabled (off by default)
	external static bool get IDBStorageEnabled;
	external static set IDBStorageEnabled(bool value);
	
	/// Open the database and make it available
	/// @param successCallback defines the callback to call on success
	/// @param errorCallback defines the callback to call on error
	@override
	external void open(void Function() successCallback, void Function() errorCallback);
	
	/// Loads an image from the database
	/// @param url defines the url to load from
	/// @param image defines the target DOM image
	@override
	external void loadImage(String url, HTML.ImageElement image);
	
	/// Loads a file from database
	/// @param url defines the URL to load from
	/// @param sceneLoaded defines a callback to call on success
	/// @param progressCallBack defines a callback to call when progress changed
	/// @param errorCallback defines a callback to call on error
	/// @param useArrayBuffer defines a boolean to use array buffer instead of text string
	@override
	external void loadFile(String url, void Function(dynamic data) sceneLoaded, [void Function(dynamic data)? progressCallBack, void Function()? errorCallback, bool? useArrayBuffer]);
	
	/// Gets a boolean indicating if scene must be saved in the database
	external bool get enableSceneOffline;
	external set enableSceneOffline(bool value);
	
	/// Gets a boolean indicating if textures must be saved in the database
	external bool get enableTexturesOffline;
	external set enableTexturesOffline(bool value);
}

/* var */
/// @hidden
@JS()
external dynamic get gpuUpdateParticlesPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get gpuUpdateParticlesVertexShader;

/* var */
/// @hidden
@JS()
external dynamic get clipPlaneFragmentDeclaration2;

/* var */
/// @hidden
@JS()
external dynamic get gpuRenderParticlesPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get clipPlaneVertexDeclaration2;

/* var */
/// @hidden
@JS()
external dynamic get gpuRenderParticlesVertexShader;

/// This represents a GPU particle system in Babylon
/// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
/// @see https://www.babylonjs-playground.com/#PU4WYI#4
@JS()
class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {
	
	/// Instantiates a GPU particle system.
	/// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
	/// @param name The name of the particle system
	/// @param options The options used to create the system
	/// @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
	/// @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
	/// @param customEffect a custom effect used to change the way particles are rendered by default
	external factory GPUParticleSystem(String name, GPUParticleSystemConstructorOptions options, dynamic sceneOrEngine, [bool? isAnimationSheetEnabled, Effect? customEffect]);
	
	/// The layer mask we are rendering the particles through.
	@override
	external num get layerMask;
	@override
	external set layerMask(num value);
	
	/// Gets a boolean indicating if the GPU particles can be rendered on current browser
	external static bool get IsSupported;
	
	/// An event triggered when the system is disposed.
	@override
	external Observable<IParticleSystem> get onDisposeObservable;
	@override
	external set onDisposeObservable(Observable<IParticleSystem> value);
	
	/// An event triggered when the system is stopped
	@override
	external Observable<IParticleSystem> get onStoppedObservable;
	@override
	external set onStoppedObservable(Observable<IParticleSystem> value);
	
	/// Gets the maximum number of particles active at the same time.
	/// @returns The max number of active particles.
	@override
	external num getCapacity();
	
	/// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
	/// to override the particles.
	@override
	external bool get forceDepthWrite;
	@override
	external set forceDepthWrite(bool value);
	
	/// Gets or set the number of active particles
	external num get activeParticleCount;
	
	external set activeParticleCount(num value);
	
	/// Specifies if the particles are updated in emitter local space or world space.
	@override
	external bool get isLocal;
	@override
	external set isLocal(bool value);
	
	/// Gets or sets a matrix to use to compute projection
	@override
	external Matrix get defaultProjectionMatrix;
	@override
	external set defaultProjectionMatrix(Matrix value);
	
	/// Is this system ready to be used/rendered
	/// @return true if the system is ready
	@override
	external bool isReady();
	
	/// Gets if the system has been started. (Note: this will still be true after stop is called)
	/// @returns True if it has been started, otherwise false.
	@override
	external bool isStarted();
	
	/// Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)
	/// @returns True if it has been stopped, otherwise false.
	external bool isStopped();
	
	/// Gets a boolean indicating that the system is stopping
	/// @returns true if the system is currently stopping
	@override
	external bool isStopping();
	
	/// Gets the number of particles active at the same time.
	/// @returns The number of active particles.
	@override
	external num getActiveCount();
	
	/// Starts the particle system and begins to emit
	/// @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
	@override
	external void start([num? delay]);
	
	/// Stops the particle system.
	@override
	external void stop();
	
	/// Remove all active particles
	@override
	external void reset();
	
	/// Returns the string "GPUParticleSystem"
	/// @returns a string containing the class name
	@override
	external String getClassName();
	
	/// Gets the custom effect used to render the particles
	/// @param blendMode Blend mode for which the effect should be retrieved
	/// @returns The effect
	@override
	external Effect? getCustomEffect([num? blendMode]);
	
	/// Sets the custom effect used to render the particles
	/// @param effect The effect to set
	/// @param blendMode Blend mode for which the effect should be set
	@override
	external void setCustomEffect(Effect? effect, [num? blendMode]);
	
	/// Adds a new color gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param color1 defines the color to affect to the specified gradient
	/// @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
	/// @returns the current particle system
	@override
	external GPUParticleSystem addColorGradient(num gradient, Color4 color1, [Color4? color2]);
	
	/// Force the system to rebuild all gradients that need to be resync
	@override
	external void forceRefreshGradients();
	
	/// Remove a specific color gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external GPUParticleSystem removeColorGradient(num gradient);
	
	/// Adds a new size gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the size factor to affect to the specified gradient
	/// @returns the current particle system
	@override
	external GPUParticleSystem addSizeGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific size gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external GPUParticleSystem removeSizeGradient(num gradient);
	
	/// Adds a new angular speed gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the angular speed to affect to the specified gradient
	/// @returns the current particle system
	@override
	external GPUParticleSystem addAngularSpeedGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific angular speed gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external GPUParticleSystem removeAngularSpeedGradient(num gradient);
	
	/// Adds a new velocity gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the velocity to affect to the specified gradient
	/// @returns the current particle system
	@override
	external GPUParticleSystem addVelocityGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific velocity gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external GPUParticleSystem removeVelocityGradient(num gradient);
	
	/// Adds a new limit velocity gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the limit velocity value to affect to the specified gradient
	/// @returns the current particle system
	@override
	external GPUParticleSystem addLimitVelocityGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific limit velocity gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external GPUParticleSystem removeLimitVelocityGradient(num gradient);
	
	/// Adds a new drag gradient
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the drag value to affect to the specified gradient
	/// @returns the current particle system
	@override
	external GPUParticleSystem addDragGradient(num gradient, num factor, [num? factor2]);
	
	/// Remove a specific drag gradient
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external GPUParticleSystem removeDragGradient(num gradient);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the emit rate value to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addEmitRateGradient(num gradient, num factor, [num? factor2]);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeEmitRateGradient(num gradient);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the start size value to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addStartSizeGradient(num gradient, num factor, [num? factor2]);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeStartSizeGradient(num gradient);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param min defines the color remap minimal range
	/// @param max defines the color remap maximal range
	/// @returns the current particle system
	@override
	external IParticleSystem addColorRemapGradient(num gradient, num min, num max);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeColorRemapGradient();
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param min defines the alpha remap minimal range
	/// @param max defines the alpha remap maximal range
	/// @returns the current particle system
	@override
	external IParticleSystem addAlphaRemapGradient(num gradient, num min, num max);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeAlphaRemapGradient();
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param color defines the color to affect to the specified gradient
	/// @returns the current particle system
	@override
	external IParticleSystem addRampGradient(num gradient, Color3 color);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	external IParticleSystem removeRampGradient();
	
	/// Not supported by GPUParticleSystem
	/// @returns the list of ramp gradients
	@override
	external List<Color3Gradient>? getRampGradients();
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to use (between 0 and 1)
	/// @param factor defines the life time factor to affect to the specified gradient
	/// @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
	/// @returns the current particle system
	@override
	external IParticleSystem addLifeTimeGradient(num gradient, num factor, [num? factor2]);
	
	/// Not supported by GPUParticleSystem
	/// @param gradient defines the gradient to remove
	/// @returns the current particle system
	@override
	external IParticleSystem removeLifeTimeGradient(num gradient);
	
	/// Fill the defines array according to the current settings of the particle system
	/// @param defines Array to be updated
	/// @param blendMode blend mode to take into account when updating the array
	@override
	external void fillDefines(List<String> defines, [num? blendMode]);
	
	/// Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
	/// @param uniforms Uniforms array to fill
	/// @param attributes Attributes array to fill
	/// @param samplers Samplers array to fill
	@override
	external void fillUniformsAttributesAndSamplerNames(List<String> uniforms, List<String> attributes, List<String> samplers);
	
	/// Animates the particle system for the current frame by emitting new particles and or animating the living ones.
	/// @param preWarm defines if we are in the pre-warmimg phase
	@override
	external void animate([bool? preWarm]);
	
	/// Renders the particle system in its current state
	/// @param preWarm defines if the system should only update the particles but not render them
	/// @returns the current number of particles
	@override
	external num render([bool? preWarm]);
	
	/// Rebuilds the particle system
	@override
	external void rebuild();
	
	/// Disposes the particle system and free the associated resources
	/// @param disposeTexture defines if the particule texture must be disposed as well (true by default)
	@override
	external void dispose([bool? disposeTexture]);
	
	/// Clones the particle system.
	/// @param name The name of the cloned object
	/// @param newEmitter The new emitter to use
	/// @returns the cloned particle system
	@override
	external GPUParticleSystem? clone(String name, dynamic newEmitter);
	
	/// Serializes the particle system to a JSON object
	/// @param serializeTexture defines if the texture must be serialized as well
	/// @returns the JSON object
	@override
	external dynamic serialize([bool? serializeTexture]);
	
	/// Parses a JSON object to create a GPU particle system.
	/// @param parsedParticleSystem The JSON object to parse
	/// @param sceneOrEngine The scene or the engine to create the particle system in
	/// @param rootUrl The root url to use to load external dependencies like texture
	/// @param doNotStart Ignore the preventAutoStart attribute and does not start
	/// @returns the parsed GPU particle system
	external static GPUParticleSystem Parse(dynamic parsedParticleSystem, dynamic sceneOrEngine, String rootUrl, [bool? doNotStart]);
	
	/// Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
	external bool get isBillboardBased;
	external set isBillboardBased(bool value);
	
	/// Gets or sets a boolean indicating if a spritesheet is used to animate the particles texture
	external bool get isAnimationSheetEnabled;
	external set isAnimationSheetEnabled(bool value);
	
	/// Gets or sets a texture used to add random noise to particle positions
	external BaseTexture? get noiseTexture;
	external set noiseTexture(BaseTexture? value);
	
	/// Observable that will be called just before the particles are drawn
	external Observable<Effect?> get onBeforeDrawParticlesObservable;
	external set onBeforeDrawParticlesObservable(Observable<Effect?> value);
	
	/// Gets the name of the particle vertex shader
	external String get vertexShaderName;
	external set vertexShaderName(String value);
	
	/// Gets or sets a boolean indicating that ramp gradients must be used
	/// @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients
	external bool get useRampGradients;
	external set useRampGradients(bool value);
}

/// Represents a set of particle systems working together to create a specific effect
@JS()
class ParticleSystemSet implements IDisposable {
	external factory ParticleSystemSet();
	
	/// Gets or sets base Assets URL
	external static String get BaseAssetsUrl;
	external static set BaseAssetsUrl(String value);
	
	/// Gets the particle system list
	external List<IParticleSystem> get systems;
	external set systems(List<IParticleSystem> value);
	
	/// Gets the emitter node used with this set
	external TransformNode? get emitterNode;
	
	/// Creates a new emitter mesh as a sphere
	/// @param options defines the options used to create the sphere
	/// @param renderingGroupId defines the renderingGroupId to use for the sphere
	/// @param scene defines the hosting scene
	external void setEmitterAsSphere(ParticleSystemSetSetEmitterAsSphereOptions options, num renderingGroupId, Scene scene);
	
	/// Starts all particle systems of the set
	/// @param emitter defines an optional mesh to use as emitter for the particle systems
	external void start([AbstractMesh? emitter]);
	
	/// Release all associated resources
	@override
	external void dispose();
	
	/// Serialize the set into a JSON compatible object
	/// @param serializeTexture defines if the texture must be serialized as well
	/// @returns a JSON compatible representation of the set
	external dynamic serialize([bool? serializeTexture]);
	
	/// Parse a new ParticleSystemSet from a serialized source
	/// @param data defines a JSON compatible representation of the set
	/// @param scene defines the hosting scene
	/// @param gpu defines if we want GPU particles or CPU particles
	/// @returns a new ParticleSystemSet
	external static ParticleSystemSet Parse(dynamic data, Scene scene, [bool? gpu]);
}

/// This class is made for on one-liner static method to help creating particle system set.
@JS()
class ParticleHelper {
	external factory ParticleHelper();
	
	/// Gets or sets base Assets URL
	external static String get BaseAssetsUrl;
	external static set BaseAssetsUrl(String value);
	
	/// Define the Url to load snippets
	external static String get SnippetUrl;
	external static set SnippetUrl(String value);
	
	/// Create a default particle system that you can tweak
	/// @param emitter defines the emitter to use
	/// @param capacity defines the system capacity (default is 500 particles)
	/// @param scene defines the hosting scene
	/// @param useGPU defines if a GPUParticleSystem must be created (default is false)
	/// @returns the new Particle system
	external static IParticleSystem CreateDefault(dynamic? emitter, [num? capacity, Scene? scene, bool? useGPU]);
	
	/// This is the main static method (one-liner) of this helper to create different particle systems
	/// @param type This string represents the type to the particle system to create
	/// @param scene The scene where the particle system should live
	/// @param gpu If the system will use gpu
	/// @returns the ParticleSystemSet created
	external static Promise<ParticleSystemSet> CreateAsync(String type, Scene? scene, [bool? gpu]);
	
	/// Static function used to export a particle system to a ParticleSystemSet variable.
	/// Please note that the emitter shape is not exported
	/// @param systems defines the particle systems to export
	/// @returns the created particle system set
	external static ParticleSystemSet ExportSet(List<IParticleSystem> systems);
	
	/// Creates a particle system from a snippet saved in a remote file
	/// @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)
	/// @param url defines the url to load from
	/// @param scene defines the hosting scene
	/// @param gpu If the system will use gpu
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a promise that will resolve to the new particle system
	external static Promise<IParticleSystem> ParseFromFileAsync(String? name, String url, Scene scene, [bool? gpu, String? rootUrl]);
	
	/// Creates a particle system from a snippet saved by the particle system editor
	/// @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)
	/// @param scene defines the hosting scene
	/// @param gpu If the system will use gpu
	/// @param rootUrl defines the root URL to use to load textures and relative dependencies
	/// @returns a promise that will resolve to the new particle system
	external static Promise<IParticleSystem> CreateFromSnippetAsync(String snippetId, Scene scene, [bool? gpu, String? rootUrl]);
}

/* enum */
abstract class PointColor {
	
	/// color value
	static const int Color = 3;
	
	/// uv value
	static const int UV = 2;
	
	/// random value
	static const int Random = 1;
	
	/// stated value
	static const int Stated = 4;
}

/// The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.
/// As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
/// The PointCloudSytem is also a particle system, with each point being a particle. It provides some methods to manage the particles.
/// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
/// 
/// Full documentation here : TO BE ENTERED
@JS()
class PointsCloudSystem implements IDisposable {
	
	/// Creates a PCS (Points Cloud System) object
	/// @param name (String) is the PCS name, this will be the underlying mesh name
	/// @param pointSize (number) is the size for each point
	/// @param scene (Scene) is the scene in which the PCS is added
	/// @param options defines the options of the PCS e.g.
	/// * updatable (optional boolean, default true) : if the PCS must be updatable or immutable
	external factory PointsCloudSystem(String name, num pointSize, Scene scene, [PointsCloudSystemConstructorOptions? options]);
	
	/// The PCS array of cloud point objects. Just access each particle as with any classic array.
	/// Example : var p = SPS.particles[i];
	external List<CloudPoint> get particles;
	external set particles(List<CloudPoint> value);
	
	/// The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.
	external num get nbParticles;
	external set nbParticles(num value);
	
	/// This a counter for your own usage. It's not set by any SPS functions.
	external num get counter;
	external set counter(num value);
	
	/// The PCS name. This name is also given to the underlying mesh.
	external String get name;
	external set name(String value);
	
	/// The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
	external Mesh get mesh;
	external set mesh(Mesh value);
	
	/// This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.
	/// Please read :
	external dynamic get vars;
	external set vars(dynamic value);
	
	/// Builds the PCS underlying mesh. Returns a standard Mesh.
	/// If no points were added to the PCS, the returned mesh is just a single point.
	/// @returns a promise for the created mesh
	external Promise<Mesh> buildMeshAsync();
	
	/// Adds points to the PCS in random positions within a unit sphere
	/// @param nb (positive integer) the number of particles to be created from this model
	/// @param pointFunction is an optional javascript function to be called for each particle on PCS creation
	/// @returns the number of groups in the system
	external num addPoints(num nb, [dynamic? pointFunction]);
	
	/// Adds points to the PCS from the surface of the model shape
	/// @param mesh is any Mesh object that will be used as a surface model for the points
	/// @param nb (positive integer) the number of particles to be created from this model
	/// @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)
	/// @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position
	/// @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color
	/// @returns the number of groups in the system
	external num addSurfacePoints(Mesh mesh, num nb, [num? colorWith, dynamic? color, num? range]);
	
	/// Adds points to the PCS inside the model shape
	/// @param mesh is any Mesh object that will be used as a surface model for the points
	/// @param nb (positive integer) the number of particles to be created from this model
	/// @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)
	/// @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position
	/// @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color
	/// @returns the number of groups in the system
	external num addVolumePoints(Mesh mesh, num nb, [num? colorWith, dynamic? color, num? range]);
	
	/// Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
	/// This method calls `updateParticle()` for each particle of the SPS.
	/// For an animated SPS, it is usually called within the render loop.
	/// @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
	/// @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
	/// @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
	/// @returns the PCS.
	external PointsCloudSystem setParticles([num? start, num? end, bool? update]);
	
	/// Disposes the PCS.
	@override
	external void dispose();
	
	/// Visibilty helper : Recomputes the visible size according to the mesh bounding box
	/// doc :
	/// @returns the PCS.
	external PointsCloudSystem refreshVisibleSize();
	
	/// Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
	/// @param size the size (float) of the visibility box
	/// note : this doesn't lock the PCS mesh bounding box.
	/// doc :
	external void setVisibilityBox(num size);
	
	/// Gets whether the PCS is always visible or not
	/// doc :
	external bool get isAlwaysVisible;
	
	/// Sets the PCS as always visible or not
	/// doc :
	external set isAlwaysVisible(bool value);
	
	/// Tells to `setParticles()` to compute the particle rotations or not
	/// Default value : false. The PCS is faster when it's set to false
	/// Note : particle rotations are only applied to parent particles
	/// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate
	external set computeParticleRotation(bool value);
	
	/// Tells to `setParticles()` to compute the particle colors or not.
	/// Default value : true. The PCS is faster when it's set to false.
	/// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
	external set computeParticleColor(bool value);
	
	external set computeParticleTexture(bool value);
	
	/// Gets if `setParticles()` computes the particle colors or not.
	/// Default value : false. The PCS is faster when it's set to false.
	/// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
	external bool get computeParticleColor;
	
	/// Gets if `setParticles()` computes the particle textures or not.
	/// Default value : false. The PCS is faster when it's set to false.
	/// Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
	external bool get computeParticleTexture;
	
	/// Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
	external set computeBoundingBox(bool value);
	
	/// Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
	external bool get computeBoundingBox;
	
	/// This function does nothing. It may be overwritten to set all the particle first values.
	/// The PCS doesn't call this function, you may have to call it by your own.
	/// doc :
	external void initParticles();
	
	/// This function does nothing. It may be overwritten to recycle a particle
	/// The PCS doesn't call this function, you can to call it
	/// doc :
	/// @param particle The particle to recycle
	/// @returns the recycled particle
	external CloudPoint recycleParticle(CloudPoint particle);
	
	/// Updates a particle : this function should  be overwritten by the user.
	/// It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
	/// doc :
	/// @example : just set a particle position or velocity and recycle conditions
	/// @param particle The particle to update
	/// @returns the updated particle
	external CloudPoint updateParticle(CloudPoint particle);
	
	/// This will be called before any other treatment by `setParticles()` and will be passed three parameters.
	/// This does nothing and may be overwritten by the user.
	/// @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()
	/// @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
	/// @param update the boolean update value actually passed to setParticles()
	external void beforeUpdateParticles([num? start, num? stop, bool? update]);
	
	/// This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
	/// This will be passed three parameters.
	/// This does nothing and may be overwritten by the user.
	/// @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()
	/// @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
	/// @param update the boolean update value actually passed to setParticles()
	external void afterUpdateParticles([num? start, num? stop, bool? update]);
}

/// Represents one particle of a points cloud system.
@JS()
class CloudPoint {
	
	/// Creates a Point Cloud object.
	/// Don't create particles manually, use instead the PCS internal tools like _addParticle()
	/// @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.
	/// @param group (PointsGroup) is the group the particle belongs to
	/// @param groupId (integer) is the group identifier in the PCS.
	/// @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))
	/// @param pcs defines the PCS it is associated to
	external factory CloudPoint(num particleIndex, PointsGroup group, num groupId, num idxInGroup, PointsCloudSystem pcs);
	
	/// particle global index
	external num get idx;
	external set idx(num value);
	
	/// The color of the particle
	external Color4? get color;
	external set color(Color4? value);
	
	/// The world space position of the particle.
	external Vector3 get position;
	external set position(Vector3 value);
	
	/// The world space rotation of the particle. (Not use if rotationQuaternion is set)
	external Vector3 get rotation;
	external set rotation(Vector3 value);
	
	/// The world space rotation quaternion of the particle.
	external Quaternion? get rotationQuaternion;
	external set rotationQuaternion(Quaternion? value);
	
	/// The uv of the particle.
	external Vector2? get uv;
	external set uv(Vector2? value);
	
	/// The current speed of the particle.
	external Vector3 get velocity;
	external set velocity(Vector3 value);
	
	/// The pivot point in the particle local space.
	external Vector3 get pivot;
	external set pivot(Vector3 value);
	
	/// Must the particle be translated from its pivot point in its local space ?
	/// In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
	/// Default : false
	external bool get translateFromPivot;
	external set translateFromPivot(bool value);
	
	/// Group id of this particle
	external num get groupId;
	external set groupId(num value);
	
	/// Index of the particle in its group id (Internal use)
	external num get idxInGroup;
	external set idxInGroup(num value);
	
	/// Parent particle Id, if any.
	/// Default null.
	external num? get parentId;
	external set parentId(num? value);
	
	/// get point size
	external Vector3 get size;
	
	/// Set point size
	external set size(Vector3 value);
	
	/// Legacy support, changed quaternion to rotationQuaternion
	external Quaternion? get quaternion;
	
	/// Legacy support, changed quaternion to rotationQuaternion
	external set quaternion(Quaternion? value);
	
	/// Returns a boolean. True if the particle intersects a mesh, else false
	/// The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere
	/// @param target is the object (point or mesh) what the intersection is computed against
	/// @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bouding sphere is used
	/// @returns true if it intersects
	external bool intersectsMesh(Mesh target, bool isSphere);
	
	/// get the rotation matrix of the particle
	/// @hidden
	external void getRotationMatrix(Matrix m);
}

/// Represents a group of points in a points cloud system
/// * PCS internal tool, don't use it manually.
@JS()
class PointsGroup {
	
	/// Creates a points group object. This is an internal reference to produce particles for the PCS.
	/// PCS internal tool, don't use it manually.
	/// @hidden
	external factory PointsGroup(num id, void Function(CloudPoint particle, [num? i, num? s])? posFunction);
	
	/// The group id
	/// @hidden
	external num get groupID;
	external set groupID(num value);
}

/// Defines the physics engine scene component responsible to manage a physics engine
@JS()
class PhysicsEngineSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory PhysicsEngineSceneComponent(Scene scene);
	
	/// The component name helpful to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/// A helper for physics simulations
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
class PhysicsHelper {
	
	/// Initializes the Physics helper
	/// @param scene Babylon.js scene
	external factory PhysicsHelper(Scene scene);
	
	/// Applies a radial explosion impulse
	/// @param origin the origin of the explosion
	/// @param radiusOrEventOptions the radius or the options of radial explosion
	/// @param strength the explosion strength
	/// @param falloff possible options: Constant & Linear. Defaults to Constant
	/// @returns A physics radial explosion event, or null
	external PhysicsRadialExplosionEvent? applyRadialExplosionImpulse(Vector3 origin, dynamic radiusOrEventOptions, [num? strength, int? falloff]);
	
	/// Applies a radial explosion force
	/// @param origin the origin of the explosion
	/// @param radiusOrEventOptions the radius or the options of radial explosion
	/// @param strength the explosion strength
	/// @param falloff possible options: Constant & Linear. Defaults to Constant
	/// @returns A physics radial explosion event, or null
	external PhysicsRadialExplosionEvent? applyRadialExplosionForce(Vector3 origin, dynamic radiusOrEventOptions, [num? strength, int? falloff]);
	
	/// Creates a gravitational field
	/// @param origin the origin of the explosion
	/// @param radiusOrEventOptions the radius or the options of radial explosion
	/// @param strength the explosion strength
	/// @param falloff possible options: Constant & Linear. Defaults to Constant
	/// @returns A physics gravitational field event, or null
	external PhysicsGravitationalFieldEvent? gravitationalField(Vector3 origin, dynamic radiusOrEventOptions, [num? strength, int? falloff]);
	
	/// Creates a physics updraft event
	/// @param origin the origin of the updraft
	/// @param radiusOrEventOptions the radius or the options of the updraft
	/// @param strength the strength of the updraft
	/// @param height the height of the updraft
	/// @param updraftMode possible options: Center & Perpendicular. Defaults to Center
	/// @returns A physics updraft event, or null
	external PhysicsUpdraftEvent? updraft(Vector3 origin, dynamic radiusOrEventOptions, [num? strength, num? height, int? updraftMode]);
	
	/// Creates a physics vortex event
	/// @param origin the of the vortex
	/// @param radiusOrEventOptions the radius or the options of the vortex
	/// @param strength the strength of the vortex
	/// @param height   the height of the vortex
	/// @returns a Physics vortex event, or null
	/// A physics vortex event or null
	external PhysicsVortexEvent? vortex(Vector3 origin, dynamic radiusOrEventOptions, [num? strength, num? height]);
}

/// Represents a physics radial explosion event
@JS()
class PhysicsRadialExplosionEvent {
	
	/// Initializes a radial explosioin event
	/// @param _scene BabylonJS scene
	/// @param _options The options for the vortex event
	external factory PhysicsRadialExplosionEvent(Scene _scene, PhysicsRadialExplosionEventOptions _options);
	
	/// Returns the data related to the radial explosion event (sphere).
	/// @returns The radial explosion event data
	external PhysicsRadialExplosionEventData getData();
	
	/// Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.
	/// @param impostor A physics imposter
	/// @param origin the origin of the explosion
	/// @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null
	external PhysicsHitData? getImpostorHitData(PhysicsImpostor impostor, Vector3 origin);
	
	/// Triggers affecterd impostors callbacks
	/// @param affectedImpostorsWithData defines the list of affected impostors (including associated data)
	external void triggerAffectedImpostorsCallback(List<PhysicsAffectedImpostorWithData> affectedImpostorsWithData);
	
	/// Disposes the sphere.
	/// @param force Specifies if the sphere should be disposed by force
	external void dispose([bool? force]);
}

/// Represents a gravitational field event
@JS()
class PhysicsGravitationalFieldEvent {
	
	/// Initializes the physics gravitational field event
	/// @param _physicsHelper A physics helper
	/// @param _scene BabylonJS scene
	/// @param _origin The origin position of the gravitational field event
	/// @param _options The options for the vortex event
	external factory PhysicsGravitationalFieldEvent(PhysicsHelper _physicsHelper, Scene _scene, Vector3 _origin, PhysicsRadialExplosionEventOptions _options);
	
	/// Returns the data related to the gravitational field event (sphere).
	/// @returns A gravitational field event
	external PhysicsGravitationalFieldEventData getData();
	
	/// Enables the gravitational field.
	external void enable();
	
	/// Disables the gravitational field.
	external void disable();
	
	/// Disposes the sphere.
	/// @param force The force to dispose from the gravitational field event
	external void dispose([bool? force]);
}

/// Represents a physics updraft event
@JS()
class PhysicsUpdraftEvent {
	
	/// Initializes the physics updraft event
	/// @param _scene BabylonJS scene
	/// @param _origin The origin position of the updraft
	/// @param _options The options for the updraft event
	external factory PhysicsUpdraftEvent(Scene _scene, Vector3 _origin, PhysicsUpdraftEventOptions _options);
	
	/// Returns the data related to the updraft event (cylinder).
	/// @returns A physics updraft event
	external PhysicsUpdraftEventData getData();
	
	/// Enables the updraft.
	external void enable();
	
	/// Disables the updraft.
	external void disable();
	
	/// Disposes the cylinder.
	/// @param force Specifies if the updraft should be disposed by force
	external void dispose([bool? force]);
}

/// Represents a physics vortex event
@JS()
class PhysicsVortexEvent {
	
	/// Initializes the physics vortex event
	/// @param _scene The BabylonJS scene
	/// @param _origin The origin position of the vortex
	/// @param _options The options for the vortex event
	external factory PhysicsVortexEvent(Scene _scene, Vector3 _origin, PhysicsVortexEventOptions _options);
	
	/// Returns the data related to the vortex event (cylinder).
	/// @returns The physics vortex event data
	external PhysicsVortexEventData getData();
	
	/// Enables the vortex.
	external void enable();
	
	/// Disables the cortex.
	external void disable();
	
	/// Disposes the sphere.
	/// @param force
	external void dispose([bool? force]);
}

/// Options fot the radial explosion event
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
class PhysicsRadialExplosionEventOptions {
	external factory PhysicsRadialExplosionEventOptions();
	
	/// The radius of the sphere for the radial explosion.
	external num get radius;
	external set radius(num value);
	
	/// The strenth of the explosion.
	external num get strength;
	external set strength(num value);
	
	/// The strenght of the force in correspondence to the distance of the affected object
	external int get falloff;
	external set falloff(int value);
	
	/// Sphere options for the radial explosion.
	external PhysicsRadialExplosionEventOptionsSphere get sphere;
	external set sphere(PhysicsRadialExplosionEventOptionsSphere value);
	
	/// Sphere options for the radial explosion.
	external void Function(List<PhysicsAffectedImpostorWithData> affectedImpostorsWithData) get affectedImpostorsCallback;
	external set affectedImpostorsCallback(void Function(List<PhysicsAffectedImpostorWithData> affectedImpostorsWithData) value);
}

/// Options fot the updraft event
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
class PhysicsUpdraftEventOptions {
	external factory PhysicsUpdraftEventOptions();
	
	/// The radius of the cylinder for the vortex
	external num get radius;
	external set radius(num value);
	
	/// The strenth of the updraft.
	external num get strength;
	external set strength(num value);
	
	/// The height of the cylinder for the updraft.
	external num get height;
	external set height(num value);
	
	/// The mode for the the updraft.
	external int get updraftMode;
	external set updraftMode(int value);
}

/// Options fot the vortex event
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
class PhysicsVortexEventOptions {
	external factory PhysicsVortexEventOptions();
	
	/// The radius of the cylinder for the vortex
	external num get radius;
	external set radius(num value);
	
	/// The strenth of the vortex.
	external num get strength;
	external set strength(num value);
	
	/// The height of the cylinder for the vortex.
	external num get height;
	external set height(num value);
	
	/// At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1
	external num get centripetalForceThreshold;
	external set centripetalForceThreshold(num value);
	
	/// This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the treshold.
	external num get centripetalForceMultiplier;
	external set centripetalForceMultiplier(num value);
	
	/// This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the treshold.
	external num get centrifugalForceMultiplier;
	external set centrifugalForceMultiplier(num value);
	
	/// This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.
	external num get updraftForceMultiplier;
	external set updraftForceMultiplier(num value);
}

/* enum */
abstract class PhysicsRadialImpulseFalloff {
	
	/// Defines that impulse is constant in strength across it's whole radius
	static const int Constant = 1;
	
	/// Defines that impulse gets weaker if it's further from the origin
	static const int Linear = 2;
}

/* enum */
abstract class PhysicsUpdraftMode {
	
	/// Defines that the upstream forces will pull towards the top center of the cylinder
	static const int Center = 1;
	
	/// Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder
	static const int Perpendicular = 2;
}

/// Interface for a physics hit data
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
@anonymous
class PhysicsHitData {
	
	external factory PhysicsHitData({Vector3 force, Vector3 contactPoint, num distanceFromOrigin});
	
	/// The force applied at the contact point
	external Vector3 get force;
	external set force( Vector3 value );
	
	/// The contact point
	external Vector3 get contactPoint;
	external set contactPoint( Vector3 value );
	
	/// The distance from the origin to the contact point
	external num get distanceFromOrigin;
	external set distanceFromOrigin( num value );
}

/// Interface for radial explosion event data
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
@anonymous
class PhysicsRadialExplosionEventData {
	
	external factory PhysicsRadialExplosionEventData({Mesh sphere});
	
	/// A sphere used for the radial explosion event
	external Mesh get sphere;
	external set sphere( Mesh value );
}

/// Interface for gravitational field event data
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
@anonymous
class PhysicsGravitationalFieldEventData {
	
	external factory PhysicsGravitationalFieldEventData({Mesh sphere});
	
	/// A sphere mesh used for the gravitational field event
	external Mesh get sphere;
	external set sphere( Mesh value );
}

/// Interface for updraft event data
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
@anonymous
class PhysicsUpdraftEventData {
	
	external factory PhysicsUpdraftEventData({Mesh cylinder});
	
	/// A cylinder used for the updraft event
	external Mesh get cylinder;
	external set cylinder( Mesh value );
}

/// Interface for vortex event data
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
@anonymous
class PhysicsVortexEventData {
	
	external factory PhysicsVortexEventData({Mesh cylinder});
	
	/// A cylinder used for the vortex event
	external Mesh get cylinder;
	external set cylinder( Mesh value );
}

/// Interface for an affected physics impostor
/// @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
@JS()
@anonymous
class PhysicsAffectedImpostorWithData {
	
	external factory PhysicsAffectedImpostorWithData({PhysicsImpostor impostor, PhysicsHitData hitData});
	
	/// The impostor affected by the effect
	external PhysicsImpostor get impostor;
	external set impostor( PhysicsImpostor value );
	
	/// The data about the hit/horce from the explosion
	external PhysicsHitData get hitData;
	external set hitData( PhysicsHitData value );
}

/* var */
/// @hidden
@JS()
external dynamic get blackAndWhitePixelShader;

/// Post process used to render in black and white
@JS()
class BlackAndWhitePostProcess extends PostProcess {
	
	/// Creates a black and white post process
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#black-and-white
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	external factory BlackAndWhitePostProcess(String name, dynamic options, Camera camera, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// Linear about to convert he result to black and white (default: 1)
	external num get degree;
	external set degree(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "BlackAndWhitePostProcess" string
	@override
	external String getClassName();
}

/// This represents a set of one or more post processes in Babylon.
/// A post process can be used to apply a shader to a texture after it is rendered.
/// @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
@JS()
class PostProcessRenderEffect {
	
	/// Instantiates a post process render effect.
	/// A post process can be used to apply a shader to a texture after it is rendered.
	/// @param engine The engine the effect is tied to
	/// @param name The name of the effect
	/// @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.
	/// @param singleInstance False if this post process can be run on multiple cameras. (default: true)
	external factory PostProcessRenderEffect(Engine engine, String name, dynamic? Function() getPostProcesses, [bool? singleInstance]);
	
	/// Checks if all the post processes in the effect are supported.
	external bool get isSupported;
	
	/// Gets a list of the post processes contained in the effect.
	/// @param camera The camera to get the post processes on.
	/// @returns The list of the post processes in the effect.
	external List<PostProcess>? getPostProcesses([Camera? camera]);
}

/* var */
/// @hidden
@JS()
external dynamic get extractHighlightsPixelShader;

/// The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
@JS()
class ExtractHighlightsPostProcess extends PostProcess {
	
	external factory ExtractHighlightsPostProcess(String name, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// The luminance threshold, pixels below this value will be set to black.
	external num get threshold;
	external set threshold(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "ExtractHighlightsPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get bloomMergePixelShader;

/// The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
@JS()
class BloomMergePostProcess extends PostProcess {
	
	/// Creates a new instance of @see BloomMergePostProcess
	/// @param name The name of the effect.
	/// @param originalFromInput Post process which's input will be used for the merge.
	/// @param blurred Blurred highlights post process which's output will be used.
	/// @param weight Weight of the bloom to be added to the original input.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory BloomMergePostProcess(String name, PostProcess originalFromInput, PostProcess blurred, num weight, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// Weight of the bloom to be added to the original input.
	external num get weight;
	external set weight(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "BloomMergePostProcess" string
	@override
	external String getClassName();
}

/// The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
@JS()
class BloomEffect extends PostProcessRenderEffect {
	
	/// Creates a new instance of @see BloomEffect
	/// @param scene The scene the effect belongs to.
	/// @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.
	/// @param bloomKernel The size of the kernel to be used when applying the blur.
	/// @param bloomWeight The the strength of bloom.
	/// @param pipelineTextureType The type of texture to be used when performing the post processing.
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory BloomEffect(Scene scene, num bloomScale, num bloomWeight, num bloomKernel, [num? pipelineTextureType, bool? blockCompilation]);
	
	/// The luminance threshold to find bright areas of the image to bloom.
	external num get threshold;
	
	external set threshold(num value);
	
	/// The strength of the bloom.
	external num get weight;
	
	external set weight(num value);
	
	/// Specifies the size of the bloom blur kernel, relative to the final output size
	external num get kernel;
	
	external set kernel(num value);
	
	/// Disposes each of the internal effects for a given camera.
	/// @param camera The camera to dispose the effect on.
	external void disposeEffects(Camera camera);
}

/* var */
/// @hidden
@JS()
external dynamic get chromaticAberrationPixelShader;

/// The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
@JS()
class ChromaticAberrationPostProcess extends PostProcess {
	
	/// Creates a new instance ChromaticAberrationPostProcess
	/// @param name The name of the effect.
	/// @param screenWidth The width of the screen to apply the effect on.
	/// @param screenHeight The height of the screen to apply the effect on.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory ChromaticAberrationPostProcess(String name, num screenWidth, num screenHeight, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// The amount of seperation of rgb channels (default: 30)
	external num get aberrationAmount;
	external set aberrationAmount(num value);
	
	/// The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
	external num get radialIntensity;
	external set radialIntensity(num value);
	
	/// The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
	external Vector2 get direction;
	external set direction(Vector2 value);
	
	/// The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
	external Vector2 get centerPosition;
	external set centerPosition(Vector2 value);
	
	/// The width of the screen to apply the effect on
	external num get screenWidth;
	external set screenWidth(num value);
	
	/// The height of the screen to apply the effect on
	external num get screenHeight;
	external set screenHeight(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "ChromaticAberrationPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get circleOfConfusionPixelShader;

/// The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
@JS()
class CircleOfConfusionPostProcess extends PostProcess {
	
	/// Creates a new instance CircleOfConfusionPostProcess
	/// @param name The name of the effect.
	/// @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory CircleOfConfusionPostProcess(String name, RenderTargetTexture? depthTexture, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
	external num get lensSize;
	external set lensSize(num value);
	
	/// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
	external num get fStop;
	external set fStop(num value);
	
	/// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
	external num get focusDistance;
	external set focusDistance(num value);
	
	/// Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
	external num get focalLength;
	external set focalLength(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "CircleOfConfusionPostProcess" string
	@override
	external String getClassName();
	
	/// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
	external set depthTexture(RenderTargetTexture value);
}

/* var */
/// @hidden
@JS()
external dynamic get colorCorrectionPixelShader;

/// 
/// This post-process allows the modification of rendered colors by using
/// a 'look-up table' (LUT). This effect is also called Color Grading.
/// 
/// The object needs to be provided an url to a texture containing the color
/// look-up table: the texture must be 256 pixels wide and 16 pixels high.
/// Use an image editing software to tweak the LUT to match your needs.
/// 
/// For an example of a color LUT, see here:
/// @see http://udn.epicgames.com/Three/rsrc/Three/ColorGrading/RGBTable16x1.png
/// For explanations on color grading, see here:
/// @see http://udn.epicgames.com/Three/ColorGrading.html
/// 
@JS()
class ColorCorrectionPostProcess extends PostProcess {
	
	external factory ColorCorrectionPostProcess(String name, String colorTableUrl, dynamic options, Camera camera, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// Gets the color table url used to create the LUT texture
	external String get colorTableUrl;
	external set colorTableUrl(String value);
	
	/// Gets a string identifying the name of the class
	/// @returns "ColorCorrectionPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get convolutionPixelShader;

/// The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
/// input texture to perform effects such as edge detection or sharpening
/// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
@JS()
class ConvolutionPostProcess extends PostProcess {
	
	/// Creates a new instance ConvolutionPostProcess
	/// @param name The name of the effect.
	/// @param kernel Array of 9 values corresponding to the 3x3 kernel to be applied
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	external factory ConvolutionPostProcess(String name, List<num> kernel, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType]);
	
	/// Array of 9 values corresponding to the 3x3 kernel to be applied
	external List<num> get kernel;
	external set kernel(List<num> value);
	
	/// Gets a string identifying the name of the class
	/// @returns "ConvolutionPostProcess" string
	@override
	external String getClassName();
	
	/// Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
	external static List<num> get EdgeDetect0Kernel;
	external static set EdgeDetect0Kernel(List<num> value);
	
	/// Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
	external static List<num> get EdgeDetect1Kernel;
	external static set EdgeDetect1Kernel(List<num> value);
	
	/// Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
	external static List<num> get EdgeDetect2Kernel;
	external static set EdgeDetect2Kernel(List<num> value);
	
	/// Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
	external static List<num> get SharpenKernel;
	external static set SharpenKernel(List<num> value);
	
	/// Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
	external static List<num> get EmbossKernel;
	external static set EmbossKernel(List<num> value);
	
	/// Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
	external static List<num> get GaussianKernel;
	external static set GaussianKernel(List<num> value);
}

/// The DepthOfFieldBlurPostProcess applied a blur in a give direction.
/// This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
/// based on samples that have a large difference in distance than the center pixel.
/// See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
@JS()
class DepthOfFieldBlurPostProcess extends BlurPostProcess {
	
	/// Creates a new instance CircleOfConfusionPostProcess
	/// @param name The name of the effect.
	/// @param scene The scene the effect belongs to.
	/// @param direction The direction the blur should be applied.
	/// @param kernel The size of the kernel used to blur.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring accross edges
	/// @param imageToBlur The image to apply the blur to (default: Current rendered frame)
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory DepthOfFieldBlurPostProcess(String name, Scene scene, Vector2 direction, num kernel, dynamic options, Camera? camera, PostProcess circleOfConfusion, [PostProcess? imageToBlur, num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// The direction the blur should be applied
	@override
	external Vector2 get direction;
	@override
	external set direction(Vector2 value);
	
	/// Gets a string identifying the name of the class
	/// @returns "DepthOfFieldBlurPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get depthOfFieldMergePixelShader;

/// Options to be set when merging outputs from the default pipeline.
@JS()
class DepthOfFieldMergePostProcessOptions {
	external factory DepthOfFieldMergePostProcessOptions();
	
	/// The original image to merge on top of
	external PostProcess get originalFromInput;
	external set originalFromInput(PostProcess value);
	
	/// Parameters to perform the merge of the depth of field effect
	external DepthOfFieldMergePostProcessOptionsDepthOfField get depthOfField;
	external set depthOfField(DepthOfFieldMergePostProcessOptionsDepthOfField value);
	
	/// Parameters to perform the merge of bloom effect
	external DepthOfFieldMergePostProcessOptionsBloom get bloom;
	external set bloom(DepthOfFieldMergePostProcessOptionsBloom value);
}

/// The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
@JS()
class DepthOfFieldMergePostProcess extends PostProcess {
	
	/// Creates a new instance of DepthOfFieldMergePostProcess
	/// @param name The name of the effect.
	/// @param originalFromInput Post process which's input will be used for the merge.
	/// @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.
	/// @param blurSteps Blur post processes from low to high which will be mixed with the original image.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory DepthOfFieldMergePostProcess(String name, PostProcess originalFromInput, PostProcess circleOfConfusion, List<PostProcess> blurSteps, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// Gets a string identifying the name of the class
	/// @returns "DepthOfFieldMergePostProcess" string
	@override
	external String getClassName();
	
	/// Updates the effect with the current post process compile time values and recompiles the shader.
	/// @param defines Define statements that should be added at the beginning of the shader. (default: null)
	/// @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
	/// @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
	/// @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
	/// @param onCompiled Called when the shader has been compiled.
	/// @param onError Called if there is an error when compiling a shader.
	@override
	external void updateEffect([String? defines, List<String>? uniforms, List<String>? samplers, dynamic? indexParameters, void Function(Effect effect)? onCompiled, void Function(Effect effect, String errors)? onError, String? vertexUrl, String? fragmentUrl]);
}

/* enum */
abstract class DepthOfFieldEffectBlurLevel {
	
	/// Subtle blur
	static const int Low = 1;
	
	/// Medium blur
	static const int Medium = 2;
	
	/// Large blur
	static const int High = 3;
}

/// The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
@JS()
class DepthOfFieldEffect extends PostProcessRenderEffect {
	
	/// Creates a new instance DepthOfFieldEffect
	/// @param scene The scene the effect belongs to.
	/// @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.
	/// @param pipelineTextureType The type of texture to be used when performing the post processing.
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory DepthOfFieldEffect(Scene scene, RenderTargetTexture? depthTexture, [int? blurLevel, num? pipelineTextureType, bool? blockCompilation]);
	
	/// The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
	external set focalLength(num value);
	
	external num get focalLength;
	
	/// F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
	external set fStop(num value);
	
	external num get fStop;
	
	/// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
	external set focusDistance(num value);
	
	external num get focusDistance;
	
	/// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
	external set lensSize(num value);
	
	external num get lensSize;
	
	/// Get the current class name of the current effet
	/// @returns "DepthOfFieldEffect"
	external String getClassName();
	
	/// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
	external set depthTexture(RenderTargetTexture value);
	
	/// Disposes each of the internal effects for a given camera.
	/// @param camera The camera to dispose the effect on.
	external void disposeEffects(Camera camera);
}

/* var */
/// @hidden
@JS()
external dynamic get displayPassPixelShader;

/// DisplayPassPostProcess which produces an output the same as it's input
@JS()
class DisplayPassPostProcess extends PostProcess {
	
	/// Creates the DisplayPassPostProcess
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	external factory DisplayPassPostProcess(String name, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// Gets a string identifying the name of the class
	/// @returns "DisplayPassPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get filterPixelShader;

/// Applies a kernel filter to the image
@JS()
class FilterPostProcess extends PostProcess {
	
	/// 
	/// @param name The name of the effect.
	/// @param kernelMatrix The matrix to be applied to the image
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	external factory FilterPostProcess(String name, Matrix kernelMatrix, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// The matrix to be applied to the image
	external Matrix get kernelMatrix;
	external set kernelMatrix(Matrix value);
	
	/// Gets a string identifying the name of the class
	/// @returns "FilterPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get fxaaPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get fxaaVertexShader;

/// Fxaa post process
/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#fxaa
@JS()
class FxaaPostProcess extends PostProcess {
	
	external factory FxaaPostProcess(String name, dynamic options, [Camera? camera, num? samplingMode, Engine? engine, bool? reusable, num? textureType]);
	
	/// Gets a string identifying the name of the class
	/// @returns "FxaaPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get grainPixelShader;

/// The GrainPostProcess adds noise to the image at mid luminance levels
@JS()
class GrainPostProcess extends PostProcess {
	
	/// Creates a new instance of @see GrainPostProcess
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory GrainPostProcess(String name, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// The intensity of the grain added (default: 30)
	external num get intensity;
	external set intensity(num value);
	
	/// If the grain should be randomized on every frame
	external bool get animated;
	external set animated(bool value);
	
	/// Gets a string identifying the name of the class
	/// @returns "GrainPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get highlightsPixelShader;

/// Extracts highlights from the image
/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses
@JS()
class HighlightsPostProcess extends PostProcess {
	
	/// Extracts highlights from the image
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of texture for the post process (default: Engine.TEXTURETYPE_UNSIGNED_INT)
	external factory HighlightsPostProcess(String name, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType]);
	
	/// Gets a string identifying the name of the class
	/// @returns "HighlightsPostProcess" string
	@override
	external String getClassName();
}

/// Contains all parameters needed for the prepass to perform
/// motion blur
@JS()
class MotionBlurConfiguration implements PrePassEffectConfiguration {
	external factory MotionBlurConfiguration();
	
	/// Is motion blur enabled
	@override
	external bool get enabled;
	@override
	external set enabled(bool value);
	
	/// Name of the configuration
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Textures that should be present in the MRT for this effect to work
	@override
	external List<num> get texturesRequired;
	@override
	external set texturesRequired(List<num> value);
	
	/// Post process to attach for this effect
	external PostProcess get postProcess;
	external set postProcess(PostProcess value);
	
	/// Disposes the effect configuration
	external void Function() get dispose;
	external set dispose(void Function() value);
	
	/// Creates the associated post process
	external PostProcess Function() get createPostProcess;
	external set createPostProcess(PostProcess Function() value);
}

/// Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
/// in several rendering techniques.
@JS()
class GeometryBufferRendererSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory GeometryBufferRendererSceneComponent(Scene scene);
	
	/// The component name helpful to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get motionBlurPixelShader;

/// The Motion Blur Post Process which blurs an image based on the objects velocity in scene.
/// Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.
/// As an example, all you have to do is to create the post-process:
/// var mb = new BABYLON.MotionBlurPostProcess(
/// 'mb',
/// scene,
/// 1.0,
/// camera
/// );
/// Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.
@JS()
class MotionBlurPostProcess extends PostProcess {
	
	/// Creates a new instance MotionBlurPostProcess
	/// @param name The name of the effect.
	/// @param scene The scene containing the objects to blur according to their velocity.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)
	/// @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)
	external factory MotionBlurPostProcess(String name, Scene scene, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation, bool? forceGeometryBuffer]);
	
	/// Defines how much the image is blurred by the movement. Default value is equal to 1
	external num get motionStrength;
	external set motionStrength(num value);
	
	/// Gets the number of iterations are used for motion blur quality. Default value is equal to 32
	external num get motionBlurSamples;
	
	/// Sets the number of iterations to be used for motion blur quality
	external set motionBlurSamples(num value);
	
	/// Gets wether or not the motion blur post-process is in object based mode.
	external bool get isObjectBased;
	
	/// Sets wether or not the motion blur post-process is in object based mode.
	external set isObjectBased(bool value);
	
	/// Gets a string identifying the name of the class
	/// @returns "MotionBlurPostProcess" string
	@override
	external String getClassName();
	
	/// Excludes the given skinned mesh from computing bones velocities.
	/// Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.
	/// @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.
	external void excludeSkinnedMesh(AbstractMesh skinnedMesh);
	
	/// Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.
	/// @param skinnedMesh The mesh containing the skeleton that has been ignored previously.
	/// @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.
	external void removeExcludedSkinnedMesh(AbstractMesh skinnedMesh);
	
	/// Disposes the post process.
	/// @param camera The camera to dispose the post process on.
	@override
	external void dispose([Camera? camera]);
}

/* var */
/// @hidden
@JS()
external dynamic get refractionPixelShader;

/// Post process which applies a refractin texture
/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction
@JS()
class RefractionPostProcess extends PostProcess {
	
	/// Initializes the RefractionPostProcess
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction
	/// @param name The name of the effect.
	/// @param refractionTextureUrl Url of the refraction texture to use
	/// @param color the base color of the refraction (used to taint the rendering)
	/// @param depth simulated refraction depth
	/// @param colorLevel the coefficient of the base color (0 to remove base color tainting)
	/// @param camera The camera to apply the render pass to.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	external factory RefractionPostProcess(String name, String refractionTextureUrl, Color3 color, num depth, num colorLevel, dynamic options, Camera camera, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// the base color of the refraction (used to taint the rendering)
	external Color3 get color;
	external set color(Color3 value);
	
	/// simulated refraction depth
	external num get depth;
	external set depth(num value);
	
	/// the coefficient of the base color (0 to remove base color tainting)
	external num get colorLevel;
	external set colorLevel(num value);
	
	/// Gets the url used to load the refraction texture
	external String get refractionTextureUrl;
	external set refractionTextureUrl(String value);
	
	/// Gets or sets the refraction texture
	/// Please note that you are responsible for disposing the texture if you set it manually
	external Texture get refractionTexture;
	
	external set refractionTexture(Texture value);
	
	/// Gets a string identifying the name of the class
	/// @returns "RefractionPostProcess" string
	@override
	external String getClassName();
	
	/// Disposes of the post process
	/// @param camera Camera to dispose post process on
	@override
	external void dispose([Camera? camera]);
}

/* var */
/// @hidden
@JS()
external dynamic get sharpenPixelShader;

/// The SharpenPostProcess applies a sharpen kernel to every pixel
/// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
@JS()
class SharpenPostProcess extends PostProcess {
	
	/// Creates a new instance ConvolutionPostProcess
	/// @param name The name of the effect.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory SharpenPostProcess(String name, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
	external num get colorAmount;
	external set colorAmount(num value);
	
	/// How much sharpness should be applied (default: 0.3)
	external num get edgeAmount;
	external set edgeAmount(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "SharpenPostProcess" string
	@override
	external String getClassName();
}

/// PostProcessRenderPipeline
/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
@JS()
class PostProcessRenderPipeline {
	
	/// Initializes a PostProcessRenderPipeline
	/// @param engine engine to add the pipeline to
	/// @param name name of the pipeline
	external factory PostProcessRenderPipeline(Engine engine, String name);
	
	/// List of inspectable custom properties (used by the Inspector)
	/// @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
	external List<IInspectable> get inspectableCustomProperties;
	external set inspectableCustomProperties(List<IInspectable> value);
	
	/// Gets pipeline name
	external String get name;
	
	/// Gets the list of attached cameras
	external List<Camera> get cameras;
	
	/// Gets the class name
	/// @returns "PostProcessRenderPipeline"
	external String getClassName();
	
	/// If all the render effects in the pipeline are supported
	external bool get isSupported;
	
	/// Adds an effect to the pipeline
	/// @param renderEffect the effect to add
	external void addEffect(PostProcessRenderEffect renderEffect);
	
	/// Sets the required values to the prepass renderer.
	/// @param prePassRenderer defines the prepass renderer to setup.
	/// @returns true if the pre pass is needed.
	external bool setPrePassRenderer(PrePassRenderer prePassRenderer);
	
	/// Disposes of the pipeline
	external void dispose();
}

/// PostProcessRenderPipelineManager class
/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
@JS()
class PostProcessRenderPipelineManager {
	
	/// Initializes a PostProcessRenderPipelineManager
	/// @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
	external factory PostProcessRenderPipelineManager();
	
	/// Gets the list of supported render pipelines
	external List<PostProcessRenderPipeline> get supportedPipelines;
	
	/// Adds a pipeline to the manager
	/// @param renderPipeline The pipeline to add
	external void addPipeline(PostProcessRenderPipeline renderPipeline);
	
	/// Attaches a camera to the pipeline
	/// @param renderPipelineName The name of the pipeline to attach to
	/// @param cameras the camera to attach
	/// @param unique if the camera can be attached multiple times to the pipeline
	external void attachCamerasToRenderPipeline(String renderPipelineName, dynamic cameras, [bool? unique]);
	
	/// Detaches a camera from the pipeline
	/// @param renderPipelineName The name of the pipeline to detach from
	/// @param cameras the camera to detach
	external void detachCamerasFromRenderPipeline(String renderPipelineName, dynamic cameras);
	
	/// Enables an effect by name on a pipeline
	/// @param renderPipelineName the name of the pipeline to enable the effect in
	/// @param renderEffectName the name of the effect to enable
	/// @param cameras the cameras that the effect should be enabled on
	external void enableEffectInPipeline(String renderPipelineName, String renderEffectName, dynamic cameras);
	
	/// Disables an effect by name on a pipeline
	/// @param renderPipelineName the name of the pipeline to disable the effect in
	/// @param renderEffectName the name of the effect to disable
	/// @param cameras the cameras that the effect should be disabled on
	external void disableEffectInPipeline(String renderPipelineName, String renderEffectName, dynamic cameras);
	
	/// Updates the state of all contained render pipelines and disposes of any non supported pipelines
	external void update();
	
	/// Disposes of the manager and pipelines
	external void dispose();
}

/// Defines the Render Pipeline scene component responsible to rendering pipelines
@JS()
class PostProcessRenderPipelineManagerSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory PostProcessRenderPipelineManagerSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
/// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
@JS()
class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
	
	/// @constructor
	/// @param name - The rendering pipeline name (default: "")
	/// @param hdr - If high dynamic range textures should be used (default: true)
	/// @param scene - The scene linked to this pipeline (default: the last created scene)
	/// @param cameras - The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)
	/// @param automaticBuild - if false, you will have to manually call prepare() to update the pipeline (default: true)
	external factory DefaultRenderingPipeline([String? name, bool? hdr, Scene? scene, List<Camera>? cameras, bool? automaticBuild]);
	
	/// @ignore
	/// ID of the image processing post process;
	external String get ImageProcessingPostProcessId;
	
	/// @ignore
	/// ID of the Fast Approximate Anti-Aliasing post process;
	external String get FxaaPostProcessId;
	
	/// Sharpen post process which will apply a sharpen convolution to enhance edges
	external SharpenPostProcess get sharpen;
	external set sharpen(SharpenPostProcess value);
	
	/// Depth of field effect, applies a blur based on how far away objects are from the focus distance.
	external DepthOfFieldEffect get depthOfField;
	external set depthOfField(DepthOfFieldEffect value);
	
	/// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
	external FxaaPostProcess get fxaa;
	external set fxaa(FxaaPostProcess value);
	
	/// Image post processing pass used to perform operations such as tone mapping or color grading.
	external ImageProcessingPostProcess get imageProcessing;
	external set imageProcessing(ImageProcessingPostProcess value);
	
	/// Chromatic aberration post process which will shift rgb colors in the image
	external ChromaticAberrationPostProcess get chromaticAberration;
	external set chromaticAberration(ChromaticAberrationPostProcess value);
	
	/// Grain post process which add noise to the image
	external GrainPostProcess get grain;
	external set grain(GrainPostProcess value);
	
	/// Animations which can be used to tweak settings over a period of time
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// This is triggered each time the pipeline has been built.
	external Observable<DefaultRenderingPipeline> get onBuildObservable;
	external set onBuildObservable(Observable<DefaultRenderingPipeline> value);
	
	/// Gets active scene
	external Scene get scene;
	
	/// Enable or disable the sharpen process from the pipeline
	external set sharpenEnabled(bool value);
	
	external bool get sharpenEnabled;
	
	/// Specifies the size of the bloom blur kernel, relative to the final output size
	external num get bloomKernel;
	
	external set bloomKernel(num value);
	
	/// The strength of the bloom.
	external set bloomWeight(num value);
	
	external num get bloomWeight;
	
	/// The strength of the bloom.
	external set bloomThreshold(num value);
	
	external num get bloomThreshold;
	
	/// The scale of the bloom, lower value will provide better performance.
	external set bloomScale(num value);
	
	external num get bloomScale;
	
	/// Enable or disable the bloom from the pipeline
	external set bloomEnabled(bool value);
	
	external bool get bloomEnabled;
	
	/// If the depth of field is enabled.
	external bool get depthOfFieldEnabled;
	
	external set depthOfFieldEnabled(bool value);
	
	/// Blur level of the depth of field effect. (Higher blur will effect performance)
	external int get depthOfFieldBlurLevel;
	
	external set depthOfFieldBlurLevel(int value);
	
	/// If the anti aliasing is enabled.
	external set fxaaEnabled(bool value);
	
	external bool get fxaaEnabled;
	
	/// MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
	external set samples(num value);
	
	external num get samples;
	
	/// If image processing is enabled.
	external set imageProcessingEnabled(bool value);
	
	external bool get imageProcessingEnabled;
	
	/// If glow layer is enabled. (Adds a glow effect to emmissive materials)
	external set glowLayerEnabled(bool value);
	
	external bool get glowLayerEnabled;
	
	/// Gets the glow layer (or null if not defined)
	external GlowLayer? get glowLayer;
	
	/// Enable or disable the chromaticAberration process from the pipeline
	external set chromaticAberrationEnabled(bool value);
	
	external bool get chromaticAberrationEnabled;
	
	/// Enable or disable the grain process from the pipeline
	external set grainEnabled(bool value);
	
	external bool get grainEnabled;
	
	/// Get the class name
	/// @returns "DefaultRenderingPipeline"
	@override
	external String getClassName();
	
	/// Force the compilation of the entire pipeline.
	external void prepare();
	
	/// Adds a camera to the pipeline
	/// @param camera the camera to be added
	external void addCamera(Camera camera);
	
	/// Removes a camera from the pipeline
	/// @param camera the camera to remove
	external void removeCamera(Camera camera);
	
	/// Dispose of the pipeline and stop all post processes
	@override
	external void dispose();
	
	/// Serialize the rendering pipeline (Used when exporting)
	/// @returns the serialized object
	external dynamic serialize();
	
	/// Parse the serialized pipeline
	/// @param source Source pipeline.
	/// @param scene The scene to load the pipeline to.
	/// @param rootUrl The URL of the serialized pipeline.
	/// @returns An instantiated pipeline from the serialized object.
	external static DefaultRenderingPipeline Parse(dynamic source, Scene scene, String rootUrl);
}

/* var */
/// @hidden
@JS()
external dynamic get lensHighlightsPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get depthOfFieldPixelShader;

/// BABYLON.JS Chromatic Aberration GLSL Shader
/// Author: Olivier Guyot
/// Separates very slightly R, G and B colors on the edges of the screen
/// Inspired by Francois Tarlier & Martins Upitis
@JS()
class LensRenderingPipeline extends PostProcessRenderPipeline {
	
	/// @constructor
	/// 
	/// Effect parameters are as follow:
	/// {
	/// chromatic_aberration: number;
	/// edge_blur: number;
	/// distortion: number;
	/// grain_amount: number;
	/// grain_texture: BABYLON.Texture;
	/// dof_focus_distance: number;
	/// dof_aperture: number;
	/// dof_darken: number;
	/// dof_pentagon: boolean;
	/// dof_gain: number;
	/// dof_threshold: number;
	/// blur_noise: boolean;
	/// }
	/// Note: if an effect parameter is unset, effect is disabled
	/// 
	/// @param name The rendering pipeline name
	/// @param parameters - An object containing all parameters (see above)
	/// @param scene The scene linked to this pipeline
	/// @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
	/// @param cameras The array of cameras that the rendering pipeline will be attached to
	external factory LensRenderingPipeline(String name, dynamic parameters, Scene scene, [num? ratio, List<Camera>? cameras]);
	
	/// @ignore
	/// The chromatic aberration PostProcess id in the pipeline
	external String get LensChromaticAberrationEffect;
	external set LensChromaticAberrationEffect(String value);
	
	/// @ignore
	/// The highlights enhancing PostProcess id in the pipeline
	external String get HighlightsEnhancingEffect;
	external set HighlightsEnhancingEffect(String value);
	
	/// @ignore
	/// The depth-of-field PostProcess id in the pipeline
	external String get LensDepthOfFieldEffect;
	external set LensDepthOfFieldEffect(String value);
	
	/// Get the class name
	/// @returns "LensRenderingPipeline"
	@override
	external String getClassName();
	
	/// Gets associated scene
	external Scene get scene;
	
	/// Gets or sets the edge blur
	external num get edgeBlur;
	
	external set edgeBlur(num value);
	
	/// Gets or sets the grain amount
	external num get grainAmount;
	
	external set grainAmount(num value);
	
	/// Gets or sets the chromatic aberration amount
	external num get chromaticAberration;
	
	external set chromaticAberration(num value);
	
	/// Gets or sets the depth of field aperture
	external num get dofAperture;
	
	external set dofAperture(num value);
	
	/// Gets or sets the edge distortion
	external num get edgeDistortion;
	
	external set edgeDistortion(num value);
	
	/// Gets or sets the depth of field distortion
	external num get dofDistortion;
	
	external set dofDistortion(num value);
	
	/// Gets or sets the darken out of focus amount
	external num get darkenOutOfFocus;
	
	external set darkenOutOfFocus(num value);
	
	/// Gets or sets a boolean indicating if blur noise is enabled
	external bool get blurNoise;
	
	external set blurNoise(bool value);
	
	/// Gets or sets a boolean indicating if pentagon bokeh is enabled
	external bool get pentagonBokeh;
	
	external set pentagonBokeh(bool value);
	
	/// Gets or sets the highlight grain amount
	external num get highlightsGain;
	
	external set highlightsGain(num value);
	
	/// Gets or sets the highlight threshold
	external num get highlightsThreshold;
	
	external set highlightsThreshold(num value);
	
	/// Sets the amount of blur at the edges
	/// @param amount blur amount
	external void setEdgeBlur(num amount);
	
	/// Sets edge blur to 0
	external void disableEdgeBlur();
	
	/// Sets the amout of grain
	/// @param amount Amount of grain
	external void setGrainAmount(num amount);
	
	/// Set grain amount to 0
	external void disableGrain();
	
	/// Sets the chromatic aberration amount
	/// @param amount amount of chromatic aberration
	external void setChromaticAberration(num amount);
	
	/// Sets chromatic aberration amount to 0
	external void disableChromaticAberration();
	
	/// Sets the EdgeDistortion amount
	/// @param amount amount of EdgeDistortion
	external void setEdgeDistortion(num amount);
	
	/// Sets edge distortion to 0
	external void disableEdgeDistortion();
	
	/// Sets the FocusDistance amount
	/// @param amount amount of FocusDistance
	external void setFocusDistance(num amount);
	
	/// Disables depth of field
	external void disableDepthOfField();
	
	/// Sets the Aperture amount
	/// @param amount amount of Aperture
	external void setAperture(num amount);
	
	/// Sets the DarkenOutOfFocus amount
	/// @param amount amount of DarkenOutOfFocus
	external void setDarkenOutOfFocus(num amount);
	
	/// Creates a pentagon bokeh effect
	external void enablePentagonBokeh();
	
	/// Disables the pentagon bokeh effect
	external void disablePentagonBokeh();
	
	/// Enables noise blur
	external void enableNoiseBlur();
	
	/// Disables noise blur
	external void disableNoiseBlur();
	
	/// Sets the HighlightsGain amount
	/// @param amount amount of HighlightsGain
	external void setHighlightsGain(num amount);
	
	/// Sets the HighlightsThreshold amount
	/// @param amount amount of HighlightsThreshold
	external void setHighlightsThreshold(num amount);
	
	/// Disables highlights
	external void disableHighlights();
	
	/// Removes the internal pipeline assets and detaches the pipeline from the scene cameras
	/// @param disableDepthRender If the scens depth rendering should be disabled (default: false)
	@override
	external void dispose([bool? disableDepthRender]);
}

/// Contains all parameters needed for the prepass to perform
/// screen space subsurface scattering
@JS()
class SSAO2Configuration implements PrePassEffectConfiguration {
	external factory SSAO2Configuration();
	
	/// Is subsurface enabled
	@override
	external bool get enabled;
	@override
	external set enabled(bool value);
	
	/// Name of the configuration
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Textures that should be present in the MRT for this effect to work
	@override
	external List<num> get texturesRequired;
	@override
	external set texturesRequired(List<num> value);
	
	/// Post process to attach for this effect
	external PostProcess get postProcess;
	external set postProcess(PostProcess value);
	
	/// Disposes the effect configuration
	external void Function() get dispose;
	external set dispose(void Function() value);
	
	/// Creates the associated post process
	external PostProcess Function() get createPostProcess;
	external set createPostProcess(PostProcess Function() value);
}

/* var */
/// @hidden
@JS()
external dynamic get ssao2PixelShader;

/* var */
/// @hidden
@JS()
external dynamic get ssaoCombinePixelShader;

/// Render pipeline to produce ssao effect
@JS()
class SSAO2RenderingPipeline extends PostProcessRenderPipeline {
	
	/// @constructor
	/// @param name The rendering pipeline name
	/// @param scene The scene linked to this pipeline
	/// @param ratio The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }
	/// @param cameras The array of cameras that the rendering pipeline will be attached to
	/// @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer
	external factory SSAO2RenderingPipeline(String name, Scene scene, dynamic ratio, [List<Camera>? cameras, bool? forceGeometryBuffer]);
	
	/// @ignore
	/// The PassPostProcess id in the pipeline that contains the original scene color
	external String get SSAOOriginalSceneColorEffect;
	external set SSAOOriginalSceneColorEffect(String value);
	
	/// @ignore
	/// The SSAO PostProcess id in the pipeline
	external String get SSAORenderEffect;
	external set SSAORenderEffect(String value);
	
	/// @ignore
	/// The horizontal blur PostProcess id in the pipeline
	external String get SSAOBlurHRenderEffect;
	external set SSAOBlurHRenderEffect(String value);
	
	/// @ignore
	/// The vertical blur PostProcess id in the pipeline
	external String get SSAOBlurVRenderEffect;
	external set SSAOBlurVRenderEffect(String value);
	
	/// @ignore
	/// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
	external String get SSAOCombineRenderEffect;
	external set SSAOCombineRenderEffect(String value);
	
	/// The output strength of the SSAO post-process. Default value is 1.0.
	external num get totalStrength;
	external set totalStrength(num value);
	
	/// Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
	external num get maxZ;
	external set maxZ(num value);
	
	/// In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
	external num get minZAspect;
	external set minZAspect(num value);
	
	/// Number of samples used for the SSAO calculations. Default value is 8
	external set samples(num value);
	
	external num get samples;
	
	/// Number of samples to use for antialiasing
	external set textureSamples(num value);
	
	external num get textureSamples;
	
	/// If bilateral blur should be used
	external set expensiveBlur(bool value);
	
	external bool get expensiveBlur;
	
	/// The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
	external num get radius;
	external set radius(num value);
	
	/// The base color of the SSAO post-process
	/// The final result is "base + ssao" between [0, 1]
	external num get base;
	external set base(num value);
	
	/// Support test.
	external static bool get IsSupported;
	
	/// Gets active scene
	external Scene get scene;
	
	/// Get the class name
	/// @returns "SSAO2RenderingPipeline"
	@override
	external String getClassName();
	
	/// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
	@override
	external void dispose([bool? disableGeometryBufferRenderer]);
	
	/// Serialize the rendering pipeline (Used when exporting)
	/// @returns the serialized object
	external dynamic serialize();
	
	/// Parse the serialized pipeline
	/// @param source Source pipeline.
	/// @param scene The scene to load the pipeline to.
	/// @param rootUrl The URL of the serialized pipeline.
	/// @returns An instantiated pipeline from the serialized object.
	external static SSAO2RenderingPipeline Parse(dynamic source, Scene scene, String rootUrl);
}

/* var */
/// @hidden
@JS()
external dynamic get ssaoPixelShader;

/// Render pipeline to produce ssao effect
@JS()
class SSAORenderingPipeline extends PostProcessRenderPipeline {
	
	/// @constructor
	/// @param name - The rendering pipeline name
	/// @param scene - The scene linked to this pipeline
	/// @param ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }
	/// @param cameras - The array of cameras that the rendering pipeline will be attached to
	external factory SSAORenderingPipeline(String name, Scene scene, dynamic ratio, [List<Camera>? cameras]);
	
	/// @ignore
	/// The PassPostProcess id in the pipeline that contains the original scene color
	external String get SSAOOriginalSceneColorEffect;
	external set SSAOOriginalSceneColorEffect(String value);
	
	/// @ignore
	/// The SSAO PostProcess id in the pipeline
	external String get SSAORenderEffect;
	external set SSAORenderEffect(String value);
	
	/// @ignore
	/// The horizontal blur PostProcess id in the pipeline
	external String get SSAOBlurHRenderEffect;
	external set SSAOBlurHRenderEffect(String value);
	
	/// @ignore
	/// The vertical blur PostProcess id in the pipeline
	external String get SSAOBlurVRenderEffect;
	external set SSAOBlurVRenderEffect(String value);
	
	/// @ignore
	/// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
	external String get SSAOCombineRenderEffect;
	external set SSAOCombineRenderEffect(String value);
	
	/// The output strength of the SSAO post-process. Default value is 1.0.
	external num get totalStrength;
	external set totalStrength(num value);
	
	/// The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
	external num get radius;
	external set radius(num value);
	
	/// Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
	/// Must not be equal to fallOff and superior to fallOff.
	/// Default value is 0.0075
	external num get area;
	external set area(num value);
	
	/// Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
	/// Must not be equal to area and inferior to area.
	/// Default value is 0.000001
	external num get fallOff;
	external set fallOff(num value);
	
	/// The base color of the SSAO post-process
	/// The final result is "base + ssao" between [0, 1]
	external num get base;
	external set base(num value);
	
	/// Gets active scene
	external Scene get scene;
	
	/// Get the class name
	/// @returns "SSAORenderingPipeline"
	@override
	external String getClassName();
	
	/// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
	@override
	external void dispose([bool? disableDepthRender]);
}

/// Contains all parameters needed for the prepass to perform
/// screen space reflections
@JS()
class ScreenSpaceReflectionsConfiguration implements PrePassEffectConfiguration {
	external factory ScreenSpaceReflectionsConfiguration();
	
	/// Is ssr enabled
	@override
	external bool get enabled;
	@override
	external set enabled(bool value);
	
	/// Name of the configuration
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Textures that should be present in the MRT for this effect to work
	@override
	external List<num> get texturesRequired;
	@override
	external set texturesRequired(List<num> value);
	
	/// Post process to attach for this effect
	external PostProcess get postProcess;
	external set postProcess(PostProcess value);
	
	/// Disposes the effect configuration
	external void Function() get dispose;
	external set dispose(void Function() value);
	
	/// Creates the associated post process
	external PostProcess Function() get createPostProcess;
	external set createPostProcess(PostProcess Function() value);
}

/* var */
/// @hidden
@JS()
external dynamic get screenSpaceReflectionPixelShader;

/// The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).
/// Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.
@JS()
class ScreenSpaceReflectionPostProcess extends PostProcess {
	
	/// Creates a new instance of ScreenSpaceReflectionPostProcess.
	/// @param name The name of the effect.
	/// @param scene The scene containing the objects to calculate reflections.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)
	/// @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)
	external factory ScreenSpaceReflectionPostProcess(String name, Scene scene, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation, bool? forceGeometryBuffer]);
	
	/// Gets or sets a reflection threshold mainly used to adjust the reflection's height.
	external num get threshold;
	external set threshold(num value);
	
	/// Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.
	external num get strength;
	external set strength(num value);
	
	/// Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.
	external num get reflectionSpecularFalloffExponent;
	external set reflectionSpecularFalloffExponent(num value);
	
	/// Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]
	external num get step;
	external set step(num value);
	
	/// Gets or sets the factor applied when computing roughness. Default value is 0.2.
	external num get roughnessFactor;
	external set roughnessFactor(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "ScreenSpaceReflectionPostProcess" string
	@override
	external String getClassName();
	
	/// Gets wether or not smoothing reflections is enabled.
	/// Enabling smoothing will require more GPU power and can generate a drop in FPS.
	external bool get enableSmoothReflections;
	
	/// Sets wether or not smoothing reflections is enabled.
	/// Enabling smoothing will require more GPU power and can generate a drop in FPS.
	external set enableSmoothReflections(bool value);
	
	/// Gets the number of samples taken while computing reflections. More samples count is high,
	/// more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].
	external num get reflectionSamples;
	
	/// Sets the number of samples taken while computing reflections. More samples count is high,
	/// more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].
	external set reflectionSamples(num value);
	
	/// Gets the number of samples taken while smoothing reflections. More samples count is high,
	/// more the post-process will require GPU power and can generate a drop in FPS.
	/// Default value (5.0) work pretty well in all cases but can be adjusted.
	external num get smoothSteps;
	
	external set smoothSteps(num value);
}

/* var */
/// @hidden
@JS()
external dynamic get standardPixelShader;

/// Standard rendering pipeline
/// Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
/// @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline
@JS()
class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
	
	/// Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
	/// @constructor
	/// @param name The rendering pipeline name
	/// @param scene The scene linked to this pipeline
	/// @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
	/// @param originalPostProcess the custom original color post-process. Must be "reusable". Can be null.
	/// @param cameras The array of cameras that the rendering pipeline will be attached to
	external factory StandardRenderingPipeline(String name, Scene scene, num ratio, [PostProcess? originalPostProcess, List<Camera>? cameras]);
	
	/// Post-process which contains the original scene color before the pipeline applies all the effects
	external PostProcess? get originalPostProcess;
	external set originalPostProcess(PostProcess? value);
	
	/// Post-process used to down scale an image x4
	external PostProcess? get downSampleX4PostProcess;
	external set downSampleX4PostProcess(PostProcess? value);
	
	/// Post-process used to calculate the illuminated surfaces controlled by a threshold
	external PostProcess? get brightPassPostProcess;
	external set brightPassPostProcess(PostProcess? value);
	
	/// Post-process array storing all the horizontal blur post-processes used by the pipeline
	external List<PostProcess> get blurHPostProcesses;
	external set blurHPostProcesses(List<PostProcess> value);
	
	/// Post-process array storing all the vertical blur post-processes used by the pipeline
	external List<PostProcess> get blurVPostProcesses;
	external set blurVPostProcesses(List<PostProcess> value);
	
	/// Post-process used to add colors of 2 textures (typically brightness + real scene color)
	external PostProcess? get textureAdderPostProcess;
	external set textureAdderPostProcess(PostProcess? value);
	
	/// Post-process used to create volumetric lighting effect
	external PostProcess? get volumetricLightPostProcess;
	external set volumetricLightPostProcess(PostProcess? value);
	
	/// Post-process used to smooth the previous volumetric light post-process on the X axis
	external BlurPostProcess? get volumetricLightSmoothXPostProcess;
	external set volumetricLightSmoothXPostProcess(BlurPostProcess? value);
	
	/// Post-process used to smooth the previous volumetric light post-process on the Y axis
	external BlurPostProcess? get volumetricLightSmoothYPostProcess;
	external set volumetricLightSmoothYPostProcess(BlurPostProcess? value);
	
	/// Post-process used to merge the volumetric light effect and the real scene color
	external PostProcess? get volumetricLightMergePostProces;
	external set volumetricLightMergePostProces(PostProcess? value);
	
	/// Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)
	external PostProcess? get volumetricLightFinalPostProcess;
	external set volumetricLightFinalPostProcess(PostProcess? value);
	
	/// Base post-process used to calculate the average luminance of the final image for HDR
	external PostProcess? get luminancePostProcess;
	external set luminancePostProcess(PostProcess? value);
	
	/// Post-processes used to create down sample post-processes in order to get
	/// the average luminance of the final image for HDR
	/// Array of length "StandardRenderingPipeline.LuminanceSteps"
	external List<PostProcess> get luminanceDownSamplePostProcesses;
	external set luminanceDownSamplePostProcesses(List<PostProcess> value);
	
	/// Post-process used to create a HDR effect (light adaptation)
	external PostProcess? get hdrPostProcess;
	external set hdrPostProcess(PostProcess? value);
	
	/// Post-process used to store the final texture adder post-process (attach/detach for debug purpose)
	external PostProcess? get textureAdderFinalPostProcess;
	external set textureAdderFinalPostProcess(PostProcess? value);
	
	/// Post-process used to store the final lens flare post-process (attach/detach for debug purpose)
	external PostProcess? get lensFlareFinalPostProcess;
	external set lensFlareFinalPostProcess(PostProcess? value);
	
	/// Post-process used to merge the final HDR post-process and the real scene color
	external PostProcess? get hdrFinalPostProcess;
	external set hdrFinalPostProcess(PostProcess? value);
	
	/// Post-process used to create a lens flare effect
	external PostProcess? get lensFlarePostProcess;
	external set lensFlarePostProcess(PostProcess? value);
	
	/// Post-process that merges the result of the lens flare post-process and the real scene color
	external PostProcess? get lensFlareComposePostProcess;
	external set lensFlareComposePostProcess(PostProcess? value);
	
	/// Post-process used to create a motion blur effect
	external PostProcess? get motionBlurPostProcess;
	external set motionBlurPostProcess(PostProcess? value);
	
	/// Post-process used to create a depth of field effect
	external PostProcess? get depthOfFieldPostProcess;
	external set depthOfFieldPostProcess(PostProcess? value);
	
	/// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
	external FxaaPostProcess? get fxaaPostProcess;
	external set fxaaPostProcess(FxaaPostProcess? value);
	
	/// Post-process used to simulate realtime reflections using the screen space and geometry renderer.
	external ScreenSpaceReflectionPostProcess? get screenSpaceReflectionPostProcess;
	external set screenSpaceReflectionPostProcess(ScreenSpaceReflectionPostProcess? value);
	
	/// Represents the brightness threshold in order to configure the illuminated surfaces
	external num get brightThreshold;
	external set brightThreshold(num value);
	
	/// Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)
	external num get blurWidth;
	external set blurWidth(num value);
	
	/// Sets if the blur for highlighted surfaces must be only horizontal
	external bool get horizontalBlur;
	external set horizontalBlur(bool value);
	
	/// Gets the overall exposure used by the pipeline
	external num get exposure;
	
	/// Sets the overall exposure used by the pipeline
	external set exposure(num value);
	
	/// Texture used typically to simulate "dirty" on camera lens
	external Texture? get lensTexture;
	external set lensTexture(Texture? value);
	
	/// Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]
	external num get volumetricLightCoefficient;
	external set volumetricLightCoefficient(num value);
	
	/// The overall power of volumetric lights, typically in interval [0, 10] maximum
	external num get volumetricLightPower;
	external set volumetricLightPower(num value);
	
	/// Used the set the blur intensity to smooth the volumetric lights
	external num get volumetricLightBlurScale;
	external set volumetricLightBlurScale(num value);
	
	/// Light (spot or directional) used to generate the volumetric lights rays
	/// The source light must have a shadow generate so the pipeline can get its
	/// depth map
	external dynamic? get sourceLight;
	external set sourceLight(dynamic? value);
	
	/// For eye adaptation, represents the minimum luminance the eye can see
	external num get hdrMinimumLuminance;
	external set hdrMinimumLuminance(num value);
	
	/// For eye adaptation, represents the decrease luminance speed
	external num get hdrDecreaseRate;
	external set hdrDecreaseRate(num value);
	
	/// For eye adaptation, represents the increase luminance speed
	external num get hdrIncreaseRate;
	external set hdrIncreaseRate(num value);
	
	/// Gets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process
	external bool get hdrAutoExposure;
	
	/// Sets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process
	external set hdrAutoExposure(bool value);
	
	/// Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled
	external Texture? get lensColorTexture;
	external set lensColorTexture(Texture? value);
	
	/// The overall strengh for the lens flare effect
	external num get lensFlareStrength;
	external set lensFlareStrength(num value);
	
	/// Dispersion coefficient for lens flare ghosts
	external num get lensFlareGhostDispersal;
	external set lensFlareGhostDispersal(num value);
	
	/// Main lens flare halo width
	external num get lensFlareHaloWidth;
	external set lensFlareHaloWidth(num value);
	
	/// Based on the lens distortion effect, defines how much the lens flare result
	/// is distorted
	external num get lensFlareDistortionStrength;
	external set lensFlareDistortionStrength(num value);
	
	/// Configures the blur intensity used for for lens flare (halo)
	external num get lensFlareBlurWidth;
	external set lensFlareBlurWidth(num value);
	
	/// Lens star texture must be used to simulate rays on the flares and is available
	/// in the documentation
	external Texture? get lensStarTexture;
	external set lensStarTexture(Texture? value);
	
	/// As the "lensTexture" (can be the same texture or different), it is used to apply the lens
	/// flare effect by taking account of the dirt texture
	external Texture? get lensFlareDirtTexture;
	external set lensFlareDirtTexture(Texture? value);
	
	/// Represents the focal length for the depth of field effect
	external num get depthOfFieldDistance;
	external set depthOfFieldDistance(num value);
	
	/// Represents the blur intensity for the blurred part of the depth of field effect
	external num get depthOfFieldBlurWidth;
	external set depthOfFieldBlurWidth(num value);
	
	/// Gets how much the image is blurred by the movement while using the motion blur post-process
	external num get motionStrength;
	
	/// Sets how much the image is blurred by the movement while using the motion blur post-process
	external set motionStrength(num value);
	
	/// Gets wether or not the motion blur post-process is object based or screen based.
	external bool get objectBasedMotionBlur;
	
	/// Sets wether or not the motion blur post-process should be object based or screen based
	external set objectBasedMotionBlur(bool value);
	
	/// List of animations for the pipeline (IAnimatable implementation)
	@override
	external List<Animation>? get animations;
	@override
	external set animations(List<Animation>? value);
	
	/// @ignore
	/// Specifies if the bloom pipeline is enabled
	external bool get BloomEnabled;
	
	external set BloomEnabled(bool value);
	
	/// @ignore
	/// Specifies if the depth of field pipeline is enabed
	external bool get DepthOfFieldEnabled;
	
	external set DepthOfFieldEnabled(bool value);
	
	/// @ignore
	/// Specifies if the lens flare pipeline is enabed
	external bool get LensFlareEnabled;
	
	external set LensFlareEnabled(bool value);
	
	/// @ignore
	/// Specifies if the HDR pipeline is enabled
	external bool get HDREnabled;
	
	external set HDREnabled(bool value);
	
	/// @ignore
	/// Specifies if the volumetric lights scattering effect is enabled
	external bool get VLSEnabled;
	
	external set VLSEnabled(bool value);
	
	/// @ignore
	/// Specifies if the motion blur effect is enabled
	external bool get MotionBlurEnabled;
	
	external set MotionBlurEnabled(bool value);
	
	/// Specifies if anti-aliasing is enabled
	external bool get fxaaEnabled;
	
	external set fxaaEnabled(bool value);
	
	/// Specifies if screen space reflections are enabled.
	external bool get screenSpaceReflectionsEnabled;
	
	external set screenSpaceReflectionsEnabled(bool value);
	
	/// Specifies the number of steps used to calculate the volumetric lights
	/// Typically in interval [50, 200]
	external num get volumetricLightStepsCount;
	
	external set volumetricLightStepsCount(num value);
	
	/// Specifies the number of samples used for the motion blur effect
	/// Typically in interval [16, 64]
	external num get motionBlurSamples;
	
	external set motionBlurSamples(num value);
	
	/// Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
	external num get samples;
	
	external set samples(num value);
	
	/// Dispose of the pipeline and stop all post processes
	@override
	external void dispose();
	
	/// Serialize the rendering pipeline (Used when exporting)
	/// @returns the serialized object
	external dynamic serialize();
	
	/// Parse the serialized pipeline
	/// @param source Source pipeline.
	/// @param scene The scene to load the pipeline to.
	/// @param rootUrl The URL of the serialized pipeline.
	/// @returns An instantiated pipeline from the serialized object.
	external static StandardRenderingPipeline Parse(dynamic source, Scene scene, String rootUrl);
	
	/// Luminance steps
	external static num get LuminanceSteps;
	external static set LuminanceSteps(num value);
}

/* var */
/// @hidden
@JS()
external dynamic get stereoscopicInterlacePixelShader;

/// StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing
@JS()
class StereoscopicInterlacePostProcessI extends PostProcess {
	
	/// Initializes a StereoscopicInterlacePostProcessI
	/// @param name The name of the effect.
	/// @param rigCameras The rig cameras to be appled to the post process
	/// @param isStereoscopicHoriz If the rendered results are horizontal or vertical
	/// @param isStereoscopicInterlaced If the rendered results are alternate line interlaced
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	external factory StereoscopicInterlacePostProcessI(String name, List<Camera> rigCameras, bool isStereoscopicHoriz, bool isStereoscopicInterlaced, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// Gets a string identifying the name of the class
	/// @returns "StereoscopicInterlacePostProcessI" string
	@override
	external String getClassName();
}

/// StereoscopicInterlacePostProcess used to render stereo views from a rigged camera
@JS()
class StereoscopicInterlacePostProcess extends PostProcess {
	
	/// Initializes a StereoscopicInterlacePostProcess
	/// @param name The name of the effect.
	/// @param rigCameras The rig cameras to be appled to the post process
	/// @param isStereoscopicHoriz If the rendered results are horizontal or verticle
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	external factory StereoscopicInterlacePostProcess(String name, List<Camera> rigCameras, bool isStereoscopicHoriz, [num? samplingMode, Engine? engine, bool? reusable]);
	
	/// Gets a string identifying the name of the class
	/// @returns "StereoscopicInterlacePostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get tonemapPixelShader;

/* enum */
abstract class TonemappingOperator {
	
	/// Hable
	static const int Hable = 1;
	
	/// Reinhard
	static const int Reinhard = 2;
	
	/// HejiDawson
	static const int HejiDawson = 3;
	
	/// Photographic
	static const int Photographic = 4;
}

/// Defines a post process to apply tone mapping
@JS()
class TonemapPostProcess extends PostProcess {
	
	/// Creates a new TonemapPostProcess
	/// @param name defines the name of the postprocess
	/// @param _operator defines the operator to use
	/// @param exposureAdjustment defines the required exposure adjustement
	/// @param camera defines the camera to use (can be null)
	/// @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)
	/// @param engine defines the hosting engine (can be ignore if camera is set)
	/// @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
	external factory TonemapPostProcess(String name, int _operator, num exposureAdjustment, Camera camera, [num? samplingMode, Engine? engine, num? textureFormat]);
	
	/// Defines the required exposure adjustement
	external num get exposureAdjustment;
	external set exposureAdjustment(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "TonemapPostProcess" string
	@override
	external String getClassName();
}

/* var */
/// @hidden
@JS()
external dynamic get volumetricLightScatteringPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get volumetricLightScatteringPassVertexShader;

/* var */
/// @hidden
@JS()
external dynamic get volumetricLightScatteringPassPixelShader;

/// Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html
@JS()
class VolumetricLightScatteringPostProcess extends PostProcess {
	
	/// @constructor
	/// @param name The post-process name
	/// @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
	/// @param camera The camera that the post-process will be attached to
	/// @param mesh The mesh used to create the light scattering
	/// @param samples The post-process quality, default 100
	/// @param samplingModeThe post-process filtering mode
	/// @param engine The babylon engine
	/// @param reusable If the post-process is reusable
	/// @param scene The constructor needs a scene reference to initialize internal components. If "camera" is null a "scene" must be provided
	external factory VolumetricLightScatteringPostProcess(String name, dynamic ratio, Camera camera, [Mesh? mesh, num? samples, num? samplingMode, Engine? engine, bool? reusable, Scene? scene]);
	
	/// If not undefined, the mesh position is computed from the attached node position
	external VolumetricLightScatteringPostProcessAttachedNode get attachedNode;
	external set attachedNode(VolumetricLightScatteringPostProcessAttachedNode value);
	
	/// Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
	external Vector3 get customMeshPosition;
	external set customMeshPosition(Vector3 value);
	
	/// Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
	external bool get useCustomMeshPosition;
	external set useCustomMeshPosition(bool value);
	
	/// If the post-process should inverse the light scattering direction
	external bool get invert;
	external set invert(bool value);
	
	/// The internal mesh used by the post-process
	external Mesh get mesh;
	external set mesh(Mesh value);
	
	/// @hidden
	/// VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead
	external bool get useDiffuseColor;
	
	external set useDiffuseColor(bool value);
	
	/// Array containing the excluded meshes not rendered in the internal pass
	external List<AbstractMesh> get excludedMeshes;
	external set excludedMeshes(List<AbstractMesh> value);
	
	/// Controls the overall intensity of the post-process
	external num get exposure;
	external set exposure(num value);
	
	/// Dissipates each sample's contribution in range [0, 1]
	external num get decay;
	external set decay(num value);
	
	/// Controls the overall intensity of each sample
	external num get weight;
	external set weight(num value);
	
	/// Controls the density of each sample
	external num get density;
	external set density(num value);
	
	/// Returns the string "VolumetricLightScatteringPostProcess"
	/// @returns "VolumetricLightScatteringPostProcess"
	@override
	external String getClassName();
	
	/// Sets the new light position for light scattering effect
	/// @param position The new custom light position
	external void setCustomMeshPosition(Vector3 position);
	
	/// Returns the light position for light scattering effect
	/// @return Vector3 The custom light position
	external Vector3 getCustomMeshPosition();
	
	/// Disposes the internal assets and detaches the post-process from the camera
	@override
	external void dispose([Camera? camera]);
	
	/// Returns the render target texture used by the post-process
	/// @return the render target texture used by the post-process
	external RenderTargetTexture getPass();
	
	/// Creates a default mesh for the Volumeric Light Scattering post-process
	/// @param name The mesh name
	/// @param scene The scene where to create the mesh
	/// @return the default mesh
	external static Mesh CreateDefaultMesh(String name, Scene scene);
}

/* var */
/// @hidden
@JS()
external dynamic get screenSpaceCurvaturePixelShader;

/// The Screen Space curvature effect can help highlighting ridge and valley of a model.
@JS()
class ScreenSpaceCurvaturePostProcess extends PostProcess {
	
	/// Creates a new instance ScreenSpaceCurvaturePostProcess
	/// @param name The name of the effect.
	/// @param scene The scene containing the objects to blur according to their velocity.
	/// @param options The required width/height ratio to downsize to before computing the render pass.
	/// @param camera The camera to apply the render pass to.
	/// @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
	/// @param engine The engine which the post process will be applied. (default: current engine)
	/// @param reusable If the post process can be reused on the same frame. (default: false)
	/// @param textureType Type of textures used when performing the post process. (default: 0)
	/// @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
	external factory ScreenSpaceCurvaturePostProcess(String name, Scene scene, dynamic options, Camera? camera, [num? samplingMode, Engine? engine, bool? reusable, num? textureType, bool? blockCompilation]);
	
	/// Defines how much ridge the curvature effect displays.
	external num get ridge;
	external set ridge(num value);
	
	/// Defines how much valley the curvature effect displays.
	external num get valley;
	external set valley(num value);
	
	/// Gets a string identifying the name of the class
	/// @returns "ScreenSpaceCurvaturePostProcess" string
	@override
	external String getClassName();
	
	/// Support test.
	external static bool get IsSupported;
}

/// Component responsible of rendering the bounding box of the meshes in a scene.
/// This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties
@JS()
class BoundingBoxRenderer implements ISceneComponent {
	
	/// Instantiates a new bounding box renderer in a scene.
	/// @param scene the scene the  renderer renders in
	external factory BoundingBoxRenderer(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Color of the bounding box lines placed in front of an object
	external Color3 get frontColor;
	external set frontColor(Color3 value);
	
	/// Color of the bounding box lines placed behind an object
	external Color3 get backColor;
	external set backColor(Color3 value);
	
	/// Defines if the renderer should show the back lines or not
	external bool get showBackLines;
	external set showBackLines(bool value);
	
	/// Observable raised before rendering a bounding box
	external Observable<BoundingBox> get onBeforeBoxRenderingObservable;
	external set onBeforeBoxRenderingObservable(Observable<BoundingBox> value);
	
	/// Observable raised after rendering a bounding box
	external Observable<BoundingBox> get onAfterBoxRenderingObservable;
	external set onAfterBoxRenderingObservable(Observable<BoundingBox> value);
	
	/// Observable raised after resources are created
	external Observable<BoundingBoxRenderer> get onResourcesReadyObservable;
	external set onResourcesReadyObservable(Observable<BoundingBoxRenderer> value);
	
	/// When false, no bounding boxes will be rendered
	external bool get enabled;
	external set enabled(bool value);
	
	/// @hidden
	external SmartArray<BoundingBox> get renderList;
	external set renderList(SmartArray<BoundingBox> value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// @hidden
	external void reset();
	
	/// Render the bounding boxes of a specific rendering group
	/// @param renderingGroupId defines the rendering group to render
	external void render(num renderingGroupId);
	
	/// In case of occlusion queries, we can render the occlusion bounding box through this method
	/// @param mesh Define the mesh to render the occlusion bounding box for
	external void renderOcclusionBoundingBox(AbstractMesh mesh);
	
	/// Dispose and release the resources attached to this renderer.
	@override
	external void dispose();
}

/// Defines the Depth Renderer scene component responsible to manage a depth buffer useful
/// in several rendering techniques.
@JS()
class DepthRendererSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory DepthRendererSceneComponent(Scene scene);
	
	/// The component name helpfull to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/// Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
/// in several rendering techniques.
@JS()
class PrePassRendererSceneComponent implements ISceneComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory PrePassRendererSceneComponent(Scene scene);
	
	/// The component name helpful to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get fibonacci;

/* var */
/// @hidden
@JS()
external dynamic get diffusionProfile;

/* var */
/// @hidden
@JS()
external dynamic get subSurfaceScatteringPixelShader;

/// Sub surface scattering post process
@JS()
class SubSurfaceScatteringPostProcess extends PostProcess {
	
	external factory SubSurfaceScatteringPostProcess(String name, Scene scene, dynamic options, [Camera? camera, num? samplingMode, Engine? engine, bool? reusable, num? textureType]);
	
	/// Gets a string identifying the name of the class
	/// @returns "SubSurfaceScatteringPostProcess" string
	@override
	external String getClassName();
}

/// Contains all parameters needed for the prepass to perform
/// screen space subsurface scattering
@JS()
class SubSurfaceConfiguration implements PrePassEffectConfiguration {
	
	/// Builds a subsurface configuration object
	/// @param scene The scene
	external factory SubSurfaceConfiguration(Scene scene);
	
	/// Post process to attach for screen space subsurface scattering
	@override
	external SubSurfaceScatteringPostProcess get postProcess;
	@override
	/* Manual Fix 30 */
	external set postProcess(PostProcess value);
	
	/// Diffusion profile color for subsurface scattering
	external List<num> get ssDiffusionS;
	
	/// Diffusion profile max color channel value for subsurface scattering
	external List<num> get ssDiffusionD;
	
	/// Diffusion profile filter radius for subsurface scattering
	external List<num> get ssFilterRadii;
	
	/// Is subsurface enabled
	@override
	external bool get enabled;
	@override
	external set enabled(bool value);
	
	/// Name of the configuration
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Diffusion profile colors for subsurface scattering
	/// You can add one diffusion color using `addDiffusionProfile` on `scene.prePassRenderer`
	/// See ...
	/// Note that you can only store up to 5 of them
	external List<Color3> get ssDiffusionProfileColors;
	external set ssDiffusionProfileColors(List<Color3> value);
	
	/// Defines the ratio real world => scene units.
	/// Used for subsurface scattering
	external num get metersPerUnit;
	external set metersPerUnit(num value);
	
	/// Textures that should be present in the MRT for this effect to work
	@override
	external List<num> get texturesRequired;
	@override
	external set texturesRequired(List<num> value);
	
	/// Adds a new diffusion profile.
	/// Useful for more realistic subsurface scattering on diverse materials.
	/// @param color The color of the diffusion profile. Should be the average color of the material.
	/// @return The index of the diffusion profile for the material subsurface configuration
	external num addDiffusionProfile(Color3 color);
	
	/// Deletes all diffusion profiles.
	/// Note that in order to render subsurface scattering, you should have at least 1 diffusion profile.
	external void clearAllDiffusionProfiles();
	
	/// @hidden
	/// https://zero-radiance.github.io/post/sampling-diffusion/
	/// 
	/// Importance sample the normalized diffuse reflectance profile for the computed value of 's'.
	/// ------------------------------------------------------------------------------------
	/// R[r, phi, s]   = s * (Exp[-r * s] + Exp[-r * s / 3]) / (8 * Pi * r)
	/// PDF[r, phi, s] = r * R[r, phi, s]
	/// CDF[r, s]      = 1 - 1/4 * Exp[-r * s] - 3/4 * Exp[-r * s / 3]
	/// ------------------------------------------------------------------------------------
	/// We importance sample the color channel with the widest scattering distance.
	external num getDiffusionProfileParameters(Color3 color);
	
	@override
	external PostProcess Function() get createPostProcess;
	@override
	external set createPostProcess(PostProcess Function() value);
	
	@override
	external void Function() get dispose;
	@override
	external set dispose(void Function() value);
}

/// Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
/// in several rendering techniques.
@JS()
class SubSurfaceSceneComponent implements ISceneSerializableComponent {
	
	/// Creates a new instance of the component for the given scene
	/// @param scene Defines the scene to register the component in
	external factory SubSurfaceSceneComponent(Scene scene);
	
	/// The component name helpful to identify the component in the list of scene components.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Registers the component in a given scene
	@override
	external void register();
	
	/// Serializes the component data to the specified json object
	/// @param serializationObject The object to serialize to
	@override
	external void serialize(dynamic serializationObject);
	
	/// Adds all the elements from the container to the scene
	/// @param container the container holding the elements
	@override
	external void addFromContainer(AbstractScene container);
	
	/// Removes all the elements in the container from the scene
	/// @param container contains the elements to remove
	/// @param dispose if the removed element should be disposed (default: false)
	@override
	external void removeFromContainer(AbstractScene container, [bool? dispose]);
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources
	@override
	external void dispose();
}

/* var */
/// @hidden
@JS()
external dynamic get outlinePixelShader;

/* var */
/// @hidden
@JS()
external dynamic get outlineVertexShader;

/// This class is responsible to draw bothe outline/overlay of meshes.
/// It should not be used directly but through the available method on mesh.
@JS()
class OutlineRenderer implements ISceneComponent {
	
	/// Instantiates a new outline renderer. (There could be only one per scene).
	/// @param scene Defines the scene it belongs to
	external factory OutlineRenderer(Scene scene);
	
	/// The name of the component. Each component must have a unique name.
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The scene the component belongs to.
	@override
	external Scene get scene;
	@override
	external set scene(Scene value);
	
	/// Defines a zOffset to prevent zFighting between the overlay and the mesh.
	external num get zOffset;
	external set zOffset(num value);
	
	/// Register the component to one instance of a scene.
	@override
	external void register();
	
	/// Rebuilds the elements related to this component in case of
	/// context lost for instance.
	@override
	external void rebuild();
	
	/// Disposes the component and the associated ressources.
	@override
	external void dispose();
	
	/// Renders the outline in the canvas.
	/// @param subMesh Defines the sumesh to render
	/// @param batch Defines the batch of meshes in case of instances
	/// @param useOverlay Defines if the rendering is for the overlay or the outline
	external void render(SubMesh subMesh, dynamic /* private _InstancesBatch */ batch, [bool? useOverlay]);
	
	/// Returns whether or not the outline renderer is ready for a given submesh.
	/// All the dependencies e.g. submeshes, texture, effect... mus be ready
	/// @param subMesh Defines the submesh to check readyness for
	/// @param useInstances Defines wheter wee are trying to render instances or not
	/// @returns true if ready otherwise false
	external bool isReady(SubMesh subMesh, bool useInstances);
}

/// Defines the basic options interface of a Sprite Frame Source Size.
@JS()
@anonymous
class ISpriteJSONSpriteSourceSize {
	
	external factory ISpriteJSONSpriteSourceSize({num w, num h});
	
	/// number of the original width of the Frame
	external num get w;
	external set w( num value );
	
	/// number of the original height of the Frame
	external num get h;
	external set h( num value );
}

/// Defines the basic options interface of a Sprite Frame Data.
@JS()
@anonymous
class ISpriteJSONSpriteFrameData {
	
	external factory ISpriteJSONSpriteFrameData({num x, num y, num w, num h});
	
	/// number of the x offset of the Frame
	external num get x;
	external set x( num value );
	
	/// number of the y offset of the Frame
	external num get y;
	external set y( num value );
	
	/// number of the width of the Frame
	external num get w;
	external set w( num value );
	
	/// number of the height of the Frame
	external num get h;
	external set h( num value );
}

/// Defines the basic options interface of a JSON Sprite.
@JS()
@anonymous
class ISpriteJSONSprite {
	
	external factory ISpriteJSONSprite({String filename, ISpriteJSONSpriteFrameData frame, bool rotated, bool trimmed, ISpriteJSONSpriteFrameData spriteSourceSize, ISpriteJSONSpriteSourceSize sourceSize});
	
	/// string name of the Frame
	external String get filename;
	external set filename( String value );
	
	/// ISpriteJSONSpriteFrame basic object of the frame data
	external ISpriteJSONSpriteFrameData get frame;
	external set frame( ISpriteJSONSpriteFrameData value );
	
	/// boolean to flag is the frame was rotated.
	external bool get rotated;
	external set rotated( bool value );
	
	/// boolean to flag is the frame was trimmed.
	external bool get trimmed;
	external set trimmed( bool value );
	
	/// ISpriteJSONSpriteFrame basic object of the source data
	external ISpriteJSONSpriteFrameData get spriteSourceSize;
	external set spriteSourceSize( ISpriteJSONSpriteFrameData value );
	
	/// ISpriteJSONSpriteFrame basic object of the source data
	external ISpriteJSONSpriteSourceSize get sourceSize;
	external set sourceSize( ISpriteJSONSpriteSourceSize value );
}

/// Defines the basic options interface of a JSON atlas.
@JS()
@anonymous
class ISpriteJSONAtlas {
	
	external factory ISpriteJSONAtlas({List<ISpriteJSONSprite> frames, dynamic meta});
	
	/// Array of objects that contain the frame data.
	external List<ISpriteJSONSprite> get frames;
	external set frames( List<ISpriteJSONSprite> value );
	
	/// object basic object containing the sprite meta data.
	external dynamic get meta;
	external set meta( dynamic value );
}

/* var */
/// @hidden
@JS()
external dynamic get spriteMapPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get spriteMapVertexShader;

/// Defines the basic options interface of a SpriteMap
@JS()
@anonymous
class ISpriteMapOptions {
	
	external factory ISpriteMapOptions({Vector2 stageSize, Vector2 outputSize, Vector3 outputPosition, Vector3 outputRotation, num layerCount, num maxAnimationFrames, num baseTile, bool flipU, Vector3 colorMultiply});
	
	/// Vector2 of the number of cells in the grid.
	external Vector2 get stageSize;
	external set stageSize( Vector2 value );
	
	/// Vector2 of the size of the output plane in World Units.
	external Vector2 get outputSize;
	external set outputSize( Vector2 value );
	
	/// Vector3 of the position of the output plane in World Units.
	external Vector3 get outputPosition;
	external set outputPosition( Vector3 value );
	
	/// Vector3 of the rotation of the output plane.
	external Vector3 get outputRotation;
	external set outputRotation( Vector3 value );
	
	/// number of layers that the system will reserve in resources.
	external num get layerCount;
	external set layerCount( num value );
	
	/// number of max animation frames a single cell will reserve in resources.
	external num get maxAnimationFrames;
	external set maxAnimationFrames( num value );
	
	/// number cell index of the base tile when the system compiles.
	external num get baseTile;
	external set baseTile( num value );
	
	/// boolean flip the sprite after its been repositioned by the framing data.
	external bool get flipU;
	external set flipU( bool value );
	
	/// Vector3 scalar of the global RGB values of the SpriteMap.
	external Vector3 get colorMultiply;
	external set colorMultiply( Vector3 value );
}

/// Defines the IDisposable interface in order to be cleanable from resources.
@JS()
abstract class ISpriteMap implements IDisposable {
	
	/// String name of the SpriteMap.
	external String get name;
	external set name(String value);
	
	/// The JSON Array file from a https://www.codeandweb.com/texturepacker export.  Or similar structure.
	external ISpriteJSONAtlas get atlasJSON;
	external set atlasJSON(ISpriteJSONAtlas value);
	
	/// Texture of the SpriteMap.
	external Texture get spriteSheet;
	external set spriteSheet(Texture value);
	
	/// The parameters to initialize the SpriteMap with.
	external ISpriteMapOptions get options;
	external set options(ISpriteMapOptions value);
}

/// Class used to manage a grid restricted sprite deployment on an Output plane.
@JS()
class SpriteMap implements ISpriteMap {
	
	/// Creates a new SpriteMap
	/// @param name defines the SpriteMaps Name
	/// @param atlasJSON is the JSON file that controls the Sprites Frames and Meta
	/// @param spriteSheet is the Texture that the Sprites are on.
	/// @param options a basic deployment configuration
	/// @param scene The Scene that the map is deployed on
	external factory SpriteMap(String name, ISpriteJSONAtlas atlasJSON, Texture spriteSheet, ISpriteMapOptions options, Scene scene);
	
	/// The Name of the spriteMap
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// The JSON file with the frame and meta data
	@override
	external ISpriteJSONAtlas get atlasJSON;
	@override
	external set atlasJSON(ISpriteJSONAtlas value);
	
	/// The systems Sprite Sheet Texture
	@override
	external Texture get spriteSheet;
	@override
	external set spriteSheet(Texture value);
	
	/// Arguments passed with the Constructor
	@override
	external ISpriteMapOptions get options;
	@override
	external set options(ISpriteMapOptions value);
	
	/// Public Sprite Storage array, parsed from atlasJSON
	external List<ISpriteJSONSprite> get sprites;
	external set sprites(List<ISpriteJSONSprite> value);
	
	/// Returns the Number of Sprites in the System
	external num get spriteCount;
	
	/// Returns the Position of Output Plane
	external Vector3 get position;
	
	/// Returns the Position of Output Plane
	external set position(Vector3 value);
	
	/// Returns the Rotation of Output Plane
	external Vector3 get rotation;
	
	/// Returns the Rotation of Output Plane
	external set rotation(Vector3 value);
	
	/// Sets the AnimationMap
	external RawTexture get animationMap;
	
	/// Sets the AnimationMap
	external set animationMap(RawTexture value);
	
	/// Returns tileID location
	/// @returns Vector2 the cell position ID
	external Vector2 getTileID();
	
	/// Gets the UV location of the mouse over the SpriteMap.
	/// @returns Vector2 the UV position of the mouse interaction
	external Vector2 getMousePosition();
	
	/// Modifies the data of the tileMaps
	/// @param _layer is the ID of the layer you want to edit on the SpriteMap
	/// @param pos is the iVector2 Coordinates of the Tile
	/// @param tile The SpriteIndex of the new Tile
	external void changeTiles(num? _layer, dynamic pos, [num? tile]);
	
	/// Modifies the data of the animationMap
	/// @param cellID is the Index of the Sprite
	/// @param _frame is the target Animation frame
	/// @param toCell is the Target Index of the next frame of the animation
	/// @param time is a value between 0-1 that is the trigger for when the frame should change tiles
	/// @param speed is a global scalar of the time variable on the map.
	external void addAnimationToTile([num? cellID, num? _frame, num? toCell, num? time, num? speed]);
	
	/// Exports the .tilemaps file
	external void saveTileMaps();
	
	/// Imports the .tilemaps file
	/// @param url of the .tilemaps file
	external void loadTileMaps(String url);
	
	/// Release associated resources
	@override
	external void dispose();
}

/// Class used to manage multiple sprites of different sizes on the same spritesheet
/// @see https://doc.babylonjs.com/babylon101/sprites
@JS()
class SpritePackedManager extends SpriteManager {
	
	/// Creates a new sprite manager from a packed sprite sheet
	/// @param name defines the manager's name
	/// @param imgUrl defines the sprite sheet url
	/// @param capacity defines the maximum allowed number of sprites
	/// @param scene defines the hosting scene
	/// @param spriteJSON null otherwise a JSON object defining sprite sheet data
	/// @param epsilon defines the epsilon value to align texture (0.01 by default)
	/// @param samplingMode defines the smapling mode to use with spritesheet
	/// @param fromPacked set to true; do not alter
	external factory SpritePackedManager(String name, String imgUrl, num capacity, Scene scene, [String? spriteJSON, num? epsilon, num? samplingMode]);
	
	/// defines the packed manager's name
	@override
	external String get name;
	@override
	external set name(String value);
}

/* enum */
abstract class AssetTaskState {
	
	/// Initialization
	static const int INIT = 1;
	
	/// Running
	static const int RUNNING = 2;
	
	/// Done
	static const int DONE = 3;
	
	/// Error
	static const int ERROR = 4;
}

/// Define an abstract asset task used with a AssetsManager class to load assets into a scene
@JS()
/* Manual Fix 36 */
abstract class AbstractAssetTask<T> {
	
	/// Creates a new AssetsManager
	/// @param name defines the name of the task
	external factory AbstractAssetTask(String name);
	
	/// Task name
	external String get name;
	external set name(String value);
	
	/* Manual Fix 37 */
	
	/// Callback called when the task is successful
	external void Function(T task) get onSuccess;
	external set onSuccess(void Function(T task) value);
	
	/// Callback called when the task is not successful
	external void Function(T task, [String? message, dynamic? exception]) get onError;
	external set onError(void Function(T task, [String? message, dynamic? exception]) value);
	
	/// Get if the task is completed
	external bool get isCompleted;
	
	/// Gets the current state of the task
	external int get taskState;
	
	/// Gets the current error object (if task is in error)
	external AbstractAssetTaskErrorObject get errorObject;
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	external void run(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
	
	/// Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.
	/// This can be used with failed tasks that have the reason for failure fixed.
	external void reset();
}

/// Define the interface used by progress events raised during assets loading
@JS()
abstract class IAssetsProgressEvent {
	
	/// Defines the number of remaining tasks to process
	external num get remainingCount;
	external set remainingCount(num value);
	
	/// Defines the total number of tasks
	external num get totalCount;
	external set totalCount(num value);
	
	/// Defines the task that was just processed
	external AbstractAssetTask get task;
	external set task(AbstractAssetTask value);
}

/// Class used to share progress information about assets loading
@JS()
class AssetsProgressEvent implements IAssetsProgressEvent {
	
	/// Creates a AssetsProgressEvent
	/// @param remainingCount defines the number of remaining tasks to process
	/// @param totalCount defines the total number of tasks
	/// @param task defines the task that was just processed
	external factory AssetsProgressEvent(num remainingCount, num totalCount, AbstractAssetTask task);
	
	/// Defines the number of remaining tasks to process
	@override
	external num get remainingCount;
	@override
	external set remainingCount(num value);
	
	/// Defines the total number of tasks
	@override
	external num get totalCount;
	@override
	external set totalCount(num value);
	
	/// Defines the task that was just processed
	@override
	external AbstractAssetTask get task;
	@override
	external set task(AbstractAssetTask value);
}

/// Define a task used by AssetsManager to load assets into a container
@JS()
/* Manual Fix 46 */
class ContainerAssetTask extends AbstractAssetTask<ContainerAssetTask> {
	
	/// Creates a new ContainerAssetTask
	/// @param name defines the name of the task
	/// @param meshesNames defines the list of mesh's names you want to load
	/// @param rootUrl defines the root url to use as a base to load your meshes and associated resources
	/// @param sceneFilename defines the filename or File of the scene to load from
	external factory ContainerAssetTask(String name, dynamic meshesNames, String rootUrl, dynamic sceneFilename);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the list of mesh's names you want to load
	external dynamic get meshesNames;
	external set meshesNames(dynamic value);
	
	/// Defines the root url to use as a base to load your meshes and associated resources
	external String get rootUrl;
	external set rootUrl(String value);
	
	/// Defines the filename or File of the scene to load from
	external dynamic get sceneFilename;
	external set sceneFilename(dynamic value);
	
	/// Get the loaded asset container
	external AssetContainer get loadedContainer;
	external set loadedContainer(AssetContainer value);
	
	/// Gets the list of loaded meshes
	external List<AbstractMesh> get loadedMeshes;
	external set loadedMeshes(List<AbstractMesh> value);
	
	/// Gets the list of loaded particle systems
	external List<IParticleSystem> get loadedParticleSystems;
	external set loadedParticleSystems(List<IParticleSystem> value);
	
	/// Gets the list of loaded skeletons
	external List<Skeleton> get loadedSkeletons;
	external set loadedSkeletons(List<Skeleton> value);
	
	/// Gets the list of loaded animation groups
	external List<AnimationGroup> get loadedAnimationGroups;
	external set loadedAnimationGroups(List<AnimationGroup> value);
	
	/// Callback called when the task is successful
	@override
	external void Function(ContainerAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(ContainerAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(ContainerAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(ContainerAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load meshes
@JS()
/* Manual Fix 38 */
class MeshAssetTask extends AbstractAssetTask<MeshAssetTask> {
	
	/// Creates a new MeshAssetTask
	/// @param name defines the name of the task
	/// @param meshesNames defines the list of mesh's names you want to load
	/// @param rootUrl defines the root url to use as a base to load your meshes and associated resources
	/// @param sceneFilename defines the filename or File of the scene to load from
	external factory MeshAssetTask(String name, dynamic meshesNames, String rootUrl, dynamic sceneFilename);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the list of mesh's names you want to load
	external dynamic get meshesNames;
	external set meshesNames(dynamic value);
	
	/// Defines the root url to use as a base to load your meshes and associated resources
	external String get rootUrl;
	external set rootUrl(String value);
	
	/// Defines the filename or File of the scene to load from
	external dynamic get sceneFilename;
	external set sceneFilename(dynamic value);
	
	/// Gets the list of loaded meshes
	external List<AbstractMesh> get loadedMeshes;
	external set loadedMeshes(List<AbstractMesh> value);
	
	/// Gets the list of loaded particle systems
	external List<IParticleSystem> get loadedParticleSystems;
	external set loadedParticleSystems(List<IParticleSystem> value);
	
	/// Gets the list of loaded skeletons
	external List<Skeleton> get loadedSkeletons;
	external set loadedSkeletons(List<Skeleton> value);
	
	/// Gets the list of loaded animation groups
	external List<AnimationGroup> get loadedAnimationGroups;
	external set loadedAnimationGroups(List<AnimationGroup> value);
	
	/// Callback called when the task is successful
	@override
	external void Function(MeshAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(MeshAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(MeshAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(MeshAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load text content
@JS()
/* Manual Fix 39 */
class TextFileAssetTask extends AbstractAssetTask<TextFileAssetTask> {
	
	/// Creates a new TextFileAssetTask object
	/// @param name defines the name of the task
	/// @param url defines the location of the file to load
	external factory TextFileAssetTask(String name, String url);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the file to load
	external String get url;
	external set url(String value);
	
	/// Gets the loaded text string
	external String get text;
	external set text(String value);
	
	/// Callback called when the task is successful
	@override
	external void Function(TextFileAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(TextFileAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(TextFileAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(TextFileAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load binary data
@JS()
/* Manual Fix 40 */
class BinaryFileAssetTask extends AbstractAssetTask<BinaryFileAssetTask> {
	
	/// Creates a new BinaryFileAssetTask object
	/// @param name defines the name of the new task
	/// @param url defines the location of the file to load
	external factory BinaryFileAssetTask(String name, String url);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the file to load
	external String get url;
	external set url(String value);
	
	/// Gets the lodaded data (as an array buffer)
	external ByteBuffer get data;
	external set data(ByteBuffer value);
	
	/// Callback called when the task is successful
	@override
	external void Function(BinaryFileAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(BinaryFileAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(BinaryFileAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(BinaryFileAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load images
@JS()
/* Manual Fix 41 */
class ImageAssetTask extends AbstractAssetTask<ImageAssetTask> {
	
	/// Creates a new ImageAssetTask
	/// @param name defines the name of the task
	/// @param url defines the location of the image to load
	external factory ImageAssetTask(String name, String url);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the image to load
	external String get url;
	external set url(String value);
	
	/// Gets the loaded images
	external HTML.ImageElement get image;
	external set image(HTML.ImageElement value);
	
	/// Callback called when the task is successful
	@override
	external void Function(ImageAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(ImageAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(ImageAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(ImageAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Defines the interface used by texture loading tasks
@JS()
abstract class ITextureAssetTask<TEX extends BaseTexture> {
	
	/// Gets the loaded texture
	external TEX get texture;
	external set texture(TEX value);
}

/// Define a task used by AssetsManager to load 2D textures
@JS()
/* Manual Fix 42 */
class TextureAssetTask extends AbstractAssetTask<TextureAssetTask> implements ITextureAssetTask<Texture> {
	
	/// Creates a new TextureAssetTask object
	/// @param name defines the name of the task
	/// @param url defines the location of the file to load
	/// @param noMipmap defines if mipmap should not be generated (default is false)
	/// @param invertY defines if texture must be inverted on Y axis (default is true)
	/// @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
	external factory TextureAssetTask(String name, String url, [bool? noMipmap, bool? invertY, num? samplingMode]);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the file to load
	external String get url;
	external set url(String value);
	
	/// Defines if mipmap should not be generated (default is false)
	external bool? get noMipmap;
	external set noMipmap(bool? value);
	
	/// Defines if texture must be inverted on Y axis (default is true)
	external bool get invertY;
	external set invertY(bool value);
	
	/// Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
	external num get samplingMode;
	external set samplingMode(num value);
	
	/// Gets the loaded texture
	@override
	external Texture get texture;
	@override
	external set texture(Texture value);
	
	/// Callback called when the task is successful
	@override
	external void Function(TextureAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(TextureAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(TextureAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(TextureAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load cube textures
@JS()
/* Manual Fix 43 */
class CubeTextureAssetTask extends AbstractAssetTask<CubeTextureAssetTask> implements ITextureAssetTask<CubeTexture> {
	
	/// Creates a new CubeTextureAssetTask
	/// @param name defines the name of the task
	/// @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
	/// @param extensions defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
	/// @param noMipmap defines if mipmaps should not be generated (default is false)
	/// @param files defines the explicit list of files (undefined by default)
	external factory CubeTextureAssetTask(String name, String url, [List<String>? extensions, bool? noMipmap, List<String>? files]);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
	external String get url;
	external set url(String value);
	
	/// Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
	external List<String>? get extensions;
	external set extensions(List<String>? value);
	
	/// Defines if mipmaps should not be generated (default is false)
	external bool? get noMipmap;
	external set noMipmap(bool? value);
	
	/// Defines the explicit list of files (undefined by default)
	external List<String>? get files;
	external set files(List<String>? value);
	
	/// Gets the loaded texture
	@override
	external CubeTexture get texture;
	@override
	external set texture(CubeTexture value);
	
	/// Callback called when the task is successful
	@override
	external void Function(CubeTextureAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(CubeTextureAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(CubeTextureAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(CubeTextureAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load HDR cube textures
@JS()
/* Manual Fix 44 */
class HDRCubeTextureAssetTask extends AbstractAssetTask<HDRCubeTextureAssetTask> implements ITextureAssetTask<HDRCubeTexture> {
	
	/// Creates a new HDRCubeTextureAssetTask object
	/// @param name defines the name of the task
	/// @param url defines the location of the file to load
	/// @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.
	/// @param noMipmap defines if mipmaps should not be generated (default is false)
	/// @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
	/// @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
	/// @param reserved Internal use only
	external factory HDRCubeTextureAssetTask(String name, String url, num size, [bool? noMipmap, bool? generateHarmonics, bool? gammaSpace, bool? reserved]);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the file to load
	external String get url;
	external set url(String value);
	
	/// Defines the desired size (the more it increases the longer the generation will be)
	external num get size;
	external set size(num value);
	
	/// Defines if mipmaps should not be generated (default is false)
	external bool get noMipmap;
	external set noMipmap(bool value);
	
	/// Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
	external bool get generateHarmonics;
	external set generateHarmonics(bool value);
	
	/// Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
	external bool get gammaSpace;
	external set gammaSpace(bool value);
	
	/// Internal Use Only
	external bool get reserved;
	external set reserved(bool value);
	
	/// Gets the loaded texture
	@override
	external HDRCubeTexture get texture;
	@override
	external set texture(HDRCubeTexture value);
	
	/// Callback called when the task is successful
	@override
	external void Function(HDRCubeTextureAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(HDRCubeTextureAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(HDRCubeTextureAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(HDRCubeTextureAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// Define a task used by AssetsManager to load Equirectangular cube textures
@JS()
/* Manual Fix 45 */
class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask<EquiRectangularCubeTextureAssetTask> implements ITextureAssetTask<EquiRectangularCubeTexture> {
	
	/// Creates a new EquiRectangularCubeTextureAssetTask object
	/// @param name defines the name of the task
	/// @param url defines the location of the file to load
	/// @param size defines the desired size (the more it increases the longer the generation will be)
	/// If the size is omitted this implies you are using a preprocessed cubemap.
	/// @param noMipmap defines if mipmaps should not be generated (default is false)
	/// @param gammaSpace specifies if the texture will be used in gamma or linear space
	/// (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
	/// (default is true)
	external factory EquiRectangularCubeTextureAssetTask(String name, String url, num size, [bool? noMipmap, bool? gammaSpace]);
	
	/// Defines the name of the task
	@override
	external String get name;
	@override
	external set name(String value);
	
	/// Defines the location of the file to load
	external String get url;
	external set url(String value);
	
	/// Defines the desired size (the more it increases the longer the generation will be)
	external num get size;
	external set size(num value);
	
	/// Defines if mipmaps should not be generated (default is false)
	external bool get noMipmap;
	external set noMipmap(bool value);
	
	/// Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,
	/// but the standard material would require them in Gamma space) (default is true)
	external bool get gammaSpace;
	external set gammaSpace(bool value);
	
	/// Gets the loaded texture
	@override
	external EquiRectangularCubeTexture get texture;
	@override
	external set texture(EquiRectangularCubeTexture value);
	
	/// Callback called when the task is successful
	@override
	external void Function(EquiRectangularCubeTextureAssetTask task) get onSuccess;
	@override
	external set onSuccess(void Function(EquiRectangularCubeTextureAssetTask task) value);
	
	/// Callback called when the task is successful
	@override
	external void Function(EquiRectangularCubeTextureAssetTask task, [String? message, dynamic? exception]) get onError;
	@override
	external set onError(void Function(EquiRectangularCubeTextureAssetTask task, [String? message, dynamic? exception]) value);
	
	/// Execute the current task
	/// @param scene defines the scene where you want your assets to be loaded
	/// @param onSuccess is a callback called when the task is successfully executed
	/// @param onError is a callback called if an error occurs
	@override
	external void runTask(Scene scene, void Function() onSuccess, void Function([String? message, dynamic? exception]) onError);
}

/// This class can be used to easily import assets into a scene
/// @see https://doc.babylonjs.com/how_to/how_to_use_assetsmanager
@JS()
class AssetsManager {
	
	/// Creates a new AssetsManager
	/// @param scene defines the scene to work on
	external factory AssetsManager(Scene scene);
	
	/// Callback called when all tasks are processed
	external void Function(List<AbstractAssetTask> tasks) get onFinish;
	external set onFinish(void Function(List<AbstractAssetTask> tasks) value);
	
	/// Callback called when a task is successful
	external void Function(AbstractAssetTask task) get onTaskSuccess;
	external set onTaskSuccess(void Function(AbstractAssetTask task) value);
	
	/// Callback called when a task had an error
	external void Function(AbstractAssetTask task) get onTaskError;
	external set onTaskError(void Function(AbstractAssetTask task) value);
	
	/// Callback called when a task is done (whatever the result is)
	external void Function(num remainingCount, num totalCount, AbstractAssetTask task) get onProgress;
	external set onProgress(void Function(num remainingCount, num totalCount, AbstractAssetTask task) value);
	
	/// Observable called when all tasks are processed
	external Observable<AbstractAssetTask> get onTaskSuccessObservable;
	external set onTaskSuccessObservable(Observable<AbstractAssetTask> value);
	
	/// Observable called when a task had an error
	external Observable<AbstractAssetTask> get onTaskErrorObservable;
	external set onTaskErrorObservable(Observable<AbstractAssetTask> value);
	
	/// Observable called when all tasks were executed
	external Observable<List<AbstractAssetTask>> get onTasksDoneObservable;
	external set onTasksDoneObservable(Observable<List<AbstractAssetTask>> value);
	
	/// Observable called when a task is done (whatever the result is)
	external Observable<IAssetsProgressEvent> get onProgressObservable;
	external set onProgressObservable(Observable<IAssetsProgressEvent> value);
	
	/// Gets or sets a boolean defining if the AssetsManager should use the default loading screen
	/// @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
	external bool get useDefaultLoadingScreen;
	external set useDefaultLoadingScreen(bool value);
	
	/// Gets or sets a boolean defining if the AssetsManager should automatically hide the loading screen
	/// when all assets have been downloaded.
	/// If set to false, you need to manually call in hideLoadingUI() once your scene is ready.
	external bool get autoHideLoadingUI;
	external set autoHideLoadingUI(bool value);
	
	/// Add a ContainerAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param meshesNames defines the name of meshes to load
	/// @param rootUrl defines the root url to use to locate files
	/// @param sceneFilename defines the filename of the scene file
	/// @returns a new ContainerAssetTask object
	external ContainerAssetTask addContainerTask(String taskName, dynamic meshesNames, String rootUrl, String sceneFilename);
	
	/// Add a MeshAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param meshesNames defines the name of meshes to load
	/// @param rootUrl defines the root url to use to locate files
	/// @param sceneFilename defines the filename of the scene file
	/// @returns a new MeshAssetTask object
	external MeshAssetTask addMeshTask(String taskName, dynamic meshesNames, String rootUrl, String sceneFilename);
	
	/// Add a TextFileAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @returns a new TextFileAssetTask object
	external TextFileAssetTask addTextFileTask(String taskName, String url);
	
	/// Add a BinaryFileAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @returns a new BinaryFileAssetTask object
	external BinaryFileAssetTask addBinaryFileTask(String taskName, String url);
	
	/// Add a ImageAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @returns a new ImageAssetTask object
	external ImageAssetTask addImageTask(String taskName, String url);
	
	/// Add a TextureAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @param noMipmap defines if the texture must not receive mipmaps (false by default)
	/// @param invertY defines if you want to invert Y axis of the loaded texture (false by default)
	/// @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
	/// @returns a new TextureAssetTask object
	external TextureAssetTask addTextureTask(String taskName, String url, [bool? noMipmap, bool? invertY, num? samplingMode]);
	
	/// Add a CubeTextureAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @param extensions defines the extension to use to load the cube map (can be null)
	/// @param noMipmap defines if the texture must not receive mipmaps (false by default)
	/// @param files defines the list of files to load (can be null)
	/// @returns a new CubeTextureAssetTask object
	external CubeTextureAssetTask addCubeTextureTask(String taskName, String url, [List<String>? extensions, bool? noMipmap, List<String>? files]);
	
	/// 
	/// Add a HDRCubeTextureAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @param size defines the size you want for the cubemap (can be null)
	/// @param noMipmap defines if the texture must not receive mipmaps (false by default)
	/// @param generateHarmonics defines if you want to automatically generate (true by default)
	/// @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
	/// @param reserved Internal use only
	/// @returns a new HDRCubeTextureAssetTask object
	external HDRCubeTextureAssetTask addHDRCubeTextureTask(String taskName, String url, num size, [bool? noMipmap, bool? generateHarmonics, bool? gammaSpace, bool? reserved]);
	
	/// 
	/// Add a EquiRectangularCubeTextureAssetTask to the list of active tasks
	/// @param taskName defines the name of the new task
	/// @param url defines the url of the file to load
	/// @param size defines the size you want for the cubemap (can be null)
	/// @param noMipmap defines if the texture must not receive mipmaps (false by default)
	/// @param gammaSpace Specifies if the texture will be used in gamma or linear space
	/// (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
	/// @returns a new EquiRectangularCubeTextureAssetTask object
	external EquiRectangularCubeTextureAssetTask addEquiRectangularCubeTextureAssetTask(String taskName, String url, num size, [bool? noMipmap, bool? gammaSpace]);
	
	/// Remove a task from the assets manager.
	/// @param task the task to remove
	external void removeTask(AbstractAssetTask task);
	
	/// Reset the AssetsManager and remove all tasks
	/// @return the current instance of the AssetsManager
	external AssetsManager reset();
	
	/// Start the loading process
	/// @return the current instance of the AssetsManager
	external AssetsManager load();
	
	/// Start the loading process as an async operation
	/// @return a promise returning the list of failed tasks
	external Promise<void> loadAsync();
}

/// Wrapper class for promise with external resolve and reject.
@JS()
class Deferred<T> {
	
	/// Constructor for this deferred object.
	external factory Deferred();
	
	/// The promise associated with this deferred object.
	external Promise<T> get promise;
	
	/// The resolve method of the promise associated with this deferred object.
	external void Function([dynamic? value]) get resolve;
	
	/// The reject method of the promise associated with this deferred object.
	external void Function([dynamic? reason]) get reject;
}

/// Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)
@JS()
class MeshExploder {
	
	/// Explodes meshes from a center mesh.
	/// @param meshes The meshes to explode.
	/// @param centerMesh The mesh to be center of explosion.
	external factory MeshExploder(List<Mesh> meshes, [Mesh? centerMesh]);
	
	/// Get class name
	/// @returns "MeshExploder"
	external String getClassName();
	
	/// "Exploded meshes"
	/// @returns Array of meshes with the centerMesh at index 0.
	external List<Mesh> getMeshes();
	
	/// Explodes meshes giving a specific direction
	/// @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.
	external void explode([num? direction]);
}

/// Class used to help managing file picking and drag'n'drop
@JS()
class FilesInput {
	
	/// Creates a new FilesInput
	/// @param engine defines the rendering engine
	/// @param scene defines the hosting scene
	/// @param sceneLoadedCallback callback called when scene is loaded
	/// @param progressCallback callback called to track progress
	/// @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop
	/// @param textureLoadingCallback callback called when a texture is loading
	/// @param startingProcessingFilesCallback callback called when the system is about to process all files
	/// @param onReloadCallback callback called when a reload is requested
	/// @param errorCallback callback call if an error occurs
	external factory FilesInput(Engine engine, Scene? scene, void Function(HTML.File sceneFile, Scene scene)? sceneLoadedCallback, void Function(ISceneLoaderProgressEvent progress)? progressCallback, void Function()? additionalRenderLoopLogicCallback, void Function(num remaining)? textureLoadingCallback, void Function([List<HTML.File>? files])? startingProcessingFilesCallback, void Function(HTML.File sceneFile)? onReloadCallback, void Function(HTML.File sceneFile, Scene? scene, String message)? errorCallback);
	
	/// List of files ready to be loaded
	external static dynamic /* object */ get FilesToLoad;
	
	/// Callback called when a file is processed
	external bool Function(HTML.File file, String name, String extension) get onProcessFileCallback;
	external set onProcessFileCallback(bool Function(HTML.File file, String name, String extension) value);
	
	/// Calls this function to listen to drag'n'drop events on a specific DOM element
	/// @param elementToMonitor defines the DOM element to track
	external void monitorElementForDragNDrop(HTML.Element elementToMonitor);
	
	/// Gets the current list of files to load
	external List<HTML.File> get filesToLoad;
	
	/// Release all associated resources
	external void dispose();
	
	/// Load files from a drop event
	/// @param event defines the drop event to use as source
	external void loadFiles(dynamic event);
	
	/// Reload the current scene from the loaded files
	external void reload();
}

/// Defines the root class used to create scene optimization to use with SceneOptimizer
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class SceneOptimization {
	
	/// Creates the SceneOptimization object
	/// @param priority defines the priority of this optimization (0 by default which means first in the list)
	/// @param desc defines the description associated with the optimization
	external factory SceneOptimization([num? priority]);
	
	/// Defines the priority of this optimization (0 by default which means first in the list)
	external num get priority;
	external set priority(num value);
	
	/// Gets a string describing the action executed by the current optimization
	/// @returns description string
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to reduce the size of render target textures
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class TextureOptimization extends SceneOptimization {
	
	/// Creates the TextureOptimization object
	/// @param priority defines the priority of this optimization (0 by default which means first in the list)
	/// @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
	/// @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
	external factory TextureOptimization([num? priority, num? maximumSize, num? step]);
	
	/// Defines the priority of this optimization (0 by default which means first in the list)
	@override
	external num get priority;
	@override
	external set priority(num value);
	
	/// Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
	external num get maximumSize;
	external set maximumSize(num value);
	
	/// Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
	external num get step;
	external set step(num value);
	
	/// Gets a string describing the action executed by the current optimization
	/// @returns description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to increase or decrease the rendering resolution
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class HardwareScalingOptimization extends SceneOptimization {
	
	/// Creates the HardwareScalingOptimization object
	/// @param priority defines the priority of this optimization (0 by default which means first in the list)
	/// @param maximumScale defines the maximum scale to use (2 by default)
	/// @param step defines the step to use between two passes (0.5 by default)
	external factory HardwareScalingOptimization([num? priority, num? maximumScale, num? step]);
	
	/// Defines the priority of this optimization (0 by default which means first in the list)
	@override
	external num get priority;
	@override
	external set priority(num value);
	
	/// Defines the maximum scale to use (2 by default)
	external num get maximumScale;
	external set maximumScale(num value);
	
	/// Defines the step to use between two passes (0.5 by default)
	external num get step;
	external set step(num value);
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to remove shadows
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class ShadowsOptimization extends SceneOptimization {
	external factory ShadowsOptimization();
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to turn post-processes off
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class PostProcessesOptimization extends SceneOptimization {
	external factory PostProcessesOptimization();
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to turn lens flares off
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class LensFlaresOptimization extends SceneOptimization {
	external factory LensFlaresOptimization();
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization based on user defined callback.
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class CustomOptimization extends SceneOptimization {
	external factory CustomOptimization();
	
	/// Callback called to apply the custom optimization.
	external bool Function(Scene scene, SceneOptimizer optimizer) get onApply;
	external set onApply(bool Function(Scene scene, SceneOptimizer optimizer) value);
	
	/// Callback called to get custom description
	external String Function() get onGetDescription;
	external set onGetDescription(String Function() value);
	
	/// Gets a string describing the action executed by the current optimization
	/// @returns description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to turn particles off
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class ParticlesOptimization extends SceneOptimization {
	external factory ParticlesOptimization();
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to turn render targets off
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class RenderTargetsOptimization extends SceneOptimization {
	external factory RenderTargetsOptimization();
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer);
}

/// Defines an optimization used to merge meshes with compatible materials
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class MergeMeshesOptimization extends SceneOptimization {
	external factory MergeMeshesOptimization();
	
	/// Gets or sets a boolean which defines if optimization octree has to be updated
	external static bool get UpdateSelectionTree;
	
	/// Gets or sets a boolean which defines if optimization octree has to be updated
	external static set UpdateSelectionTree(bool value);
	
	/// Gets a string describing the action executed by the current optimization
	/// @return description string
	@override
	external String getDescription();
	
	/// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
	/// @param scene defines the current scene where to apply this optimization
	/// @param optimizer defines the current optimizer
	/// @param updateSelectionTree defines that the selection octree has to be updated (false by default)
	/// @returns true if everything that can be done was applied
	@override
	external bool apply(Scene scene, SceneOptimizer optimizer, [bool? updateSelectionTree]);
}

/// Defines a list of options used by SceneOptimizer
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class SceneOptimizerOptions {
	
	/// Creates a new list of options used by SceneOptimizer
	/// @param targetFrameRate defines the target frame rate to reach (60 by default)
	/// @param trackerDuration defines the interval between two checkes (2000ms by default)
	external factory SceneOptimizerOptions([num? targetFrameRate, num? trackerDuration]);
	
	/// Defines the target frame rate to reach (60 by default)
	external num get targetFrameRate;
	external set targetFrameRate(num value);
	
	/// Defines the interval between two checkes (2000ms by default)
	external num get trackerDuration;
	external set trackerDuration(num value);
	
	/// Gets the list of optimizations to apply
	external List<SceneOptimization> get optimizations;
	external set optimizations(List<SceneOptimization> value);
	
	/// Add a new optimization
	/// @param optimization defines the SceneOptimization to add to the list of active optimizations
	/// @returns the current SceneOptimizerOptions
	external SceneOptimizerOptions addOptimization(SceneOptimization optimization);
	
	/// Add a new custom optimization
	/// @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)
	/// @param onGetDescription defines the callback called to get the description attached with the optimization.
	/// @param priority defines the priority of this optimization (0 by default which means first in the list)
	/// @returns the current SceneOptimizerOptions
	external SceneOptimizerOptions addCustomOptimization(bool Function(Scene scene) onApply, String Function() onGetDescription, [num? priority]);
	
	/// Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene
	/// @param targetFrameRate defines the target frame rate (60 by default)
	/// @returns a SceneOptimizerOptions object
	external static SceneOptimizerOptions LowDegradationAllowed([num? targetFrameRate]);
	
	/// Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual
	/// @param targetFrameRate defines the target frame rate (60 by default)
	/// @returns a SceneOptimizerOptions object
	external static SceneOptimizerOptions ModerateDegradationAllowed([num? targetFrameRate]);
	
	/// Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual
	/// @param targetFrameRate defines the target frame rate (60 by default)
	/// @returns a SceneOptimizerOptions object
	external static SceneOptimizerOptions HighDegradationAllowed([num? targetFrameRate]);
}

/// Class used to run optimizations in order to reach a target frame rate
/// @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
@JS()
class SceneOptimizer implements IDisposable {
	
	/// Creates a new SceneOptimizer
	/// @param scene defines the scene to work on
	/// @param options defines the options to use with the SceneOptimizer
	/// @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)
	/// @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)
	external factory SceneOptimizer(Scene scene, [SceneOptimizerOptions? options, bool? autoGeneratePriorities, bool? improvementMode]);
	
	/// Defines an observable called when the optimizer reaches the target frame rate
	external Observable<SceneOptimizer> get onSuccessObservable;
	external set onSuccessObservable(Observable<SceneOptimizer> value);
	
	/// Defines an observable called when the optimizer enables an optimization
	external Observable<SceneOptimization> get onNewOptimizationAppliedObservable;
	external set onNewOptimizationAppliedObservable(Observable<SceneOptimization> value);
	
	/// Defines an observable called when the optimizer is not able to reach the target frame rate
	external Observable<SceneOptimizer> get onFailureObservable;
	external set onFailureObservable(Observable<SceneOptimizer> value);
	
	/// Gets a boolean indicating if the optimizer is in improvement mode
	external bool get isInImprovementMode;
	
	/// Gets the current priority level (0 at start)
	external num get currentPriorityLevel;
	
	/// Gets the current frame rate checked by the SceneOptimizer
	external num get currentFrameRate;
	
	/// Gets or sets the current target frame rate (60 by default)
	external num get targetFrameRate;
	
	/// Gets or sets the current target frame rate (60 by default)
	external set targetFrameRate(num value);
	
	/// Gets or sets the current interval between two checks (every 2000ms by default)
	external num get trackerDuration;
	
	/// Gets or sets the current interval between two checks (every 2000ms by default)
	external set trackerDuration(num value);
	
	/// Gets the list of active optimizations
	external List<SceneOptimization> get optimizations;
	
	/// Stops the current optimizer
	external void stop();
	
	/// Reset the optimizer to initial step (current priority level = 0)
	external void reset();
	
	/// Start the optimizer. By default it will try to reach a specific framerate
	/// but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
	external void start();
	
	/// Release all resources
	@override
	external void dispose();
	
	/// Helper function to create a SceneOptimizer with one single line of code
	/// @param scene defines the scene to work on
	/// @param options defines the options to use with the SceneOptimizer
	/// @param onSuccess defines a callback to call on success
	/// @param onFailure defines a callback to call on failure
	/// @returns the new SceneOptimizer object
	external static SceneOptimizer OptimizeAsync(Scene scene, [SceneOptimizerOptions? options, void Function()? onSuccess, void Function()? onFailure]);
}

/// Class used to serialize a scene into a string
@JS()
class SceneSerializer {
	external factory SceneSerializer();
	
	/// Clear cache used by a previous serialization
	external static void ClearCache();
	
	/// Serialize a scene into a JSON compatible object
	/// @param scene defines the scene to serialize
	/// @returns a JSON compatible object
	external static dynamic Serialize(Scene scene);
	
	/// Serialize a mesh into a JSON compatible object
	/// @param toSerialize defines the mesh to serialize
	/// @param withParents defines if parents must be serialized as well
	/// @param withChildren defines if children must be serialized as well
	/// @returns a JSON compatible object
	external static dynamic SerializeMesh(dynamic toSerialize, [bool? withParents, bool? withChildren]);
}

/// Class used to host texture specific utilities
@JS()
class TextureTools {
	external factory TextureTools();
	
	/// Uses the GPU to create a copy texture rescaled at a given size
	/// @param texture Texture to copy from
	/// @param width defines the desired width
	/// @param height defines the desired height
	/// @param useBilinearMode defines if bilinear mode has to be used
	/// @return the generated texture
	external static Texture CreateResizedCopy(Texture texture, num width, num height, [bool? useBilinearMode]);
}

/// This represents the different options available for the video capture.
@JS()
@anonymous
class VideoRecorderOptions {
	
	external factory VideoRecorderOptions({String mimeType, num fps, num recordChunckSize, List<HTML.MediaStreamTrack> audioTracks});
	
	/// Defines the mime type of the video.
	external String get mimeType;
	external set mimeType( String value );
	
	/// Defines the FPS the video should be recorded at.
	external num get fps;
	external set fps( num value );
	
	/// Defines the chunk size for the recording data.
	external num get recordChunckSize;
	external set recordChunckSize( num value );
	
	/// The audio tracks to attach to the recording.
	external List<HTML.MediaStreamTrack> get audioTracks;
	external set audioTracks( List<HTML.MediaStreamTrack> value );
}

/// This can help with recording videos from BabylonJS.
/// This is based on the available WebRTC functionalities of the browser.
/// 
/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_video
@JS()
class VideoRecorder {
	
	/// Create a new VideoCapture object which can help converting what you see in Babylon to a video file.
	/// @param engine Defines the BabylonJS Engine you wish to record.
	/// @param options Defines options that can be used to customize the capture.
	external factory VideoRecorder(Engine engine, [VideoRecorderOptions? options]);
	
	/// Returns whether or not the VideoRecorder is available in your browser.
	/// @param engine Defines the Babylon Engine.
	/// @returns true if supported otherwise false.
	external static bool IsSupported(Engine engine);
	
	/// True when a recording is already in progress.
	external bool get isRecording;
	
	/// Stops the current recording before the default capture timeout passed in the startRecording function.
	external void stopRecording();
	
	/// Starts recording the canvas for a max duration specified in parameters.
	/// @param fileName Defines the name of the file to be downloaded when the recording stop.
	/// If null no automatic download will start and you can rely on the promise to get the data back.
	/// @param maxDuration Defines the maximum recording time in seconds.
	/// It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.
	/// @return A promise callback at the end of the recording with the video data in Blob.
	external Promise<HTML.Blob> startRecording([String? fileName, num? maxDuration]);
	
	/// Releases internal resources used during the recording.
	external void dispose();
}

/// Class containing a set of static utilities functions for screenshots
@JS()
class ScreenshotTools {
	external factory ScreenshotTools();
	
	/// Captures a screenshot of the current rendering
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine defines the rendering engine
	/// @param camera defines the source camera
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param successCallback defines the callback receives a single parameter which contains the
	/// screenshot as a string of base64-encoded characters. This string can be assigned to the
	/// src parameter of an <img> to display it
	/// @param mimeType defines the MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	external static void CreateScreenshot(Engine engine, Camera camera, dynamic size, [void Function(String data)? successCallback, String? mimeType]);
	
	/// Captures a screenshot of the current rendering
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine defines the rendering engine
	/// @param camera defines the source camera
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param mimeType defines the MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	/// @returns screenshot as a string of base64-encoded characters. This string can be assigned
	/// to the src parameter of an <img> to display it
	external static Promise<String> CreateScreenshotAsync(Engine engine, Camera camera, dynamic size, [String? mimeType]);
	
	/// Generates an image screenshot from the specified camera.
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine The engine to use for rendering
	/// @param camera The camera to use for rendering
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param successCallback The callback receives a single parameter which contains the
	/// screenshot as a string of base64-encoded characters. This string can be assigned to the
	/// src parameter of an <img> to display it
	/// @param mimeType The MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	/// @param samples Texture samples (default: 1)
	/// @param antialiasing Whether antialiasing should be turned on or not (default: false)
	/// @param fileName A name for for the downloaded file.
	/// @param renderSprites Whether the sprites should be rendered or not (default: false)
	/// @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
	external static void CreateScreenshotUsingRenderTarget(Engine engine, Camera camera, dynamic size, [void Function(String data)? successCallback, String? mimeType, num? samples, bool? antialiasing, String? fileName, bool? renderSprites, bool? enableStencilBuffer]);
	
	/// Generates an image screenshot from the specified camera.
	/// @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
	/// @param engine The engine to use for rendering
	/// @param camera The camera to use for rendering
	/// @param size This parameter can be set to a single number or to an object with the
	/// following (optional) properties: precision, width, height. If a single number is passed,
	/// it will be used for both width and height. If an object is passed, the screenshot size
	/// will be derived from the parameters. The precision property is a multiplier allowing
	/// rendering at a higher or lower resolution
	/// @param mimeType The MIME type of the screenshot image (default: image/png).
	/// Check your browser for supported MIME types
	/// @param samples Texture samples (default: 1)
	/// @param antialiasing Whether antialiasing should be turned on or not (default: false)
	/// @param fileName A name for for the downloaded file.
	/// @param renderSprites Whether the sprites should be rendered or not (default: false)
	/// @returns screenshot as a string of base64-encoded characters. This string can be assigned
	/// to the src parameter of an <img> to display it
	external static Promise<String> CreateScreenshotUsingRenderTargetAsync(Engine engine, Camera camera, dynamic size, [String? mimeType, num? samples, bool? antialiasing, String? fileName, bool? renderSprites]);
}

/// Interface for a data buffer
@JS()
abstract class IDataBuffer {
	
	/// Reads bytes from the data buffer.
	/// @param byteOffset The byte offset to read
	/// @param byteLength The byte length to read
	/// @returns A promise that resolves when the bytes are read
	external Promise<dynamic> readAsync(num byteOffset, num byteLength);
	
	/// The byte length of the buffer.
	external num get byteLength;
}

/// Utility class for reading from a data buffer
@JS()
class DataReader {
	
	/// Constructor
	/// @param buffer The buffer to read
	external factory DataReader(IDataBuffer buffer);
	
	/// The data buffer associated with this data reader.
	external IDataBuffer get buffer;
	
	/// The current byte offset from the beginning of the data buffer.
	external num get byteOffset;
	external set byteOffset(num value);
	
	/// Loads the given byte length.
	/// @param byteLength The byte length to load
	/// @returns A promise that resolves when the load is complete
	external Promise<void> loadAsync(num byteLength);
	
	/// Read a unsigned 32-bit integer from the currently loaded data range.
	/// @returns The 32-bit integer read
	external num readUint32();
	
	/// Read a byte array from the currently loaded data range.
	/// @param byteLength The byte length to read
	/// @returns The byte array read
	external Uint8List readUint8Array(num byteLength);
	
	/// Read a string from the currently loaded data range.
	/// @param byteLength The byte length to read
	/// @returns The string read
	external String readString(num byteLength);
	
	/// Skips the given byte length the currently loaded data range.
	/// @param byteLength The byte length to skip
	external void skipBytes(num byteLength);
}

/// Class for storing data to local storage if available or in-memory storage otherwise
@JS()
class DataStorage {
	external factory DataStorage();
	
	/// Reads a string from the data storage
	/// @param key The key to read
	/// @param defaultValue The value if the key doesn't exist
	/// @returns The string value
	external static String ReadString(String key, String defaultValue);
	
	/// Writes a string to the data storage
	/// @param key The key to write
	/// @param value The value to write
	external static void WriteString(String key, String value);
	
	/// Reads a boolean from the data storage
	/// @param key The key to read
	/// @param defaultValue The value if the key doesn't exist
	/// @returns The boolean value
	external static bool ReadBoolean(String key, bool defaultValue);
	
	/// Writes a boolean to the data storage
	/// @param key The key to write
	/// @param value The value to write
	external static void WriteBoolean(String key, bool value);
	
	/// Reads a number from the data storage
	/// @param key The key to read
	/// @param defaultValue The value if the key doesn't exist
	/// @returns The number value
	external static num ReadNumber(String key, num defaultValue);
	
	/// Writes a number to the data storage
	/// @param key The key to write
	/// @param value The value to write
	external static void WriteNumber(String key, num value);
}

/// Class used to record delta files between 2 scene states
@JS()
class SceneRecorder {
	external factory SceneRecorder();
	
	/// Track a given scene. This means the current scene state will be considered the original state
	/// @param scene defines the scene to track
	external void track(Scene scene);
	
	/// Get the delta between current state and original state
	/// @returns a string containing the delta
	external dynamic getDelta();
	
	/// Apply a given delta to a given scene
	/// @param deltaJSON defines the JSON containing the delta
	/// @param scene defines the scene to apply the delta to
	external static void ApplyDelta(dynamic deltaJSON, Scene scene);
}

/// A 3D trajectory consisting of an order list of vectors describing a
/// path of motion through 3D space.
@JS()
class Trajectory {
	
	/// Create a new empty Trajectory.
	/// @param segmentLength radius of discretization for Trajectory points
	external factory Trajectory([num? segmentLength]);
	
	/// Serialize to JSON.
	/// @returns serialized JSON string
	external String serialize();
	
	/// Deserialize from JSON.
	/// @param json serialized JSON string
	/// @returns deserialized Trajectory
	external static Trajectory Deserialize(String json);
	
	/// Get the length of the Trajectory.
	/// @returns length of the Trajectory
	external num getLength();
	
	/// Append a new point to the Trajectory.
	/// NOTE: This implementation has many allocations.
	/// @param point point to append to the Trajectory
	external void add(Vector3 point);
	
	/// Create a new Trajectory with a segment length chosen to make it
	/// probable that the new Trajectory will have a specified number of
	/// segments. This operation is imprecise.
	/// @param targetResolution number of segments desired
	/// @returns new Trajectory with approximately the requested number of segments
	external Trajectory resampleAtTargetResolution(num targetResolution);
	
	/// Convert Trajectory segments into tokenized representation. This
	/// representation is an array of numbers where each nth number is the
	/// index of the token which is most similar to the nth segment of the
	/// Trajectory.
	/// @param tokens list of vectors which serve as discrete tokens
	/// @returns list of indices of most similar token per segment
	external List<num> tokenize(List<Vector3> tokens);
}

/// Class representing a set of known, named trajectories to which Trajectories can be
/// added and using which Trajectories can be recognized.
@JS()
class TrajectoryClassifier {
	
	external factory TrajectoryClassifier();
	
	/// Serialize to JSON.
	/// @returns JSON serialization
	external String serialize();
	
	/// Deserialize from JSON.
	/// @param json JSON serialization
	/// @returns deserialized TrajectorySet
	external static TrajectoryClassifier Deserialize(String json);
	
	/// Initialize a new empty TrajectorySet with auto-generated Alphabets.
	/// VERY naive, need to be generating these things from known
	/// sets. Better version later, probably eliminating this one.
	/// @returns auto-generated TrajectorySet
	external static TrajectoryClassifier Generate();
	
	/// Add a new Trajectory to the set with a given name.
	/// @param trajectory new Trajectory to be added
	/// @param classification name to which to add the Trajectory
	external void addTrajectoryToClassification(Trajectory trajectory, String classification);
	
	/// Remove a known named trajectory and all Trajectories associated with it.
	/// @param classification name to remove
	/// @returns whether anything was removed
	external bool deleteClassification(String classification);
	
	/// Attempt to recognize a Trajectory from among all the classifications
	/// already known to the classifier.
	/// @param trajectory Trajectory to be recognized
	/// @returns classification of Trajectory if recognized, null otherwise
	external String? classifyTrajectory(Trajectory trajectory);
}

/// An interface for all Hit test features
@JS()
abstract class IWebXRHitTestFeature<T extends IWebXRLegacyHitResult> implements IWebXRFeature {
	
	/// Triggered when new babylon (transformed) hit test results are available
	external Observable<List<T>> get onHitTestResultObservable;
	external set onHitTestResultObservable(Observable<List<T>> value);
}

/// Options used for hit testing
@JS()
abstract class IWebXRLegacyHitTestOptions {
	
	/// Only test when user interacted with the scene. Default - hit test every frame
	external bool get testOnPointerDownOnly;
	external set testOnPointerDownOnly(bool value);
	
	/// The node to use to transform the local results to world coordinates
	external TransformNode get worldParentNode;
	external set worldParentNode(TransformNode value);
}

/// Interface defining the babylon result of raycasting/hit-test
@JS()
abstract class IWebXRLegacyHitResult {
	
	/// Transformation matrix that can be applied to a node that will put it in the hit point location
	external Matrix get transformationMatrix;
	external set transformationMatrix(Matrix value);
	
	/// The native hit test result
	external dynamic get xrHitResult;
	external set xrHitResult(dynamic value);
}

/// The currently-working hit-test module.
/// Hit test (or Ray-casting) is used to interact with the real world.
/// For further information read here - https://github.com/immersive-web/hit-test
@JS()
class WebXRHitTestLegacy extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRLegacyHitResult> {
	
	/// Creates a new instance of the (legacy version) hit test feature
	/// @param _xrSessionManager an instance of WebXRSessionManager
	/// @param options options to use when constructing this feature
	external factory WebXRHitTestLegacy(WebXRSessionManager _xrSessionManager, [IWebXRLegacyHitTestOptions? options]);
	
	/// options to use when constructing this feature
	external IWebXRLegacyHitTestOptions get options;
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// Populated with the last native XR Hit Results
	external List<XRHitResult> get lastNativeXRHitResults;
	external set lastNativeXRHitResults(List<XRHitResult> value);
	
	/// Triggered when new babylon (transformed) hit test results are available
	@override
	external Observable<List<IWebXRLegacyHitResult>> get onHitTestResultObservable;
	@override
	external set onHitTestResultObservable(Observable<List<IWebXRLegacyHitResult>> value);
	
	/// execute a hit test with an XR Ray
	/// 
	/// @param xrSession a native xrSession that will execute this hit test
	/// @param xrRay the ray (position and direction) to use for ray-casting
	/// @param referenceSpace native XR reference space to use for the hit-test
	/// @param filter filter function that will filter the results
	/// @returns a promise that resolves with an array of native XR hit result in xr coordinates system
	external static Promise<List<XRHitResult>> XRHitTestWithRay(dynamic xrSession, XRRay xrRay, dynamic referenceSpace, [bool Function(XRHitResult result)? filter]);
	
	/// Execute a hit test on the current running session using a select event returned from a transient input (such as touch)
	/// @param event the (select) event to use to select with
	/// @param referenceSpace the reference space to use for this hit test
	/// @returns a promise that resolves with an array of native XR hit result in xr coordinates system
	external static Promise<List<XRHitResult>> XRHitTestWithSelectEvent(dynamic event, dynamic referenceSpace);
	
	/// attach this feature
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
	
	/// Should auto-attach be disabled?
	external bool get disableAutoAttach;
	external set disableAutoAttach(bool value);
	
	/// This function will be executed during before enabling the feature and can be used to not-allow enabling it.
	/// Note that at this point the session has NOT started, so this is purely checking if the browser supports it
	/// 
	/// @returns whether or not the feature is compatible in this environment
	external bool isCompatible();
	
	/// Was this feature disposed;
	external bool get isDisposed;
	external set isDisposed(bool value);
	
	/// The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)
	external String get xrNativeFeatureName;
	external set xrNativeFeatureName(String value);
}

/// Options used for hit testing (version 2)
@JS()
@anonymous
class IWebXRHitTestOptions {
	
	external factory IWebXRHitTestOptions({bool disablePermanentHitTest, bool enableTransientHitTest, Vector3 offsetRay, Vector3 transientOffsetRay, bool useReferenceSpace, List<int> entityTypes});
	
	/// Do not create a permanent hit test. Will usually be used when only
	/// transient inputs are needed.
	external bool get disablePermanentHitTest;
	external set disablePermanentHitTest( bool value );
	
	/// Enable transient (for example touch-based) hit test inspections
	external bool get enableTransientHitTest;
	external set enableTransientHitTest( bool value );
	
	/// Offset ray for the permanent hit test
	external Vector3 get offsetRay;
	external set offsetRay( Vector3 value );
	
	/// Offset ray for the transient hit test
	external Vector3 get transientOffsetRay;
	external set transientOffsetRay( Vector3 value );
	
	/// Instead of using viewer space for hit tests, use the reference space defined in the session manager
	external bool get useReferenceSpace;
	external set useReferenceSpace( bool value );
	
	/// Override the default entity type(s) of the hit-test result
	external List<int> get entityTypes;
	external set entityTypes( List<int> value );
}

/// Interface defining the babylon result of hit-test
@JS()
@anonymous
/* Manual Fix 47 */
class IWebXRHitResult extends IWebXRLegacyHitResult {
	
	external factory IWebXRHitResult({dynamic inputSource, bool isTransient, Vector3 position, Quaternion rotationQuaternion, XRHitTestResult xrHitResult});
	
	/// The input source that generated this hit test (if transient)
	external dynamic get inputSource;
	external set inputSource( dynamic value );
	
	/// Is this a transient hit test
	external bool get isTransient;
	external set isTransient( bool value );
	
	/// Position of the hit test result
	external Vector3 get position;
	external set position( Vector3 value );
	
	/// Rotation of the hit test result
	external Quaternion get rotationQuaternion;
	external set rotationQuaternion( Quaternion value );
	
	/// The native hit test result
	external XRHitTestResult get xrHitResult;
	/* Manual Fix 48 */
	external set xrHitResult( dynamic value );
}

/// The currently-working hit-test module.
/// Hit test (or Ray-casting) is used to interact with the real world.
/// For further information read here - https://github.com/immersive-web/hit-test
/// 
/// Tested on chrome (mobile) 80.
@JS()
class WebXRHitTest extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRHitResult> {
	
	/// Creates a new instance of the hit test feature
	/// @param _xrSessionManager an instance of WebXRSessionManager
	/// @param options options to use when constructing this feature
	external factory WebXRHitTest(WebXRSessionManager _xrSessionManager, [IWebXRHitTestOptions? options]);
	
	/// options to use when constructing this feature
	external IWebXRHitTestOptions get options;
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// When set to true, each hit test will have its own position/rotation objects
	/// When set to false, position and rotation objects will be reused for each hit test. It is expected that
	/// the developers will clone them or copy them as they see fit.
	external bool get autoCloneTransformation;
	external set autoCloneTransformation(bool value);
	
	/// Triggered when new babylon (transformed) hit test results are available
	/// Note - this will be called when results come back from the device. It can be an empty array!!
	@override
	external Observable<List<IWebXRHitResult>> get onHitTestResultObservable;
	@override
	external set onHitTestResultObservable(Observable<List<IWebXRHitResult>> value);
	
	/// Use this to temporarily pause hit test checks.
	external bool get paused;
	external set paused(bool value);
	
	/// attach this feature
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
	
	/// Should auto-attach be disabled?
	external bool get disableAutoAttach;
	external set disableAutoAttach(bool value);
	
	/// This function will be executed during before enabling the feature and can be used to not-allow enabling it.
	/// Note that at this point the session has NOT started, so this is purely checking if the browser supports it
	/// 
	/// @returns whether or not the feature is compatible in this environment
	external bool isCompatible();
	
	/// Was this feature disposed;
	external bool get isDisposed;
	external set isDisposed(bool value);
	
	/// The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)
	external String get xrNativeFeatureName;
	external set xrNativeFeatureName(String value);
}

/// Configuration options of the anchor system
@JS()
@anonymous
class IWebXRAnchorSystemOptions {
	
	external factory IWebXRAnchorSystemOptions({TransformNode worldParentNode, bool doNotRemoveAnchorsOnSessionEnded});
	
	/// a node that will be used to convert local to world coordinates
	external TransformNode get worldParentNode;
	external set worldParentNode( TransformNode value );
	
	/// If set to true a reference of the created anchors will be kept until the next session starts
	/// If not defined, anchors will be removed from the array when the feature is detached or the session ended.
	external bool get doNotRemoveAnchorsOnSessionEnded;
	external set doNotRemoveAnchorsOnSessionEnded( bool value );
}

/// A babylon container for an XR Anchor
@JS()
abstract class IWebXRAnchor {
	
	/// A babylon-assigned ID for this anchor
	external num get id;
	external set id(num value);
	
	/// Transformation matrix to apply to an object attached to this anchor
	external Matrix get transformationMatrix;
	external set transformationMatrix(Matrix value);
	
	/// The native anchor object
	external XRAnchor get xrAnchor;
	external set xrAnchor(XRAnchor value);
	
	/// if defined, this object will be constantly updated by the anchor's position and rotation
	external TransformNode get attachedNode;
	external set attachedNode(TransformNode value);
	
	/// Remove this anchor from the scene
	external void remove();
}

/// An implementation of the anchor system for WebXR.
/// For further information see https://github.com/immersive-web/anchors/
@JS()
class WebXRAnchorSystem extends WebXRAbstractFeature {
	
	/// constructs a new anchor system
	/// @param _xrSessionManager an instance of WebXRSessionManager
	/// @param _options configuration object for this feature
	external factory WebXRAnchorSystem(WebXRSessionManager _xrSessionManager, [IWebXRAnchorSystemOptions? _options]);
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// Observers registered here will be executed when a new anchor was added to the session
	external Observable<IWebXRAnchor> get onAnchorAddedObservable;
	external set onAnchorAddedObservable(Observable<IWebXRAnchor> value);
	
	/// Observers registered here will be executed when an anchor was removed from the session
	external Observable<IWebXRAnchor> get onAnchorRemovedObservable;
	external set onAnchorRemovedObservable(Observable<IWebXRAnchor> value);
	
	/// Observers registered here will be executed when an existing anchor updates
	/// This can execute N times every frame
	external Observable<IWebXRAnchor> get onAnchorUpdatedObservable;
	external set onAnchorUpdatedObservable(Observable<IWebXRAnchor> value);
	
	/// Set the reference space to use for anchor creation, when not using a hit test.
	/// Will default to the session's reference space if not defined
	external set referenceSpaceForFrameAnchors(dynamic value);
	
	/// Create a new anchor point using a hit test result at a specific point in the scene
	/// An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.
	/// Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.
	/// 
	/// @param hitTestResult The hit test result to use for this anchor creation
	/// @param position an optional position offset for this anchor
	/// @param rotationQuaternion an optional rotation offset for this anchor
	/// @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun
	external Promise<IWebXRAnchor> addAnchorPointUsingHitTestResultAsync(IWebXRHitResult hitTestResult, [Vector3? position, Quaternion? rotationQuaternion]);
	
	/// Add a new anchor at a specific position and rotation
	/// This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function
	/// will be called in the next xrFrame loop to make sure that the anchor can be created correctly.
	/// An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.
	/// Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.
	/// 
	/// @param position the position in which to add an anchor
	/// @param rotationQuaternion an optional rotation for the anchor transformation
	/// @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!
	/// @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun
	external Promise<IWebXRAnchor> addAnchorAtPositionAndRotationAsync(Vector3 position, [Quaternion? rotationQuaternion, bool? forceCreateInCurrentFrame]);
	
	/// Get the list of anchors currently being tracked by the system
	external List<IWebXRAnchor> get anchors;
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// Options used in the plane detector module
@JS()
@anonymous
class IWebXRPlaneDetectorOptions {
	
	external factory IWebXRPlaneDetectorOptions({TransformNode worldParentNode, bool doNotRemovePlanesOnSessionEnded});
	
	/// The node to use to transform the local results to world coordinates
	external TransformNode get worldParentNode;
	external set worldParentNode( TransformNode value );
	
	/// If set to true a reference of the created planes will be kept until the next session starts
	/// If not defined, planes will be removed from the array when the feature is detached or the session ended.
	external bool get doNotRemovePlanesOnSessionEnded;
	external set doNotRemovePlanesOnSessionEnded( bool value );
}

/// A babylon interface for a WebXR plane.
/// A Plane is actually a polygon, built from N points in space
/// 
/// Supported in chrome 79, not supported in canary 81 ATM
@JS()
@anonymous
class IWebXRPlane {
	
	external factory IWebXRPlane({num id, List<Vector3> polygonDefinition, Matrix transformationMatrix, XRPlane xrPlane});
	
	/// a babylon-assigned ID for this polygon
	external num get id;
	external set id( num value );
	
	/// an array of vector3 points in babylon space. right/left hand system is taken into account.
	external List<Vector3> get polygonDefinition;
	external set polygonDefinition( List<Vector3> value );
	
	/// A transformation matrix to apply on the mesh that will be built using the polygonDefinition
	/// Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module
	external Matrix get transformationMatrix;
	external set transformationMatrix( Matrix value );
	
	/// the native xr-plane object
	external XRPlane get xrPlane;
	external set xrPlane( XRPlane value );
}

/// The plane detector is used to detect planes in the real world when in AR
/// For more information see https://github.com/immersive-web/real-world-geometry/
@JS()
class WebXRPlaneDetector extends WebXRAbstractFeature {
	
	/// construct a new Plane Detector
	/// @param _xrSessionManager an instance of xr Session manager
	/// @param _options configuration to use when constructing this feature
	external factory WebXRPlaneDetector(WebXRSessionManager _xrSessionManager, [IWebXRPlaneDetectorOptions? _options]);
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// Observers registered here will be executed when a new plane was added to the session
	external Observable<IWebXRPlane> get onPlaneAddedObservable;
	external set onPlaneAddedObservable(Observable<IWebXRPlane> value);
	
	/// Observers registered here will be executed when a plane is no longer detected in the session
	external Observable<IWebXRPlane> get onPlaneRemovedObservable;
	external set onPlaneRemovedObservable(Observable<IWebXRPlane> value);
	
	/// Observers registered here will be executed when an existing plane updates (for example - expanded)
	/// This can execute N times every frame
	external Observable<IWebXRPlane> get onPlaneUpdatedObservable;
	external set onPlaneUpdatedObservable(Observable<IWebXRPlane> value);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Check if the needed objects are defined.
	/// This does not mean that the feature is enabled, but that the objects needed are well defined.
	@override
	external bool isCompatible();
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// Options interface for the background remover plugin
@JS()
@anonymous
class IWebXRBackgroundRemoverOptions {
	
	external factory IWebXRBackgroundRemoverOptions({List<AbstractMesh> backgroundMeshes, IWebXRBackgroundRemoverOptionsEnvironmentHelperRemovalFlags environmentHelperRemovalFlags, bool ignoreEnvironmentHelper});
	
	/// Further background meshes to disable when entering AR
	external List<AbstractMesh> get backgroundMeshes;
	external set backgroundMeshes( List<AbstractMesh> value );
	
	/// flags to configure the removal of the environment helper.
	/// If not set, the entire background will be removed. If set, flags should be set as well.
	external IWebXRBackgroundRemoverOptionsEnvironmentHelperRemovalFlags get environmentHelperRemovalFlags;
	external set environmentHelperRemovalFlags( IWebXRBackgroundRemoverOptionsEnvironmentHelperRemovalFlags value );
	
	/// don't disable the environment helper
	external bool get ignoreEnvironmentHelper;
	external set ignoreEnvironmentHelper( bool value );
}

/// A module that will automatically disable background meshes when entering AR and will enable them when leaving AR.
@JS()
class WebXRBackgroundRemover extends WebXRAbstractFeature {
	
	/// constructs a new background remover module
	/// @param _xrSessionManager the session manager for this module
	/// @param options read-only options to be used in this module
	external factory WebXRBackgroundRemover(WebXRSessionManager _xrSessionManager, [IWebXRBackgroundRemoverOptions? options]);
	
	/// read-only options to be used in this module
	external IWebXRBackgroundRemoverOptions get options;
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// registered observers will be triggered when the background state changes
	external Observable<bool> get onBackgroundStateChangedObservable;
	external set onBackgroundStateChangedObservable(Observable<bool> value);
	
	/// attach this feature
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// Options for the controller physics feature
@JS()
class IWebXRControllerPhysicsOptions {
	external factory IWebXRControllerPhysicsOptions();
	
	/// Should the headset get its own impostor
	external bool get enableHeadsetImpostor;
	external set enableHeadsetImpostor(bool value);
	
	/// Optional parameters for the headset impostor
	external IWebXRControllerPhysicsOptionsHeadsetImpostorParams get headsetImpostorParams;
	external set headsetImpostorParams(IWebXRControllerPhysicsOptionsHeadsetImpostorParams value);
	
	/// The physics properties of the future impostors
	external IWebXRControllerPhysicsOptionsPhysicsProperties get physicsProperties;
	external set physicsProperties(IWebXRControllerPhysicsOptionsPhysicsProperties value);
	
	/// the xr input to use with this pointer selection
	external WebXRInput get xrInput;
	external set xrInput(WebXRInput value);
}

/// Add physics impostor to your webxr controllers,
/// including naive calculation of their linear and angular velocity
@JS()
class WebXRControllerPhysics extends WebXRAbstractFeature {
	
	/// Construct a new Controller Physics Feature
	/// @param _xrSessionManager the corresponding xr session manager
	/// @param _options options to create this feature with
	external factory WebXRControllerPhysics(WebXRSessionManager _xrSessionManager, IWebXRControllerPhysicsOptions _options);
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the webxr specs version
	external static num get Version;
	
	/// Manually add a controller (if no xrInput was provided or physics engine was not enabled)
	/// @param xrController the controller to add
	external void addController(WebXRInputSource xrController);
	
	/// attach this feature
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Get the headset impostor, if enabled
	/// @returns the impostor
	external PhysicsImpostor? getHeadsetImpostor();
	
	/// Get the physics impostor of a specific controller.
	/// The impostor is not attached to a mesh because a mesh for each controller is not obligatory
	/// @param controller the controller or the controller id of which to get the impostor
	/// @returns the impostor or null
	external PhysicsImpostor? getImpostorForController(dynamic controller);
	
	/// Update the physics properties provided in the constructor
	/// @param newProperties the new properties object
	external void setPhysicsProperties(WebXRControllerPhysicsSetPhysicsPropertiesNewProperties newProperties);
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
	
	/// Releases all held resources
	external void dispose();
}

/// A babylon interface for a "WebXR" feature point.
/// Represents the position and confidence value of a given feature point.
@JS()
@anonymous
class IWebXRFeaturePoint {
	
	external factory IWebXRFeaturePoint({Vector3 position, num confidenceValue});
	
	/// Represents the position of the feature point in world space.
	external Vector3 get position;
	external set position( Vector3 value );
	
	/// Represents the confidence value of the feature point in world space. 0 being least confident, and 1 being most confident.
	external num get confidenceValue;
	external set confidenceValue( num value );
}

/// The feature point system is used to detect feature points from real world geometry.
/// This feature is currently experimental and only supported on BabylonNative, and should not be used in the browser.
/// The newly introduced API can be seen in webxr.nativeextensions.d.ts and described in FeaturePoints.md.
@JS()
class WebXRFeaturePointSystem extends WebXRAbstractFeature {
	
	/// construct the feature point system
	/// @param _xrSessionManager an instance of xr Session manager
	external factory WebXRFeaturePointSystem(WebXRSessionManager _xrSessionManager);
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// Observers registered here will be executed whenever new feature points are added (on XRFrame while the session is tracking).
	/// Will notify the observers about which feature points have been added.
	external Observable<List<num>> get onFeaturePointsAddedObservable;
	
	/// Observers registered here will be executed whenever a feature point has been updated (on XRFrame while the session is tracking).
	/// Will notify the observers about which feature points have been updated.
	external Observable<List<num>> get onFeaturePointsUpdatedObservable;
	
	/// The current feature point cloud maintained across frames.
	external List<IWebXRFeaturePoint> get featurePointCloud;
	
	/// Detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// Configuration interface for the hand tracking feature
@JS()
@anonymous
class IWebXRHandTrackingOptions {
	
	external factory IWebXRHandTrackingOptions({WebXRInput xrInput, IWebXRHandTrackingOptionsJointMeshes jointMeshes});
	
	/// The xrInput that will be used as source for new hands
	external WebXRInput get xrInput;
	external set xrInput( WebXRInput value );
	
	/// Configuration object for the joint meshes
	external IWebXRHandTrackingOptionsJointMeshes get jointMeshes;
	external set jointMeshes( IWebXRHandTrackingOptionsJointMeshes value );
}

/* enum */
abstract class HandPart {
	
	/// HandPart - Wrist
	static const String WRIST = "wrist";
	
	/// HandPart - The THumb
	static const String THUMB = "thumb";
	
	/// HandPart - Index finger
	static const String INDEX = "index";
	
	/// HandPart - Middle finger
	static const String MIDDLE = "middle";
	
	/// HandPart - Ring finger
	static const String RING = "ring";
	
	/// HandPart - Little finger
	static const String LITTLE = "little";
}

/// Representing a single hand (with its corresponding native XRHand object)
@JS()
class WebXRHand implements IDisposable {
	
	/// Construct a new hand object
	/// @param xrController the controller to which the hand correlates
	/// @param trackedMeshes the meshes to be used to track the hand joints
	/// @param _handMesh an optional hand mesh. if not provided, ours will be used
	/// @param _rigMapping an optional rig mapping for the hand mesh. if not provided, ours will be used
	/// @param disableDefaultHandMesh should the default mesh creation be disabled
	external factory WebXRHand(WebXRInputSource xrController, List<AbstractMesh> trackedMeshes, [AbstractMesh? _handMesh, List<String>? _rigMapping, bool? disableDefaultHandMesh]);
	
	/// the controller to which the hand correlates
	external WebXRInputSource get xrController;
	
	/// the meshes to be used to track the hand joints
	external List<AbstractMesh> get trackedMeshes;
	
	/// Hand-parts definition (key is HandPart)
	external dynamic /* object */ get handPartsDefinition;
	external set handPartsDefinition(dynamic /* object */ value);
	
	/// Update this hand from the latest xr frame
	/// @param xrFrame xrFrame to update from
	/// @param referenceSpace The current viewer reference space
	/// @param scaleFactor optional scale factor for the meshes
	external void updateFromXRFrame(dynamic xrFrame, dynamic referenceSpace, [num? scaleFactor]);
	
	/// Get meshes of part of the hand
	/// @param part the part of hand to get
	/// @returns An array of meshes that correlate to the hand part requested
	external List<AbstractMesh> getHandPartMeshes(int part);
	
	/// Dispose this Hand object
	@override
	external void dispose();
}

/// WebXR Hand Joint tracking feature, available for selected browsers and devices
@JS()
class WebXRHandTracking extends WebXRAbstractFeature {
	
	/// Creates a new instance of the hit test feature
	/// @param _xrSessionManager an instance of WebXRSessionManager
	/// @param options options to use when constructing this feature
	external factory WebXRHandTracking(WebXRSessionManager _xrSessionManager, IWebXRHandTrackingOptions options);
	
	/// options to use when constructing this feature
	external IWebXRHandTrackingOptions get options;
	
	/// The module's name
	external static String get Name;
	
	/// The (Babylon) version of this module.
	/// This is an integer representing the implementation version.
	/// This number does not correspond to the WebXR specs version
	external static num get Version;
	
	/// This observable will notify registered observers when a new hand object was added and initialized
	external Observable<WebXRHand> get onHandAddedObservable;
	external set onHandAddedObservable(Observable<WebXRHand> value);
	
	/// This observable will notify its observers right before the hand object is disposed
	external Observable<WebXRHand> get onHandRemovedObservable;
	external set onHandRemovedObservable(Observable<WebXRHand> value);
	
	/// Check if the needed objects are defined.
	/// This does not mean that the feature is enabled, but that the objects needed are well defined.
	@override
	external bool isCompatible();
	
	/// attach this feature
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool attach([bool? force]);
	
	/// detach this feature.
	/// Will usually be called by the features manager
	/// 
	/// @returns true if successful.
	@override
	external bool detach();
	
	/// Dispose this feature and all of the resources attached
	@override
	external void dispose();
	
	/// Get the hand object according to the controller id
	/// @param controllerId the controller id to which we want to get the hand
	/// @returns null if not found or the WebXRHand object if found
	external WebXRHand? getHandByControllerId(String controllerId);
	
	/// Get a hand object according to the requested handedness
	/// @param handedness the handedness to request
	/// @returns null if not found or the WebXRHand object if found
	external WebXRHand? getHandByHandedness(dynamic handedness);
	
	/// Is this feature attached
	external bool get attached;
	external set attached(bool value);
	
	/// A list of (Babylon WebXR) features this feature depends on
	external List<String> get dependsOn;
	external set dependsOn(List<String> value);
}

/// The motion controller class for all microsoft mixed reality controllers
@JS()
class WebXRMicrosoftMixedRealityController extends WebXRAbstractMotionController {
	
	external factory WebXRMicrosoftMixedRealityController(Scene scene, IMinimalMotionControllerObject gamepadObject, dynamic handedness);
	
	/// The base url used to load the left and right controller models
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// The name of the left controller model file
	external static String get MODEL_LEFT_FILENAME;
	external static set MODEL_LEFT_FILENAME(String value);
	
	/// The name of the right controller model file
	external static String get MODEL_RIGHT_FILENAME;
	external static set MODEL_RIGHT_FILENAME(String value);
	
	@override
	external String get profileId;
	@override
	external set profileId(String value);
}

/// The motion controller class for oculus touch (quest, rift).
/// This class supports legacy mapping as well the standard xr mapping
@JS()
class WebXROculusTouchMotionController extends WebXRAbstractMotionController {
	
	external factory WebXROculusTouchMotionController(Scene scene, IMinimalMotionControllerObject gamepadObject, dynamic handedness, [bool? legacyMapping, bool? _forceLegacyControllers]);
	
	/// The base url used to load the left and right controller models
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// The name of the left controller model file
	external static String get MODEL_LEFT_FILENAME;
	external static set MODEL_LEFT_FILENAME(String value);
	
	/// The name of the right controller model file
	external static String get MODEL_RIGHT_FILENAME;
	external static set MODEL_RIGHT_FILENAME(String value);
	
	/// Base Url for the Quest controller model.
	external static String get QUEST_MODEL_BASE_URL;
	external static set QUEST_MODEL_BASE_URL(String value);
	
	@override
	external String get profileId;
	@override
	external set profileId(String value);
}

/// The motion controller class for the standard HTC-Vive controllers
@JS()
class WebXRHTCViveMotionController extends WebXRAbstractMotionController {
	
	/// Create a new Vive motion controller object
	/// @param scene the scene to use to create this controller
	/// @param gamepadObject the corresponding gamepad object
	/// @param handedness the handedness of the controller
	external factory WebXRHTCViveMotionController(Scene scene, IMinimalMotionControllerObject gamepadObject, dynamic handedness);
	
	/// The base url used to load the left and right controller models
	external static String get MODEL_BASE_URL;
	external static set MODEL_BASE_URL(String value);
	
	/// File name for the controller model.
	external static String get MODEL_FILENAME;
	external static set MODEL_FILENAME(String value);
	
	@override
	external String get profileId;
	@override
	external set profileId(String value);
}

/// A cursor which tracks a point on a path
@JS()
class PathCursor {
	
	/// Initializes the path cursor
	/// @param path The path to track
	external factory PathCursor(Path2 path);
	
	/// The value of the path cursor
	external num get value;
	external set value(num value);
	
	/// The animation array of the path cursor
	external List<Animation> get animations;
	external set animations(List<Animation> value);
	
	/// Gets the cursor point on the path
	/// @returns A point on the path cursor at the cursor location
	external Vector3 getPoint();
	
	/// Moves the cursor ahead by the step amount
	/// @param step The amount to move the cursor forward
	/// @returns This path cursor
	external PathCursor moveAhead([num? step]);
	
	/// Moves the cursor behind by the step amount
	/// @param step The amount to move the cursor back
	/// @returns This path cursor
	external PathCursor moveBack([num? step]);
	
	/// Moves the cursor by the step amount
	/// If the step amount is greater than one, an exception is thrown
	/// @param step The amount to move the cursor
	/// @returns This path cursor
	external PathCursor move(num step);
	
	/// Executes a function on change
	/// @param f A path cursor onchange callback
	/// @returns This path cursor
	external PathCursor onchange(void Function(PathCursor cursor) f);
}

/* var */
/// @hidden
@JS()
external dynamic get blurPixelShader;

/* var */
/// @hidden
@JS()
external dynamic get pointCloudVertexDeclaration;
